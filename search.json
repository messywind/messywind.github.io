[{"categories":["杂项"],"content":"比赛链接 ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:0:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"前言 业余选手，这次比赛算是做的最爽的一次 CTF 比赛了，感谢 furryCTF，一开始在俊杰群里看到福瑞控居然能搞出个 CTF 比赛，比较好奇想去试试，早在大一的时候就想好好学习一下 CTF，但被钩八 ACM 占用了时间，现在工作了有摸鱼时间可以好好研究一下了！从一开始啥都不会只会做签到题和 osint 题到慢慢学习逐步会做后面的题，虽然可能大佬都是秒切的，但我确实学到了很多东西和技巧，以下是按照过题顺序的题解： ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:1:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"A [beginner]签到题 网易云识曲，造梦西游 3 ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:2:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"B [misc]猫猫的故事 F12 发现零宽字符，解密工具：在线零宽字符unicode文字隐写工具-BFW工具箱 ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:3:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"D [misc]丢失的文档 改成 .zip 然后解压，记事本打开 WordDocument 找到 flag ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:4:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"o [osint]人文风景 看了图片填了马家老式油茶，错误。但是注意审题是对面！所以高德搜位置然后看对面饭店，老刘传统蒸菜馆。 ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:5:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"p [osint]循迹 我也不知道怎么过的.jpg，观察到有一头牛，百度识图他叫墨小牛，然后他是即墨古城的吉祥物，然后搜一下即墨古城附近火锅店就出来了。 ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:6:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"w [osint]归去 一看群主 QQ 资料是阜阳的，所以锁定阜阳西站。 阜阳西 观察到高铁时间是从早到晚的，所以去官网找到这俩站： 然后查找到： 答案是上海站。 ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:7:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"u [osint]旅行照片 百度识图，日月双塔。 ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:8:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"K [misc]Windows 1.0 直接用 010editor 打开一下搜索 furryCTF ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:9:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"l [hardware]Charge 直接用 AI 识图，加 AI 提问，furryCTF{20000_50_PPJL65C} ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:10:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"Q [misc]求而不得 打开压缩包发现有密码，然后文件头 90 改 00 发现不行，不是伪加密。 发现 1.txt 2.txt 3.txt 4.txt 5.txt 原始大小很小，考虑 CRC32 碰撞。 用几个工具，字节为 2 和 3 的很容易破解。 +--------------遍历指定压缩包的CRC值----------------+ [OK] 1.txt: 0xd6794fcc [OK] 2.txt: 0xa4923bd1 [OK] 3.txt: 0x5150ce86 [OK] 4.txt: 0x269fce5d [OK] 5.txt: 0x327e383 [OK] flag.txt: 0x77093881 +-------------对输出的CRC值进行碰撞-----------------+ [Success] 0xd6794fcc: 1qa [Success] 0xa4923bd1: 4?u [Success] 0x327e383: !w 得到以下三个文件的内容： 1.txt: 1qa 2.txt: 4?u 5.txt: !w 考虑 6 字节的，有工具：https://github.com/theonlypwner/crc32 所有可能如下： !;F#5. !j$BY2 $#UO.@ $nxrCH %n9CXQ )Al1\u003cV )]#m=B +a\u0026sd_ +}i/eK ,x!MNt -5MA8e -Eq0=5 -Y\u003el\u003c! /e;re\u003c /yt.d( 07}LZt 0GA=_$ 1+s!@y 17\u003c}Am 1[OPE) 2*\u0026Bj% 2FUona 3*gsq\u003c 36(/p( 5_RQDJ 6.;CkF 7.zrp_ 725.qK 8!$sWH 9!eBLQ ;PMaxD \u003c%9rV+ \u003c9v.W? \u003cIJ_Ro =%xCM2 =UD2Hb ?8#M}c @*RYc8 @Zn(fh BG5\u0026V9 B[zzW- Bfk6?u Bz$j\u003ea C7HfHp C[;KL4 Cze[%x D.OXb[ E2A5xV FC('WZ F_g{VN G_\u0026JMW HPxKj@ ILv\u0026pM IP9zqY J!Ph^U Jl}U3] Kl\u003cd(D Kps8)P L$Y;ns LTeJk# MHk'q. MT${p: N%Mi_6 NI\u003eD[r Oh!e)' Otn9(3 PwJf{g R'\u003cU\u0026\u003e S'}d=' S;28\u003c3 SjPYP/ V#!T'] VrC5KA W?/9=P WnMXQL YaRhmB []Wv4_ ]eOil! ^)77+u ^5xk*a ^xUVGi _59Z1x _YJw5\u003c _d[;]d atB0/8 b$u2ix b8:nhl bTICl( c8{_su cHG.v% d=3=XJ e!=PBG ep_1.[ fPTBmK gLZ/wF h_KrQE j.cQeP l7%^Tb l[VsP\u0026 m++3No m7doO{ nZB!ac oFLL{n p5Tb-j pY'O). pxy_@b qdw2Zo qx8n[{ sy,\u003cj\u003e t]:N(M uA4#2@ va?PqP w}1=k] xro\u003cLJ y#Ll;O ynaQVG }'Qm:, 5 字节的，直接暴力跑 (跑了几十分钟)： 最后都拼成字典用 archpr 暴力破解。 得到密码，解压即可。 ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:11:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"M [misc]此时无声胜有声 直接用 Audacity 打开。 看图发现是 furryCTF{B1ack_Pi2no} ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:12:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"E [misc]黑暗 一开始没什么头绪，但是必须要考虑数字顺序 (受求而不得启发)。 010editor 发现 8 张图片的文件尾不一样，依次是： ZnVy cnlD VEZ7 SGVs bG9f SUVO RF9B d0F9 拼起来是 ZnVycnlDVEZ7SGVsbG9fSUVORF9Bd0F9，Base64 解码。 ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:13:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"L [misc]春风得意 题面提示趴在电脑上，所以考虑键盘加密。发现前面按 8 个字符分组是： egtrcvge 6i87hji6 3t54dft3 3t54dft3 5u76ghu5 VSFSFFXD 4Y65FGY4 EGTRCVGE 0]=-;']0 对应 furryCTF{ 按照密文脑补明文 (疯狂看电脑键盘)。 得到答案 furryCTF{keyboard_with_random_cout} ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:14:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"R [misc]图片的秘密 标题提示图片，考虑使用 SSTV，音频变成图片。 枚举凯撒加密，字母往前移 10 位 furryCTF{WELAOME_TO_FURRYCTF!} ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:15:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"_ [mobile]登录 解包搜 furryCTF ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:16:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"` [mobile]认证系统 继续解包搜 furryCTF ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:17:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"C [misc]安装包 解压安装包发现 flag 凯撒解不出来，考虑维吉尼亚密码，密钥是 furryCTF ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:18:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"d [rev]烦人的黑框框 发现程序图标是 Python 编写，使用 pyinstxtractor.py 反编译。 反编译 trojan.pyc Base32 解密。 ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:19:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"f [crypto]亡羊补牢 枚举一下栅栏，发现 9 不对劲。 然后发现每五个字符进行分组，前两组按照 swap(s[1], s[2]) swap(s[0], s[2]) swap(s[2], s[3]) 的交换规则可以得到 furryCTF{A，于是模拟一下得到答案。 ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:20:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"H [misc]乱码 开始想统计一下字符集，没想到字符集有意外收获 (出现 furryCTF 和 {} 等)，然后词频统计一下。 尝试按词频排序。 补一个 r 然后得到答案：furryCTF{How_Man1-times} ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:21:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"Z [web]剑走偏锋 发现 furry 和 CTF 参数可以有 ./，又发现 CTF 参数可以有问号，于是模糊匹配。 正确 flag 为：furryCTF{Hundred_Secrets_An6_4_Mere_Care1essness} ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:22:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"补题 ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:23:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"F [misc]校园浏览器 不是，啊？这为什么不是 osint 题！！ 点一下 V5 就可以了，一开始以为是等级。。 ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:24:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"T [misc]网盘 把这图片保存下来直接上传到网盘就可以得到 flag 图片了。还能这样属实没想到，原理是 MD5 碰撞。 ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:25:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"U [web]flag下载 没道理的，纯没道理的。 https://hydro.ac/p/34977/file/flag.txt?tid=6728fe9aa325b9e5ba5f9489 打开文件发现是 furryCTF%7BD%23n't_Y%25u_Kn%40w_The_HTML_Re*p0nce%7D URL 解码： furryCTF{D#n't_Y%u_Kn@w_The_HTML_Re*p0nce} ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:26:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"V [web]列表 使用堆快照： 去查找该 Scratch 项目的 JSON 文件，所以搜索 {\"targets\":[{\"isStage\":true 并看到一个奇怪的内容，鼠标附上去最后能看到一串密码。(不是哥们这谁能找到啊！) F$_\u003ci}Zp:\u0026yd\u0026AXeCQ'#]Zap5Gf\u0026ojDyCN\u0026KN$*N$4j\u003e*DdpE^jc/=2h5IgRY8\\ Base92 解码： ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:27:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"W [web]雪花飘飘 一开始是靶机搭的 web，但后来挂了换成 GitHub，这让我得知了跟请求没有啥关系，重点看可疑的 JS 文件。 注意到 snowflakes.min.js 文件里有一串可疑密码 (注意力惊人) 50955130862247346033128821496195502070347087340218689554242763562407659428661122869571965 先转个 16 进制： 66757272794354467b466c79316e675f536e6f775f49735f53305f4265617574696675317d 再转个 Hex 得到 flag： ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:28:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"X [web]史莱姆的世界 随便找找，高玩榜里有镜像的 flag： 答案为：furryCTF{The_Wyrms1ayer_0f_Ender_Drag0n} ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:29:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"P [misc] 湍流细木 用 Wireshark 打开流量包，搜索字符串 flag 找到网址。 然后用 winHex 打开图片，发现末尾有可疑的 PHP 显示乱码，尝试字符集转成 UTF-8，发现是如下： \u003c?php eval($_POST('⠋⠥⠗⠗⠽⠉⠞⠋{⠎⠑⠑⠸⠽⠕⠥⠸⠁⠛⠁⠂⠝}'))?\u003e 这是盲文，用一下转换器得到 flag ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:30:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"b [rev]Login 这个题差一点点就过了。牢记数字转 hex！ IDA 打开一下，然后看 strings 的视图找到可疑字符串50955130862247346033129849911215869256974228669048534734398765262912025541901441526490493 和雪花飘飘一样，转 16 进制再转 hex 得到 flag furryCTF{P0inter_Is_Out_Of_The_Ran9e} ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:31:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"c [rev]MEMZ 用 ARCHPR 暴力破解出密码 furry 然后还是用 IDA 打开里面的文件做和 b 题相同的操作。得到数字 181028990419375709681764670364570214516897360554680698682721225149223938429 然后继续做相同操作得到 flag：furryCTF{MEMZ_W1th_furryCTF_:)} ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:32:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"g [crypto]Scratch 直接把 project.json 后缀改成 sb3，然后用 scratch 在线网站 打开 102 117 114 114 121 67 84 70 123 76 105 102 101 95 49 115 95 83 105 110 103 49 110 103 125 这显然是 ASCII 码，转成字符串。 ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:33:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"j [crypto]粗心的猫猫 拿到压缩包先检验并去除伪加密 09 改 00 拿到 RSA.py import gmpy2 import random def generate_large_prime_by_digits(n): random_num_str = ''.join(random.choices('0123456789', k=n)) random_num = gmpy2.mpz(random_num_str) if random_num \u003c (10 ** (n - 1)): random_num = gmpy2.mpz('1' + random_num_str) large_prime = gmpy2.next_prime(random_num) return large_prime p = generate_large_prime_by_digits(1024) while True: q = generate_large_prime_by_digits(1024) e=65537 n=p*q code=int(input(\"flag is:\")) enc=pow(code,e,n) print(\"enc=\",enc,\"n=\",n) 发现 e=65537，写脚本 import math from Crypto.Util.number import long_to_bytes enc1=14177645175039229116346030403132099232252291153135307407968472015386303969683440897768815154592798117707771834485750461958443494947077758686797445730457810973274288497317238758699116770492362164018314656983870227104328935858969940914375276048149445994058151332456001392503777508200612633803312738586770586755013253205953269657307673778973476227494712144720441189698203045625466899244934392249740966985280244968876913636228035050537977472852346681757901914549624771278966903150572142886596754698966732044532202038232827298624740542580907036703357527815925181548750101170784981364664580512451534103637029856932407134866372713573545050892181185667064803687344711738898892838348108679006582429550280239878299713862061257101727544519979298670679547873030689357800544769896490678581665642152338087552510986570351080648866785919010250813510930181871917743091330970945292451475777264717478411897482788457237513337893000855934977851366995648686944439625119226736305985408249926817752951238053324680244459535284276788239830947558347535661273319272484426815624119065243814479879857227145702378384759185314521936222526848877809462669205720864948586639549366689439976188939046094706634697938828506448713318664719793526508677047964791882055229097094781355551992321052050659928504783119721120774623169080609520865738446131354441282017108450334959907176316850807504353060288090773899541830156545907659887546868659349496971137510457219070328808047883992985109715387908536371129932819658627586772048725108230180498906483055208587614479396813916197684987133676920294287905763418186855940039145683340370669962759840202308485657591957590273832469518324770544333477076900023293723036842238146047083500015962610279943202343016823333927538123149146284856126566138456780044758422390128056433588123572267326282082937925150760280856896266334230763089077110273446705797808420211653823402873724031368031219469218762817642063689845991466836385443863409322164086224047368995544586280661464612101614921197417828356003039287413996830974696626978384439317161695922653499755056482841 enc2=2616225154450846689007019196467926428889335392687050302769125495331219155668425194780781458645304149681663973357461389224562424487784310794756579631345719496320832579698822304406489281432570702452882703080294827491547820478810444983638468616932258002719179818081343158089855576463264164753561267674729628882776567546366017222741226772322238364747330373462896755140824095623231991834869394764529723605422659813046495933553203308416526932431661892228085539797510953948913494048115598908447500306735781632990876053715796840734065637083945498816978333903291427504950094532586379230459419282607700258159197084544269832027652041906079125435947691174280332211485671223498673100624653184850860369692866219691645715021136039458382854909116076746371597369292705809382543578366227650803513829227929083620479933681739010669550872704078690203057990245007222842377199187630912571959046950453779754976367572287610253489085892895641300580823474487881469457303399310570371696799051815628502806994314131920638865962130784092479812783980140649364864396941794438536482030819400982032060756086798896937337971590567401617556346039733036739426696718046990095907981926703848526590297073083062402619996197924605789667977257490385284288989133931896760472774485362774660568746115642632897456225326350952034168238085875764288239379473879162754911488715293691874202","date":"2025-01-15","objectID":"/posts/misc-furryctf/:34:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["杂项"],"content":"参考 官方 WP ","date":"2025-01-15","objectID":"/posts/misc-furryctf/:35:0","tags":["CTF"],"title":"FurryCTF 2024 (寒假赛) WP","uri":"/posts/misc-furryctf/"},{"categories":["机器学习"],"content":"学了那么多理论了做一下斯坦福大学的 CS 课程：CS231n，对 CV 有一个基本的认识，同时加强一下实操能力。 课程网址 ","date":"2024-12-03","objectID":"/posts/mlcs231n/:0:0","tags":["KNN","神经网络","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["机器学习"],"content":"本地环境部署 由于 2024 版的没有给 jupyter 的压缩包，所以先下载 2024 colab 版本，然后在 colab 上把数据拉下来然后下载到本地，放到 /datasets 下，之后删除掉一开始的 google.colab 驱动相关。 虚拟环境的话就用 conda 创一个 python3.7 然后使用 2020 jupyter 版本的 requirements.txt ，如果有漏包情况再说。 个人练习 GitHub 地址 ","date":"2024-12-03","objectID":"/posts/mlcs231n/:1:0","tags":["KNN","神经网络","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["机器学习"],"content":"Assignment 1 ","date":"2024-12-03","objectID":"/posts/mlcs231n/:2:0","tags":["KNN","神经网络","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["机器学习"],"content":"Q1: k-Nearest Neighbor classifier 数据集是一个很多 32 * 32 * 3 (32 × 32 像素，RGB) 的图片分类。 为了方便处理直接压成一行，$32 \\times 32 \\times 3 = 3072$ 列。 取前 $5000$ 个作为训练集，前 $500$ 个作为测试集。 X_train, y_train, X_test, y_test = load_CIFAR10(cifar10_dir) # As a sanity check, we print out the size of the training and test data. print('Training data shape: ', X_train.shape) print('Training labels shape: ', y_train.shape) print('Test data shape: ', X_test.shape) print('Test labels shape: ', y_test.shape) # Subsample the data for more efficient code execution in this exercise num_training = 5000 mask = list(range(num_training)) X_train = X_train[mask] y_train = y_train[mask] num_test = 500 mask = list(range(num_test)) X_test = X_test[mask] y_test = y_test[mask] # Reshape the image data into rows X_train = np.reshape(X_train, (X_train.shape[0], -1)) X_test = np.reshape(X_test, (X_test.shape[0], -1)) print(X_train.shape, X_test.shape) 导入 KNN 分类器，他已经把类写好了。 from cs231n.classifiers import KNearestNeighbor # Create a kNN classifier instance. # Remember that training a kNN classifier is a noop: # the Classifier simply remembers the data and does no further processing classifier = KNearestNeighbor() classifier.train(X_train, y_train) 接下来要计算距离。需要写一下 compute_distances_two_loops 的 TODO # Open cs231n/classifiers/k_nearest_neighbor.py and implement # compute_distances_two_loops. # Test your implementation: dists = classifier.compute_distances_two_loops(X_test) print(dists.shape) TODO: 两重循环计算 L2 距离。 np.sqrt() 开根，np.sum() 求和。 def compute_distances_two_loops(self, X): \"\"\" Compute the distance between each test point in X and each training point in self.X_train using a nested loop over both the training data and the test data. Inputs: - X: A numpy array of shape (num_test, D) containing test data. Returns: - dists: A numpy array of shape (num_test, num_train) where dists[i, j] is the Euclidean distance between the ith test point and the jth training point. \"\"\" num_test = X.shape[0] num_train = self.X_train.shape[0] dists = np.zeros((num_test, num_train)) for i in range(num_test): for j in range(num_train): ##################################################################### # TODO: # # Compute the l2 distance between the ith test point and the jth # # training point, and store the result in dists[i, j]. You should # # not use a loop over dimension, nor use np.linalg.norm(). # ##################################################################### # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** dists[i, j] = np.sqrt(np.sum((X[i] - self.X_train[j]) ** 2)) # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** return dists 看一下距离的网格图。 # We can visualize the distance matrix: each row is a single test example and # its distances to training examples plt.imshow(dists, interpolation='none') plt.show() Inline Question 1 Notice the structured patterns in the distance matrix, where some rows or columns are visibly brighter. (Note that with the default color scheme black indicates low distances while white indicates high distances.) What in the data is the cause behind the distinctly bright rows? What causes the columns? ${\\textit Your Answer:}$ fill this in. 注意距离矩阵中的结构化模式，其中一些行或列明显更亮。（注意在默认的颜色方案中，黑色表示低距离，而白色表示高距离。） 数据中是什么原因导致了这些明显更亮的行？ 是什么导致了这些明显的列？ ${\\textit Your Answer:}$ 行是测试数据，列是训练数据。白色的行是该测试数据远离训练数据，白色的列是该训练数据远离测试数据。 TODO: predict_labels np.argsort() 表示返回排序后的原数组下标。这里 [0 : k] 取前 $k$ 大，然后再映射到 y np.bincount() 表示将输入数据装进桶计数。 np.argmax() 表示取最大值的下标。 def predict_labels(self, dists, k=1): \"\"\" Given a matrix of distances between test points and training points, predict a label for each test point. Inputs: - dists: A numpy array of shape (num_test, num_train) where dists[i, j] gives the distance betwen the ith test point and the jth training point. Returns: - y: A numpy array of shape (num_test,) containing predicted labels for the test data, where y[i] is the predicted label for the test point X[i]. \"\"\" num_test = dists.shape[0] y_pred = np.zeros(num_test) for i in range(num_","date":"2024-12-03","objectID":"/posts/mlcs231n/:2:1","tags":["KNN","神经网络","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["机器学习"],"content":"Q2: Training a Support Vector Machine 还是那个数据集，这次先减去一个图像像素的平均值。然后因为是 SVM，所以 np.ones 加上一个 $1$ 的偏置。 # Preprocessing: subtract the mean image # first: compute the image mean based on the training data mean_image = np.mean(X_train, axis=0) print(mean_image[:10]) # print a few of the elements plt.figure(figsize=(4,4)) plt.imshow(mean_image.reshape((32,32,3)).astype('uint8')) # visualize the mean image plt.show() # second: subtract the mean image from train and test data X_train -= mean_image X_val -= mean_image X_test -= mean_image X_dev -= mean_image # third: append the bias dimension of ones (i.e. bias trick) so that our SVM # only has to worry about optimizing a single weight matrix W. X_train = np.hstack([X_train, np.ones((X_train.shape[0], 1))]) X_val = np.hstack([X_val, np.ones((X_val.shape[0], 1))]) X_test = np.hstack([X_test, np.ones((X_test.shape[0], 1))]) X_dev = np.hstack([X_dev, np.ones((X_dev.shape[0], 1))]) print(X_train.shape, X_val.shape, X_test.shape, X_dev.shape) TODO: svm_loss_naive 计算损失的时候，用 X[i].dot(W) 表示该条数据在 $10$ 个分类下的表现得分 (W 是 3073 * 10 的矩阵)，correct_class_score = scores[y[i]] 表示从得分向量中提取出第 $i$ 个样本的正确类别的得分。根据官网讲义(https://cs231n.github.io/linear-classify/)，定义损失为 $L_i = \\sum\\limits_{j \\ne y_i}\\max(0, s_j - s_{y_i} + \\Delta)$ 为什么这么定义呢？根据讲义 The Multiclass Support Vector Machine “wants” the score of the correct class to be higher than all other scores by at least a margin of delta. If any class has a score inside the red region (or higher), then there will be accumulated loss. Otherwise the loss will be zero. Our objective will be to find the weights that will simultaneously satisfy this constraint for all examples in the training data and give a total loss that is as low as possible. 多类别支持向量机 “希望 “正确类别的得分至少比所有其他类别的得分高出 delta 值。 如果任何一个类别的得分在红色区域内（或更高），那么就会有累计损失。 否则，损失为零。 我们的目标是为训练数据中的所有示例找到同时满足这一约束条件的权重，并尽可能降低总损失。 除此之外，还要加上一个正则化损失，一般是 L2： $$ R(W) = \\sum_{k}\\sum_{l}W_{k, l} ^ 2 $$ 然后乘以一个参数(函数传入的 reg)，最后和平均累计损失相加得到最终损失： $$ L = \\frac{1}{N}\\sum_i L_i + \\lambda R(W) $$ 那么梯度就是对损失函数对 W 求导，第一部分可以在算损失的时候计算出来。 def svm_loss_naive(W, X, y, reg): \"\"\" Structured SVM loss function, naive implementation (with loops). Inputs have dimension D, there are C classes, and we operate on minibatches of N examples. Inputs: - W: A numpy array of shape (D, C) containing weights. - X: A numpy array of shape (N, D) containing a minibatch of data. - y: A numpy array of shape (N,) containing training labels; y[i] = c means that X[i] has label c, where 0 \u003c= c \u003c C. - reg: (float) regularization strength Returns a tuple of: - loss as single float - gradient with respect to weights W; an array of same shape as W \"\"\" dW = np.zeros(W.shape) # initialize the gradient as zero # compute the loss and the gradient num_classes = W.shape[1] num_train = X.shape[0] loss = 0.0 for i in range(num_train): scores = X[i].dot(W) correct_class_score = scores[y[i]] for j in range(num_classes): if j == y[i]: continue margin = scores[j] - correct_class_score + 1 # note delta = 1 if margin \u003e 0: loss += margin dW[:, j] += X[i] dW[:, y[i]] -= X[i] # Right now the loss is a sum over all training examples, but we want it # to be an average instead so we divide by num_train. loss /= num_train # Add regularization to the loss. loss += reg * np.sum(W * W) ############################################################################# # TODO: # # Compute the gradient of the loss function and store it dW. # # Rather that first computing the loss and then computing the derivative, # # it may be simpler to compute the derivative at the same time that the # # loss is being computed. As a result you may need to modify some of the # # code above to compute the gradient. # ############################################################################# # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** dW /= num_train dW += 2 * reg * W # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** return loss, dW 检验一下梯度是否对 # Once you've implemented the gradient, recompute it with","date":"2024-12-03","objectID":"/posts/mlcs231n/:2:2","tags":["KNN","神经网络","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["机器学习"],"content":"Q3: Implement a Softmax classifier SoftMax 损失函数 SoftMax 是把得分转换成了概率。公式如下： $$ S(y_i) = \\dfrac{e ^ {y_i}}{\\sum\\limits_{j} e ^ {y_j}} $$ 损失函数就是根据交叉熵套了个 $-\\log(x)$： $$ L_i = -\\log\\left(\\dfrac{e ^ {y_i}}{\\sum\\limits_{j} e ^ {y_j}}\\right) $$ SoftMax 梯度推导 首先样本 $i$ 的得分为： $$ s_i = x_i \\cdot W $$ $s_{i, j}$ 表示样本 $i$ 在类别 $j$ 上的得分。 $$ p_i = \\text{softmax}(s_i) = \\dfrac{e ^ {s_i}}{\\sum\\limits_{k} e ^ {s_{i, k}}} $$ $p_{i, j}$ 表示样本 $i$ 被预测为类别 $j$ 的概率。 假设一共有 $C$ 类，$p_i$ 是长这样子的： $$ p_i = \\left[ \\frac{e^{s_{i, 1}}}{\\sum\\limits_{k=1}^{C} e^{s_{i, k}}}, \\frac{e^{s_{i, 2}}}{\\sum\\limits_{k=1}^{C} e^{s_{i, k}}}, \\cdots, \\frac{e^{s_{i, C}}}{\\sum\\limits_{k=1}^{C} e^{s_{i, k}}} \\right] $$ 那么它的损失函数为： $$ L_i = -\\log(p_i) = -\\log\\left(\\dfrac{e ^ {s_i}}{\\sum\\limits_{k} e ^ {s_{i, k}}}\\right) $$ (以下公式为了形式美观将 $s_{i, j}$ 令成 $s_j$，$p_{i, j}$ 令成 $p_j$，意思是都是样本 $i$ 的) 损失函数对 $W$ 求导，并使用链式法则： $$ \\dfrac{\\partial L_i}{\\partial W} = \\dfrac{\\partial L_i}{\\partial s_j} \\times \\dfrac{\\partial s_j}{\\partial W} $$ 显然有 $\\dfrac{\\partial s_j}{\\partial W} = x_i$，重点讨论 $\\dfrac{\\partial L_i}{\\partial s_j}$： $\\frac{\\partial L_i}{\\partial s_j}$ 对于每个类别 $j$： 如果 $j$ 为正确类别 ($y_i = j$)： $$ \\frac{\\partial L_i}{\\partial s_j} = \\frac{\\partial (-\\log(p_j))}{\\partial s_j} = -\\frac{1}{p_j} \\times \\frac{\\partial p_j}{\\partial s_j} $$ 接下来 $\\dfrac{\\partial p_j}{\\partial s_j}$ 是： $$ \\frac{\\partial p_j}{\\partial s_j} = \\frac{\\partial}{\\partial s_j} \\left( \\frac{e^{s_j}}{\\sum\\limits_{k} e^{s_{j, k}}} \\right) $$ 求导： $$ \\frac{\\partial}{\\partial s_j} \\left( \\frac{e^{s_j}}{\\sum\\limits_{k} e^{s_{j, k}}} \\right) = \\frac{e^{s_j} \\sum\\limits_{k} e^{s_{j, k}} - e^{s_j} \\cdot e^{s_j}}{\\left(\\sum\\limits_{k} e^{s_{j, k}}\\right)^2} = \\frac{e^{s_j} \\left(\\sum\\limits_{k} e^{s_{j, k}} - e^{s_j}\\right)}{\\left(\\sum\\limits_{k} e^{s_{j, k}}\\right)^2} = \\dfrac{e ^ {s_j}}{\\sum\\limits_{k} e^{s_{j, k}}} \\times \\left(1 - \\dfrac{e ^ {s_j}}{\\sum\\limits_{k} e^{s_{j, k}}}\\right) = p_j (1 - p_j) $$ 于是 $\\dfrac{\\partial L_i}{\\partial s_j} = -\\dfrac{1}{p_j} \\times p_j(1 - p_j) = (p_j - 1)$ 则 $\\dfrac{\\partial L_i}{\\partial W} = (p_j - 1) x_i$ 如果 $j$ 为不正确类别 ($y_i \\ne j$)： $$ \\frac{\\partial L_i}{\\partial s_{y_j}} = \\frac{\\partial (-\\log(p_{y_i}))}{\\partial s_{y_j}} = -\\frac{1}{p_{y_i}} \\times \\frac{\\partial p_{y_i}}{\\partial s_{y_j}} $$ 接下来 $\\dfrac{\\partial p_{y_j}}{\\partial s_{y_j}}$ 是： $$ \\dfrac{\\partial p_{y_j}}{\\partial s_{y_j}} = \\frac{\\partial}{\\partial s_{y_j}} \\left( \\frac{e^{s_j}}{\\sum\\limits_{k} e^{s_{j, k}}} \\right) $$ 求导： $$ \\frac{\\partial}{\\partial s_{y_j}} \\left( \\frac{e^{s_j}}{\\sum\\limits_{k} e^{s_{j, k}}} \\right) = -\\frac{e^{s_j} e ^ {s_{y_j}}}{\\left(\\sum\\limits_{k} e^{s_{j, k}}\\right) ^ 2} = -p_j p_{y_j} $$ 于是 $\\dfrac{\\partial L_i}{\\partial s_{y_j}} = -\\dfrac{1}{p_{y_i}} \\times \\dfrac{\\partial p_{y_i}}{\\partial s_{y_j}} = p_j$ 则 $\\dfrac{\\partial L_i}{\\partial W} = p_j x_i$ TODO: softmax_loss_naive def softmax_loss_naive(W, X, y, reg): \"\"\" Softmax loss function, naive implementation (with loops) Inputs have dimension D, there are C classes, and we operate on minibatches of N examples. Inputs: - W: A numpy array of shape (D, C) containing weights. - X: A numpy array of shape (N, D) containing a minibatch of data. - y: A numpy array of shape (N,) containing training labels; y[i] = c means that X[i] has label c, where 0 \u003c= c \u003c C. - reg: (float) regularization strength Returns a tuple of: - loss as single float - gradient with respect to weights W; an array of same shape as W \"\"\" # Initialize the loss and gradient to zero. loss = 0.0 dW = np.zeros_like(W) ############################################################################# # TODO: Compute the softmax loss and its gradient using explicit loops. # # Store the loss in loss and the gradient in dW. If you are not careful # # here, it is easy to run into numeric instability. Don't forget the # # regularization! # ############################################################################# # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** # 获取样本数量和类别数量 num","date":"2024-12-03","objectID":"/posts/mlcs231n/:2:3","tags":["KNN","神经网络","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["机器学习"],"content":"Q4: Two-Layer Neural Network 首先检验一下前向传播，数据生成一个两组大小为 $4 \\times 5 \\times 6$ 的数据，也就是说输入层是 $120$ 个节点，然后直接连接输出层，设输出层有 $3$ 个节点。 所以说 $w$ 就是 $120 \\times 3$ 的，$b$ 就是 $3$ 的。 # Test the affine_forward function num_inputs = 2 input_shape = (4, 5, 6) output_dim = 3 input_size = num_inputs * np.prod(input_shape) weight_size = output_dim * np.prod(input_shape) x = np.linspace(-0.1, 0.5, num=input_size).reshape(num_inputs, *input_shape) w = np.linspace(-0.2, 0.3, num=weight_size).reshape(np.prod(input_shape), output_dim) b = np.linspace(-0.3, 0.1, num=output_dim) out, _ = affine_forward(x, w, b) correct_out = np.array([[ 1.49834967, 1.70660132, 1.91485297], [ 3.25553199, 3.5141327, 3.77273342]]) # Compare your output with ours. The error should be around e-9 or less. print('Testing affine_forward function:') print('difference: ', rel_error(out, correct_out)) TODO: affine_forward 把 $x$ 压成 $120$ 的第二维。 def affine_forward(x, w, b): \"\"\" Computes the forward pass for an affine (fully-connected) layer. The input x has shape (N, d_1, ..., d_k) and contains a minibatch of N examples, where each example x[i] has shape (d_1, ..., d_k). We will reshape each input into a vector of dimension D = d_1 * ... * d_k, and then transform it to an output vector of dimension M. Inputs: - x: A numpy array containing input data, of shape (N, d_1, ..., d_k) - w: A numpy array of weights, of shape (D, M) - b: A numpy array of biases, of shape (M,) Returns a tuple of: - out: output, of shape (N, M) - cache: (x, w, b) \"\"\" out = None ########################################################################### # TODO: Implement the affine forward pass. Store the result in out. You # # will need to reshape the input into rows. # ########################################################################### # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** out = x.reshape(x.shape[0], -1).dot(w) + b cache = (x, w, b) # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** ########################################################################### # END OF YOUR CODE # ########################################################################### cache = (x, w, b) return out, cache 接下来检验反向传播。 TODO: affine_backward 我们知道这是批量梯度下降，也就是说输入数据 $x$ 被我们处理成了 $n \\times k$ 维的，每一行代表一个数据，列就是特征。那么输出层定义为 $n \\times m$ 维的，$n$ 是数据批量个数，$m$ 是输出层节点个数，但是 $w$ 和 $b$ 分别是 $k \\times m$ 与 $1 \\times m$ 维的，也就是说这 $n$ 个数据共用 $w$ 和 $b$，然后每个数据对应一组输出。 那么在反向传播时，我们需要计算 $x, w, b$ 的偏导，首先他给了一个 dout 数组，这代表输出层的导数，他也是一个 $n \\times m$ 的。 单看 $\\text{out}_{i, j}$： $$ \\text{out}_{i, j} = \\sum_k x_{i, k} w_{k, j} + b_j $$ $\\text{out}_{i, j}$ 对 $w_{k, j}$ 求偏导： $$ \\dfrac{\\partial \\text{out}_{i, j}}{\\partial w_{k, j}} = x_{i, k} $$ $\\text{out}_{i, j}$ 对 $x_{i, k}$ 求偏导： $$ \\dfrac{\\partial \\text{out}_{i, j}}{\\partial x_{i, k}} = w_{k, j} $$ $\\text{out}_{i, j}$ 对 $b_j$ 求偏导： $$ \\dfrac{\\partial \\text{out}_{i, j}}{\\partial b_j} = 1 $$ 那么损失函数 $L$ 对 $w_{k, j}$ 求偏导，根据链式法则有： $$ \\dfrac{\\partial L}{\\partial w_{k, j}} = \\sum_i \\dfrac{\\partial L}{\\partial \\text{out}_{i, j}} \\dfrac{\\partial \\text{out}_{i, j}}{\\partial w_{k, j}} $$ 其中 $\\dfrac{\\partial L}{\\partial \\text{out}_{i, j}}$ 这个东西就是 dout[i, j] (上游传来的导数)，而 $\\dfrac{\\partial \\text{out}_{i, j}}{\\partial w_{k, j}} = x_{i, k}$，所以 $$ \\dfrac{\\partial L}{\\partial w_{k, j}} = \\sum_i \\text{dout}_{i, j}x_{i, k} $$ 再来看损失函数 $L_i$ 对 $x_{i, k}$ 求偏导，根据链式法则有： $$ \\dfrac{\\partial L}{\\partial x_{i, k}} = \\sum_j \\dfrac{\\partial L}{\\partial \\text{out}_{i, j}} \\dfrac{\\partial \\text{out}_{i, j}}{\\partial x_{i, k}} $$ 继续带入 $\\dfrac{\\partial L}{\\partial \\text{out}_{i, j}} = \\text{dout}_{i, j}$，$\\dfrac{\\partial \\text{out}_{i, j}}{\\partial x_{i, k}} = w_{k, j}$： $$ \\dfrac{\\partial L}{\\partial x_{i, k}} = \\sum_j \\text{dout}_{i, j}w_{k, j} $$ 继续看损失函数 $L_i$ 对 $b_{j}$ 求偏导，根据链式法则有： $$ \\dfrac{\\partial L}{\\partial b_{j}} = \\sum_i \\dfrac{\\partial L}{\\partial \\text{out}_{i, j}} \\dfrac{\\partial \\text{out}_{i, j}}{\\partial b_{j}} $$ 还是继续带入 $\\dfrac{\\partial L}{\\partial \\text{out}_{i, j}} = \\text{dout}_{i, j}$，$\\dfrac{\\p","date":"2024-12-03","objectID":"/posts/mlcs231n/:2:4","tags":["KNN","神经网络","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["机器学习"],"content":"Q5: Higher Level Representations: Image Features 使用 HOG 和 color histogram 特征提取一下图像的信息，简单来说就是将图片的特征表现得更明显。 from cs231n.features import * num_color_bins = 10 # Number of bins in the color histogram feature_fns = [hog_feature, lambda img: color_histogram_hsv(img, nbin=num_color_bins)] X_train_feats = extract_features(X_train, feature_fns, verbose=True) X_val_feats = extract_features(X_val, feature_fns) X_test_feats = extract_features(X_test, feature_fns) # Preprocessing: Subtract the mean feature mean_feat = np.mean(X_train_feats, axis=0, keepdims=True) X_train_feats -= mean_feat X_val_feats -= mean_feat X_test_feats -= mean_feat # Preprocessing: Divide by standard deviation. This ensures that each feature # has roughly the same scale. std_feat = np.std(X_train_feats, axis=0, keepdims=True) X_train_feats /= std_feat X_val_feats /= std_feat X_test_feats /= std_feat # Preprocessing: Add a bias dimension X_train_feats = np.hstack([X_train_feats, np.ones((X_train_feats.shape[0], 1))]) X_val_feats = np.hstack([X_val_feats, np.ones((X_val_feats.shape[0], 1))]) X_test_feats = np.hstack([X_test_feats, np.ones((X_test_feats.shape[0], 1))]) TODO: Train SVM on features 用新数据训练，代码和之前差不多 # Use the validation set to tune the learning rate and regularization strength from cs231n.classifiers.linear_classifier import LinearSVM learning_rates = [1e-9, 1e-8, 1e-7] regularization_strengths = [5e4, 5e5, 5e6] results = {} best_val = -1 best_svm = None ################################################################################ # TODO: # # Use the validation set to set the learning rate and regularization strength. # # This should be identical to the validation that you did for the SVM; save # # the best trained classifer in best_svm. You might also want to play # # with different numbers of bins in the color histogram. If you are careful # # you should be able to get accuracy of near 0.44 on the validation set. # ################################################################################ # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** for lr in learning_rates: for reg in regularization_strengths: svm = LinearSVM() svm.train(X_train_feats, y_train, learning_rate=lr, reg=reg, num_iters=2000, verbose=False) y_train_pred = svm.predict(X_train_feats) train_accuracy = np.mean(y_train == y_train_pred) y_val_pred = svm.predict(X_val_feats) val_accuracy = np.mean(y_val == y_val_pred) results[(lr, reg)] = (train_accuracy, val_accuracy) if val_accuracy \u003e best_val: best_val = val_accuracy best_svm = svm # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** # Print out results. for lr, reg in sorted(results): train_accuracy, val_accuracy = results[(lr, reg)] print('lr %e reg %e train accuracy: %f val accuracy: %f' % ( lr, reg, train_accuracy, val_accuracy)) print('best validation accuracy achieved: %f' % best_val) lr 1.000000e-09 reg 5.000000e+04 train accuracy: 0.099714 val accuracy: 0.093000 lr 1.000000e-09 reg 5.000000e+05 train accuracy: 0.093898 val accuracy: 0.078000 lr 1.000000e-09 reg 5.000000e+06 train accuracy: 0.414571 val accuracy: 0.413000 lr 1.000000e-08 reg 5.000000e+04 train accuracy: 0.092082 val accuracy: 0.077000 lr 1.000000e-08 reg 5.000000e+05 train accuracy: 0.413224 val accuracy: 0.422000 lr 1.000000e-08 reg 5.000000e+06 train accuracy: 0.409714 val accuracy: 0.393000 lr 1.000000e-07 reg 5.000000e+04 train accuracy: 0.417327 val accuracy: 0.421000 lr 1.000000e-07 reg 5.000000e+05 train accuracy: 0.407857 val accuracy: 0.396000 lr 1.000000e-07 reg 5.000000e+06 train accuracy: 0.321898 val accuracy: 0.309000 best validation accuracy achieved: 0.422000 # Evaluate your trained SVM on the test set: you should be able to get at least 0.40 y_test_pred = best_svm.predict(X_test_feats) test_accuracy = np.mean(y_test == y_test_pred) print(test_accuracy) 0.424 Inline question 1: Describe the misclassification results that you see. Do they make sense? ${\\textit Your Answer:}$ 可以理解，因为有些太相似了。 TODO: Neural Network on image f","date":"2024-12-03","objectID":"/posts/mlcs231n/:2:5","tags":["KNN","神经网络","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["机器学习"],"content":"Assignment 2 ","date":"2024-12-03","objectID":"/posts/mlcs231n/:3:0","tags":["KNN","神经网络","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["机器学习"],"content":"Q1: Multi-Layer Fully Connected Neural Networks TODO: fc_net __init__ 先解释一下 __init__ 的参数。 参数翻译： hidden_dims: 一个整数列表，指定每个隐藏层的大小（神经元数量） input_dim: 一个整数，指定输入层的维度大小（默认值为3x32x32，适用于32x32的RGB图像） num_classes: 一个整数，指定需要分类的类别数量（默认为10类） dropout_keep_ratio: 丢弃强度，一个0到1之间的标量，表示dropout保留神经元的比例。如果等于1则表示不使用dropout normalization: 指定网络使用的归一化类型，可选值包括： batchnorm: 批量归一化 layernorm: 层归一化 None: 不使用归一化（默认值） reg: 一个标量，表示L2正则化的强度 weight_scale: 一个标量，表示权重初始化时使用的正态分布标准差 dtype: numpy数据类型对象。所有计算都将使用此数据类型： float32: 运算更快但精度较低 float64: 适用于数值梯度检查，精度更高 seed: 随机种子。如果不为None，则传递给dropout层使其具有确定性，便于进行梯度检查 然后开始初始化参数， # 获取所有层的维度 dims = [input_dim] + hidden_dims + [num_classes] # 初始化每一层的参数 for i in range(self.num_layers): # 初始化权重矩阵,使用正态分布 self.params['W' + str(i + 1)] = weight_scale * np.random.randn(dims[i], dims[i + 1]) # 初始化偏置向量为0 self.params['b' + str(i + 1)] = np.zeros(dims[i + 1]) # 如果使用批归一化且不是最后一层，最后一层不需要正则化参数 if self.normalization and i \u003c self.num_layers - 1: # gamma初始化为1 self.params['gamma' + str(i + 1)] = np.ones(dims[i + 1]) # beta初始化为0 self.params['beta' + str(i + 1)] = np.zeros(dims[i + 1]) 注意最后一层不需要正则化参数，因为模型里最后一层是 softmax，本身就会归一化到 $0 \\sim 1$ loss 把 assignment1 的 layers.py 先抄过来，然后写一下前向传播和反向传播。 def loss(self, X, y=None): \"\"\"Compute loss and gradient for the fully connected net. Inputs: - X: Array of input data of shape (N, d_1, ..., d_k) - y: Array of labels, of shape (N,). y[i] gives the label for X[i]. Returns: If y is None, then run a test-time forward pass of the model and return: - scores: Array of shape (N, C) giving classification scores, where scores[i, c] is the classification score for X[i] and class c. If y is not None, then run a training-time forward and backward pass and return a tuple of: - loss: Scalar value giving the loss - grads: Dictionary with the same keys as self.params, mapping parameter names to gradients of the loss with respect to those parameters. \"\"\" X = X.astype(self.dtype) mode = \"test\" if y is None else \"train\" # Set train/test mode for batchnorm params and dropout param since they # behave differently during training and testing. if self.use_dropout: self.dropout_param[\"mode\"] = mode if self.normalization == \"batchnorm\": for bn_param in self.bn_params: bn_param[\"mode\"] = mode scores = None ############################################################################ # TODO: Implement the forward pass for the fully connected net, computing # # the class scores for X and storing them in the scores variable. # # # # When using dropout, you'll need to pass self.dropout_param to each # # dropout forward pass. # # # # When using batch normalization, you'll need to pass self.bn_params[0] to # # the forward pass for the first batch normalization layer, pass # # self.bn_params[1] to the forward pass for the second batch normalization # # layer, etc. # ############################################################################ # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** # 用一个变量保存上一层的输出 layer_input = X caches = {} # 对前面 L - 1 层进行操作，因为最后一层的操作和前面的不一样 for i in range(1, self.num_layers): W = self.params['W' + str(i)] b = self.params['b' + str(i)] # 计算affine层的输出 affine_out, affine_cache = affine_forward(layer_input, W, b) # 计算relu层的输出 relu_out, relu_cache = relu_forward(affine_out) # 保存cache caches['affine_cache' + str(i)] = affine_cache caches['relu_cache' + str(i)] = relu_cache # 更新layer_input layer_input = relu_out # 最后一层的操作 W = self.params['W' + str(self.num_layers)] b = self.params['b' + str(self.num_layers)] scores, affine_cache = affine_forward(layer_input, W, b) caches['affine_cache' + str(self.num_layers)] = affine_cache # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** ############################################################################ # END OF YOUR CODE # ############################################################################ # If test mode return early. if mode == \"test\": return scores loss, grads = 0.0, {} ############################################################################ #","date":"2024-12-03","objectID":"/posts/mlcs231n/:3:1","tags":["KNN","神经网络","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["机器学习"],"content":"Q2: Batch Normalization 参考论文 核心公式： TODO: batchnorm_forward def batchnorm_forward(x, gamma, beta, bn_param): \"\"\" Forward pass for batch normalization. During training the sample mean and (uncorrected) sample variance are computed from minibatch statistics and used to normalize the incoming data. During training we also keep an exponentially decaying running mean of the mean and variance of each feature, and these averages are used to normalize data at test-time. At each timestep we update the running averages for mean and variance using an exponential decay based on the momentum parameter: running_mean = momentum * running_mean + (1 - momentum) * sample_mean running_var = momentum * running_var + (1 - momentum) * sample_var Note that the batch normalization paper suggests a different test-time behavior: they compute sample mean and variance for each feature using a large number of training images rather than using a running average. For this implementation we have chosen to use running averages instead since they do not require an additional estimation step; the torch7 implementation of batch normalization also uses running averages. Input: - x: Data of shape (N, D) - gamma: Scale parameter of shape (D,) - beta: Shift paremeter of shape (D,) - bn_param: Dictionary with the following keys: - mode: 'train' or 'test'; required - eps: Constant for numeric stability - momentum: Constant for running mean / variance. - running_mean: Array of shape (D,) giving running mean of features - running_var Array of shape (D,) giving running variance of features Returns a tuple of: - out: of shape (N, D) - cache: A tuple of values needed in the backward pass \"\"\" mode = bn_param[\"mode\"] eps = bn_param.get(\"eps\", 1e-5) momentum = bn_param.get(\"momentum\", 0.9) N, D = x.shape running_mean = bn_param.get(\"running_mean\", np.zeros(D, dtype=x.dtype)) running_var = bn_param.get(\"running_var\", np.zeros(D, dtype=x.dtype)) out, cache = None, None if mode == \"train\": ####################################################################### # TODO: Implement the training-time forward pass for batch norm. # # Use minibatch statistics to compute the mean and variance, use # # these statistics to normalize the incoming data, and scale and # # shift the normalized data using gamma and beta. # # # # You should store the output in the variable out. Any intermediates # # that you need for the backward pass should be stored in the cache # # variable. # # # # You should also use your computed sample mean and variance together # # with the momentum variable to update the running mean and running # # variance, storing your result in the running_mean and running_var # # variables. # # # # Note that though you should be keeping track of the running # # variance, you should normalize the data based on the standard # # deviation (square root of variance) instead! # # Referencing the original paper (https://arxiv.org/abs/1502.03167) # # might prove to be helpful. # ####################################################################### # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** mean, var = np.mean(x, axis=0), np.var(x, axis=0) x_norm = (x - mean) / np.sqrt(var + eps) out = gamma * x_norm + beta running_mean = momentum * running_mean + (1 - momentum) * mean running_var = momentum * running_var + (1 - momentum) * var cache = (x, x_norm, mean, var, gamma, beta, eps) # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** ####################################################################### # END OF YOUR CODE # ####################################################################### elif mode == \"test\": ####################################################################### # TODO: Implement the test-time forward pass for batch normalization. # # Use the running mean and variance to normalize the incoming data, # # then scale and shift the normalized data using gamma and beta. # # Store the result in the out variable. # ################################","date":"2024-12-03","objectID":"/posts/mlcs231n/:3:2","tags":["KNN","神经网络","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["机器学习"],"content":"Q3: Dropout 参考论文 简单来说就是前向传播的时候会随机把一些神经元的值变为 0，可以缓解过拟合。 TODO: dropout_forward 参考官网讲义：官网讲义 生成一个 0/1 概率向量，其中概率为 $p$，如果概率小于 $p$ 则不会被置为 $0$，为了最后输出期望统一要乘上 $\\dfrac{1}{p}$ 放缩。 def dropout_forward(x, dropout_param): \"\"\" Performs the forward pass for (inverted) dropout. Inputs: - x: Input data, of any shape - dropout_param: A dictionary with the following keys: - p: Dropout parameter. We keep each neuron output with probability p. - mode: 'test' or 'train'. If the mode is train, then perform dropout; if the mode is test, then just return the input. - seed: Seed for the random number generator. Passing seed makes this function deterministic, which is needed for gradient checking but not in real networks. Outputs: - out: Array of the same shape as x. - cache: tuple (dropout_param, mask). In training mode, mask is the dropout mask that was used to multiply the input; in test mode, mask is None. NOTE: Please implement **inverted** dropout, not the vanilla version of dropout. See http://cs231n.github.io/neural-networks-2/#reg for more details. NOTE 2: Keep in mind that p is the probability of **keep** a neuron output; this might be contrary to some sources, where it is referred to as the probability of dropping a neuron output. \"\"\" p, mode = dropout_param[\"p\"], dropout_param[\"mode\"] if \"seed\" in dropout_param: np.random.seed(dropout_param[\"seed\"]) mask = None out = None if mode == \"train\": ####################################################################### # TODO: Implement training phase forward pass for inverted dropout. # # Store the dropout mask in the mask variable. # ####################################################################### # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** mask = (np.random.rand(*x.shape) \u003c p) / p out = x * mask # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** ####################################################################### # END OF YOUR CODE # ####################################################################### elif mode == \"test\": ####################################################################### # TODO: Implement the test phase forward pass for inverted dropout. # ####################################################################### # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** out = x # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** ####################################################################### # END OF YOUR CODE # ####################################################################### cache = (dropout_param, mask) out = out.astype(x.dtype, copy=False) return out, cache Running tests with p = 0.25 Mean of input: 10.000207878477502 Mean of train-time output: 10.014059116977283 Mean of test-time output: 10.000207878477502 Fraction of train-time output set to zero: 0.749784 Fraction of test-time output set to zero: 0.0 Running tests with p = 0.4 Mean of input: 10.000207878477502 Mean of train-time output: 9.977917658761159 Mean of test-time output: 10.000207878477502 Fraction of train-time output set to zero: 0.600796 Fraction of test-time output set to zero: 0.0 Running tests with p = 0.7 Mean of input: 10.000207878477502 Mean of train-time output: 9.987811912159426 Mean of test-time output: 10.000207878477502 Fraction of train-time output set to zero: 0.30074 Fraction of test-time output set to zero: 0.0 TODO: dropout_backward def dropout_backward(dout, cache): \"\"\" Perform the backward pass for (inverted) dropout. Inputs: - dout: Upstream derivatives, of any shape - cache: (dropout_param, mask) from dropout_forward. \"\"\" dropout_param, mask = cache mode = dropout_param[\"mode\"] dx = None if mode == \"train\": ####################################################################### # TODO: Implement training phase backward pass for inverted dropout # ####################################################################### # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** dx = dout * mask # *****END OF YOUR CO","date":"2024-12-03","objectID":"/posts/mlcs231n/:3:3","tags":["KNN","神经网络","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["机器学习"],"content":"Q4: Convolutional Neural Networks TODO: conv_forward_naive def conv_forward_naive(x, w, b, conv_param): \"\"\" A naive implementation of the forward pass for a convolutional layer. The input consists of N data points, each with C channels, height H and width W. We convolve each input with F different filters, where each filter spans all C channels and has height HH and width WW. Input: - x: Input data of shape (N, C, H, W) - w: Filter weights of shape (F, C, HH, WW) - b: Biases, of shape (F,) - conv_param: A dictionary with the following keys: - 'stride': The number of pixels between adjacent receptive fields in the horizontal and vertical directions. - 'pad': The number of pixels that will be used to zero-pad the input. During padding, 'pad' zeros should be placed symmetrically (i.e equally on both sides) along the height and width axes of the input. Be careful not to modfiy the original input x directly. Returns a tuple of: - out: Output data, of shape (N, F, H', W') where H' and W' are given by H' = 1 + (H + 2 * pad - HH) / stride W' = 1 + (W + 2 * pad - WW) / stride - cache: (x, w, b, conv_param) \"\"\" out = None ########################################################################### # TODO: Implement the convolutional forward pass. # # Hint: you can use the function np.pad for padding. # ########################################################################### # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** # 先获取一些需要用到的数据 N, C, H_input, W_input = x.shape # N个样本，C个通道，H_input高，W_input宽 F, C_w_, HH, WW = w.shape # F个卷积核, C_w_个通道，HH高，WW宽 stride = conv_param[\"stride\"] # 步长 pad = conv_param[\"pad\"] # 填充数量 # 计算卷积后的高和宽 out_H = int(1 + (H_input + 2 * pad - HH) / stride) out_W = int(1 + (W_input + 2 * pad - WW) / stride) # 给x的上下左右填充上pad个0 x_pad = np.pad(x, ((0, 0), (0, 0), (pad, pad), (pad, pad)), \"constant\", constant_values=0) # 将卷积核w转换成F * (C * HH * WW)的矩阵 (便于使用矩阵乘法) w_row = w.reshape(F, -1) # 生成空白输出便于后续循环填充 out = np.zeros((N, F, out_H, out_W)) # 开始卷积 for n in range(N): # 遍历样本 for f in range(F): # 遍历卷积核 for i in range(out_H): # 遍历高 for j in range(out_W): # 遍历宽 # 获取当前卷积窗口 window = x_pad[n, :, i * stride:i * stride + HH, j * stride:j * stride + WW] # 将卷积窗口拉成一行 window_row = window.reshape(1, -1) # 计算当前卷积窗口和卷积核的卷积结果 out[n, f, i, j] = np.sum(window_row * w_row[f, :]) + b[f] # 将pad后的x存入cache (省的反向传播的时候在计算一次) x = x_pad # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** ########################################################################### # END OF YOUR CODE # ########################################################################### cache = (x, w, b, conv_param) return out, cache Testing conv_forward_naive difference: 2.2121476417505994e-08 TODO: conv_backward_naive def conv_backward_naive(dout, cache): \"\"\" A naive implementation of the backward pass for a convolutional layer. Inputs: - dout: Upstream derivatives. - cache: A tuple of (x, w, b, conv_param) as in conv_forward_naive Returns a tuple of: - dx: Gradient with respect to x - dw: Gradient with respect to w - db: Gradient with respect to b \"\"\" dx, dw, db = None, None, None ########################################################################### # TODO: Implement the convolutional backward pass. # ########################################################################### # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** # 获取一些需要用到的数据 x, w, b, conv_param = cache N, C, H_input, W_input = x.shape # N个样本，C个通道，H_input高，W_input宽 F, C_w_, HH, WW = w.shape # F个卷积核, C_w_个通道，HH高，WW宽 stride = conv_param[\"stride\"] # 步长 pad = conv_param[\"pad\"] # 填充数量 # 计算卷积后的高和宽 out_H = int(1 + (H_input - HH) / stride) out_W = int(1 + (W_input - WW) / stride) # 给dx,dw,db分配空间 dx = np.zeros_like(x) dw = np.zeros_like(w) db = np.zeros_like(b) for n in range(N): for f in range(F): for i in range(out_H): for j in range(out_W): # 获取当前卷积窗口 window = x[n, :, i * stride:i * stride + HH, j * stride:j * stride + WW] # 计算db db[f] += dout[n, f, i, j] # 计算dw dw[f] += window ","date":"2024-12-03","objectID":"/posts/mlcs231n/:3:4","tags":["KNN","神经网络","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["机器学习"],"content":"Q5: PyTorch on CIFAR-10 使用 PyTorch 来实现一些神经网络。 Barebones PyTorch: Two-Layer Network 实现一个两层 ReLU 的全连接神经网络，主要是对 PyTorch 的基本语法熟悉一下。 import torch.nn.functional as F # useful stateless functions def two_layer_fc(x, params): \"\"\" A fully-connected neural networks; the architecture is: NN is fully connected -\u003e ReLU -\u003e fully connected layer. Note that this function only defines the forward pass; PyTorch will take care of the backward pass for us. The input to the network will be a minibatch of data, of shape (N, d1, ..., dM) where d1 * ... * dM = D. The hidden layer will have H units, and the output layer will produce scores for C classes. Inputs: - x: A PyTorch Tensor of shape (N, d1, ..., dM) giving a minibatch of input data. - params: A list [w1, w2] of PyTorch Tensors giving weights for the network; w1 has shape (D, H) and w2 has shape (H, C). Returns: - scores: A PyTorch Tensor of shape (N, C) giving classification scores for the input data x. \"\"\" # first we flatten the image x = flatten(x) # shape: [batch_size, C x H x W] w1, w2 = params # Forward pass: compute predicted y using operations on Tensors. Since w1 and # w2 have requires_grad=True, operations involving these Tensors will cause # PyTorch to build a computational graph, allowing automatic computation of # gradients. Since we are no longer implementing the backward pass by hand we # don't need to keep references to intermediate values. # you can also use `.clamp(min=0)`, equivalent to F.relu() x = F.relu(x.mm(w1)) x = x.mm(w2) return x def two_layer_fc_test(): hidden_layer_size = 42 x = torch.zeros((64, 50), dtype=dtype) # minibatch size 64, feature dimension 50 w1 = torch.zeros((50, hidden_layer_size), dtype=dtype) w2 = torch.zeros((hidden_layer_size, 10), dtype=dtype) scores = two_layer_fc(x, [w1, w2]) print(scores.size()) # you should see [64, 10] two_layer_fc_test() torch.nn.functional 是定义了一个无状态函数，他提供了一系列的常用函数。 torch.zeros 是 PyTorch 中的一个函数，用于创建一个全为零的张量。 flatten 是将输入的图像数据扁平化为一维向量，以便于后续的全连接层处理。 mm() 矩阵乘法。 TODO: Barebones PyTorch: Three-Layer ConvNet 完成函数 three_layer_convnet 的实现，该函数将执行三层卷积网络的前向传播。网络应具有以下架构： 一个卷积层（带偏置），具有 channel_1 个滤波器，每个滤波器的形状为 KW1 x KH1，并且有零填充为2。 ReLU 非线性激活。 一个卷积层（带偏置），具有 channel_2 个滤波器，每个滤波器的形状为 KW2 x KH2，并且有零填充为1。 ReLU 非线性激活。 一个全连接层（带偏置），生成 C 类的分数。 def three_layer_convnet(x, params): \"\"\" Performs the forward pass of a three-layer convolutional network with the architecture defined above. Inputs: - x: A PyTorch Tensor of shape (N, 3, H, W) giving a minibatch of images - params: A list of PyTorch Tensors giving the weights and biases for the network; should contain the following: - conv_w1: PyTorch Tensor of shape (channel_1, 3, KH1, KW1) giving weights for the first convolutional layer - conv_b1: PyTorch Tensor of shape (channel_1,) giving biases for the first convolutional layer - conv_w2: PyTorch Tensor of shape (channel_2, channel_1, KH2, KW2) giving weights for the second convolutional layer - conv_b2: PyTorch Tensor of shape (channel_2,) giving biases for the second convolutional layer - fc_w: PyTorch Tensor giving weights for the fully-connected layer. Can you figure out what the shape should be? - fc_b: PyTorch Tensor giving biases for the fully-connected layer. Can you figure out what the shape should be? Returns: - scores: PyTorch Tensor of shape (N, C) giving classification scores for x \"\"\" conv_w1, conv_b1, conv_w2, conv_b2, fc_w, fc_b = params scores = None ################################################################################ # TODO: Implement the forward pass for the three-layer ConvNet. # ################################################################################ # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** # 第一层卷积 x = F.conv2d(x, conv_w1, conv_b1, padding=2) # 使用零填充 x = F.relu(x) # ReLU 激活 # 第二层卷积 x = F.conv2d(x, conv_w2, conv_b2, padding=1) # 使用零填充 x = F.relu(x) # ReLU 激活 # 展平 x = flatten(x) # 全连接层 scores = x.mm(fc_w) + fc_b # 计算分数 # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** ########","date":"2024-12-03","objectID":"/posts/mlcs231n/:3:5","tags":["KNN","神经网络","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["机器学习"],"content":"BareBones PyTorch: 训练卷积神经网络 训练一个三层卷积网络。网络应具有以下架构： 卷积层（带偏置），使用32个5x5的滤波器，零填充为2 ReLU激活 卷积层（带偏置），使用16个3x3的滤波器，零填充为1 ReLU激活 全连接层（带偏置），用于计算10个类别的分数 您应该使用上面定义的random_weight函数来初始化权重矩阵，并使用zero_weight函数来初始化偏置向量。 您不需要调整任何超参数，但如果一切正常，您应该在一个epoch后达到超过42%的准确率。 learning_rate = 3e-3 channel_1 = 32 channel_2 = 16 conv_w1 = None conv_b1 = None conv_w2 = None conv_b2 = None fc_w = None fc_b = None ################################################################################ # TODO: Initialize the parameters of a three-layer ConvNet. # ################################################################################ # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** conv_w1 = random_weight((channel_1, 3, 5, 5)) conv_b1 = zero_weight(channel_1) conv_w2 = random_weight((channel_2, channel_1, 3, 3)) conv_b2 = zero_weight(channel_2) fc_w = random_weight((channel_2 * 32 * 32, 10)) fc_b = zero_weight(10) # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** ################################################################################ # END OF YOUR CODE # ################################################################################ params = [conv_w1, conv_b1, conv_w2, conv_b2, fc_w, fc_b] train_part2(three_layer_convnet, params, learning_rate) Iteration 0, loss = 3.8646 Checking accuracy on the val set Got 107 / 1000 correct (10.70%) Iteration 100, loss = 1.8770 Checking accuracy on the val set Got 317 / 1000 correct (31.70%) Iteration 200, loss = 1.8188 Checking accuracy on the val set Got 375 / 1000 correct (37.50%) Iteration 300, loss = 1.6608 Checking accuracy on the val set Got 397 / 1000 correct (39.70%) Iteration 400, loss = 1.7184 Checking accuracy on the val set Got 437 / 1000 correct (43.70%) Iteration 500, loss = 1.6697 Checking accuracy on the val set Got 450 / 1000 correct (45.00%) Iteration 600, loss = 1.6106 ... Iteration 700, loss = 1.4275 Checking accuracy on the val set Got 438 / 1000 correct (43.80%) TODO: Module API: Three-Layer ConvNet ","date":"2024-12-03","objectID":"/posts/mlcs231n/:3:6","tags":["KNN","神经网络","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["机器学习"],"content":"模块 API：三层卷积网络 实现一个三层卷积网络，后面跟一个全连接层。网络架构应该与第二部分相同： 使用 channel_1 个 5x5 的卷积层，零填充为 2 ReLU 激活 使用 channel_2 个 3x3 的卷积层，零填充为 1 ReLU 激活 全连接层，输出 num_classes 个类别 你应该使用 Kaiming 正态初始化方法来初始化模型的权重矩阵。 提示: PyTorch 文档 在你实现三层卷积网络后，test_ThreeLayerConvNet 函数将运行你的实现；它应该打印输出分数的形状为 (64, 10)。 class ThreeLayerConvNet(nn.Module): def __init__(self, in_channel, channel_1, channel_2, num_classes): super().__init__() ######################################################################## # TODO: Set up the layers you need for a three-layer ConvNet with the # # architecture defined above. # ######################################################################## # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** # 定义卷积层和全连接层 self.conv1 = nn.Conv2d(in_channel, channel_1, kernel_size=5, padding=2) # 第一层卷积 self.conv2 = nn.Conv2d(channel_1, channel_2, kernel_size=3, padding=1) # 第二层卷积 self.fc3 = nn.Linear(channel_2 * 32 * 32, num_classes) # 全连接层 # Kaiming 正态初始化 nn.init.kaiming_normal_(self.conv1.weight) nn.init.kaiming_normal_(self.conv2.weight) nn.init.kaiming_normal_(self.fc3.weight) # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** ######################################################################## # END OF YOUR CODE # ######################################################################## def forward(self, x): scores = None ######################################################################## # TODO: Implement the forward function for a 3-layer ConvNet. you # # should use the layers you defined in __init__ and specify the # # connectivity of those layers in forward() # ######################################################################## # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** # 定义前向传播 x = F.relu(self.conv1(x)) # 第一层卷积 + ReLU x = F.relu(self.conv2(x)) # 第二层卷积 + ReLU x = flatten(x) # 展平 scores = self.fc3(x) # 全连接层 # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** ######################################################################## # END OF YOUR CODE # ######################################################################## return scores def test_ThreeLayerConvNet(): x = torch.zeros((64, 3, 32, 32), dtype=dtype) # minibatch size 64, image size [3, 32, 32] model = ThreeLayerConvNet(in_channel=3, channel_1=12, channel_2=8, num_classes=10) scores = model(x) print(scores.size()) # you should see [64, 10] test_ThreeLayerConvNet() TODO: Module API: Train a Three-Layer ConvNet learning_rate = 3e-3 channel_1 = 32 channel_2 = 16 model = None optimizer = None ################################################################################ # TODO: Instantiate your ThreeLayerConvNet model and a corresponding optimizer # ################################################################################ # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** # 实例化三层卷积神经网络模型 model = ThreeLayerConvNet(in_channel=3, channel_1=channel_1, channel_2=channel_2, num_classes=10) # 定义优化器 optimizer = optim.SGD(model.parameters(), lr=learning_rate) # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** ################################################################################ # END OF YOUR CODE # ################################################################################ train_part34(model, optimizer) Iteration 0, loss = 2.8420 Checking accuracy on validation set Got 120 / 1000 correct (12.00) Iteration 100, loss = 1.8090 Checking accuracy on validation set Got 336 / 1000 correct (33.60) Iteration 200, loss = 1.8638 Checking accuracy on validation set Got 385 / 1000 correct (38.50) Iteration 300, loss = 1.5297 Checking accuracy on validation set Got 402 / 1000 correct (40.20) Iteration 400, loss = 1.5403 Checking accuracy on validation set Got 430 / 1000 correct (43.00) Iteration 500, loss = 1.5430 Checking accuracy on validation set Got 450 / 1000 correct (45.00) Iteration 600, loss = 1.5708 ... Iteration 700, loss = 1.6809 Checking accuracy on validation set Got 466 / 1000 correct ","date":"2024-12-03","objectID":"/posts/mlcs231n/:3:7","tags":["KNN","神经网络","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["机器学习"],"content":"顺序API：三层卷积神经网络 使用 nn.Sequential 来定义和训练一个三层卷积神经网络，其架构与我们在第三部分中使用的相同： 卷积层（带偏置）使用32个5x5的滤波器，零填充为2 ReLU 卷积层（带偏置）使用16个3x3的滤波器，零填充为1 ReLU 全连接层（带偏置）计算10个类别的分数 您可以使用默认的PyTorch权重初始化。 您应该使用带有Nesterov动量0.9的随机梯度下降来优化您的模型。 同样，您不需要调整任何超参数，但您应该在训练一个周期后看到准确率超过55%。 channel_1 = 32 channel_2 = 16 learning_rate = 1e-2 model = None optimizer = None ################################################################################ # TODO: Rewrite the 3-layer ConvNet with bias from Part III with the # # Sequential API. # ################################################################################ # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** model = nn.Sequential( nn.Conv2d(3, channel_1, kernel_size=5, padding=2), # 第一层卷积 nn.ReLU(), # ReLU 激活 nn.Conv2d(channel_1, channel_2, kernel_size=3, padding=1), # 第二层卷积 nn.ReLU(), # ReLU 激活 Flatten(), # 展平 nn.Linear(channel_2 * 32 * 32, 10) # 全连接层 ) optimizer = optim.SGD(model.parameters(), lr=learning_rate, momentum=0.9, nesterov=True) # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** ################################################################################ # END OF YOUR CODE # ################################################################################ train_part34(model, optimizer) Iteration 0, loss = 2.2989 Checking accuracy on validation set Got 116 / 1000 correct (11.60) Iteration 100, loss = 1.6947 Checking accuracy on validation set Got 457 / 1000 correct (45.70) Iteration 200, loss = 1.7063 Checking accuracy on validation set Got 476 / 1000 correct (47.60) Iteration 300, loss = 1.1563 Checking accuracy on validation set Got 495 / 1000 correct (49.50) Iteration 400, loss = 1.3090 Checking accuracy on validation set Got 553 / 1000 correct (55.30) Iteration 500, loss = 1.0429 Checking accuracy on validation set Got 539 / 1000 correct (53.90) Iteration 600, loss = 1.4302 ... Iteration 700, loss = 1.3101 Checking accuracy on validation set Got 579 / 1000 correct (57.90) TODO: Part V. CIFAR-10 open-ended challenge 在这一部分中，您可以尝试在 CIFAR-10 上实验任何卷积神经网络架构。 现在轮到您实验架构、超参数、损失函数和优化器，以训练一个在 CIFAR-10 验证集上达到 至少 70% 准确率的模型，训练时间不超过 10 个周期。您可以使用上面的 check_accuracy 和 train 函数。您可以使用 nn.Module 或 nn.Sequential API。 使用 ResNet 模型。 import torchvision ################################################################################ # TODO: # # Experiment with any architectures, optimizers, and hyperparameters. # # Achieve AT LEAST 70% accuracy on the *validation set* within 10 epochs. # # # # Note that you can use the check_accuracy function to evaluate on either # # the test set or the validation set, by passing either loader_test or # # loader_val as the second argument to check_accuracy. You should not touch # # the test set until you have finished your architecture and hyperparameter # # tuning, and only run the test set once at the end to report a final value. # ################################################################################ model = None optimizer = None # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)***** ################################################################################ # TODO: # # Experiment with any architectures, optimizers, and hyperparameters. # # Achieve AT LEAST 70% accuracy on the *validation set* within 10 epochs. # # # # Note that you can use the check_accuracy function to evaluate on either # # the test set or the validation set, by passing either loader_test or # # loader_val as the second argument to check_accuracy. You should not touch # # the test set until you have finished your architecture and hyperparameter # # tuning, and only run the test set once at the end to report a final value. # ################################################################################ model = None optimizer = None # 使用ResNet-18架构 model = torchvision.models.resnet18(pretrained=False) # 修改第一层卷积（原ImageNet输入为3通道224x224，CIFAR-10为3通道32x32） model.conv1 = nn.Conv2d(3, 64, kernel_size=3, stride=1, padding=1, bias=False) # 移除原最大池化层（因图像尺寸较小） model.maxpo","date":"2024-12-03","objectID":"/posts/mlcs231n/:3:8","tags":["KNN","神经网络","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["机器学习"],"content":"参考 https://github.com/Divsigma/2020-cs213n/tree/master/cs231n https://github.com/Na-moe/CS231n-2024/tree/main https://github.com/Chia202/CS231n/tree/main https://blog.csdn.net/leezed525/category_12388436.html ","date":"2024-12-03","objectID":"/posts/mlcs231n/:4:0","tags":["KNN","神经网络","SVM"],"title":"CS231n","uri":"/posts/mlcs231n/"},{"categories":["机器学习"],"content":"概述 简单来讲，就是给定一个训练集，然后拿到一个新的输入数据，在训练集中找到与该输入的 $k$ 个数据，这 $k$ 个数据数量多的某个类，就是该新数据的类别。这个算法称为 $k$ 近邻 ($\\text{K-Nearest Neighbors}$) ","date":"2024-11-28","objectID":"/posts/mlknn/:1:0","tags":["KNN","KDTree"],"title":"KNN","uri":"/posts/mlknn/"},{"categories":["机器学习"],"content":"模型 ","date":"2024-11-28","objectID":"/posts/mlknn/:2:0","tags":["KNN","KDTree"],"title":"KNN","uri":"/posts/mlknn/"},{"categories":["机器学习"],"content":"距离 输入和训练集的距离该如何度量，一般来说有以下几种度量方式： 假设数据集特征向量 $x_i \\in \\textbf{R}^n$，$x_i = \\left(x_i^{(1)}, x_i^{(2)},\\cdots,x_i^{(n)}\\right) ^ \\top$ 闵可夫斯基 (Minkowski) 距离 $$ L_p(x_i,x_j) = \\left( \\sum_{l = 1} ^ {n} |x_i^{(l)} - x_j^{(l)}|^p \\right) ^ {\\frac{1}{p}} $$ 欧氏距离 其实就是闵可夫斯基距离的 $p = 2$ $$ L_2(x_i,x_j) = \\sqrt{ \\sum_{l = 1} ^ {n} |x_i^{(l)} - x_j^{(l)}|^2 } $$ 曼哈顿距离 其实就是闵可夫斯基距离的 $p = 1$ $$ L_2(x_i,x_j) = \\sum_{l = 1} ^ {n} |x_i^{(l)} - x_j^{(l)}| $$ 显然的，不同距离的 k 近邻点是不同的。 ","date":"2024-11-28","objectID":"/posts/mlknn/:2:1","tags":["KNN","KDTree"],"title":"KNN","uri":"/posts/mlknn/"},{"categories":["机器学习"],"content":"$k$ 的大小 $k$ 过小：如果相邻点是噪声，会影响预测，过拟合。 $k$ 过大：模型简化，欠拟合。 建议使用网格搜索，交叉验证，选取一个较小的 $k$ 值开始，不断增加 $k$ 值，然后计算方差。 ","date":"2024-11-28","objectID":"/posts/mlknn/:2:2","tags":["KNN","KDTree"],"title":"KNN","uri":"/posts/mlknn/"},{"categories":["机器学习"],"content":"分类决策规则 多数表决法。 对于每个类别 $c_j \\in \\{ c_1,c_2,\\cdots,c_m \\}$ 来说，假设 $k$ 个近邻点的领域集为 $N_k(x)$，那么输出为 $$ y = \\argmax_{c_j} \\sum_{x_i \\in N_k(x)} [y_i = c_j] $$ 即出现次数最多的类别的类就是分类结果。 ","date":"2024-11-28","objectID":"/posts/mlknn/:2:3","tags":["KNN","KDTree"],"title":"KNN","uri":"/posts/mlknn/"},{"categories":["机器学习"],"content":"KDTree (K-Dimension Tree) 如何找 $k$ 个近邻的点呢？可以考虑使用 KDTree 实现，没错这就是算竞中的 KDTree。 建树 首先取第一维，找到该维所有点的中位数，选择这个点作为根节点，然后将小于该维的点归入左子树，其余的归入右子树 (相当于分割成两个超正方体) 维度增加 $1$ 并取模 $k$，继续对该维做步骤 $1$ 如此递归下去，当只有一个点的时候返回该点。 举一个 $k = 2$ 的例子。 建出的树： 这样树的高度最多为 $\\log n$ 插入 从根节点开始，在每一个节点处根据划分维度的坐标的相对大小决定往左还是往右走，直至到达某个叶子节点，然后将新点插入到该叶子节点下方即可。 删除 删除某个节点时，需要首先对该节点下方子树上的所有节点打散并重新构建新的子树，然后用新子树的根节点替换被删除的节点，并释放被删除节点的内存。 查询 首先看一下最近邻的查询方法。 从根节点出发，递归向下访问，如果目标点 $x$ 的当前维坐标小于访问点的坐标，则访问左子树，否则访问右子树，直到访问到叶节点为止。 假设该叶节点为最近点，以目标点 $x$ 为圆心，目标点 $x$ 到叶节点的距离为半径画一个超球。 递归向上回退，深度遍历每个树上节点，如果树上节点对应的点在超球内，则更新超球的半径，如果在超球外，直接剪枝。 最后超球上的那个点就是最近邻点。 那么 $k$ 近邻的方法就是将所有点放到一个优先队列里，优先队列里只存前 $k$ 近的点，超球半径就是目标点到最远点的距离，dfs 过程中依然要剪枝。 ","date":"2024-11-28","objectID":"/posts/mlknn/:2:4","tags":["KNN","KDTree"],"title":"KNN","uri":"/posts/mlknn/"},{"categories":["机器学习"],"content":"参考 https://zhuanlan.zhihu.com/p/529487972 https://oi-wiki.org/ds/kdt/ https://blog.csdn.net/weixin_39910711/article/details/114447104 https://blog.csdn.net/qq_42688495/article/details/124049811 统计学习方法(第2版)李航 ","date":"2024-11-28","objectID":"/posts/mlknn/:3:0","tags":["KNN","KDTree"],"title":"KNN","uri":"/posts/mlknn/"},{"categories":["机器学习"],"content":"线性可分二分类模型 在二维空间上，两类点被一条直线完全分开叫做线性可分。 还是拿之前的数据集举例，$(x_1, y_1), (x_2,y_2), \\cdots (x_n, y_n)$，$x_i \\in \\textbf{R} ^ d$，$d$ 为特征向量维度。 模型的目标是找到一条直线 $w x + b = 0$ 对于每个 $x_i$ 满足 $$ \\text{sign}(w^\\top x_i + b) = \\begin{cases} 1, y_i = 1 \\\\ -1, y_i = -1 \\end{cases} $$ 也就是说 $$ \\begin{cases} w^\\top x_i + b \u003e 0, y_i = 1 \\\\ w^\\top x_i + b \u003c 0, y_i = -1 \\end{cases} $$ 我们可以再简化一下式子，注意到 $y_i$ 乘以 $w^\\top x_i + b$ 始终大于 $0$，所以式子转化为 $y_i(w^\\top x_i + b) \u003e 0$ ","date":"2024-11-11","objectID":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/:1:0","tags":["SVM"],"title":"支持向量机 (SVM)","uri":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"categories":["机器学习"],"content":"最大化间隔 我们需要找到这条直线将正负样本划分开来，然后样本到直线的距离必须都要最远。 ","date":"2024-11-11","objectID":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/:1:1","tags":["SVM"],"title":"支持向量机 (SVM)","uri":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"categories":["机器学习"],"content":"支持向量 正负样本中距离超平面最近的一些点，这些点叫做支持向量。 ","date":"2024-11-11","objectID":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/:1:2","tags":["SVM"],"title":"支持向量机 (SVM)","uri":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"categories":["机器学习"],"content":"最优化 我们的目标是支持向量到划分超平面的距离最大。 考虑点到超平面的距离 $\\dfrac{|w^\\top x + b|}{||w||}$ 根据支持向量到超平面的距离为 $d$，其他点到超平面的距离大于 $d$ 我们有： $$ \\begin{cases} \\dfrac{1}{||w||} (w^\\top x_i + b) \\ge d, y_i = 1 \\\\ \\dfrac{1}{||w||} (w^\\top x_i + b) \\le -d, y_i = -1 \\end{cases} $$ 把 $d$ 除过去： $$ \\begin{cases} \\dfrac{1}{||w||d} (w^\\top x_i + b) \\ge 1, y_i = 1 \\\\ \\dfrac{1}{||w||d} (w^\\top x_i + b) \\le -1, y_i = -1 \\end{cases} $$ 令这一坨 $\\dfrac{1}{||w||d}$ 为 $1$ (方便推导，且对目标函数无影响) 得到： $$ \\begin{cases} w^\\top x_i + b \\ge 1, y_i = 1 \\\\ w^\\top x_i + b \\le -1, y_i = -1 \\end{cases} $$ 式子简化为 $y_i (w^\\top x_i + b) \\ge 1$ 含义如下图所示： 回顾我们要最大化的目标 $\\dfrac{|w^\\top x_i + b|}{||w||}$，由于 $y_i (w^\\top x_i + b) \\ge 1$，那么 $y_i (w^\\top x_i + b) = |w^\\top x_i + b|$，然后只考虑支持向量，那么 $y_i (w^\\top x_i + b) = 1$，再为了推导方便，我们将式子整体乘 $2$ (无影响)，原式变为 $\\max \\dfrac{2}{||w||}$，相当于 $\\min \\dfrac{||w||}{2}$，然后我们把 $||w||$ 加一个平方，因为 $x ^ 2$ 单调 (指大于 $0$ 时)不影响最小值点，式子变为 $$ \\min \\frac{1}{2} ||w|| ^ 2 \\\\ \\text{s.t.} \\ y_i (w^\\top x_i + b) \\ge 1 $$ 这就是硬间隔线性 SVM ","date":"2024-11-11","objectID":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/:1:3","tags":["SVM"],"title":"支持向量机 (SVM)","uri":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"categories":["机器学习"],"content":"对偶型 接下来考虑对偶型。 ","date":"2024-11-11","objectID":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/:2:0","tags":["SVM"],"title":"支持向量机 (SVM)","uri":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"categories":["机器学习"],"content":"KKT 条件 要先引入一个方法就是 KKT 条件。 首先看一个同时含有等式和不等式约束的多元函数极值。 $$ \\begin{aligned} \\min_u\\ \u0026f(u) \\\\ \\text{s.t.} \\ \u0026 g_i(u) \\le 0, \u0026 i = 1,2,\\cdots,m \\\\ \u0026 h_j(u) = 0, \u0026 j = 1,2,\\cdots, n \\end{aligned} $$ 对于等式直接拉格朗日乘数法没什么好说的，重点关注一下不等式。 我们假设目标函数为 $L(u, \\alpha, \\beta) = f(u) + \\sum\\limits_{i = 1} ^ {m} \\alpha_i g_i(u) + \\sum\\limits_{j = 1} ^ {n} \\beta_jh_j(u)$ 对于不等式来说，有 $g(u) \u003c 0$ 和 $g(u) = 0$ 两种情况。 当 $g(u) \u003c 0$ 时，相当于此条件作废，也就是没有限制条件了，约束函数不起作用，那么此时相当于 $\\alpha = 0$ 当 $g(u) = 0$ 时，相当于是等式的情况了，可行解 $u ^ *$ 满足 $\\nabla f(u ^ *) = -\\alpha \\nabla g(u ^ *)$，且梯度方向相反且平行，所以 $\\alpha \u003e 0$ 如下图所示 ($u$ 替换为 $x$)： 综上所述，满足 $\\alpha_i^* g(u*) = 0$，称作互补松弛。 ","date":"2024-11-11","objectID":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/:2:1","tags":["SVM"],"title":"支持向量机 (SVM)","uri":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"categories":["机器学习"],"content":"约束问题转换为 min max 拉格朗日函数 约束问题等价于 $$ \\begin{aligned} \\min_u \\max_{\\alpha, \\beta}\\ \u0026 L(u, \\alpha, \\beta) \\\\ \\text{s.t.} \\ \u0026 \\alpha_i \\ge 0, \u0026 i = 1,2,\\cdots,m \\end{aligned} $$ 证明： 原式为 $$ \\min_u \\max_{\\alpha, \\beta} \\left(f(u) + \\sum_{i = 1} ^ {m} \\alpha_i g_i(u) + \\sum_{j = 1} ^ {n} \\beta_jh_j(u) \\right) $$ $f(u)$ 无关，将 $\\max_{\\alpha, \\beta}$ 拿进去 $$ \\min_u \\left(f(u) + \\max_{\\alpha, \\beta} \\left(\\sum_{i = 1} ^ {m} \\alpha_i g_i(u) + \\sum_{j = 1} ^ {n} \\beta_jh_j(u) \\right) \\right) $$ 如果 $u$ 不满足约束，那么 $g_i(u) \u003e 0$，由于约束 $\\alpha_i \\ge 0$，可以取 $\\alpha_i = \\infty$，使得式子为 $\\infty$ 如果 $u$ 不满足等式约束，即 $h_j(u) \\ne 0$，由于 $\\beta_j$ 没有正负限制，可以取 $\\beta_j = \\text{sign}(h_j(u)) = \\infty$ 如果 $u$ 满足约束，那么 $\\alpha_i \\ge 0, \\alpha_i g(u) \\le 0$，且 $\\beta_jh_j(u) = 0$，式子结果为 $0$ 所以转化为 $$ \\min_u \\left(f(u) + \\begin{cases}0, \\forall i,j \\ g_i(u) \\le 0, h_j(u) = 0\\\\ \\infty, \\text{else}\\end{cases} \\right) $$ 分配 $\\min$ $$ \\min_u f(u) + \\min_u\\begin{cases}0, \\forall i,j \\ g_i(u) \\le 0, h_j(u) = 0\\\\ \\infty, \\text{else}\\end{cases} $$ 等价于 $\\min_u f(u)$，且 $u$ 满足约束。 交换 min max 由于硬间隔线性 SVM 满足 Slater 条件 (https://www.cnblogs.com/guanyang/p/16287060.html)，所以可以交换 min max 等价： $$ \\min_u \\max_{\\alpha, \\beta}\\ L(u, \\alpha, \\beta) = \\max_{\\alpha, \\beta} \\min_u \\ L(u, \\alpha, \\beta) $$ ","date":"2024-11-11","objectID":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/:2:2","tags":["SVM"],"title":"支持向量机 (SVM)","uri":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"categories":["机器学习"],"content":"对偶问题 回顾一下原始问题 $$ \\min \\frac{1}{2} ||w|| ^ 2 \\\\ \\text{s.t.} \\ 1 - y_i (w^\\top x_i + b) \\le 0 $$ 该问题没有等式约束，那么定义拉格朗日函数为 $L(w, b, \\alpha) = \\dfrac{1}{2} ||w||^2 + \\sum\\limits_{i = 1} ^ {m} \\alpha_i(1 - y_i (w^\\top x_i + b))$ 根据对偶性转换为 $$ \\max_\\alpha \\min_{w, b} \\ L(w, b, \\alpha) \\\\ \\text{s.t.} \\ \\alpha_i \\ge 0, i = 1, 2, \\cdots, m $$ 先考虑里面的 $\\min\\limits_{w, b} \\ L(w, b, \\alpha)$，我们直接对 $w, b$ 求偏导令成 $0$： $$ \\begin{aligned} \\frac{\\partial L}{\\partial w} \u0026= 0 \\\\ w - \\sum_{i = 1} ^ m \\alpha_i x_i y_i \u0026= 0 \\\\ \\sum_{i = 1} ^ m \\alpha_i x_i y_i \u0026= w \\end{aligned} $$ 解得最优值 $w ^ * = \\sum\\limits_{i = 1} ^ m\\alpha_i x_i y_i$，接下来对 $b$ 偏导： $$ \\begin{aligned} \\frac{\\partial L}{\\partial b} \u0026= 0 \\\\ \\sum_{i = 1} ^ m\\alpha_i y_i \u0026= 0 \\end{aligned} $$ 得到了一个等式 $\\sum\\limits_{i = 1} ^ m\\alpha_i y_i = 0$ 我们将两个偏导结果带入到原式： $$ \\begin{aligned} L(w ^ *, b ^ *, \\alpha) \u0026= \\frac{1}{2} ||w ^ *||^2 + \\sum_{i = 1} ^ {m} \\alpha_i(1 - y_i(w^\\top x_i + b)) \\\\ \u0026= \\frac{1}{2} ||w ^ *||^2 + \\sum_{i = 1} ^ {m} \\alpha_i - \\sum_{i = 1} ^ {m} \\alpha_i y_i w^\\top x_i - \\sum_{i = 1} ^ {m} \\alpha_i y_i b \\\\ \u0026= \\frac{1}{2} ||w ^ *||^2 + \\sum_{i = 1} ^ {m} \\alpha_i - ||w ^ *|| ^ 2 - b \\times 0 \\\\ \u0026= -\\frac{1}{2} ||w ^ *||^2 + \\sum_{i = 1} ^ {m} \\alpha_i \\\\ \u0026= -\\frac{1}{2} \\left(\\sum\\limits_{i = 1} ^ m\\alpha_i x_i y_i\\right) \\left(\\sum\\limits_{j = 1} ^ m\\alpha_j x_j y_j\\right) + \\sum_{i = 1} ^ {m} \\alpha_i \\\\ \u0026= -\\frac{1}{2} \\sum\\limits_{i = 1} ^ m \\sum\\limits_{j = 1} ^ m \\alpha_i \\alpha_j x_i x_j y_i y_j + \\sum_{i = 1} ^ {m} \\alpha_i \\end{aligned} $$ 然后问题变为： $$ \\max_\\alpha \\left(-\\frac{1}{2} \\sum\\limits_{i = 1} ^ m \\sum\\limits_{j = 1} ^ m \\alpha_i \\alpha_j x_i x_j y_i y_j + \\sum_{i = 1} ^ {m} \\alpha_i\\right) \\\\ \\text{s.t.} \\ \\alpha_i \\ge 0, i = 1, 2, \\cdots, m \\\\ \\sum_{i = 1} ^ m\\alpha_i y_i = 0 $$ 加个负号变成 $\\min$： $$ \\min_\\alpha \\left(\\frac{1}{2} \\sum\\limits_{i = 1} ^ m \\sum\\limits_{j = 1} ^ m \\alpha_i \\alpha_j x_i x_j y_i y_j - \\sum_{i = 1} ^ {m} \\alpha_i\\right) \\\\ \\text{s.t.} \\ \\alpha_i \\ge 0, i = 1, 2, \\cdots, m \\\\ \\sum_{i = 1} ^ m\\alpha_i y_i = 0 $$ 这就是硬间隔线性 SVM 的对偶型。 ","date":"2024-11-11","objectID":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/:2:3","tags":["SVM"],"title":"支持向量机 (SVM)","uri":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"categories":["机器学习"],"content":"SMO 算法 这是一个二次规划问题，可以用 SMO(Sequential Minimal Optimization) 即序列最小优化算法求解。 SMO 核心思想是每次只优化一个参数，其他固定。但是我们这里有 $\\sum\\limits_{i = 1} ^ m\\alpha_i y_i = 0$，如果我们优化其中一个 $\\alpha_i$，其他固定，那么 $\\alpha_i$ 也成定值了。 所以我们考虑固定住两个参数 $\\alpha_i, \\alpha_j$，约束变为 $$ \\alpha_i y_i + \\alpha_j y_j = C \\\\ C = -\\sum_{k \\ne i,j} \\alpha_k y_k $$ 由此得出 $\\alpha_j = \\dfrac{C - \\alpha_i y_i}{y_j}$，我们带入原式，就得到了只含有一个 $\\alpha_i$ 变量的式子，直接对 $\\alpha_i$ 梯度下降。之后再选一个新的变量即可。 完事之后根据式子 $w = \\sum\\limits_{i = 1} ^ m\\alpha_i x_i y_i$ 可以求出 $w$，再根据 $y_i(w^\\top x_i + b) = 1$ 求出 $b$，可以把每个支持向量带进去求一个 $b$ 的平均值。 ","date":"2024-11-11","objectID":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/:2:4","tags":["SVM"],"title":"支持向量机 (SVM)","uri":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"categories":["机器学习"],"content":"核函数 假设现在是一个线性不可分的样本。 我们可以把特征映射到更高维度。这样在高维就线性可分了。 处理方式是将 $x_i, x_j$ 变为 $\\Phi(x_i), \\Phi(x_j)$，我们把核函数写做 $K(x_i, x_j)$ $$ \\min_\\alpha \\left(\\frac{1}{2} \\sum\\limits_{i = 1} ^ m \\sum\\limits_{j = 1} ^ m \\alpha_i \\alpha_j \\Phi(x_i) \\Phi(x_j) y_i y_j - \\sum_{i = 1} ^ {m} \\alpha_i\\right) \\\\ \\text{s.t.} \\ \\alpha_i \\ge 0, i = 1, 2, \\cdots, m \\\\ \\sum_{i = 1} ^ m\\alpha_i y_i = 0 $$ ","date":"2024-11-11","objectID":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/:3:0","tags":["SVM"],"title":"支持向量机 (SVM)","uri":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"categories":["机器学习"],"content":"常见的核函数 线性核函数 $$ K(x_i, x_j) = x_i ^ \\top x_j $$ 多项式核函数 $$ K(x_i, x_j) = (\\gamma x_i ^ \\top x_j + b) ^ d $$ 高斯核函数 $$ K(x_i, x_j) = \\exp(-\\gamma||x_i - x_j|| ^ 2) $$ sigmoid 核函数 $$ K(x_i, x_j) = \\tanh(\\gamma x ^ \\top x_j + b) $$ ","date":"2024-11-11","objectID":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/:3:1","tags":["SVM"],"title":"支持向量机 (SVM)","uri":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"categories":["机器学习"],"content":"参考 统计学习方法(第2版)李航 https://zhuanlan.zhihu.com/p/77750026 https://zhuanlan.zhihu.com/p/38163970 https://zhuanlan.zhihu.com/p/55532322 https://zhuanlan.zhihu.com/p/261061617 https://zhuanlan.zhihu.com/p/480302399 https://blog.csdn.net/qq_25018077/article/details/139541976 ","date":"2024-11-11","objectID":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/:4:0","tags":["SVM"],"title":"支持向量机 (SVM)","uri":"/posts/ml%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"},{"categories":["机器学习"],"content":"模型 模型由多层感知机构成，每层有若干个神经元，第一层是输入层，最后一层是输出层。如下图所示 其中输入层表示输入数据的若干个特征 记为 $x_1, x_2, \\cdots, x_n$，输出层表示分类的概率。 ","date":"2024-11-10","objectID":"/posts/ml%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:1:0","tags":["神经网络"],"title":"前馈神经网络","uri":"/posts/ml%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["机器学习"],"content":"神经元 每个节点就是一个神经元，从图中不难发现上一层的每个神经元都有一条边连向该神经元，其中边有边权 $w$ 定义 $w ^ l_{jk}$ 为第 $l-1$ 层的第 $k$ 个神经元和第 $l$ 层的第 $j$ 个神经元连接对应的权重 ($l - 1$ 层表示他左边的层) 定义 $z^l_j$ 为第 $l$ 层第 $j$ 个神经元的未激活值(加权计算值)。 定义 $a^l_j$ 为第 $l$ 层第 $j$ 个神经元的激活值。 定义 $b^l_j$ 为第 $l$ 层第 $j$ 个神经元带有的偏置。 其中 $$ z_j^l = \\sum\\limits_k w_{jk} ^ l a_k ^ {l - 1} + b_j ^ l \\\\ a_j^l=\\sigma(z_j^l) $$ $\\sigma(x)$ 代表 sigmoid 函数，$k$ 下标求和范围为 $l$ 层神经元个数。 直观来讲就是该神经元的值是上一层每个神经元的值乘以到他的边权，累加起来再加上一个该神经元带的偏置，最后套一个 sigmoid 函数。 那么为什么要套 sigmoid？因为线性组合如果叠加在一起，那么始终可以用一个式子来表达，就用不着多层网络了，所以要引入一个非线性的复合，并且，sigmoid 可以让数据归一化，始终在 $(0, 1)$ 之间。当然 ReLU 也是可以的。 ","date":"2024-11-10","objectID":"/posts/ml%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:1:1","tags":["神经网络"],"title":"前馈神经网络","uri":"/posts/ml%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["机器学习"],"content":"损失函数 定义 $y_j$ 表示输出层第 $j$ 个输出的真实值。 考虑用 MSE (均方误差) 来作为损失函数 $C$ $$ C = \\frac{1}{2}\\sum_{k}(y_k - a_k ^ l) ^ 2 $$ ","date":"2024-11-10","objectID":"/posts/ml%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:1:2","tags":["神经网络"],"title":"前馈神经网络","uri":"/posts/ml%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["机器学习"],"content":"反向传播 现在考虑最小化损失函数，一般来说都是梯度下降，但是我们需要调整整个网络中的 $w, b$ 来使损失函数最小化，这样不好计算。 我们知道，训练过程就是要让模型的预测 $a^l_j$ 越接近真实值 $y_j$ 越好。那么 $a^l_j$ 跟什么有关呢？根据样本的真实值 $y_j$，可以计算 $a^l_j$ 和 $y_j$ 的误差，计算出误差之后，我们肯定知道要增大还是减小 $a^l_j$ 才能让模型的预测更好。而我们能够改变的量只有：第 $l - 1$ 层和第 $l$ 层之间的每个权重 $w^l_{jk}$，偏置项 $b_j^l$，或者是第 $l-1$ 层的激活函数的输出值 $a^{l-1}_k$，但是 $a_k^{l-1}$ 并无法直接改变，它是由更前面的权重和偏置项的值决定的。当我们从后往前根据预测的误差，考虑要如何修改每一层的权重和偏置项的时候，就是在做反向传播。 上述过程解释了 $a_j^l$ 想要如何调整模型的权重和偏置项。当然，我们还需要考虑输出层中除了$a_j^l$ 以外的神经元的“意见”。他们各自对如何改变模型的权重和偏置项的“意见”并不一定相同。最后，我们需要考虑输出层中所有神经元的意见来更新模型的权重和偏差。 四个基本公式 我们希望能得到任意的 $\\dfrac{\\partial C}{\\partial w_{jk}}, \\dfrac{\\partial C}{\\partial b^l_j}$ 在此之前，我们先定义几个东西。 公式 1 定义 $\\delta^l_j \\equiv \\dfrac{\\partial C}{\\partial z^l_j}$ 那么有 $$ \\begin{aligned} \\delta_j^l \u0026= \\frac{\\partial C}{\\partial z_j^l} \\\\ \u0026= \\frac{\\partial C}{\\partial a_j^l} \\frac{\\partial a_j^l}{\\partial z_j^l} \\\\ \u0026= \\frac{\\partial C}{\\partial a_j^l} \\frac{\\partial \\sigma(z_j^l)}{\\partial z_j^l} \\\\ \u0026= \\frac{\\partial C}{\\partial a_j^l}\\sigma ' (z_j^l) \\end{aligned} $$ 然后 $\\dfrac{\\partial C}{\\partial a^l_j} = (y_j - a^l_j)$，所以 $\\delta_j^l = (y_j - a^l_j)\\sigma ' (z_j^l)$ 那么 $l$ 层的 $\\delta$ 用矩阵表示： $$ \\delta ^ l = \\begin{bmatrix} \\frac{\\partial C}{\\partial a_1^l}\\sigma ' (z_1^l) \\\\ \\frac{\\partial C}{\\partial a_2^l}\\sigma ' (z_2^l) \\\\ \\vdots \\\\ \\frac{\\partial C}{\\partial a_k^l}\\sigma ' (z_k^l) \\\\ \\end{bmatrix} = \\begin{bmatrix} \\frac{\\partial C}{\\partial a_1^l} \\\\ \\frac{\\partial C}{\\partial a_2^l} \\\\ \\vdots \\\\ \\frac{\\partial C}{\\partial a_k^l} \\\\ \\end{bmatrix} \\odot \\begin{bmatrix} \\sigma ' (z_1^l) \\\\ \\sigma ' (z_2^l) \\\\ \\vdots \\\\ \\sigma ' (z_k^l) \\\\ \\end{bmatrix} = \\nabla C_{a^l} \\odot \\sigma ' (z^l) $$ 其中 $\\odot$ 表示按元素 (element-wise) 乘。 公式 2 继续对于 $l - 1$ 层进行推导。 $$ \\begin{aligned} \\delta_j^{l - 1} \u0026= \\frac{\\partial C}{\\partial z_j^{l - 1}} \\\\ \u0026= \\frac{\\partial C}{\\partial a_j^{l - 1}} \\frac{\\partial a_j^{l - 1}}{\\partial z_j^{l - 1}} \\\\ \u0026= \\frac{\\partial C}{\\partial a_j^{l - 1}} \\frac{\\partial \\sigma(z_j^{l - 1})}{\\partial z_j^{l - 1}} \\\\ \u0026= \\frac{\\partial C}{\\partial a_j^{l - 1}} \\sigma ' (z_j^{l - 1}) \\end{aligned} $$ 发现此时 $\\dfrac{\\partial C}{\\partial a_j^{l - 1}}$ 不好求了，但我们知道 $a_j^{l - 1}$ 和 $z_j^l$ 都有关。 拿 $a^{l - 1}_1$ 举例子，如下图 所以我们可以先把 $C$ 看成 $z^l_1, z^l_2, \\cdots, z^l_k$ 的复合函数。 $$ \\begin{aligned} \\frac{\\partial C}{\\partial a_1^{l - 1}} \u0026= \\frac{\\partial C(z^l_1, z^l_2, \\cdots, z^l_k)}{\\partial a_1^{l - 1}} \\\\ \u0026= \\sum_k \\frac{\\partial C}{\\partial z^l_k} \\frac{\\partial z^l_k}{\\partial a_1^{l - 1}} \\end{aligned} $$ 由于 $z_j^l = \\sum\\limits_k w_{jk} ^ l a_k ^ {l - 1} + b_j ^ l$，所以 $\\dfrac{\\partial z^l_k}{\\partial a_1^{l - 1}} = w_{k1} ^ l$ 又根据公式 1 的定义 $\\delta^l_j \\equiv \\dfrac{\\partial C}{\\partial z^l_j}$，将两个式子带入上述求和公式得： $$ \\sum_k \\frac{\\partial C}{\\partial z^l_k} \\frac{\\partial z^l_k}{\\partial a_1^{l - 1}} = \\sum_k w^l_{k1}\\delta_k^l $$ 同理，对于其他的 $a^{l - 1}_{j}$，都有： $$ \\frac{\\partial C}{\\partial a_j^{l - 1}} = \\sum_k w^l_{kj}\\delta_k^l $$ 所以说，$\\delta_j^{l - 1} = \\dfrac{\\partial C}{\\partial a_j^{l - 1}} \\sigma ' (z_j^{l - 1}) = \\left(\\sum\\limits_k w^l_{kj}\\delta_k^l \\right) \\times \\sigma ' (z_j^{l - 1})$ 推广到矩阵形式，即对 $l$ 层所有 $\\delta ^ l$ (层数下标先平移一层)： $$ \\delta ^ l = \\begin{bmatrix} \\left(\\sum\\limits_k w^{l + 1}_{k1} \\delta^{l + 1}_k \\right) \\times \\sigma ' (z_1^l) \\\\ \\left(\\sum\\limits_k w^{l + 1}_{k2} \\delta^{l + 1}_k \\right) \\times \\sigma ' (z_2^l) \\\\ \\vdots \\\\ \\left(\\sum\\limits_k w^{l + 1}_{kn} \\delta^{l + 1}_k \\right) \\times \\sigma ' (z_n^l) \\\\ \\end{bmatrix} = ((w^{l+1})^\\top \\delta^{l+1})\\odot \\sigma ' (z^l) $$ 公式 3 好了现在终于可以解决 $w, b$ 的偏导问题了 $$ \\begin{aligned} \\frac{\\partial C}{\\partial b^l_j} \u0026= \\frac{\\partial C}{\\partial z^l_j} \\frac{\\partial z^l_j}{\\partial b^l_j} \\\\ \u0026= \\frac{\\partial C}{\\partial z^l_j} \\\\ \u0026= \\delta^l_j \\end{aligned} $$ 由于 $z_j^l = \\sum\\limits_k w_{jk} ^ l a_k ^ {l - 1} + b_j ^ l$，所以 $\\dfrac{\\partial z^l_j}{\\partial b^l_j} = 1$ 公式 4 $$ \\begin{aligned} \\frac{\\partial C}{\\partial w_{jk}^l}\u0026=\\frac{\\partial C}{\\partial z^l_j}\\frac{\\partial z^l_j}{\\partial w_{jk}^l} \\\\ \u0026=\\frac{\\partial C}{\\part","date":"2024-11-10","objectID":"/posts/ml%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:1:3","tags":["神经网络"],"title":"前馈神经网络","uri":"/posts/ml%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["机器学习"],"content":"参考 https://martinlwx.github.io/zh-cn/backpropagation-tutorial/ https://zhuanlan.zhihu.com/p/683499770 https://playground.tensorflow.org/ ","date":"2024-11-10","objectID":"/posts/ml%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:2:0","tags":["神经网络"],"title":"前馈神经网络","uri":"/posts/ml%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["游戏"],"content":"虽然我英雄联盟只入坑了半年，峡谷也只有白银水平，今年也刚开始看英雄联盟比赛，但这次总决赛我能感受到 LPL 观众对于这次寄希望于全华班夺冠的厚重感。今年从春季赛看到世界赛，也看到了 BLG 的一路努力，从春季赛夺冠到 MSI 击败 T1 但惨败 GENG，夏季赛调整继续夺冠，再到世界赛瑞士轮前期越挫越勇 最后击败 G2 成功晋级八强，淘汰赛横扫 HLE，在四强承接着 WBG 意志走向决赛，目的就是在总决赛的舞台上大放异彩。 为此我准备去电影院给 BLG 加油助威，现场观众都非常激情，因为我们渴望有一支全华班队伍可以获得一个 S 冠，虽然 LPL 在 S8，S9，S11 都获得过冠军，但是我们必须向全世界证明五个中国人也是可以夺冠的，让世界听到我们的声音，这也是继承 4045 天以前全华班进入决赛的皇族战队的卢本伟、Uzi、tabe、神超、Lucky 的意志，弥补他们的遗憾，所以此刻奖杯就在眼前，五位选手必须要考虑这是否是他们此生仅有的机会。 比赛第一小局，BLG 打出巨大优势，最终以 18:3 拿下第一小局，士气大增，场内观众的掌声和呐喊声也此起彼伏。 第二小局前期同样也打出很大优势，8 分钟被 T1 找到机会越塔双杀，后期大龙团又被 faker 打崩，此时比赛已经基本无望，最后被 T1 拿下一局。 第三小局 BLG 又拿到巨大优势，选手出色发挥下 17:3 终结第三小局。 来到最关键的第四局，此时我们只需要再赢下这局就可以夺冠了，前期 BLG 又拿下优势，可惜又被 T1 找到机会把节奏打回来了，资源更是一个都没有控到。最后被 faker 塞拉斯终结掉比赛。 此时比赛已经来到了 2:2 的白热化阶段，两个队都离冠军只有一步之遥。在如此关键的第五小局，前期 BLG 抓掉 faker 打出优势，10 分钟再次起节奏令左手拿到两个人头，然后比赛来到 28 分钟，河道开团 Xun 打出 Guma 霞的闪现随后被 Bin 抓掉，随后 keria 也倒下，此时我们一度认为那个梦想终于要实现了，但是此时最关键的一幕发生了：左手闪现 E 空掉，想继续追击，那么 Bin 则 TP 绕后，但此时 faker 和 Zeus 赶到，加里奥的一个闪现嘲讽控住了左手和 Xun，此时酒桶也跟上了伤害，Bin 就位但为时已晚，ELK 更是难以操作交出死亡闪，这一波被 faker 操作团灭。T1 拿完大龙后上路试图开团 Zeus，此时 faker 及时支援，Zeus 死掉后 faker 再残血金身等队友支援，在 BLG 三人残血的情况下也没能收掉有一丝血量的 faker，让解说不禁感叹到这就是不死魔王 faker。可能也这就是命运吧，faker 一丝血的逃跑在告诉着我们：即使我老了，还有一口气，也不会倒在 LPL 手下。 随着 BLG 基地的爆炸，现场的观众也难以接受这一幕，大家也看着荧幕上 T1 捧起奖杯的画面沉默离场。在凌晨三点半离开电影院的路上，充满着 LPL 观众的落寞，大家的心情也久久无法平复，全华班夺冠难道还是做不到吗，我们必须要跨过这个最高的山、最长的河，就像王多多说的那句诗一样：海到无边天作岸，山登绝顶我为峰。只能希望下个赛季 LPL 加油吧，S15 再见！ ","date":"2024-11-02","objectID":"/posts/game%E8%8B%B1%E9%9B%84%E8%81%94%E7%9B%9F-s14-%E6%80%BB%E5%86%B3%E8%B5%9B/:0:0","tags":["小作文"],"title":"2024 英雄联盟 S14 全球总决赛 观赛感悟","uri":"/posts/game%E8%8B%B1%E9%9B%84%E8%81%94%E7%9B%9F-s14-%E6%80%BB%E5%86%B3%E8%B5%9B/"},{"categories":["机器学习"],"content":"感知机 ","date":"2024-10-29","objectID":"/posts/ml%E6%84%9F%E7%9F%A5%E6%9C%BA/:1:0","tags":["感知机"],"title":"感知机","uri":"/posts/ml%E6%84%9F%E7%9F%A5%E6%9C%BA/"},{"categories":["机器学习"],"content":"模型 设输入的特征向量为 $X \\subseteq \\textbf{R}^n$，每个向量对应输出 $Y = {1, -1}$，也就是两种分类。 设函数 $f(x) = \\text{sign}(w \\cdot x + b)$ 称为感知机，其中 $w \\in \\textbf{R}^n$ 表示一组权值，$b \\in \\textbf{R}$ 叫做偏置，$\\cdot$ 表示向量点乘 (内积)。$\\text{sign}$ 是符号函数如下： $$ \\text{sign}(x) = \\begin{cases} 1,\u0026x \\ge 0 \\\\ -1, \u0026x \u003c 0 \\end{cases} $$ 通过感知机的学习，得到方程 $w \\cdot x + b = 0$，表示一个 $\\textbf{R}^n$ 空间的超平面，将特征向量划分为两类。 ","date":"2024-10-29","objectID":"/posts/ml%E6%84%9F%E7%9F%A5%E6%9C%BA/:1:1","tags":["感知机"],"title":"感知机","uri":"/posts/ml%E6%84%9F%E7%9F%A5%E6%9C%BA/"},{"categories":["机器学习"],"content":"学习策略 数据集的线性可分性 对所有正类的数据集都有 $w \\cdot x + b \u003e 0$，负类数据集 $w \\cdot x + b \u003c 0$ 如上图，考虑两个特征 $x_1,x_2$，类型用 x 和 o 来表示，x 类型都在直线的下方，带入直线方程会发现均小于 $0$，那么 $\\text{sign}$ 值就为 $-1$ 损失函数 首先特征向量 $x_0$ 到超平面的距离为 $\\dfrac{|wx_0 + b|}{||w||}$，其中 $||w||$ 是 $L_2$ 范数，即 $\\sqrt{\\sum\\limits_{i = 1} ^ {n}w_i^2}$ 我们只考虑错误分类的点到超平面的距离，对于误分类的点 $(x_i,y_i)$，$-y_i(w \\cdot x + b) \u003e 0$ 成立，因为假设该点为正类 ($y_i = 1$)，由于误分类那么他会在直线下方，导致 $w \\cdot x + b \u003c 0$，所以 $-1 \\times (w \\cdot x + b) \u003e 0$，负类则相同。 此时误分类点到超平面的距离就为 $-\\dfrac{y_i(wx_i + b)}{||w||}$，设误分类点的集合为 $M$，那么总距离就为 $$ -\\frac{1}{||w||}\\sum_{x_i \\in M} y_i (w \\cdot x_i + b) $$ 不考虑 $\\dfrac{1}{||w||}$，就得到了损失函数 $L(w, b) = -\\sum\\limits_{x_i \\in M} y_i (w \\cdot x_i + b)$，此函数连续可导。 我们考虑最小化损失函数。首先任选一个超平面 $w_0,b_0$，然后随机选择一个误分类点梯度下降。 $$ \\frac{\\partial L(w, b)}{\\partial w} = -\\sum_{x_i \\in M}y_ix_i \\ \\frac{\\partial L(w, b)}{\\partial b} = -\\sum_{x_i \\in M}y_i $$ 随机选择误分类点 $(x_i,y_i)$ 对 $w, b$ 进行更新：$w + \\alpha y_ix_i, b + \\alpha y_i$，最后直到损失函数为 $0$ 为止。 对偶形式 由于每次对随机一个点进行梯度下降，那么我们从结果考虑，假设第 $i$ 个点更新的次数为 $k_i$ 次，那么最终的 $w, b$ 就为 $w = \\sum\\limits_{i = 1} ^ {n}\\alpha k_i y_ix_i, b = \\sum\\limits_{i = 1} ^ {n}\\alpha k_i y_i$，那么感知机模型就为 $\\text{sign}\\left(\\sum\\limits_{j = 1} ^ {n}\\alpha k_j y_j x_j \\cdot x +b \\right)$ 训练的时候对于某个点 $(x_i,y_i)$ 如果 $y_i \\left(\\sum\\limits_{j = 1} ^ {n}\\alpha k_j y_j x_j \\cdot x_i +b \\right) \\le 0$，就：$k_i + 1, b + \\alpha y_i$，直到没有误分类数据。 由于数据大量出现 $x_i \\cdot x_j$，为了方便可以先算出 Gram 矩阵 $\\textbf{G} = [x_i\\cdot x_j]_{n \\times n}$，即 $x$ 向量组自己和自己做 $n \\times n$ 的矩阵乘法。 ","date":"2024-10-29","objectID":"/posts/ml%E6%84%9F%E7%9F%A5%E6%9C%BA/:1:2","tags":["感知机"],"title":"感知机","uri":"/posts/ml%E6%84%9F%E7%9F%A5%E6%9C%BA/"},{"categories":["机器学习"],"content":"分类 有些数据例如：客户是否会购买某个商品，他的结果只有 0 与 1，如果使用线性回归，效果会非常差。所以我们考虑引入新的模型来拟合这些数据。 ","date":"2024-10-29","objectID":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/:1:0","tags":["逻辑回归"],"title":"逻辑回归","uri":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"},{"categories":["机器学习"],"content":"sigmoid 函数 逻辑回归的拟合函数是 sigmoid 函数：$f(z) = \\dfrac{1}{1+e^{-z}}$ 通过函数图像的观察，我们可以发现 $\\lim\\limits_{x \\rightarrow \\infty} f(x) = 1, \\lim\\limits_{x \\rightarrow -\\infty} f(x) = 0, f(0) = \\dfrac{1}{2}$ 这样就很巧妙又很光滑的(指函数图像)建立了一个 0/1 的函数模型。 他表示这个事件预测的概率，如果 $\\dfrac{1}{2} \\le f(x)$，则事件预测发生，相反 $f(x) \u003c \\dfrac{1}{2}$，事件预测不发生。 ","date":"2024-10-29","objectID":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/:2:0","tags":["逻辑回归"],"title":"逻辑回归","uri":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"},{"categories":["机器学习"],"content":"决策边界 已经有了假设函数了，现在考虑什么时候将某个样本预测为正类，什么时候预测为负类。也就是说用一个方程来把数据划分为两类，在一侧是一类，在另一侧是另一类。 ","date":"2024-10-29","objectID":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/:3:0","tags":["逻辑回归"],"title":"逻辑回归","uri":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"},{"categories":["机器学习"],"content":"线性决策边界 如上图所示，此线性数据的决策边界为 $x_1 + x_2 - 3 = 0$，如果 $x_1 + x_2 - 3 \u003e 0$ 时，就会在这条直线的上方判定为属于 1 类，那 sigmoid 函数值就会大于等于 $0.5$，反之。 ","date":"2024-10-29","objectID":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/:3:1","tags":["逻辑回归"],"title":"逻辑回归","uri":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"},{"categories":["机器学习"],"content":"非线性决策边界 这里的决策边界为 $x_1^2 + x_2^2 - 1 = 0$，如果在圆内是一类，在圆外是另一类。 ","date":"2024-10-29","objectID":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/:3:2","tags":["逻辑回归"],"title":"逻辑回归","uri":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"},{"categories":["机器学习"],"content":"损失函数 如果按照线性回归的计算方式，直接用 y 和 sigmoid 函数做差，会导致损失函数不是凸函数，不容易优化，容易陷入局部最小值。所以逻辑回归要用对数函数来做损失函数。 $$ J(\\theta)=-\\frac{1}{m}\\sum_{i = 1} ^ {n}(y_i\\log(h(x_i))+(1-y_i)\\log(1-h(x_i))) $$ 对于梯度下降，也是 $\\theta_i - \\alpha \\dfrac{\\partial J}{\\partial\\theta_i}$ ","date":"2024-10-29","objectID":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/:4:0","tags":["逻辑回归"],"title":"逻辑回归","uri":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"},{"categories":["机器学习"],"content":"多元分类 假设我们的训练集中有三种物品，我们可以训练三个分类器如上图，分别将其中的一类当正类，其他都当负类，然后进行一次二元分类。计算完三个分类器后，在预测时，向三个分类器中输入一个数据，将会分别返回三个概率，选择概率最大的那个当做预测类别。 ","date":"2024-10-29","objectID":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/:4:1","tags":["逻辑回归"],"title":"逻辑回归","uri":"/posts/ml%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"},{"categories":["机器学习"],"content":"单变量线性回归 ","date":"2024-10-28","objectID":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/:1:0","tags":["线性回归"],"title":"线性回归","uri":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"},{"categories":["机器学习"],"content":"模型表示 以最经典的问题为例，假设现在我们要预测房价数据，且目前房价只跟一个因素有关。 实际上就是用一条直线拟合一些数据，等同于高中学过的回归直线方程。我们假设用 $h(x) = \\theta_0 + \\theta_1x$ 来对数据做回归。 ","date":"2024-10-28","objectID":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/:1:1","tags":["线性回归"],"title":"线性回归","uri":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"},{"categories":["机器学习"],"content":"损失函数 损失函数就是误差值，假设数据集为 $(x_i,y_i)$，那么误差值就为每个点到直线的距离之和，即 $\\sum\\limits_{i=0} ^ {n}(h(x_i) - y_i)^2$，为了方便后续的梯度下降，这里距离选择用平方而不是绝对值。 现在把上述损失函数看作一个二元函数 (因为斜率和截距都是不确定变量)，即 $J(\\theta_0, \\theta_1) = \\sum\\limits_{i=0} ^ {n}(\\theta_0 + \\theta_1x_i - y_i)^2$，我们需要将损失函数最小化。这个二元函数就是空间中的一个山谷，我们需要用梯度下降法来找到“谷底”，即损失最小的点。 ","date":"2024-10-28","objectID":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/:1:2","tags":["线性回归"],"title":"线性回归","uri":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"},{"categories":["机器学习"],"content":"梯度下降 先以一元函数为例，现假设有 $f(x) = x ^ 2$，现在有一个小球在点 $x_0 = (10, f(10))$ 处，该点的导数为 $f'(10) = 2 \\times 10 = 20$，那么我们此时引入一个学习率 $\\alpha$ (相当于步长)，用学习率乘以该点的负导数，再加上该点的坐标，相当于该点在函数上移动。假设 $\\alpha = 0.2$，则新位置 $x_1 = x_0 - 0.2 \\times 20 = 6$，即 $x_1 = (6, f(6))$，继续迭代，$x_2 = x_1 - 0.2 \\times (2 \\times 6) = 3.6$，如此迭代下去，发现最终新的位置会无限接近于 $0$，即函数的最小值处。 #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; signed main() { double x = 10, alpha = 0.2; for (int i = 1; i \u003c= 20; i ++) { x += -2 * x * alpha; cout \u003c\u003c x \u003c\u003c \"\\n\"; } } 用 C++ 代码模拟 20 次的输出结果： 6 3.6 2.16 1.296 0.7776 0.46656 0.279936 0.167962 0.100777 0.0604662 0.0362797 0.0217678 0.0130607 0.00783642 0.00470185 0.00282111 0.00169267 0.0010156 0.00060936 0.000365616 为什么会这样？因为导数是描述函数变化率的，越靠近极值点导数越小，每次走的步长就小。 我们可以通过调整 $\\alpha$ 来改变这个过程。下面是一些调参的结果： 对于二元函数，同样和上述过程类似，需要把求导改为偏导，即 $\\theta_i -\\alpha\\dfrac{\\partial J}{\\partial \\theta_i}$ ","date":"2024-10-28","objectID":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/:1:3","tags":["线性回归"],"title":"线性回归","uri":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"},{"categories":["机器学习"],"content":"多变量线性回归 假设现在有很多变量影响了房价因素，这些特征为 $(x_1,x_2,\\cdots,x_n)$，此时模型也必须表述为一个超平面 $h(x_1,x_2,\\cdots,x_n) = \\theta_0 + \\sum\\limits_{i = 1}^{n}\\theta_ix_i$，由于变量太多了我们用矩阵表示 $\\theta=\\begin{bmatrix} \\theta_0 \u0026 \\cdots \u0026 \\theta_n \\end{bmatrix}, X = \\begin{bmatrix} 0 \\\\ x_1 \\\\ \\vdots \\\\ x_n \\end{bmatrix}$ 则 $h(X) = \\theta X$，那么损失函数就为 $J(\\theta) = \\sum\\limits_{i = 1} ^ {n}(\\theta X_i - y_i)^2$ 梯度下降：$\\theta_i - \\alpha\\sum\\limits_{i = 1} ^ {n} 2x_i(h(x_i) - y_i) $ ","date":"2024-10-28","objectID":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/:2:0","tags":["线性回归"],"title":"线性回归","uri":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"},{"categories":["机器学习"],"content":"特征缩放 在我们面对多维特征问题的时候，我们要保证这些特征都具有相近的尺度，这将帮助梯度下降算法更快地收敛。以房价问题为例，假设我们使用两个特征，房屋的尺寸和房间的数量，尺寸的值为 02000 平方英尺，而房间数量的值则是 05，以两个参数分别为横纵坐标，绘制代价函数的等高线图能，看出图像会显得很扁，梯度下降算法需要非常多次的迭代才能收敛。我们可以将房屋大小除以 2000，将卧室个数除以 5，再画出等高线图就比较合适了（如下图右）。 均值归一化 将数值都缩放在 $[-1,1]$ 之间，公式：$x_i = \\dfrac{x_i - \\mu}{s}$，其中 $\\mu$ 表示平均值，$s$ 表示标准差 ","date":"2024-10-28","objectID":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/:2:1","tags":["线性回归"],"title":"线性回归","uri":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"},{"categories":["机器学习"],"content":"学习率选取 梯度下降算法的每次迭代受到学习率的影响，如果学习率过小，则达到收敛所需的迭代次数会非常高；如果学习率过大，每次迭代可能不会减小代价函数，可能会越过局部最小值导致无法收敛。 通常可以考虑尝试些学习率：$\\alpha = 0.01, 0.03, 0.1, 0.3, 1, 3,10$ ","date":"2024-10-28","objectID":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/:2:2","tags":["线性回归"],"title":"线性回归","uri":"/posts/ml%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"},{"categories":["游戏"],"content":"\u003c!doctype html\u003e Vite + Vue ","date":"2024-10-20","objectID":"/posts/game%E5%88%9B%E6%83%B3%E5%85%B5%E5%9B%A2%E4%B8%80%E6%9E%AA%E4%BC%A4%E5%AE%B3%E8%AE%A1%E7%AE%97/:0:0","tags":["计算"],"title":"创想兵团一枪伤害计算","uri":"/posts/game%E5%88%9B%E6%83%B3%E5%85%B5%E5%9B%A2%E4%B8%80%E6%9E%AA%E4%BC%A4%E5%AE%B3%E8%AE%A1%E7%AE%97/"},{"categories":["游戏"],"content":"代码 \u003ctemplate\u003e \u003cel-form ref=\"formRef\" style=\"max-width: 600px\" :model=\"info\" :rules=\"rules\" label-width=\"auto\" status-icon \u003e \u003cel-form-item label=\"武器\" prop=\"weapon\"\u003e \u003cel-select v-model=\"info.weapon\" value-key=\"damage\" placeholder=\"选择武器\" style=\"width: 300px\"\u003e \u003cel-option v-for=\"item in weapons\" :key=\"item.damage\" :label=\"item.name + ' 伤害:' + item.damage\" :value=\"item\" \u003e \u003cspan style=\"float: left\"\u003e{{ item.name }}\u003c/span\u003e \u003cspan style=\" float: right; color: var(--el-text-color-secondary); font-size: 13px; \"\u003e 伤害:{{ item.damage }} \u003c/span\u003e \u003c/el-option\u003e \u003c/el-select\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"武器强化等级\" prop=\"level\"\u003e \u003cel-input-number v-model=\"info.level\" :min=\"0\" :max=\"20\" @change=\"handleChange\" /\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"己方破甲\" prop=\"breakArmor\"\u003e \u003cel-input-number v-model=\"info.breakArmor\" :min=\"0\" :max=\"40\" @change=\"handleChange\" /\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"对方护甲\" prop=\"Armor\"\u003e \u003cel-input-number v-model=\"info.Armor\" :min=\"0\" :max=\"400\" @change=\"handleChange\" /\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"伤害类型\" prop=\"Critical\"\u003e \u003cel-radio-group v-model=\"info.Critical\"\u003e \u003cel-radio :value=\"1\"\u003e普通\u003c/el-radio\u003e \u003cel-radio :value=\"2.5\"\u003e暴击(致命打击)\u003c/el-radio\u003e \u003cel-radio :value=\"3\"\u003e狼暴(狼卡 + 致命打击)\u003c/el-radio\u003e \u003c/el-radio-group\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"改造伤害\" prop=\"addDamage\"\u003e \u003cel-input-number v-model=\"info.addDamage\" :min=\"0\" :max=\"43\" @change=\"handleChange\" /\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"伤害浮动百分比\" prop=\"addDamage\"\u003e \u003cel-input-number v-model=\"info.damageFloat\" :min=\"-6\" :max=\"6\" @change=\"handleChange\" /\u003e \u003c/el-form-item\u003e \u003cel-form-item\u003e \u003cel-button type=\"primary\" @click=\"calc(formRef)\"\u003e计算\u003c/el-button\u003e \u003c/el-form-item\u003e \u003c/el-form\u003e \u003cel-text class=\"mx-1\" type=\"danger\" v-if=\"show\"\u003e伤害数值：{{ damage }}\u003c/el-text\u003e \u003c/template\u003e \u003cscript lang=\"ts\" setup\u003e import { ref, reactive } from 'vue' import type { FormInstance } from 'element-plus' const formRef = ref\u003cFormInstance\u003e() const info = reactive({ weapon: undefined, level: 0, breakArmor: 0, Armor: 0, Critical: undefined, addDamage: 0, damageFloat: 0 }) const rules = reactive({ weapon: [{ required: true, message: '请选择武器', trigger: 'change', }], Critical: [{ required: true, message: '请选择伤害类型', trigger: 'change', }] }) const weapons = [{ name: '破心Ⅱ', damage: 1070, }, { name: '祥云自由之鹰Ⅳ', damage: 1012, }, { name: 'DSR-7', damage: 1010, }, { name: '祥云自由之鹰Ⅲ', damage: 1009, }, { name: '音障突破/魔龙之吻Ⅲ', damage: 1008, }, { name: '破心-夏季PK特别版', damage: 1003, }, { name: '破心', damage: 995, }, { name: 'S224EV-DZ', damage: 987, } ] function Ar (x) { return 29.11 * Math.log(x + 170.83) - 149.86; } const show = ref(false) const damage = ref(0) const calc = async (formRef) =\u003e { await formRef.validate((valid) =\u003e { if (valid) { let addDamage = info.level * info.weapon.damage * 0.01; addDamage = parseFloat(addDamage.toFixed(2)); let weaponDamage = info.Critical * (info.weapon.damage + addDamage + info.addDamage); weaponDamage *= parseFloat(((100 + info.damageFloat) * 0.01).toFixed(2)) weaponDamage = parseFloat(weaponDamage.toFixed(2)); let armour = (100.0 - Ar(Math.max(info.Armor - info.breakArmor, 0.0))) * 0.01; armour = parseFloat(armour.toFixed(2)); damage.value = (armour * weaponDamage).toFixed(2); show.value = true; } }) } \u003c/script\u003e ","date":"2024-10-20","objectID":"/posts/game%E5%88%9B%E6%83%B3%E5%85%B5%E5%9B%A2%E4%B8%80%E6%9E%AA%E4%BC%A4%E5%AE%B3%E8%AE%A1%E7%AE%97/:1:0","tags":["计算"],"title":"创想兵团一枪伤害计算","uri":"/posts/game%E5%88%9B%E6%83%B3%E5%85%B5%E5%9B%A2%E4%B8%80%E6%9E%AA%E4%BC%A4%E5%AE%B3%E8%AE%A1%E7%AE%97/"},{"categories":["游戏"],"content":" 结论 $$ y = 29.11 \\log(x + 170.83) - 149.86 $$ 计算 数据集 护甲值 承伤百分比 0 0 14 2.2 15 2.3 20 3.1 25 3.8 26 3.9 28 4.2 30 4.5 35 5.2 40 5.9 45 6.6 46 6.7 49 7.1 50 7.2 55 7.9 60 8.5 64 9 65 9.1 66 9.2 68 9.5 70 9.7 75 10.3 80 10.9 81 11.1 85 11.5 90 12.1 94 12.5 95 12.6 100 13.2 102 13.4 105 13.7 106 13.8 110 14.2 118 15.1 119 15.2 120 15.3 125 15.8 130 16.3 135 16.7 140 17.2 144 17.6 145 17.7 146 17.8 149 18.1 150 18.1 153 18.4 154 18.5 155 18.6 158 18.9 160 19 165 19.5 166 19.6 168 19.7 169 19.8 170 19.9 174 20.3 175 20.3 176 20.4 178 20.6 179 20.7 180 20.8 183 21 184 21.1 185 21.2 188 21.4 189 21.5 190 21.6 192 21.8 193 21.9 194 21.9 195 22 196 22.1 200 22.4 202 22.5 204 22.7 205 22.8 207 23 209 23.1 210 23.2 212 23.3 215 23.5 217 23.7 218 23.8 220 23.9 222 24.1 223 24.1 225 24.3 226 24.4 227 24.5 228 24.6 230 24.6 231 24.7 232 24.8 233 24.9 235 25 238 25.2 239 25.3 240 25.4 241 25.4 245 25.7 246 25.8 247 25.9 250 26.1 252 26.2 257 26.5 258 26.6 260 26.7 263 26.9 264 27 268 27.3 274 27.6 279 28 285 28.3 288 28.5 290 28.7 296 29 298 29.1 301 29.3 307 29.7 328 30.8 329 30.9 342 31.7 ","date":"2024-08-28","objectID":"/posts/game%E5%88%9B%E6%83%B3%E5%85%B5%E5%9B%A2%E6%8A%A4%E7%94%B2%E5%87%BD%E6%95%B0%E6%8B%9F%E5%90%88/:0:0","tags":["拟合"],"title":"创想兵团护甲函数拟合","uri":"/posts/game%E5%88%9B%E6%83%B3%E5%85%B5%E5%9B%A2%E6%8A%A4%E7%94%B2%E5%87%BD%E6%95%B0%E6%8B%9F%E5%90%88/"},{"categories":["游戏"],"content":"代码： import pandas as pd import numpy as np import matplotlib.pyplot as plt from scipy.optimize import curve_fit import pylab as mpl mpl.rcParams['font.sans-serif'] = ['SimHei'] # 解决中文不显示问题 plt.rcParams['axes.unicode_minus'] = False #解决负数坐标显示问题 data = pd.read_csv('./data2.csv') x_data = data['value'] y_data = data['armour'] def fitting_function(x, a, b, c): return a * np.log(x + b) + c # 进行曲线拟合 popt, pcov = curve_fit(fitting_function, x_data, y_data) # 获取拟合参数 a_fit, b_fit, c_fit = popt # 生成拟合曲线的 x 值范围 x_fit = x_data # 计算拟合曲线的 y 值 y_fit = fitting_function(x_fit, a_fit, b_fit, c_fit) # 绘制原始数据和拟合曲线 plt.scatter(x_data, y_data, label='原始数据') plt.plot(x_fit, y_fit, color='red', label='拟合曲线') # 添加拟合表达式文本 fit_expression = f\"y = {a_fit:.2f} * log(x + {b_fit:.2f}) {c_fit:.2f}\" plt.text(min(x_data), max(y_data), fit_expression, fontsize=12, color='green') plt.xlabel('护甲值') plt.ylabel('承伤百分比') plt.legend() plt.show() ","date":"2024-08-28","objectID":"/posts/game%E5%88%9B%E6%83%B3%E5%85%B5%E5%9B%A2%E6%8A%A4%E7%94%B2%E5%87%BD%E6%95%B0%E6%8B%9F%E5%90%88/:1:0","tags":["拟合"],"title":"创想兵团护甲函数拟合","uri":"/posts/game%E5%88%9B%E6%83%B3%E5%85%B5%E5%9B%A2%E6%8A%A4%E7%94%B2%E5%87%BD%E6%95%B0%E6%8B%9F%E5%90%88/"},{"categories":["算法竞赛"],"content":"我们已经大四了，还有机会拿金牌吗？ 如何评价2024CCPC长春邀请赛暨吉林省赛? ","date":"2024-05-20","objectID":"/posts/cp2024ccpc%E9%95%BF%E6%98%A5%E9%82%80%E8%AF%B7%E8%B5%9B%E6%B8%B8%E8%AE%B0/:0:0","tags":["小作文"],"title":"2024CCPC长春邀请赛游记","uri":"/posts/cp2024ccpc%E9%95%BF%E6%98%A5%E9%82%80%E8%AF%B7%E8%B5%9B%E6%B8%B8%E8%AE%B0/"},{"categories":["算法竞赛"],"content":"大概是我们办过最好的一次比赛了。 校内正式赛链接 重现赛链接 牛客链接 榜单链接 校赛回放合集 题面 题解 ","date":"2024-05-13","objectID":"/posts/cp16%E5%B1%8A%E6%A0%A1%E8%B5%9B/:0:0","tags":["比赛"],"title":"山东理工大学第十六届ACM程序设计竞赛","uri":"/posts/cp16%E5%B1%8A%E6%A0%A1%E8%B5%9B/"},{"categories":["算法竞赛"],"content":"出的比较满意的一次比赛。在大一的时候就注意到 OJ 有愚人节专场赛，发现做起来非常有意思，可惜之后学长就不办了。 在 2024.3 的时候突发奇想，想全程自己办一次愚人节专场赛，于是开始想 idea： A 题 idea 是蔚蓝赛原神赛废案，算是小活。 B 题 idea 是我之前想整活一个冗杂的数学式子，于是随便写了点公式。 C 题 idea 也来自于蔚蓝赛原神赛，然后想到愚人节有一个 '，提瓦特语没有对应字符，于是考察选手英文节日拼写（） D 题 idea 是以前打 PTA 时想到的交互测样例。 E 题 idea 来自于 OJ 支持进入题目自动播放 BGM，于是想到了猜 BV 号 F 题 idea 来自于文件夹的树形结构，然后两个叶子节点暗示找 LCA G 题 idea 来自于牛客除夕赛。 H 题 idea 构思了很久，算是比较满意。 I 题 idea 来自于通过 URL 进入隐藏比赛。然后题面也是稍微整活了一下。提示非常有用，暗示 URL！ J 题 idea 来自于我检索题目，于是给选手整一道检索题。 K 题 idea 来自于质因数分解，还有标题 reverse 的经典 trick L 题 idea 也是质因数分解，还有使用 oeis 重现赛链接 题解 ","date":"2024-04-01","objectID":"/posts/cp2024%E6%84%9A%E4%BA%BA%E8%8A%82%E4%B8%93%E5%9C%BA%E8%B5%9B/:0:0","tags":["比赛"],"title":"2024愚人节专场赛","uri":"/posts/cp2024%E6%84%9A%E4%BA%BA%E8%8A%82%E4%B8%93%E5%9C%BA%E8%B5%9B/"},{"categories":["算法竞赛"],"content":"比赛链接 ","date":"2024-02-03","objectID":"/posts/cp%E8%94%9A%E8%93%9Dr2/:0:0","tags":["比赛"],"title":"[蔚蓝系列赛 Azur Series - Sponsored by BLue] Round 2","uri":"/posts/cp%E8%94%9A%E8%93%9Dr2/"},{"categories":["算法竞赛"],"content":"一次 2023 级寒假集训的讲课，做的非常认真的一次 PPT，将我所知道的算法竞赛信息都写上了。 ","date":"2024-01-14","objectID":"/posts/cp%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF/:0:0","tags":["基本信息"],"title":"算法竞赛入门基本信息","uri":"/posts/cp%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF/"},{"categories":["博客语法"],"content":"注意 {{\u003c admonition note \u003e}} 一个 **注意** 横幅 {{\u003c /admonition \u003e}} 注意 一个 注意 横幅 ","date":"2024-01-01","objectID":"/posts/blogadmonition/:1:0","tags":["博客语法"],"title":"博客 admonition","uri":"/posts/blogadmonition/"},{"categories":["博客语法"],"content":"技巧 {{\u003c admonition tip \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 技巧 一个 提示 横幅 ","date":"2024-01-01","objectID":"/posts/blogadmonition/:2:0","tags":["博客语法"],"title":"博客 admonition","uri":"/posts/blogadmonition/"},{"categories":["博客语法"],"content":"摘要 {{\u003c admonition abstract \u003e}} 一个 **摘要** 横幅 {{\u003c /admonition \u003e}} 摘要 一个 摘要 横幅 ","date":"2024-01-01","objectID":"/posts/blogadmonition/:3:0","tags":["博客语法"],"title":"博客 admonition","uri":"/posts/blogadmonition/"},{"categories":["博客语法"],"content":"信息 {{\u003c admonition info \u003e}} 一个 **信息** 横幅 {{\u003c /admonition \u003e}} 信息 一个 信息 横幅 ","date":"2024-01-01","objectID":"/posts/blogadmonition/:4:0","tags":["博客语法"],"title":"博客 admonition","uri":"/posts/blogadmonition/"},{"categories":["博客语法"],"content":"成功 {{\u003c admonition success \u003e}} 一个 **成功** 横幅 {{\u003c /admonition \u003e}} 成功 一个 成功 横幅 ","date":"2024-01-01","objectID":"/posts/blogadmonition/:5:0","tags":["博客语法"],"title":"博客 admonition","uri":"/posts/blogadmonition/"},{"categories":["博客语法"],"content":"问题 {{\u003c admonition question \u003e}} 一个 **问题** 横幅 {{\u003c /admonition \u003e}} 问题 一个 问题 横幅 ","date":"2024-01-01","objectID":"/posts/blogadmonition/:6:0","tags":["博客语法"],"title":"博客 admonition","uri":"/posts/blogadmonition/"},{"categories":["博客语法"],"content":"警告 {{\u003c admonition warning \u003e}} 一个 **警告** 横幅 {{\u003c /admonition \u003e}} 警告 一个 警告 横幅 ","date":"2024-01-01","objectID":"/posts/blogadmonition/:7:0","tags":["博客语法"],"title":"博客 admonition","uri":"/posts/blogadmonition/"},{"categories":["博客语法"],"content":"失败 {{\u003c admonition failure \u003e}} 一个 **失败** 横幅 {{\u003c /admonition \u003e}} 失败 一个 失败 横幅 ","date":"2024-01-01","objectID":"/posts/blogadmonition/:8:0","tags":["博客语法"],"title":"博客 admonition","uri":"/posts/blogadmonition/"},{"categories":["博客语法"],"content":"危险 {{\u003c admonition danger \u003e}} 一个 **危险** 横幅 {{\u003c /admonition \u003e}} 危险 一个 危险 横幅 ","date":"2024-01-01","objectID":"/posts/blogadmonition/:9:0","tags":["博客语法"],"title":"博客 admonition","uri":"/posts/blogadmonition/"},{"categories":["博客语法"],"content":"bug {{\u003c admonition bug \u003e}} 一个 **bug** 横幅 {{\u003c /admonition \u003e}} Bug 一个 bug 横幅 ","date":"2024-01-01","objectID":"/posts/blogadmonition/:10:0","tags":["博客语法"],"title":"博客 admonition","uri":"/posts/blogadmonition/"},{"categories":["博客语法"],"content":"示例 {{\u003c admonition example \u003e}} 一个 **示例** 横幅 {{\u003c /admonition \u003e}} 示例 一个 示例 横幅 ","date":"2024-01-01","objectID":"/posts/blogadmonition/:11:0","tags":["博客语法"],"title":"博客 admonition","uri":"/posts/blogadmonition/"},{"categories":["博客语法"],"content":"引用 {{\u003c admonition quote \u003e}} 一个 **引用** 横幅 {{\u003c /admonition \u003e}} 引用 一个 引用 横幅 ","date":"2024-01-01","objectID":"/posts/blogadmonition/:12:0","tags":["博客语法"],"title":"博客 admonition","uri":"/posts/blogadmonition/"},{"categories":["算法竞赛"],"content":"比赛链接(div.1) 比赛链接(div.2) ","date":"2023-12-17","objectID":"/posts/cp%E8%94%9A%E8%93%9Dr1/:0:0","tags":["比赛"],"title":"[蔚蓝系列赛 Azur Series - Sponsored by bLue] Round 1","uri":"/posts/cp%E8%94%9A%E8%93%9Dr1/"},{"categories":["游戏"],"content":"假设分解服从二项分布，设分解的绿武为 $n$ 个，分解到材料的概率为 $p$，那么分解到金币的概率就为 $1 - p$，则获得材料的期望为 $n \\times p$，获得金币的期望为 $1000 \\times n \\times (1 - p)$，那么消耗的总金币为 $2400 \\times n - 1000 \\times n \\times (1 - p)$ 假设一万金币价值为 $x$ 兑换券，一个材料价值为 $y$ 兑换券，那么成本价为 $\\dfrac{2400 \\times n - 1000 \\times n \\times (1 - p)}{10000} x$ 收益价为 $n \\times p \\times y$ 解不等式 $$\\frac{2400 \\times n - 1000 \\times n \\times (1 - p)}{10000} \\times x \\le n \\times p \\times y \\Leftrightarrow \\frac{0.14 x}{y - 0.1x} \\le p $$ 假设 $x = 3, y = 2$，可知概率大约 $p$ 在 $24.7%$ 概率可以盈利。 ","date":"2023-11-10","objectID":"/posts/game%E5%88%9B%E6%83%B3%E5%85%B5%E5%9B%A2%E7%BB%BF%E6%AD%A6%E5%88%86%E8%A7%A3%E8%AE%A1%E7%AE%97/:0:0","tags":["计算"],"title":"创想兵团绿武分解计算","uri":"/posts/game%E5%88%9B%E6%83%B3%E5%85%B5%E5%9B%A2%E7%BB%BF%E6%AD%A6%E5%88%86%E8%A7%A3%E8%AE%A1%E7%AE%97/"},{"categories":["游戏"],"content":"蓝色武器经验:2500 紫色武器经验:12000 (均使用蓝瓶) 同名武器经验1.5倍 蓝色武器 紫色武器 等级 经验 总经验 经验 总经验 0~1 1000 1000 2000 2000 1~2 1500 2500 3000 5000 2~3 2000 4500 4000 9000 3~4 2500 7000 5000 14000 4~5 3000 10000 6000 20000 5~6 4000 14000 12000 32000 6~7 7500 21500 18000 50000 7~8 10000 31500 24000 74000 8~9 12500 44000 31000 105000 9~10 14500 58500 37000 142000 10~11 26000 84500 77000 219000 11~12 37500 122000 117000 336000 12~13 48500 170500 156000 492000 13~14 60000 230500 196000 688000 14~15 71000 301500 236000 924000 15~16 124000 426500 487000 1411000 16~17 179000 605500 738000 2149000 17~18 233000 838500 990000 3139000 18~19 286500 1125000 1241000 4380000 19~20 340500 1465500 1492000 5872000 ","date":"2023-10-26","objectID":"/posts/game%E5%88%9B%E6%83%B3%E5%85%B5%E5%9B%A2%E6%AD%A6%E5%99%A8%E5%BC%BA%E5%8C%96%E7%BB%8F%E9%AA%8C%E8%A1%A8/:1:0","tags":["表格"],"title":"创想兵团武器强化经验表","uri":"/posts/game%E5%88%9B%E6%83%B3%E5%85%B5%E5%9B%A2%E6%AD%A6%E5%99%A8%E5%BC%BA%E5%8C%96%E7%BB%8F%E9%AA%8C%E8%A1%A8/"},{"categories":["算法竞赛"],"content":"很有纪念意义的一次活动。 视频合集 重现赛链接 榜单链接 速览 ","date":"2023-10-15","objectID":"/posts/cpsdutacm15%E5%91%A8%E5%B9%B4/:0:0","tags":["比赛"],"title":"SDUTACM 15 周年","uri":"/posts/cpsdutacm15%E5%91%A8%E5%B9%B4/"},{"categories":["算法竞赛"],"content":"博客链接 ","date":"2023-09-01","objectID":"/posts/cpjiangly%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/:0:0","tags":["模板"],"title":"jiangly 算法模板","uri":"/posts/cpjiangly%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"},{"categories":["算法竞赛"],"content":"原题链接 题意 定义函数 $f_k(x) = (x ^ 2 - 1)f' _{k - 1}(x)$，其中 $f_0(x) = x$，求 $f_n(x_0)$ 对 $998,244,353$ 取模。 $0\\le n \\le 2 \\times 10 ^ 5, 0 \\le x_0 \\le 998,244,352$ 分析： 首先看到递推式含有导数，我们可以考虑序列 $f_0(x),f_1(x),f_2(x),\\cdots$ 的 EGF。由于 $x$ 变量已存在，我们用二元函数 $F(x, y)$ 来刻画，即： $$ F(x,y) = \\sum_{i = 0} ^ {\\infty}\\frac{f_i(x)}{i!} y ^ i $$ 我们希望在 $F(x, y)$ 中看到 $f’_i(x)$，于是对 $F(x, y)$ 求一次 $x$ 的偏导。 $$ \\frac{\\partial F(x,y)}{\\partial x} = \\sum_{i = 0} ^ {\\infty}\\frac{f’_i(x)}{i!} y ^ i $$ 这样我们就可以把 $f' _ {i}(x)$ 替换为 $\\dfrac{f_{i + 1}(x)}{x ^ 2 - 1}$ (此时分母必然不为 $0$，否则不满足样例解释) $$ \\frac{\\partial F(x,y)}{\\partial x} = \\sum_{i = 0} ^ {\\infty}\\frac{f_{i + 1}(x)}{(x ^ 2 - 1) \\times i!} y ^ i $$ 我们希望右边也凑成 $\\sum\\limits_{i = 0} ^ {\\infty}\\dfrac{f_i(x)}{i!} y ^ i$，所以把 $(x ^ 2 - 1)$ 乘到左边。 $$ (x ^ 2 - 1)\\frac{\\partial F(x,y)}{\\partial x} = \\sum_{i = 0} ^ {\\infty}\\frac{f_{i + 1}(x)}{i!} y ^ i $$ 此时差别为 $f_{i + 1}(x)$ 产生的错位，所以我们可以对 $F(x, y)$ 求一次 $y$ 的偏导。 $$ \\begin{array}{c} \u0026\u0026\\dfrac{\\partial F(x,y)}{\\partial y} \u0026=\u0026 \\sum\\limits_{i = 1} ^ {\\infty}\\dfrac{f_i(x)}{(i - 1)!} y ^ {i - 1} \\\\ \u0026\\Leftrightarrow\u0026 \\dfrac{\\partial F(x,y)}{\\partial y} \u0026=\u0026 \\sum\\limits_{i = 0} ^ {\\infty}\\dfrac{f_{i + 1}(x)}{i!} y ^ i \\end{array} $$ 这样两个等式右边就一样了，于是直接联立。 $$ \\frac{\\partial F(x,y)}{\\partial y} = (x ^ 2 - 1)\\frac{\\partial F(x,y)}{\\partial x} $$ 问题变为求解这个一阶线性偏微分方程，考虑用特征线法。方程改写为： $$ a(x,y,F)F_x+b(x,y,F)F_y=c(x,y,F) $$ 其中 $a(x,y,F) = 1 - x ^ 2, b(x,y,F) = 1,c(x,y,F) = 0$，故有特征系统： $$ \\begin{array}{c} \\dfrac{\\mathrm{d}x}{\\mathrm{d}t} \u0026=\u0026 1 - x ^ 2 \u0026(1)\\\\ \\dfrac{\\mathrm{d}y}{\\mathrm{d}t} \u0026=\u0026 1 \u0026 (2) \\\\ \\dfrac{\\mathrm{d}F}{\\mathrm{d}t} \u0026=\u0026 0 \u0026 (3) \\end{array} $$ 将 $(1), (2)$ 方程联立消掉 $\\mathrm{d}t$ 得 $\\mathrm{d}y = \\dfrac{1}{1 - x ^ 2} \\mathrm{d}x$，两边积分得 $2y + C_1 = \\ln\\left|\\dfrac{1 + x}{1 - x}\\right|$ 再由 $(3)$ 得 $F = C_2$，与上式结合得： $$ F(x, y) = h\\left(\\ln\\left|\\dfrac{1 + x}{1 - x}\\right| - 2y\\right) $$ 其中 $h$ 为任意函数，此时由边界条件 $F(x, 0) = x$ 代入得： $$ x = h\\left(\\ln\\left|\\dfrac{1 + x}{1 - x}\\right|\\right) $$ 于是令 $u = \\ln\\left|\\dfrac{1 + x}{1 - x}\\right|$，反解 $x$ 得 $\\dfrac{e ^ u - 1}{e ^ u + 1} = x$，所以 $h(u) = \\dfrac{e ^ u - 1}{e ^ u + 1}$，即 $h(x) = \\dfrac{e ^ x - 1}{e ^ x + 1}$ 将 $\\ln\\left|\\dfrac{1 + x}{1 - x}\\right| - 2y$ 代入到 $h(x)$，整理出 $F(x, y)$： $$ F(x, y) = \\dfrac{1 + x - (1 - x)e ^ {2y}}{1 + x + (1 - x)e ^ {2y}} $$ 故 $$ \\dfrac{1 + x - (1 - x)e ^ {2y}}{1 + x + (1 - x)e ^ {2y}} = \\sum_{i = 0} ^ {\\infty}\\frac{f_i(x)}{i!} y ^ i $$ 直接代入 $x_0$ 并求 $f_n(x_0)$，那么答案就为 $$ f_n(x_0) = n!\\times [y ^ n] \\left(\\dfrac{1 + x_0 - (1 - x_0) e ^ {2y}}{1 + x_0 + (1 - x_0)e ^ {2y}}\\right) $$ 展开 $e ^ {2y}$ 到 $n$ 项，进行多项式求逆再卷积即可。 ","date":"2023-08-22","objectID":"/posts/cp2023%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A110-h-differential-equation/:0:0","tags":["生成函数","多项式","PDE"],"title":"[2023牛客多校10 H] Differential Equation","uri":"/posts/cp2023%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A110-h-differential-equation/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } template\u003cint mod\u003e struct ModInt { int x; ModInt() : x(0) {} ModInt(i64 y) : x(y \u003e= 0 ? y % mod : (mod - (-y) % mod) % mod) {} ModInt \u0026operator+=(const ModInt \u0026p) { if ((x += p.x) \u003e= mod) x -= mod; return *this; } ModInt \u0026operator-=(const ModInt \u0026p) { if ((x += mod - p.x) \u003e= mod) x -= mod; return *this; } ModInt \u0026operator*=(const ModInt \u0026p) { x = (int)(1LL * x * p.x % mod); return *this; } ModInt \u0026operator/=(const ModInt \u0026p) { *this *= p.inv(); return *this; } ModInt operator-() const { return ModInt(-x); } ModInt operator+(const ModInt \u0026p) const { return ModInt(*this) += p; } ModInt operator-(const ModInt \u0026p) const { return ModInt(*this) -= p; } ModInt operator*(const ModInt \u0026p) const { return ModInt(*this) *= p; } ModInt operator/(const ModInt \u0026p) const { return ModInt(*this) /= p; } bool operator==(const ModInt \u0026p) const { return x == p.x; } bool operator!=(const ModInt \u0026p) const { return x != p.x; } ModInt inv() const { int a = x, b = mod, u = 1, v = 0, t; while (b \u003e 0) { t = a / b; swap(a -= t * b, b); swap(u -= t * v, v); } return ModInt(u); } ModInt pow(i64 n) const { ModInt res(1), mul(x); while (n \u003e 0) { if (n \u0026 1) res *= mul; mul *= mul; n \u003e\u003e= 1; } return res; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const ModInt \u0026p) { return os \u003c\u003c p.x; } friend istream \u0026operator\u003e\u003e(istream \u0026is, ModInt \u0026a) { i64 t; is \u003e\u003e t; a = ModInt\u003cmod\u003e(t); return (is); } int val() const { return x; } static constexpr int val_mod() { return mod; } }; using Z = ModInt\u003cmod\u003e; vector\u003cZ\u003e fact, infact; void init(int n) { fact.resize(n + 1), infact.resize(n + 1); fact[0] = infact[0] = 1; for (int i = 1; i \u003c= n; i ++) { fact[i] = fact[i - 1] * i; } infact[n] = fact[n].inv(); for (int i = n; i; i --) { infact[i - 1] = infact[i] * i; } } Z C(int n, int m) { if (n \u003c 0 || m \u003c 0 || n \u003c m) return Z(0); return fact[n] * infact[n - m] * infact[m]; } vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*","date":"2023-08-22","objectID":"/posts/cp2023%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A110-h-differential-equation/:1:0","tags":["生成函数","多项式","PDE"],"title":"[2023牛客多校10 H] Differential Equation","uri":"/posts/cp2023%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A110-h-differential-equation/"},{"categories":["算法竞赛"],"content":"原题链接 题意 有 $n$ 个商店卖 $m$ 种商品，每个商店只无限卖一种商品，第 $i$ 个商店卖第 $a_i$ 种类型商品。 你将购物 $k$ 次，每次随机选择某个商店购买一件商品。购物完后，以下情况你将不满意： 存在一个商品类型 $i$，你恰好购买了该类型商品 $c_i$ 个，并且这 $c_i$ 个商品恰好来自不同的商店。($c_i$ 表示卖类型 $i$ 的商品的商店个数) 求购物 $k$ 次后使你满意的概率，对 $998,244,353$ 取模。(购物带标号) $(1 \\le m \\le n \\le 2 \\times 10 ^ 5,1 \\le a_i \\le m, 1 \\le k \u003c 998,244,353)$ 分析： 考虑计算满意的方案数。我们可以先分别考虑每种商品的方案数。 首先第 $i$ 种类型的商品有 $c_i$ 个商店，由于带标号，那么每个商店的 EGF 就为 $\\sum\\limits_{j = 0} ^ {\\infty} \\dfrac{x ^ j}{j!}$，一共 $c_i$ 个商店，所以此类型商品的 EGF 就为 $\\left(\\sum\\limits_{j = 0} ^ {\\infty} \\dfrac{x ^ j}{j!}\\right) ^ {c_i} = e ^ {c_ix}$ 现在考虑减掉不满意的条件，每个商店需要恰好选择一个商品，所以此情况就为 $x ^ {c_i}$，这样满足题意的生成函数为 $e ^ {c_ix} - x ^ {c_i}$ 所以满意的总方案数就为 $$ k![x ^ k]\\prod_{i = 1} ^ {m}\\left(e ^ {c_ix} - x ^ {c_i} + [c_i = 0]\\right) $$ 这里先令 $e ^ {c_ix} = 1$，也就是构造多项式 $f(x) = 1 - x ^ {c_i}$ 进行分治 NTT，由于 $\\sum\\limits_{i = 1} ^ {m}c_i = n$，所以多项式的项数最多到 $n$，我们直接枚举答案多项式系数 $i$，那么只需要求 $e ^ {(n - i)x}$ 的第 $k - i$ 项系数就好，即 $\\dfrac{(n - i) ^ {k - i}}{(k - i)!}$ 那么概率就为方案数除以所有情况 $n ^ k$ 即可。 注意到 $k \u003c 998,244,353$，所以求阶乘时需要用到快速阶乘算法。 这里粗略用一下 $O(\\sqrt{n} \\log ^ 2n)$ 的做法： 将 $n!$ 分块，即构造多项式 $f(x) = \\prod\\limits_{i = 1} ^ {\\lfloor\\sqrt{n}\\rfloor}(x + i)$，用分治 NTT 求出，再对 $f(0), f(\\sqrt{n}), f(2\\sqrt{n}), \\cdots,f(\\lfloor\\dfrac{n}{\\sqrt{n}}\\rfloor \\sqrt{n})$ 进行多项式多点求值，最后乘起来即可。 此题时限 $18$ 秒完全够用。 ","date":"2023-08-15","objectID":"/posts/cp2023%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A19-k-cargo/:0:0","tags":["生成函数","多项式","快速阶乘"],"title":"[2023杭电多校9 K] Cargo","uri":"/posts/cp2023%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A19-k-cargo/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } template\u003cint mod\u003e struct ModInt { int x; ModInt() : x(0) {} ModInt(i64 y) : x(y \u003e= 0 ? y % mod : (mod - (-y) % mod) % mod) {} ModInt \u0026operator+=(const ModInt \u0026p) { if ((x += p.x) \u003e= mod) x -= mod; return *this; } ModInt \u0026operator-=(const ModInt \u0026p) { if ((x += mod - p.x) \u003e= mod) x -= mod; return *this; } ModInt \u0026operator*=(const ModInt \u0026p) { x = (int)(1LL * x * p.x % mod); return *this; } ModInt \u0026operator/=(const ModInt \u0026p) { *this *= p.inv(); return *this; } ModInt operator-() const { return ModInt(-x); } ModInt operator+(const ModInt \u0026p) const { return ModInt(*this) += p; } ModInt operator-(const ModInt \u0026p) const { return ModInt(*this) -= p; } ModInt operator*(const ModInt \u0026p) const { return ModInt(*this) *= p; } ModInt operator/(const ModInt \u0026p) const { return ModInt(*this) /= p; } bool operator==(const ModInt \u0026p) const { return x == p.x; } bool operator!=(const ModInt \u0026p) const { return x != p.x; } ModInt inv() const { int a = x, b = mod, u = 1, v = 0, t; while (b \u003e 0) { t = a / b; swap(a -= t * b, b); swap(u -= t * v, v); } return ModInt(u); } ModInt pow(i64 n) const { ModInt res(1), mul(x); while (n \u003e 0) { if (n \u0026 1) res *= mul; mul *= mul; n \u003e\u003e= 1; } return res; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const ModInt \u0026p) { return os \u003c\u003c p.x; } friend istream \u0026operator\u003e\u003e(istream \u0026is, ModInt \u0026a) { i64 t; is \u003e\u003e t; a = ModInt\u003cmod\u003e(t); return (is); } int val() const { return x; } static constexpr int val_mod() { return mod; } }; using Z = ModInt\u003cmod\u003e; vector\u003cZ\u003e fact, infact; void init(int n) { fact.resize(n + 1), infact.resize(n + 1); fact[0] = infact[0] = 1; for (int i = 1; i \u003c= n; i ++) { fact[i] = fact[i - 1] * i; } infact[n] = fact[n].inv(); for (int i = n; i; i --) { infact[i - 1] = infact[i] * i; } } Z C(int n, int m) { if (n \u003c 0 || m \u003c 0 || n \u003c m) return Z(0); return fact[n] * infact[n - m] * infact[m]; } vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*","date":"2023-08-15","objectID":"/posts/cp2023%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A19-k-cargo/:1:0","tags":["生成函数","多项式","快速阶乘"],"title":"[2023杭电多校9 K] Cargo","uri":"/posts/cp2023%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A19-k-cargo/"},{"categories":["算法竞赛"],"content":"原题链接 题意 计算满足下列条件长度为 $n$ 的序列 $(a_1,a_2,\\cdots,a_n)$ 的个数。 对于 $1 \\le i \\le n$ 满足 $0 \\le a_i \\le 2 ^ m$ $\\sum\\limits_{i = 1} ^ {n} \\text{cnt}_1(a_i \\oplus b_i) = k$ 其中序列 $b$ 为 $(a_2,a_3,\\cdots,a_n,a_1)$，$\\text{cnt}_1(x)$ 代表 $x$ 二进制中 $1$ 的个数。 对 $998,244,353$ 取模。 $2 \\le n \u003c 998,244,353, 1 \\le m \\le 10 ^ 8,1 \\le k \\le 5\\times 10 ^ 4$ 分析： 首先观察第二个条件，由于每一位是独立的，考虑拆位。 统计 $m$ 位中每一位对答案的贡献，记 $a_i = \\sum\\limits_{j = 0} ^ {m - 1} c_{ij} \\times 2 ^ j$，其中 $c_{ij}$ 表示 $a_i$ 二进制的第 $j$ 位。 那么对第 $j$ 位来说，只需要知道序列 $(c_{1j} \\oplus c_{2j},c_{2j} \\oplus c_{3j},\\cdots, c_{(n - 1)j} \\oplus c_{nj}, c_{nj} \\oplus c_{1j})$ 中产生若干个 $1$ 的方案数。 下面简单证一下序列中只可能包含偶数个 $1$： $c_{pj} \\oplus c_{qj} = 1$ 等价于 $c_{pj} \\ne c_{qj}$ $c_{pj} \\oplus c_{qj} = 0$ 等价于 $c_{pj} = c_{qj}$ 所以问题等价于在 $01$ 环选择 $u$ 条边使相邻点的值不相等，那么剩下 $n - u$ 条边使得相邻点的值相等。 由于相等边不改变值，所以我们可以将不相等边构成的连通块缩成一个连通块，也就是将相等边构成连通块的两边节点合并到一起。 此时问题变为二分图染色问题，我们知道二分图染色奇数环是不可行的，所以环大小必定为偶数，由此推出 $1$ 必须为偶数个。 那么得到 $2u$ 个 $1$ 的方案数就为 $2\\dbinom{n}{2u}$，考虑每一位的生成函数 $$ F(x) = \\sum_{u = 0} ^ {\\lfloor \\frac{n}{2} \\rfloor } 2\\binom{n}{2u}x ^ {2u} $$ 由于每一位独立，所以 $m$ 个生成函数都相等，所以答案为 $$ [x ^ k] F^ m(x) $$ 由于 $n \u003c 998,244,353$ ，但 $k \\le 5\\times 10 ^ 4$，所以 $F(x)$ 至多算到第 $k$ 项，那么 $\\dbinom{n}{2u}$ 经典维护下降幂。最后使用多项式快速幂求解即可。 ","date":"2023-08-08","objectID":"/posts/cp2023%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A17-f-counting-sequences/:0:0","tags":["生成函数","多项式快速幂"],"title":"[2023牛客多校7 F] Counting Sequences","uri":"/posts/cp2023%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A17-f-counting-sequences/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } template\u003cint mod\u003e struct ModInt { int x; ModInt() : x(0) {} ModInt(i64 y) : x(y \u003e= 0 ? y % mod : (mod - (-y) % mod) % mod) {} ModInt \u0026operator+=(const ModInt \u0026p) { if ((x += p.x) \u003e= mod) x -= mod; return *this; } ModInt \u0026operator-=(const ModInt \u0026p) { if ((x += mod - p.x) \u003e= mod) x -= mod; return *this; } ModInt \u0026operator*=(const ModInt \u0026p) { x = (int)(1LL * x * p.x % mod); return *this; } ModInt \u0026operator/=(const ModInt \u0026p) { *this *= p.inv(); return *this; } ModInt operator-() const { return ModInt(-x); } ModInt operator+(const ModInt \u0026p) const { return ModInt(*this) += p; } ModInt operator-(const ModInt \u0026p) const { return ModInt(*this) -= p; } ModInt operator*(const ModInt \u0026p) const { return ModInt(*this) *= p; } ModInt operator/(const ModInt \u0026p) const { return ModInt(*this) /= p; } bool operator==(const ModInt \u0026p) const { return x == p.x; } bool operator!=(const ModInt \u0026p) const { return x != p.x; } ModInt inv() const { int a = x, b = mod, u = 1, v = 0, t; while (b \u003e 0) { t = a / b; swap(a -= t * b, b); swap(u -= t * v, v); } return ModInt(u); } ModInt pow(i64 n) const { ModInt res(1), mul(x); while (n \u003e 0) { if (n \u0026 1) res *= mul; mul *= mul; n \u003e\u003e= 1; } return res; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const ModInt \u0026p) { return os \u003c\u003c p.x; } friend istream \u0026operator\u003e\u003e(istream \u0026is, ModInt \u0026a) { i64 t; is \u003e\u003e t; a = ModInt\u003cmod\u003e(t); return (is); } int val() const { return x; } static constexpr int val_mod() { return mod; } }; using Z = ModInt\u003cmod\u003e; vector\u003cZ\u003e fact, infact; void init(int n) { fact.resize(n + 1), infact.resize(n + 1); fact[0] = infact[0] = 1; for (int i = 1; i \u003c= n; i ++) { fact[i] = fact[i - 1] * i; } infact[n] = fact[n].inv(); for (int i = n; i; i --) { infact[i - 1] = infact[i] * i; } } Z C(int n, int m) { if (n \u003c 0 || m \u003c 0 || n \u003c m) return Z(0); return fact[n] * infact[n - m] * infact[m]; } vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*","date":"2023-08-08","objectID":"/posts/cp2023%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A17-f-counting-sequences/:1:0","tags":["生成函数","多项式快速幂"],"title":"[2023牛客多校7 F] Counting Sequences","uri":"/posts/cp2023%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A17-f-counting-sequences/"},{"categories":["算法竞赛"],"content":"原题链接 题意 有 $n$ 个标号为 $1,2,\\cdots,n$ 的球，放到 $m$ 个无标号盒子 (盒内顺序有标号)，且每个盒子球数不超过 $k$，求方案数对 $998,244,353$ 取模。 $1 \\le m,k \\le n \\le 10 ^ 6$ 分析： 考虑每个盒子内球的生成函数 $\\sum\\limits_{i = 1} ^ {k}x ^ i$，那么 $m$ 个盒子的生成函数就为 $\\left( \\sum\\limits_{i = 1} ^ {k}x ^ i\\right) ^ m$，那么方案数就为第 $n$ 项系数。 由于球带标号，所以需要对答案全排列，也就是乘 $n!$，又由于盒子不带标号，所以要对答案除 $m!$，那么答案为 $$ \\frac{n!}{m!} \\times [x ^ n]\\left( \\sum\\limits_{i = 1} ^ {k}x ^ i\\right) ^ m $$ $10 ^ 6$ 用多项式快速幂会超时，考虑 $$ \\left( \\sum\\limits_{i = 1} ^ {k}x ^ i\\right) ^ m= x ^ m \\left( \\sum\\limits_{i = 0} ^ {k - 1}x ^ i\\right) ^ m = x ^ m \\frac{(1 -x ^ k)^m}{(1 - x) ^ m} $$ 转为求 $[x^{n - m}] \\dfrac{(1 -x ^ k)^m}{(1 - x) ^ m}$ 其中 $$ (1 - x ^ k) ^ m = \\sum_{i = 0} ^ {m}\\binom{m}{i} \\times (-1) ^ i \\times x ^ {i \\times k} $$ $$ \\frac{1}{(1 - x) ^ m} = \\sum_{i = 0} ^ {\\infty} \\binom{m - 1 + i}{m - 1} \\times x ^ i $$ 于是枚举第一个式子的 $i$，那么只需要求第二个式子的 $n - m - i \\times k$ 项系数即可。 ","date":"2023-08-02","objectID":"/posts/cp2023%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A15-1005-snake/:0:0","tags":["生成函数"],"title":"[2023杭电多校5 1005] Snake","uri":"/posts/cp2023%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A15-1005-snake/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } template\u003cint mod\u003e struct ModInt { int x; ModInt() : x(0) {} ModInt(i64 y) : x(y \u003e= 0 ? y % mod : (mod - (-y) % mod) % mod) {} ModInt \u0026operator+=(const ModInt \u0026p) { if ((x += p.x) \u003e= mod) x -= mod; return *this; } ModInt \u0026operator-=(const ModInt \u0026p) { if ((x += mod - p.x) \u003e= mod) x -= mod; return *this; } ModInt \u0026operator*=(const ModInt \u0026p) { x = (int)(1LL * x * p.x % mod); return *this; } ModInt \u0026operator/=(const ModInt \u0026p) { *this *= p.inv(); return *this; } ModInt operator-() const { return ModInt(-x); } ModInt operator+(const ModInt \u0026p) const { return ModInt(*this) += p; } ModInt operator-(const ModInt \u0026p) const { return ModInt(*this) -= p; } ModInt operator*(const ModInt \u0026p) const { return ModInt(*this) *= p; } ModInt operator/(const ModInt \u0026p) const { return ModInt(*this) /= p; } bool operator==(const ModInt \u0026p) const { return x == p.x; } bool operator!=(const ModInt \u0026p) const { return x != p.x; } ModInt inv() const { int a = x, b = mod, u = 1, v = 0, t; while (b \u003e 0) { t = a / b; swap(a -= t * b, b); swap(u -= t * v, v); } return ModInt(u); } ModInt pow(i64 n) const { ModInt res(1), mul(x); while (n \u003e 0) { if (n \u0026 1) res *= mul; mul *= mul; n \u003e\u003e= 1; } return res; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const ModInt \u0026p) { return os \u003c\u003c p.x; } friend istream \u0026operator\u003e\u003e(istream \u0026is, ModInt \u0026a) { i64 t; is \u003e\u003e t; a = ModInt\u003cmod\u003e(t); return (is); } int val() const { return x; } static constexpr int val_mod() { return mod; } }; using Z = ModInt\u003cmod\u003e; vector\u003cZ\u003e fact, infact; void init(int n) { fact.resize(n + 1), infact.resize(n + 1); fact[0] = infact[0] = 1; for (int i = 1; i \u003c= n; i ++) { fact[i] = fact[i - 1] * i; } infact[n] = fact[n].inv(); for (int i = n; i; i --) { infact[i - 1] = infact[i] * i; } } Z C(int n, int m) { if (n \u003c 0 || m \u003c 0 || n \u003c m) return Z(0); return fact[n] * infact[n - m] * infact[m]; } void solve() { int n, m, k; cin \u003e\u003e n \u003e\u003e m \u003e\u003e k; Z ans; for (int i = 0; i \u003c= m; i ++) { Z f = i \u0026 1 ? Z(-1) : Z(1); ans += f * C(m, i) * C(n - k * i - 1, m - 1); } cout \u003c\u003c ans * fact[n] / fact[m] \u003c\u003c \"\\n\"; } signed main() { init(1e6); cin.tie(0) -\u003e sync_with_stdio(0); int T; cin \u003e\u003e T; while (T --) { solve(); } } ","date":"2023-08-02","objectID":"/posts/cp2023%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A15-1005-snake/:1:0","tags":["生成函数"],"title":"[2023杭电多校5 1005] Snake","uri":"/posts/cp2023%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A15-1005-snake/"},{"categories":["算法竞赛"],"content":"原题链接 题意 求 $$ \\sum_{i = 1} ^ {n} \\sum_{j = 1} ^ {n}[\\gcd(2 ^ i - 1, 2 ^ j - 1)] ^ k $$ 对 $998,244,353$ 取模。 $1 \\le n \\le 10 ^ 9, 0 \\le k \\le 10$ 分析： 易证 $\\gcd(2 ^ i - 1, 2 ^ j - 1) = 2 ^ {\\gcd(i, j)} - 1$，代入得 $$ \\sum_{i = 1} ^ {n} \\sum_{j = 1} ^ {n}(2^{\\gcd(i, j)} - 1) ^ k $$ 常规枚举 $d$ $$ \\sum_{d = 1} ^ {n} \\sum_{i = 1} ^ {n} \\sum_{j = 1} ^ {n}(2^d - 1) ^ k [\\gcd(i,j) = d] $$ 把 $d$ 拿到求和上界 $$ \\sum_{d = 1} ^ {n} \\sum_{i = 1} ^ { \\lfloor \\frac{n}{d} \\rfloor } \\sum_{j = 1} ^ { \\lfloor \\frac{n}{d} \\rfloor}\\left(2^d - 1\\right) ^ k[\\gcd(i,j) = 1] $$ 我们知道 $\\sum\\limits_{i = 1} ^ {n}\\sum\\limits_{j = 1} ^ {n}[\\gcd(i,j) = 1] = 2\\sum\\limits_{i = 1} ^ {n}\\varphi(i) - 1$，($-1$ 在 $\\sum$ 外面)，代入得 $$ \\sum_{d = 1} ^ {n}\\left(2^d - 1\\right) ^ k \\left(2\\sum_{i = 1} ^ { \\lfloor \\frac{n}{d} \\rfloor}\\varphi(i) - 1\\right) $$ 考虑整除分块，后面欧拉函数前缀和可以用杜教筛，那么考虑如何快速求 $\\left(2^d - 1\\right) ^ k$ 的前缀和。记 $$ S(n) = \\sum_{i = 1} ^ {n}(2 ^ i - 1) ^ k $$ 将 $\\left(2^i - 1\\right) ^ k$ 二项式展开 $$ S(n) = \\sum_{i = 1} ^ {n}\\sum_{j = 0} ^ {k} \\binom{k}{j} \\times 2 ^ {i\\times j} \\times (-1) ^ {k - j} $$ 交换求和顺序 $$ \\sum_{j = 0} ^ {k} \\binom{k}{j}\\times (-1) ^ {k - j} \\sum_{i = 1} ^ {n} (2 ^ {j}) ^ {i} $$ 其中 $\\sum\\limits_{i = 1} ^ {n} (2 ^ {j}) ^ {i}$ 用等比数列求和公式 $$ \\sum_{j = 0} ^ {k} \\binom{k}{j}\\times (-1) ^ {k - j} \\times 2 ^ j \\times \\frac{2 ^ {j \\times n} - 1}{2 ^ j - 1} $$ 这样求 $S(n)$ 就变为 $O(k \\log n)$ 了，注意特判 $j = 0$ 和欧拉降幂 时间复杂度 $O(n ^ {\\frac{2}{3}} + k \\sqrt n \\log n)$ ","date":"2023-08-01","objectID":"/posts/cp2023%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A15-1002-gcd-magic/:0:0","tags":["莫比乌斯反演","推式子","杜教筛"],"title":"[2023杭电多校5 1002] GCD Magic","uri":"/posts/cp2023%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A15-1002-gcd-magic/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 2e6 + 5, mod = 998244353; int n, k, primes[N], euler[N], cnt, sum[N], fact[N], infact[N]; bool st[N]; unordered_map\u003cint, int\u003e mp; void get_eulers(int n) { euler[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; euler[i] = i - 1; } for (int j = 0; i * primes[j] \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { euler[t] = primes[j] * euler[i]; break; } euler[t] = (primes[j] - 1) * euler[i]; } } for (int i = 1; i \u003c= n; i ++) { sum[i] = (sum[i - 1] + euler[i]) % mod; } } int qmi(int a, int b) { int res = 1; while (b) { if (b \u0026 1) res = res * a % mod; a = a * a % mod; b \u003e\u003e= 1; } return res; } int C(int m, int n) { return fact[m] * infact[m - n] % mod * infact[n] % mod; } int Sum_euler(int n) { if (n \u003c N) return sum[n]; if (mp[n]) return mp[n]; int res = n * (n + 1) / 2 % mod; for (int l = 2, r; l \u003c= n; l = r + 1) { r = n / (n / l); res = (res - Sum_euler(n / l) * (r - l + 1) % mod + mod) % mod; } return mp[n] = res; } int Sum(int n) { int res = 0; for (int j = 0; j \u003c= k; j ++) { int f = (k - j) % 2 == 1 ? mod - 1 : 1; if (!j) { res = (res + n * f % mod) % mod; } else { int omod = mod - 1; int t = (qmi(2, j * n % omod) - 1 + mod) % mod; int S = C(k, j) * f % mod % mod * qmi(2, j) % mod * t % mod; int inv = (qmi(2, j) - 1 + mod) % mod; S = S * qmi(inv, mod - 2) % mod; res = (res + S) % mod; } } return res; } signed main() { get_eulers(N - 1); fact[0] = infact[0] = 1; for (int i = 1; i \u003c N; i ++) fact[i] = fact[i - 1] * i % mod; infact[N - 1] = qmi(fact[N - 1], mod - 2); for (int i = N - 2; i; i --) infact[i] = infact[i + 1] * (i + 1) % mod; int T; cin \u003e\u003e T; while (T --) { int res = 0; cin \u003e\u003e n \u003e\u003e k; for (int l = 1, r; l \u003c= n; l = r + 1) { r = n / (n / l); res = (res + (2 * Sum_euler(n / l) % mod - 1 + mod) % mod * (Sum(r) - Sum(l - 1) + mod) % mod) % mod; } cout \u003c\u003c res \u003c\u003c \"\\n\"; } } ","date":"2023-08-01","objectID":"/posts/cp2023%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A15-1002-gcd-magic/:1:0","tags":["莫比乌斯反演","推式子","杜教筛"],"title":"[2023杭电多校5 1002] GCD Magic","uri":"/posts/cp2023%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A15-1002-gcd-magic/"},{"categories":["算法竞赛"],"content":"办的不错的一次比赛。 重现赛链接 榜单链接 视频合集 题解 ","date":"2023-05-28","objectID":"/posts/cp%E5%B1%B1%E4%B8%9C%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E4%BA%94%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B/:0:0","tags":["比赛"],"title":"山东理工大学第十五届ACM程序设计竞赛","uri":"/posts/cp%E5%B1%B1%E4%B8%9C%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E4%BA%94%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B/"},{"categories":["算法竞赛"],"content":"视频： 讲义： ","date":"2023-02-01","objectID":"/posts/cp%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/:0:0","tags":["数论"],"title":"基础数论","uri":"/posts/cp%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/"},{"categories":["算法竞赛"],"content":"生成函数、多项式题单 (大佬轻喷😭) ","date":"2022-10-20","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/:1:0","tags":["题单","生成函数","多项式"],"title":"生成函数、多项式题单","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/"},{"categories":["算法竞赛"],"content":"模板： ","date":"2022-10-20","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/:2:0","tags":["题单","生成函数","多项式"],"title":"生成函数、多项式题单","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/"},{"categories":["算法竞赛"],"content":"FFT/NTT 模板 用来测试多项式板子 多项式乘法：【模板】多项式乘法（FFT） 高精度乘法：A*B Problem 升级版 ","date":"2022-10-20","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/:2:1","tags":["题单","生成函数","多项式"],"title":"生成函数、多项式题单","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/"},{"categories":["算法竞赛"],"content":"基础多项式全家桶模板 稍有难度的多项式板子 拉格朗日插值：【模板】拉格朗日插值 MTT(任意模数多项式乘法)：【模板】任意模数多项式乘法 多项式或/与/异或卷积：【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT) 分治 FFT/NTT：【模板】分治 FFT 多项式除法：【模板】多项式除法 多项式求逆：【模板】多项式乘法逆 多项式开根： $a_0 = 1$ ：【模板】多项式开根 $a_0 \\ne 1$ ：【模板】多项式开根（加强版） 多项式 $\\ln$：【模板】多项式对数函数（多项式 ln） 多项式 $\\exp$：【模板】多项式指数函数（多项式 exp） 多项式快速幂： $a_0 = 1$ ：【模板】多项式快速幂 $a_0 \\ne 1$ ：【模板】多项式幂函数（加强版） ","date":"2022-10-20","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/:2:2","tags":["题单","生成函数","多项式"],"title":"生成函数、多项式题单","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/"},{"categories":["算法竞赛"],"content":"进阶多项式全家桶模板 非常困难的的多项式板子 自然数幂前缀和：The Sum of the k-th Powers MTT 多项式求逆：任意模数多项式乘法逆 高阶差分/前缀和：差分与前缀和 子集卷积：【模板】子集卷积 十二重计数法：十二重计数法 多项式连续点值平移：拉格朗日插值2 Chirp Z 变换：【模板】Chirp Z-Transform 多项式多点求值：【模板】多项式多点求值 多项式快速插值：【模板】多项式快速插值 多项式复合函数：【模板】多项式复合函数 多项式复合函数求逆：【模板】多项式复合逆 下降幂多项式： 下降幂多项式乘法：【模板】下降幂多项式乘法 下降幂多项式与普通幂多项式的互相转换： 普通多项式转下降幂多项式 下降幂多项式转普通多项式 斯特林数： 第一类斯特林数·行 第一类斯特林数·列 第二类斯特林数·行 第二类斯特林数·列 分拆数：分拆数 贝尔数：集合划分计数 欧拉数：排列计数 快速求阶乘：【模板】快速阶乘算法 快速求调和级数：调和级数求和 一阶微分方程：一阶微分方程 常系数齐次线性递推：【模板】常系数齐次线性递推 常系数非齐次线性递推：【模板】常系数非齐次线性递推 整式递推：【模板】整式递推 多项式三角函数：多项式三角函数 多项式反三角函数：多项式反三角函数 ","date":"2022-10-20","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/:2:3","tags":["题单","生成函数","多项式"],"title":"生成函数、多项式题单","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/"},{"categories":["算法竞赛"],"content":"题目： ","date":"2022-10-20","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/:3:0","tags":["题单","生成函数","多项式"],"title":"生成函数、多项式题单","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/"},{"categories":["算法竞赛"],"content":"生成函数/多项式基础题： 比较好推的生成函数/多项式题目 Dice Sum [NOIP2012 普及组] 摆花 Blocks 挑选队友 Reordering msc的背包 Product Tuples Thief in a Shop Lucky Tickets Needle Counting Sequences Snake ","date":"2022-10-20","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/:3:1","tags":["题单","生成函数","多项式"],"title":"生成函数、多项式题单","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/"},{"categories":["算法竞赛"],"content":"生成函数/多项式提高题： 比较难或者需要一些多项式科技的生成函数/多项式题目，还有一些集合幂级数的题目 Function analysis One to One Tree Coloring Fly The Child and Binary Tree 付公主的背包 Falfa with Substring Easy Counting Problem Equipment Upgrade Count Set 带权子集和 Odd Sum [TJOI2019]唱、跳、rap和篮球 [省选联考 2020 A 卷] 组合数问题 Forest NIO’s OAuth2 Server Lndjy and the mex [TJOI2018]教科书般的亵渎 Cargo Differential Equation Expectation (Hard Version) ","date":"2022-10-20","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/:3:2","tags":["题单","生成函数","多项式"],"title":"生成函数、多项式题单","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/"},{"categories":["算法竞赛"],"content":"ICPC/CCPC 区域赛生成函数/多项式题目： 题目之间难度差别较大 2017 CCPC 杭州：Marriage 2018 CCPC 桂林：Array Modify 2018 ICPC 沈阳：Renaissance Past in Nancy 2019 ICPC 上海网络赛：Counting Sequences II、Triple 2019 ICPC 南昌现场赛：XOR Sum 2019 ICPC 南昌网络赛：Interesting Series 2019 ICPC 南昌邀请赛：Polynomial 2020 ICPC 澳门：Accelerator、Fly Me To The Moon 2020 ICPC 沈阳：United in Stormwind 2021 CCPC 威海：810975、Shinyruo and KFC 2021 CCPC 广州：Math Ball、Unnamed Easy Problem 2021 CCPC 江苏省赛：Five Phases 2021 ICPC 上海：Strange Permutations 2021 ICPC 澳门：Pass the Ball! 2021 ICPC 济南：Strange Series 2022 CCPC 广东省赛：拉格朗日插值 2022 CCPC 江苏省赛：Pockets、Super Gray Pony 2022 CCPC 桂林：Alice’s Dolls 2022 CCPC 女生赛：Devil May Cry ","date":"2022-10-20","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/:3:3","tags":["题单","生成函数","多项式"],"title":"生成函数、多项式题单","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95/"},{"categories":["算法竞赛"],"content":"原题链接 题意 给定 $n$ 个权值为 $c_1,c_2,\\cdots,c_n$ 的物品，总共最多取 $W$ 个，求 $$ \\sum_{k_1+k_2+\\cdots+k_n \\le W} \\prod_{i = 1} ^ {n} k_i ^ {c_i} $$ 对 $998,244,353$ 取模，其中 $k_i$ 代表第 $i$ 个物品取的次数。 $1 \\le n \\le 10 ^ 5, \\sum\\limits_{i = 1} ^ {n} c_i \\le 10 ^ 5, W \\le 10 ^ {18}$ 分析： 首先观察题目要我们求的式子，可以看出是一个多项式卷积形式，不难写出每个物品的生成函数，设第 $i$ 个物品的生成函数为 $$ f_i(x) = \\sum_{j = 0} ^ {\\infty} j ^ {c_i}x ^ j $$ 那么答案就是 $$ \\sum_{i = 0} ^ {W} [x ^ i]\\prod_{j = 1} ^ {n}f_j(x) $$ 但 $W$ 是 $10 ^ {18}$ 的，我们肯定不能这么求，所以考虑将答案求一次前缀和，计算第 $W$ 项的系数。 我们知道给一个多项式乘以 $\\sum\\limits_{i = 0} ^ {\\infty} x ^ i = \\dfrac{1}{1 -x}$ 就相当于求一次前缀和，故答案为 $$ [x ^ W]\\frac{1}{1 - x} \\times \\prod_{j = 1} ^ {n}f_j(x) $$ 但这样还是不能解决问题。 所以考虑化简每个物品的生成函数 $f_i(x)$，我们知道有自然数幂展开 $i ^ k = \\sum\\limits_{j = 0} ^ {k} {k \\brace j} \\times j! \\times \\dbinom{i}{j}$，所以 $f_i(x)$ 就为 $$ f_i(x) = \\sum_{j = 0} ^ {\\infty} \\sum_{k = 0} ^ {c_i}{c_i \\brace k} \\times k! \\times \\binom{j}{k} \\times x ^ j $$ 交换求和次序 $$ f_i(x) = \\sum_{k = 0} ^ {c_i} {c_i \\brace k} \\times k! \\sum_{j = 0} ^ {\\infty}\\binom{j}{k} x ^ j $$ 现在考虑化简 $\\sum\\limits_{j = 0} ^ {\\infty}\\dbinom{j}{k} x ^ j$，我们根据广义二项式定理知道 $\\sum\\limits_{i = 0} ^ {\\infty} \\dbinom{i + k - 1}{i}x ^ i$ 的封闭形式为 $\\dfrac{1}{(1 - x) ^ k}$，那么 $\\sum\\limits_{i = 0} ^ {\\infty} \\dbinom{i + k}{i}x ^ i = \\dfrac{1}{(1 - x) ^ {k + 1}}$ 由组合数性质有 $\\dbinom{i + k}{i}=\\dbinom{i + k}{k}$，所以 $\\sum\\limits_{i = 0} ^ {\\infty} \\dbinom{i + k}{i}x ^ i = \\sum\\limits_{i = 0} ^ {\\infty} \\dbinom{i + k}{k}x ^ i = \\sum\\limits_{i = k} ^ {\\infty} \\dbinom{i}{k}x ^ {i - k} = \\dfrac{1}{(1 - x) ^ {k + 1}}$ 再等式两边同乘 $x ^ k$，得出结论 $$ \\sum_{i = 0} ^ {\\infty} \\binom{i}{k}x ^ i = \\frac{x ^ k}{(1 - x) ^ {k + 1}} $$ (由于 $\\dbinom{n}{m}$ 在 $n \u003c m$ 时为 $0$，所以 $i$ 从 $0$ 或从 $k$ 开始都一样) 所以进一步化简了 $f_i(x)$，为 $$ f_i(x) = \\sum_{k = 0} ^ {c_i} {c_i \\brace k} \\times k! \\times \\frac{x ^ k}{(1 - x) ^ {k + 1}} $$ 尽管如此，$f_i(x)$ 仍然不好算，我们注意到题目条件 $\\sum\\limits_{i = 1} ^ {n} c_i \\le 10 ^ 5$，一般会往分治 $\\texttt{NTT}$ 上考虑，我们不妨将 $f_i(x)$ 的形式变成 $$ f_i(x) = \\sum\\limits_{k = 0} ^ {c_i} {c_i \\brace k} \\times k! \\times (\\frac{x}{1-x}) ^ {k} \\times \\frac{1}{1 - x} $$ 此时如果令 $y = \\dfrac{x}{1 - x},f_i(x) = g_i(y) \\times \\dfrac{1}{1 - x}$，其中 $g_i(y) = \\sum\\limits_{k = 0} ^ {c_i} {c_i \\brace k} \\times k! \\times y ^ {k}$ 那么答案就为 $$ [x ^ W] \\frac{\\prod_{j = 1} ^ {n} g_j(y)}{(1 - x) ^ {n + 1}} $$ 这样的话 $\\prod\\limits_{j = 1} ^ {n} g_j(y)$ 是可以用分治 $\\texttt{NTT}$ 求解的，其中需要用到快速求解第二类斯特林数的每一行，求出之后考虑计算第 $W$ 项的系数。 令 $F(x) = \\prod\\limits_{j = 1} ^ {n} g_j(y)$，那么 $F(x)$ 的第 $k$ 项就形如 $a_k \\times (\\dfrac{x}{1 - x}) ^ k$，其中 $a_k$ 为 $F(x)$ 的第 $k$ 项系数，那么 $a_k \\times (\\dfrac{x}{1 - x}) ^ k = a_k \\times x ^ k \\times \\dfrac{1}{(1 - x) ^ k}$，把 $\\dfrac{1}{(1 - x) ^ k}$ 拿到下面，变为 $\\dfrac{1}{(1 - x) ^ {n + k + 1}}$ 由于 $F(x)$ 项数较少，所以考虑枚举 $F(x)$ 的每一项，即答案为 $a_k$ 与 $\\dfrac{1}{(1 - x) ^ {n + k + 1}}$ 的第 $W - k$ 项的乘积之和，考虑展开 $\\dfrac{1}{(1 - x) ^ {n + k + 1}} = \\sum\\limits_{i = 0} ^ {\\infty} \\dbinom{n + k + i}{i}x ^ i$，所以第 $W - k$ 项为 $\\dbinom{W + n}{W - k}$，虽然 $W$ 较大，但 $n$ 很小，经典维护 $W$ 的下降幂即可。 ","date":"2022-10-16","objectID":"/posts/cp2021-ccpc-%E5%B9%BF%E5%B7%9E-a-math-ball/:0:0","tags":["生成函数","多项式"],"title":"[2021 CCPC 广州 A] Math Ball","uri":"/posts/cp2021-ccpc-%E5%B9%BF%E5%B7%9E-a-math-ball/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } template\u003cint mod\u003e struct ModInt { int x; ModInt() : x(0) {} ModInt(i64 y) : x(y \u003e= 0 ? y % mod : (mod - (-y) % mod) % mod) {} ModInt \u0026operator+=(const ModInt \u0026p) { if ((x += p.x) \u003e= mod) x -= mod; return *this; } ModInt \u0026operator-=(const ModInt \u0026p) { if ((x += mod - p.x) \u003e= mod) x -= mod; return *this; } ModInt \u0026operator*=(const ModInt \u0026p) { x = (int)(1LL * x * p.x % mod); return *this; } ModInt \u0026operator/=(const ModInt \u0026p) { *this *= p.inv(); return *this; } ModInt operator-() const { return ModInt(-x); } ModInt operator+(const ModInt \u0026p) const { return ModInt(*this) += p; } ModInt operator-(const ModInt \u0026p) const { return ModInt(*this) -= p; } ModInt operator*(const ModInt \u0026p) const { return ModInt(*this) *= p; } ModInt operator/(const ModInt \u0026p) const { return ModInt(*this) /= p; } bool operator==(const ModInt \u0026p) const { return x == p.x; } bool operator!=(const ModInt \u0026p) const { return x != p.x; } ModInt inv() const { int a = x, b = mod, u = 1, v = 0, t; while (b \u003e 0) { t = a / b; swap(a -= t * b, b); swap(u -= t * v, v); } return ModInt(u); } ModInt pow(i64 n) const { ModInt res(1), mul(x); while (n \u003e 0) { if (n \u0026 1) res *= mul; mul *= mul; n \u003e\u003e= 1; } return res; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const ModInt \u0026p) { return os \u003c\u003c p.x; } friend istream \u0026operator\u003e\u003e(istream \u0026is, ModInt \u0026a) { i64 t; is \u003e\u003e t; a = ModInt\u003cmod\u003e(t); return (is); } int val() const { return x; } static constexpr int val_mod() { return mod; } }; using Z = ModInt\u003cmod\u003e; vector\u003cZ\u003e fact, infact; void init(int n) { fact.resize(n + 1), infact.resize(n + 1); fact[0] = infact[0] = 1; for (int i = 1; i \u003c= n; i ++) { fact[i] = fact[i - 1] * i; } infact[n] = fact[n].inv(); for (int i = n; i; i --) { infact[i - 1] = infact[i] * i; } } Z C(int n, int m) { if (n \u003c 0 || m \u003c 0 || n \u003c m) return Z(0); return fact[n] * infact[n - m] * infact[m]; } vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*","date":"2022-10-16","objectID":"/posts/cp2021-ccpc-%E5%B9%BF%E5%B7%9E-a-math-ball/:1:0","tags":["生成函数","多项式"],"title":"[2021 CCPC 广州 A] Math Ball","uri":"/posts/cp2021-ccpc-%E5%B9%BF%E5%B7%9E-a-math-ball/"},{"categories":["算法竞赛"],"content":"原题链接 题意 给定 $n$ 个正整数 $a_1,a_2,\\cdots,a_n$，并给定正整数 $m$，对于每个 $k \\in [1, m]$，计算 $\\prod\\limits_{i = 1} ^ {n} \\dbinom{k}{a_i}$ 对 $998,244,353$ 取模。 $(1 \\le n, m \\le 5 \\times 10 ^ 4, \\sum\\limits_{i = 1} ^ {n}a_i \\le 10 ^ 5)$ 分析： 考虑拆组合数 $$ \\prod_{i = 1} ^ {n}\\binom{k}{a_i}=\\prod_{i = 1} ^ {n}\\frac{k!}{a_i! \\times (k - a_i)!} \\ = \\frac{1}{\\prod\\limits_{i = 1} ^ {n}a_i!} \\times \\prod_{i = 1} ^ {n} k ^ {\\underline {a_i}} $$ 所以可以把 $k ^ {\\underline{a_i}}$ 看作一个下降幂多项式，那么使用分治下降幂多项式乘法可以求出 $\\prod\\limits_{i = 1} ^ {n} k ^ {\\underline {a_i}}$，再转为普通幂多项式，再对 $(1, 2, \\cdots,m)$ 使用多项式多点求值即可求出答案，时间复杂度 $O(n\\log ^ 2 n)$ ","date":"2022-10-04","objectID":"/posts/cp2021ccpc-%E5%A8%81%E6%B5%B7g-shinyruo-and-kfc/:0:0","tags":["下降幂多项式","多项式多点求值"],"title":"[2021CCPC 威海G] Shinyruo and KFC","uri":"/posts/cp2021ccpc-%E5%A8%81%E6%B5%B7g-shinyruo-and-kfc/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } template\u003cint mod\u003e struct ModInt { int x; ModInt() : x(0) {} ModInt(i64 y) : x(y \u003e= 0 ? y % mod : (mod - (-y) % mod) % mod) {} ModInt \u0026operator+=(const ModInt \u0026p) { if ((x += p.x) \u003e= mod) x -= mod; return *this; } ModInt \u0026operator-=(const ModInt \u0026p) { if ((x += mod - p.x) \u003e= mod) x -= mod; return *this; } ModInt \u0026operator*=(const ModInt \u0026p) { x = (int)(1LL * x * p.x % mod); return *this; } ModInt \u0026operator/=(const ModInt \u0026p) { *this *= p.inv(); return *this; } ModInt operator-() const { return ModInt(-x); } ModInt operator+(const ModInt \u0026p) const { return ModInt(*this) += p; } ModInt operator-(const ModInt \u0026p) const { return ModInt(*this) -= p; } ModInt operator*(const ModInt \u0026p) const { return ModInt(*this) *= p; } ModInt operator/(const ModInt \u0026p) const { return ModInt(*this) /= p; } bool operator==(const ModInt \u0026p) const { return x == p.x; } bool operator!=(const ModInt \u0026p) const { return x != p.x; } ModInt inv() const { int a = x, b = mod, u = 1, v = 0, t; while (b \u003e 0) { t = a / b; swap(a -= t * b, b); swap(u -= t * v, v); } return ModInt(u); } ModInt pow(i64 n) const { ModInt res(1), mul(x); while (n \u003e 0) { if (n \u0026 1) res *= mul; mul *= mul; n \u003e\u003e= 1; } return res; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const ModInt \u0026p) { return os \u003c\u003c p.x; } friend istream \u0026operator\u003e\u003e(istream \u0026is, ModInt \u0026a) { i64 t; is \u003e\u003e t; a = ModInt\u003cmod\u003e(t); return (is); } int val() const { return x; } static constexpr int val_mod() { return mod; } }; using Z = ModInt\u003cmod\u003e; vector\u003cZ\u003e fact, infact; void init(int n) { fact.resize(n + 1), infact.resize(n + 1); fact[0] = infact[0] = 1; for (int i = 1; i \u003c= n; i ++) { fact[i] = fact[i - 1] * i; } infact[n] = fact[n].inv(); for (int i = n; i; i --) { infact[i - 1] = infact[i] * i; } } Z C(int n, int m) { if (n \u003c 0 || m \u003c 0 || n \u003c m) return Z(0); return fact[n] * infact[n - m] * infact[m]; } vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*","date":"2022-10-04","objectID":"/posts/cp2021ccpc-%E5%A8%81%E6%B5%B7g-shinyruo-and-kfc/:1:0","tags":["下降幂多项式","多项式多点求值"],"title":"[2021CCPC 威海G] Shinyruo and KFC","uri":"/posts/cp2021ccpc-%E5%A8%81%E6%B5%B7g-shinyruo-and-kfc/"},{"categories":["算法竞赛"],"content":"原题链接 题意 有 $4$ 类数量分别为 $a,b,c,d$ 的物品，求出长度为 $n$ 的所有不包含 abcd 子串的序列的方案数，对 $998, 244 , 353$ 取模。 分析： 此题比较像 2022 牛客多校2 E，考虑将 abcd 捆绑，我们可以先算出至少存在 $i$ 个 abcd 子串的方案数，那么会有 $n - 4 \\times i + i = n - 3 \\times i$ 个位置，从中选出 $i$ 个位置的方案数为 $\\dbinom{n - 3 \\times i}{i}$，那么现在要解决的问题是从剩下 $n - 4 \\times i$ 个位置随意选 $a,b,c,d$ 的方案数，我们可以写出它们的生成函数，记 $$ F_k(x) = \\sum_{i = 0} ^ {k} \\frac{x ^ i}{i!} $$ 那么 $a,b,c,d$ 的生成函数分别为 $F_{a - i}(x),F_{b - i}(x),F_{c - i}(x),F_{d - i}(x)$，所以方案数为 $(n - 4 \\times i)! \\times [x ^ {n - 4 \\times i}]F_{a - i}(x) * F_{b - i}(x) * F_{c - i}(x) * F_{d - i}(x)$，我们现在求出了至少为 $i$ 的方案数，可以用二项式反演求出恰好为 $0$ 的方案数，那么答案就是 $$ \\sum_{i = 0} ^ {\\min(a,b,c,d)} (-1) ^ i \\times \\binom{n - 3 \\times i}{i} \\times (n - 4 \\times i)! \\times [x ^ {n - 4 \\times i}]F_{a - i}(x) * F_{b - i}(x) * F_{c - i}(x) * F_{d - i}(x) $$ ","date":"2022-09-22","objectID":"/posts/cptjoi2019-%E5%94%B1%E8%B7%B3rap%E5%92%8C%E7%AF%AE%E7%90%83/:0:0","tags":["二项式反演","NTT"],"title":"[TJOI2019] 唱、跳、rap和篮球","uri":"/posts/cptjoi2019-%E5%94%B1%E8%B7%B3rap%E5%92%8C%E7%AF%AE%E7%90%83/"},{"categories":["算法竞赛"],"content":"代码： #pragma GCC optimize(2) #pragma GCC optimize(3) #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*(Poly a, Poly b) { if (a.size() == 0 || b.size() == 0) { return Poly(); } int sz = 1, tot = a.size() + b.size() - 1; while (sz \u003c tot) { sz *= 2; } a.a.resize(sz); b.a.resize(sz); dft(a.a); dft(b.a); for (int i = 0; i \u003c sz; i ++) { a.a[i] = a[i] * b[i]; } idft(a.a); a.resize(tot); return a; } friend Poly operator*(Z a, Poly b) { for (int i = 0; i \u003c int(b.size()); i ++) { b[i] *= a; } return b; } friend Poly operator*(Poly a, Z b) { for (int i = 0; i \u003c int(a.size()); i ++) { a[i] *= b; } return a; } Poly \u0026operator+=(Poly b) { return (*this) = (*this) + b; } Poly \u0026operator-=(Poly b) { return (*this) = (*this) - b; } Poly \u0026operator*=(Poly b) { return (*this) = (*this) * b; } Poly deriv() const { if (a.empty()) { return Poly(); } vec","date":"2022-09-22","objectID":"/posts/cptjoi2019-%E5%94%B1%E8%B7%B3rap%E5%92%8C%E7%AF%AE%E7%90%83/:1:0","tags":["二项式反演","NTT"],"title":"[TJOI2019] 唱、跳、rap和篮球","uri":"/posts/cptjoi2019-%E5%94%B1%E8%B7%B3rap%E5%92%8C%E7%AF%AE%E7%90%83/"},{"categories":["杂项"],"content":"求证： $$ \\frac{n}{\\sum\\limits_{i = 1} ^ {n} \\dfrac{1}{x_i}} \\le \\sqrt [n] {\\prod_{i = 1} ^ {n} x_i } \\le \\frac{\\sum\\limits_{i = 1} ^ {n} x_i}{n} \\le \\sqrt{\\frac{\\sum\\limits_{i = 1} ^ {n} x_i ^ 2}{n}} $$ 分析： 引理：琴生不等式 若 $f(x)$ 是区间 $[a,b]$ 的凹函数，则对任意 $x_1,x_2,\\cdots,x_n \\in [a,b]$ 有不等式 $$ f\\left(\\frac{\\sum\\limits_{i = 1} ^ {n} x_i}{n}\\right) \\le \\frac{\\sum\\limits_{i = 1} ^ {n} f(x_i)}{n} $$ 若 $f(x)$ 是区间 $[a,b]$ 的凸函数，则对任意 $x_1,x_2,\\cdots,x_n \\in [a,b]$ 有不等式 $$ \\frac{\\sum\\limits_{i = 1} ^ {n} f(x_i)}{n}\\le f\\left(\\frac{\\sum\\limits_{i = 1} ^ {n} x_i}{n}\\right) $$ 设 $f(x) = \\ln x$，易得 $\\ln x$ 为凸函数，所以有 $$ \\frac{\\sum\\limits_{i = 1} ^ {n} \\ln x_i}{n} \\le \\ln \\frac{\\sum\\limits_{i = 1} ^ {n} x_i}{n} \\\\ \\Leftrightarrow \\frac{\\ln \\prod\\limits_{i = 1} ^ {n} x_i}{n} \\le \\ln \\frac{\\sum\\limits_{i = 1} ^ {n} x_i}{n} \\\\ \\Leftrightarrow \\ln \\prod\\limits_{i = 1} ^ {n} x_i \\le \\ln \\left (\\frac{\\sum\\limits_{i = 1} ^ {n} x_i}{n} \\right) ^ n \\\\ \\Leftrightarrow \\prod\\limits_{i = 1} ^ {n} x_i \\le \\left (\\frac{\\sum\\limits_{i = 1} ^ {n} x_i}{n} \\right) ^ n \\\\ \\Leftrightarrow \\sqrt[n]{\\prod\\limits_{i = 1} ^ {n} x_i} \\le \\frac{\\sum\\limits_{i = 1} ^ {n} x_i}{n} $$ 第二个不等式得证。 若对于第二个不等式做变换 $x_i \\rightarrow \\dfrac{1}{x_i}$，有 $$ \\sqrt[n]{\\prod\\limits_{i = 1} ^ {n} \\frac{1}{x_i}} \\le \\frac{\\sum\\limits_{i = 1} ^ {n} \\dfrac{1}{x_i}}{n} \\\\ \\Leftrightarrow \\frac{1}{\\sqrt[n]{\\prod\\limits_{i = 1} ^ {n} x_i}} \\le \\frac{\\sum\\limits_{i = 1} ^ {n} \\dfrac{1}{x_i}}{n} \\\\ \\Leftrightarrow \\frac{n}{\\sum\\limits_{i = 1} ^ {n} \\dfrac{1}{x_i}} \\le \\sqrt[n]{\\prod\\limits_{i = 1} ^ {n} x_i} $$ 第一个不等式得证。 再设 $f(x) = x ^ 2$，易得 $f(x)$ 在 $x \\in [0, \\infty]$ 为凹函数，所以有 $$ \\left(\\frac{\\sum\\limits_{i = 1} ^ {n} x_i}{n}\\right) ^ 2 \\le \\frac{\\sum\\limits_{i = 1} ^ {n} x_i ^ 2}{n} \\\\ \\Leftrightarrow \\frac{\\sum\\limits_{i = 1} ^ {n} x_i}{n} \\le \\sqrt{\\frac{\\sum\\limits_{i = 1} ^ {n} x_i ^ 2}{n}} $$ 第三个不等式得证。 ","date":"2022-09-16","objectID":"/posts/miscn%E5%85%83%E5%9D%87%E5%80%BC%E4%B8%8D%E7%AD%89%E5%BC%8F%E7%9A%84%E8%AF%81%E6%98%8E/:0:0","tags":["数学"],"title":"n元均值不等式的证明","uri":"/posts/miscn%E5%85%83%E5%9D%87%E5%80%BC%E4%B8%8D%E7%AD%89%E5%BC%8F%E7%9A%84%E8%AF%81%E6%98%8E/"},{"categories":["算法竞赛"],"content":"CF 题目选讲 ","date":"2022-09-15","objectID":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:1:0","tags":["CF"],"title":"CF 题目选讲","uri":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["算法竞赛"],"content":"Gym 103736 D Tree Problem 题目链接 https://codeforces.com/gym/103736/problem/D 题意 给定一颗 $n$ 个点的树，有 $q$ 次询问，每次给定一个点 $x$，计算有多少长度至少为 $1$ 的简单路径经过点 $x$ 分析： 经过点 $u$ 的路径总数为以 $u$ 为根的各子树大小两两乘积和再加上剩下 $n - 1$ 个点，也就是 $$ n - 1 + \\sum\\limits_{i \\in u} \\sum\\limits_{j \\in u} S_i \\times S_j[i \u003c j] $$ 其中 $S_i$ 为点 $i$ 子树大小。 将右边式子化简一下 $$ n - 1 + \\frac{\\sum\\limits_{i \\in u} \\sum\\limits_{j \\in u} S_i \\times S_j - \\sum\\limits_{i \\in u} S_i ^ 2}{2} $$ 其中 $\\sum\\limits_{i \\in u} \\sum\\limits_{j \\in u} S_i \\times S_j =\\sum\\limits_{i \\in u} S_i \\sum\\limits_{j \\in u} S_j = \\left (\\sum\\limits_{j \\in u} S_j \\right ) ^ 2 = (n - 1) ^ 2$ 故答案为 $$ n - 1 + \\frac{(n - 1) ^ 2 - \\sum\\limits_{i \\in u} S_i ^ 2}{2} $$ 其中 $\\sum\\limits_{i \\in u} S_i ^ 2$ 可以用一遍 $\\text{dfs}$ 预处理。 ","date":"2022-09-15","objectID":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:2:0","tags":["CF"],"title":"CF 题目选讲","uri":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int n; cin \u003e\u003e n; vector\u003cvector\u003cint\u003e\u003e g(n + 1); for (int i = 1; i \u003c n; i ++) { int u, v; cin \u003e\u003e u \u003e\u003e v; g[u].push_back(v), g[v].push_back(u); } vector\u003cint\u003e Size(n + 1), dp(n + 1); function\u003cvoid(int, int)\u003e dfs = [\u0026](int u, int fa) { Size[u] = 1; int sum = 0; for (auto v : g[u]) { if (v == fa) { continue; } dfs(v, u); Size[u] += Size[v]; sum += Size[v] * Size[v]; } sum += (n - Size[u]) * (n - Size[u]); dp[u] = ((n - 1) * (n - 1) - sum) / 2; }; dfs(1, -1); int m; cin \u003e\u003e m; while (m --) { int u; cin \u003e\u003e u; cout \u003c\u003c dp[u] + n - 1 \u003c\u003c \"\\n\"; } } ","date":"2022-09-15","objectID":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:3:0","tags":["CF"],"title":"CF 题目选讲","uri":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["算法竞赛"],"content":"CF1517 C Fillomino 2 题目链接 https://codeforces.com/contest/1517/problem/C 题意 给定长度为 $n \\space (1 \\le n \\le 500)$ 的排列 $p$，要求构造一个三角形，满足以下条件： 三角形共 $n$ 行，第 $i$ 行有 $i$ 个数。第 $i$ 行最后一个数是 $p_i$ 接下来构造 $n$ 个连通块。对于第 $x \\space (1 \\le x \\le n)$ 个连通块，每个元素、连通块大小都必须等于 $x$ 三角形每个格子必须恰好填一个数。 分析： 每次能向左延伸就向左延伸，不能往左延伸就向下延伸。 ","date":"2022-09-15","objectID":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:4:0","tags":["CF"],"title":"CF 题目选讲","uri":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int n; cin \u003e\u003e n; vector\u003cint\u003e p(n + 1); vector\u003cvector\u003cint\u003e\u003e a(n + 1); for (int i = 1; i \u003c= n; i ++) { cin \u003e\u003e p[i]; a[i].resize(i + 1); a[i][i] = p[i]; } for (int i = 1; i \u003c= n; i ++) { int x = i, y = i; for (int j = 1; j \u003c= p[i] - 1; j ++) { if (y - 1 \u003e= 1 \u0026\u0026 !a[x][y - 1]) { a[x][y - 1] = p[i]; y --; } else if (x + 1 \u003c= n \u0026\u0026 !a[x + 1][y]) { a[x + 1][y] = p[i]; x ++; } } } for (int i = 1; i \u003c= n; i ++) { for (int j = 1; j \u003c= i; j ++) { cout \u003c\u003c a[i][j] \u003c\u003c \" \\n\"[j == i]; } } } ","date":"2022-09-15","objectID":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:5:0","tags":["CF"],"title":"CF 题目选讲","uri":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["算法竞赛"],"content":"CF1649 D Integral Array 题目链接 https://codeforces.com/contest/1649/problem/D 题意 给定一个数组 $a$，该数组完整的定义 ：对数组 $a$ 中任意两数 $x, y$ $(y \\le x)$ 满足 $\\lfloor \\dfrac{x}{y} \\rfloor$ 也在数组中 数组中每个数 $a_i \\le c$，判断数组 $a$ 是否完整。 $(1 \\le n, c \\le 10 ^ 6)$ 分析： 首先朴素想法是对于每个数可以用整除分块判断是否在数组中，但时间复杂度 $O(n \\sqrt n)$，会超时。 所以考虑 $O(n \\log n)$ 的做法，可以用枚举倍数法。 枚举 $1 \\le i \\le c$，那么 $i$ 的倍数为 $j$，对于 $j \\sim j + i - 1$ 这一段数来说除 $i$ 下取整得到的结果都是 $\\dfrac{j}{i}$，所以枚举 $i$ 就相当于枚举 $y$，$j \\sim j + i - 1$ 中的所有数都是 $x$，可以用前缀和快速判断区间里的数是否存在，如果区间存在一个数并且 $i$ 也在数组出现过，并且 $\\dfrac{j}{i}$ 在数组中不存在，那么数组 $a$ 就是不完整的。 ","date":"2022-09-15","objectID":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:6:0","tags":["CF"],"title":"CF 题目选讲","uri":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; void solve() { int n, c; cin \u003e\u003e n \u003e\u003e c; vector\u003cint\u003e a(n + 1), sum(c + 1), mp(c + 1); for (int i = 1; i \u003c= n; i ++) { cin \u003e\u003e a[i]; sum[a[i]] ++; mp[a[i]] = 1; } for (int i = 1; i \u003c= c; i ++) { sum[i] += sum[i - 1]; } string ans = \"Yes\"; for (int i = 1; i \u003c= c; i ++) { for (int j = i; j \u003c= c; j += i) { int l = j, r = min(c, j + i - 1); if (sum[r] - sum[l - 1] \u0026\u0026 mp[i] \u0026\u0026 !mp[j / i]) { ans = \"No\"; } } } cout \u003c\u003c ans \u003c\u003c endl; } signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int T; cin \u003e\u003e T; while (T --) { solve(); } } ","date":"2022-09-15","objectID":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:7:0","tags":["CF"],"title":"CF 题目选讲","uri":"/posts/cpcf-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["算法竞赛"],"content":"原题链接 题意 给定四个整数 $n,x,p,m$，求 $$ \\sum_{i=0}^{n}f(i)\\times x^i\\times \\binom{n}{i} $$ 对 $p$ 取模，其中 $f(x) = a_0 + a_1x + a_2x ^ 2 + \\cdots + a_mx ^ m$ $1 \\le n,x,p \\le 10 ^ 9, 0 \\le a_i \\le 10 ^ 9, 0 \\le m \\le \\min(n, 10 ^ 3)$ 分析： 首先把 $f(i)$ 带入原式 $$ \\sum_{i=0}^{n} x^i\\times \\binom{n}{i} \\sum_{j = 0} ^ {m} a_j \\times i ^ {j} $$ 看到 $i ^ j$，故想到展开 $i ^ j = \\sum\\limits_{k = 0} ^ {j} {j \\brace k} i ^ {\\underline k}$ $$ \\sum_{i=0}^{n} x^i\\times \\binom{n}{i} \\sum_{j = 0} ^ {m} a_j \\sum_{k = 0} ^ {j} {j \\brace k} \\times \\frac{i!}{(i - k)!} $$ 把前面的 $\\dbinom{n}{i}$ 放到最后面化简 $$ \\sum_{i=0}^{n} x^i \\sum_{j = 0} ^ {m} a_j \\sum_{k = 0} ^ {j} {j \\brace k} \\times\\dfrac{n!}{i! \\times (n - i)!} \\times \\frac{i!}{(i - k)!} \\\\ = \\sum_{i=0}^{n} x^i \\sum_{j = 0} ^ {m} a_j \\sum_{k = 0} ^ {j} {j \\brace k} \\times\\dfrac{n!}{(n - i)! \\times (i - k)!} $$ 考虑凑组合数 $\\dbinom{n - k}{n - i} = \\dfrac{(n - k)!}{(n - i)! \\times (i - k)!}$，所以分式上下同乘 $(n - k)!$，即 $$ \\sum_{i=0}^{n} x^i \\sum_{j = 0} ^ {m} a_j \\sum_{k = 0} ^ {j} {j \\brace k} \\times \\binom{n - k}{n - i} \\times n ^ {\\underline k} $$ 交换求和次序，将 $i$ 放到最后求和 $$ \\sum_{j = 0} ^ {m} a_{j} \\sum_{k = 0} ^ {j} {j \\brace k} \\times n ^ {\\underline k} \\sum_{i=0}^{n} x^i \\times \\binom{n - k}{n - i} \\\\ = \\sum_{j = 0} ^ {m} a_j \\sum_{k = 0} ^ {j} {j \\brace k} \\times n ^ {\\underline k} \\sum_{i=0}^{n} x^i \\times \\binom{n - k}{i - k} \\\\ = \\sum_{j = 0} ^ {m} a_j \\sum_{k = 0} ^ {j} {j \\brace k} \\times n ^ {\\underline k} \\sum_{i=k}^{n} x^i \\times \\binom{n - k}{i - k} $$ 做变换 $(i - k) \\rightarrow i$ $$ \\sum_{j = 0} ^ {m} a_j \\sum_{k = 0} ^ {j} {j \\brace k} \\times n ^ {\\underline k} \\sum_{i=0}^{n - k} x^{i + k} \\times \\binom{n - k}{i} \\\\ = \\sum_{j = 0} ^ {m} a_j \\sum_{k = 0} ^ {j} {j \\brace k} \\times n ^ {\\underline k} \\times x ^ {k} \\sum_{i=0}^{n - k} x^{i} \\times \\binom{n - k}{i} $$ 考虑二项式展开 $(a + b) ^ n = \\sum\\limits_{i = 0} ^ {n} \\dbinom{n}{i} a ^ {i} b ^ {n - i}$，所以 $\\sum\\limits_{i=0}^{n - k} x^{i} \\times \\dbinom{n - k}{i} = (1 + x) ^ {n - k}$，故式子变为 $$ \\sum_{j = 0} ^ {m} a_j \\sum_{k = 0} ^ {j} {j \\brace k} \\times n ^ {\\underline k} \\times x ^ {k} \\times (1 + x) ^ {n - k} $$ 这样式子就变为 $O(m ^ 2)$ 了，第二类斯特林数可以预处理，下降幂可以线性维护。 ","date":"2022-09-01","objectID":"/posts/cpnoi2020%E7%BB%9F%E4%B8%80%E7%9C%81%E9%80%89-a-%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98/:0:0","tags":["推式子"],"title":"[NOI2020统一省选 A] 组合数问题","uri":"/posts/cpnoi2020%E7%BB%9F%E4%B8%80%E7%9C%81%E9%80%89-a-%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int N = 1e3; int mod; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cvector\u003cZ\u003e\u003e stirling(N + 1, vector\u003cZ\u003e(N + 1)); void init() { stirling[0][0] = 1; for (int i = 1; i \u003c= N; i ++) { for (int j = 1; j \u003c= i; j ++) { stirling[i][j] = stirling[i - 1][j - 1] + j * stirling[i - 1][j]; } } } signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int n, x, m; cin \u003e\u003e n \u003e\u003e x \u003e\u003e mod \u003e\u003e m; init(); vector\u003cZ\u003e a(m + 1); for (int i = 0; i \u003c= m; i ++) { cin \u003e\u003e a[i]; } Z res; for (int j = 0; j \u003c= m; j ++) { Z sum = 1; for (int k = 0, cnt = n; k \u003c= j; k ++, cnt --) { res += a[j] * stirling[j][k] * power(Z(x), k) * sum * power(Z(1 + x), n - k); sum *= cnt; } } cout \u003c\u003c res \u003c\u003c \"\\n\"; } ","date":"2022-09-01","objectID":"/posts/cpnoi2020%E7%BB%9F%E4%B8%80%E7%9C%81%E9%80%89-a-%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98/:1:0","tags":["推式子"],"title":"[NOI2020统一省选 A] 组合数问题","uri":"/posts/cpnoi2020%E7%BB%9F%E4%B8%80%E7%9C%81%E9%80%89-a-%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98/"},{"categories":["算法竞赛"],"content":"题意 $T$ 组输入，给定一个 $n$ 次多项式 $f(x) = a_0 + a_1x + \\cdots + a_nx ^ n$，定义 $S = \\sum\\limits_{i = 0} ^ {\\infty} \\dfrac{f(i)}{i!}$，可以证明 $S$ 一定是 $e$ 的倍数，即 $S = p \\times e$，求 $p$ 对 $998,244,353$ 取模。 $1 \\le T \\le 100, 0 \\le n \\le 10 ^ 5,0 \\le a_i \u003c 998,244,353$ 分析： 首先将 $f(x)$ 代入 $S$ 得 $$ \\sum_{i = 0} ^ {\\infty}\\frac{1}{i!} \\sum_{j = 0} ^ {n}a_j \\times i ^ j $$ 看到自然数幂想到展开 $i ^ k = \\sum\\limits_{j = 0} ^ {k} {k \\brace j} i ^{\\underline j}$，代入得 $$ \\sum_{i = 0} ^ {\\infty} \\frac{1}{i!} \\sum_{j = 0} ^ {n}a_j \\sum_{k = 0} ^ {j} {j \\brace k} i ^ {\\underline k} $$ 交换求和次序，先对 $i$ 求和 $$ \\sum_{j = 0} ^ {n}a_j \\sum_{k = 0} ^ {j} {j \\brace k} \\sum_{i = 0} ^ {\\infty} \\frac{i ^ {\\underline k}}{i!} $$ 把下降幂消掉 $$ \\sum_{j = 0} ^ {n}a_j \\sum_{k = 0} ^ {j} {j \\brace k} \\sum_{i = k} ^ {\\infty} \\frac{1}{(i-k)!} $$ 做变换 $(i - k) \\rightarrow i$ $$ \\sum_{j = 0} ^ {n}a_j \\sum_{k = 0} ^ {j} {j \\brace k} \\sum_{i = 0} ^ {\\infty} \\frac{1}{i!} $$ 由于 $e = \\sum\\limits_{i = 0} ^ {\\infty} \\dfrac{1}{i!}$，所以原式为 $e$ 的倍数得证，那么式子变为 $$ \\sum_{j = 0} ^ {n}a_j \\sum_{k = 0} ^ {j} {j \\brace k} \\times e $$ 事实上 $\\text{Bell} _ {n} = \\sum \\limits_{i = 0} ^ {n} {n \\brace i}$，其中 $\\text{Bell}_{n}$ 为第 $n$ 项贝尔数，代表 $n$ 个元素的集合划分为任意非空子集的方案数，所以答案就为 $$ \\sum_{i = 0} ^ {n} a_i \\times \\text{Bell}_{i} $$ 考虑快速求解贝尔数，设贝尔数的 $\\textbf{EGF}$ 为 $B(x) = \\sum\\limits_ {i = 0} ^ {\\infty} \\dfrac{F(x) ^ i}{i!}$，其中 $F(x) = \\sum\\limits_{i = 1} ^ {\\infty}\\dfrac{x ^ i}{i!} = e ^ x - 1$，那么 $B(x) = \\sum\\limits_{i = 0} ^ {\\infty} \\dfrac{(e ^ x - 1) ^ i}{i!} = e ^ {e ^ {x} - 1}$，直接多项式 $\\text{exp}$ 就好了。 ","date":"2022-08-30","objectID":"/posts/cp2021icpc%E6%B5%8E%E5%8D%97-l-strange-series/:0:0","tags":["Bell 数","多项式"],"title":"[2021ICPC济南 L] Strange Series","uri":"/posts/cp2021icpc%E6%B5%8E%E5%8D%97-l-strange-series/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*(Poly a, Poly b) { if (a.size() == 0 || b.size() == 0) { return Poly(); } int sz = 1, tot = a.size() + b.size() - 1; while (sz \u003c tot) { sz *= 2; } a.a.resize(sz); b.a.resize(sz); dft(a.a); dft(b.a); for (int i = 0; i \u003c sz; i ++) { a.a[i] = a[i] * b[i]; } idft(a.a); a.resize(tot); return a; } friend Poly operator*(Z a, Poly b) { for (int i = 0; i \u003c int(b.size()); i ++) { b[i] *= a; } return b; } friend Poly operator*(Poly a, Z b) { for (int i = 0; i \u003c int(a.size()); i ++) { a[i] *= b; } return a; } Poly \u0026operator+=(Poly b) { return (*this) = (*this) + b; } Poly \u0026operator-=(Poly b) { return (*this) = (*this) - b; } Poly \u0026operator*=(Poly b) { return (*this) = (*this) * b; } Poly deriv() const { if (a.empty()) { return Poly(); } vector\u003cZ\u003e res(size() - 1); for (int i = 0; i \u003c size","date":"2022-08-30","objectID":"/posts/cp2021icpc%E6%B5%8E%E5%8D%97-l-strange-series/:1:0","tags":["Bell 数","多项式"],"title":"[2021ICPC济南 L] Strange Series","uri":"/posts/cp2021icpc%E6%B5%8E%E5%8D%97-l-strange-series/"},{"categories":["算法竞赛"],"content":"原题链接 题意 给定一个大小为 $n$ 的多重集 $A = {a_1, a_2, \\cdots,a_n}$ 和两个非负整数 $k, t$，求 $$ \\sum_{S \\subseteq A,S \\ne \\varnothing } t ^ {|S|} \\left ( \\sum_{i \\in S} i \\right ) ^ k $$ 保证 $k=0$ 时没有子集的和是 $0$，对 $998 , 244 ,353$ 取模。 $(1 \\le n \\le 10 ^ 2, 0 \\le k \\le 10 ^4, 0 \\le x,a_i \u003c 988244352)$ 分析： 若直接枚举子集复杂度为 $O(n \\times 2 ^ n)$，无法接受，考虑化简，右边和式的 $k$ 次方可以做一下展开，那么 $$ \\left ( \\sum\\limits_{i \\in S} i \\right ) ^ k = \\underbrace{(i_1 + i_2+ \\cdots+i_{|S|}) \\times \\cdots \\times (i_1 + i_2+ \\cdots + i_{|S|})}_{k项} $$ 也就是在 $i_1,i_2,\\cdots,i_{|S|}$ 中任选 $k$ 个可重复的数的所有乘积和，考虑 $A$ 中每个数 $a_i$ 的贡献，对于每个 $a_i$ 都有选与不选两种状态，组成了集合 $S$，那么假设不考虑后面的 $k$ 次方和式，我们可以写出生成函数 $(1 + tx) ^ n$，但是现在多乘了 $k$ 次方和式，我们再只考虑这个和式，也就是说每个 $a_i$ 都可以被选 $0 \\sim k$ 次，而且随意排列，所以 $\\textbf{EGF}$ 为 $$ 1 + \\frac{a_i}{1!}x + \\frac{a_i ^ 2}{2!}x ^ 2 + \\cdots + \\frac{a_i ^ k}{k!}x ^ k $$ 那么对于某个子集的贡献就为 $$ [x ^ k] \\prod _ {i = 1} ^ n (1 + \\frac{a_i}{1!}x + \\frac{a_i ^ 2}{2!}x ^ 2 + \\cdots + \\frac{a_i ^ k}{k!}x ^ k) $$ 所以只需要将这两个生成函数结合一下，也就是把这个 $\\textbf{EGF}$ 带入到每个 $1 + tx$ 中 $$ \\prod_{i = 1} ^ {n} \\left (1 + t \\times (1 + \\frac{a_i}{1!}x + \\frac{a_i ^ 2}{2!}x ^ 2 + \\cdots + \\frac{a_i ^ k}{k!}x ^ k) \\right) \\\\ = \\prod _{i = 1} ^ {n}\\left (1 + t + \\frac{t \\times a_i}{1!}x + \\frac{t \\times a_i ^ 2}{2!}x ^ 2 + \\cdots + \\frac{t \\times a_i ^ k}{k!}x ^ k\\right) $$ 由于题目保证了 $k=0$ 时没有子集的和是 $0$，所以如果 $k = 0$ 答案需要减去 $1$，也就是空集的情况。 那么最后的答案就为 $[x ^ k] \\prod \\limits_{i = 1} ^ {n} (1 + t + \\dfrac{t \\times a_i}{1!}x + \\dfrac{t \\times a_i ^ 2}{2!}x ^ 2 + \\cdots + \\dfrac{t \\times a_i ^ k}{k!}x ^ k) - [k=0]$ 注意每次 $\\texttt{NTT}$ 卷积需要将大小设为 $k$，不然会超时。 ","date":"2022-08-22","objectID":"/posts/cp2022ccpc%E5%8D%8E%E4%B8%BA%E4%BA%911005-%E5%B8%A6%E6%9D%83%E5%AD%90%E9%9B%86%E5%92%8C/:0:0","tags":["NTT"],"title":"[2022CCPC华为云1005] 带权子集和","uri":"/posts/cp2022ccpc%E5%8D%8E%E4%B8%BA%E4%BA%911005-%E5%B8%A6%E6%9D%83%E5%AD%90%E9%9B%86%E5%92%8C/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*(Poly a, Poly b) { if (a.size() == 0 || b.size() == 0) { return Poly(); } int sz = 1, tot = a.size() + b.size() - 1; while (sz \u003c tot) { sz *= 2; } a.a.resize(sz); b.a.resize(sz); dft(a.a); dft(b.a); for (int i = 0; i \u003c sz; i ++) { a.a[i] = a[i] * b[i]; } idft(a.a); a.resize(tot); return a; } friend Poly operator*(Z a, Poly b) { for (int i = 0; i \u003c int(b.size()); i ++) { b[i] *= a; } return b; } friend Poly operator*(Poly a, Z b) { for (int i = 0; i \u003c int(a.size()); i ++) { a[i] *= b; } return a; } Poly \u0026operator+=(Poly b) { return (*this) = (*this) + b; } Poly \u0026operator-=(Poly b) { return (*this) = (*this) - b; } Poly \u0026operator*=(Poly b) { return (*this) = (*this) * b; } Poly deriv() const { if (a.empty()) { return Poly(); } vector\u003cZ\u003e res(size() - 1); for (int i = 0; i \u003c size","date":"2022-08-22","objectID":"/posts/cp2022ccpc%E5%8D%8E%E4%B8%BA%E4%BA%911005-%E5%B8%A6%E6%9D%83%E5%AD%90%E9%9B%86%E5%92%8C/:1:0","tags":["NTT"],"title":"[2022CCPC华为云1005] 带权子集和","uri":"/posts/cp2022ccpc%E5%8D%8E%E4%B8%BA%E4%BA%911005-%E5%B8%A6%E6%9D%83%E5%AD%90%E9%9B%86%E5%92%8C/"},{"categories":["算法竞赛"],"content":"原题链接 题意 给定三个正整数 $n,m,k$，有 $n$ 个盒子，每个盒子有 $m$ 个标号分别为 $1 \\sim m$ 的球，现从每个盒子选出恰好一个球，将奇数编号的球的个数记为 $F$，求所有方案的 $F ^ k$ 之和对 $998 , 244 , 353$ 取模。 $(1 \\le n, m \\le 998244352, 1 \\le k \\le 2 \\times 10 ^ 3)$ 分析： 首先每个盒子有 $\\lceil \\dfrac{m}{2} \\rceil$ 个奇数球和 $\\lfloor \\dfrac{m}{2} \\rfloor$ 个偶数球，那么所有方案数为 $m ^ n = (\\lceil \\dfrac{m}{2} \\rceil + \\lfloor \\dfrac{m}{2} \\rfloor) ^ n$，根据二项式定理，所以每个 $F$ 的贡献就为 $F ^ k \\times \\dbinom{n}{F} \\times \\lceil \\dfrac{m}{2} \\rceil ^ F \\times \\lfloor \\dfrac{m}{2} \\rfloor ^ {n - F}$ 所以总答案为 $$ \\sum_{i = 0} ^ {n} i ^ k \\times \\dbinom{n}{i} \\times \\lceil \\dfrac{m}{2} \\rceil ^ i \\times \\lfloor \\dfrac{m}{2} \\rfloor ^ {n - i} $$ 由于 $n \\le 998244352$，没法直接求，但是看到 $i ^ k$ 想到自然数幂展开 $$ i ^ k = \\sum_{j = 0} ^ {k} {k \\brace j} \\times j! \\times \\binom{i}{j} $$ 带入得 $$ \\sum_{i = 0} ^ {n} \\dbinom{n}{i} \\times \\lceil \\dfrac{m}{2} \\rceil ^ i \\times \\lfloor \\dfrac{m}{2} \\rfloor ^ {n - i} \\sum_{j = 0} ^ {k} {k \\brace j} \\times j! \\times \\binom{i}{j} $$ 将 $\\dbinom{n}{i}$ 放到后面的求和号化简：$\\dbinom{n}{i} \\times j! \\times \\dbinom{i}{j} = \\dfrac{n!}{i! \\times (n - i)!} \\times j! \\times \\dfrac{i!}{j! \\times (i - j)!} = \\dfrac{n!}{(n - i)! \\times (i - j)!}$，那么式子变为 $$ \\sum_{i = 0} ^ {n} \\lceil \\dfrac{m}{2} \\rceil ^ i \\times \\lfloor \\dfrac{m}{2} \\rfloor ^ {n - i} \\sum_{j = 0} ^ {k} {k \\brace j} \\times \\dfrac{n!}{(n - i)! \\times (i - j)!} $$ 交换求和次序，注意 $i$ 要从 $j$ 开始，因为要保证 $i - j \\ge 0$ $$ \\sum_{j = 0} ^ {k} {k \\brace j} \\sum_{i = j} ^ {n} \\dfrac{n!}{(n - i)! \\times (i - j)!} \\times \\lceil \\dfrac{m}{2} \\rceil ^ i \\times \\lfloor \\dfrac{m}{2} \\rfloor ^ {n - i} $$ 对第二个和式做变换 $i - j \\rightarrow i$ $$ \\sum_{j = 0} ^ {k} {k \\brace j} \\sum_{i = 0} ^ {n - j} \\dfrac{n!}{(n - i - j)! \\times i!} \\times \\lceil \\dfrac{m}{2} \\rceil ^ {i + j} \\times \\lfloor \\dfrac{m}{2} \\rfloor ^ {n - i - j} $$ 到这里发现第二个和式比较像二项式展开了，即 $(a + b) ^ n = \\sum\\limits_{i = 0} ^ {n} \\dbinom{n}{i} a ^ {i} b ^ {n - i}$，那么考虑往这个方向凑式子，首先要解决的是组合数，发现第二个和式上界为 $n - j$，那么我们就要凑一个 $\\dbinom{n - j}{i} = \\dfrac{(n - j)!}{(n - i - j) \\times i!}$ 的组合数，发现恰好多了 $n \\times(n - 1) \\times \\cdots \\times (n - j + 1) = n ^ {\\underline j}$，那么后面也多了 $\\lceil \\dfrac{m}{2} \\rceil ^ {j}$，提出来之后为 $$ \\sum_{j = 0} ^ {k} {k \\brace j} \\times n ^ {\\underline j} \\times \\lceil \\dfrac{m}{2} \\rceil ^ {j} \\sum_{i = 0} ^ {n - j} \\binom{n - j}{i} \\times \\lceil \\dfrac{m}{2} \\rceil ^ {i} \\times \\lfloor \\dfrac{m}{2} \\rfloor ^ {n - i - j} $$ 由二项式定理得 $\\sum\\limits_{i = 0} ^ {n - j} \\dbinom{n - j}{i} \\times \\lceil \\dfrac{m}{2} \\rceil ^ {i} \\times \\lfloor \\dfrac{m}{2} \\rfloor ^ {n - i - j} = (\\lceil \\dfrac{m}{2} \\rceil + \\lfloor \\dfrac{m}{2} \\rfloor) ^ {n - j} = m ^ {n - j}$，那么答案为 $$ \\sum_{j = 0} ^ {k} {k \\brace j} \\times n ^ {\\underline j} \\times \\lceil \\dfrac{m}{2} \\rceil ^ {j} \\times m ^ {n - j} $$ 所以只需要预处理 $2 \\times 10 ^ 3$ 以内的第二类斯特林数，再 $O(k)$ 维护下降幂即可。 ","date":"2022-08-05","objectID":"/posts/cpeducational-codeforces-round-133-f-bags-with-balls/:0:0","tags":["组合计数","推式子"],"title":"[Educational Codeforces Round 133 F] Bags with Balls","uri":"/posts/cpeducational-codeforces-round-133-f-bags-with-balls/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353, N = 2e3; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cvector\u003cZ\u003e\u003e stirling(N + 1, vector\u003cZ\u003e(N + 1)); void init() { stirling[0][0] = 1; for (int i = 1; i \u003c= N; i ++) { for (int j = 1; j \u003c= i; j ++) { stirling[i][j] = stirling[i - 1][j - 1] + j * stirling[i - 1][j]; } } } void solve() { int n, m, k; cin \u003e\u003e n \u003e\u003e m \u003e\u003e k; Z res, sum = 1; for (int i = 0, cnt = n; i \u003c= k; i ++, cnt --) { res += stirling[k][i] * power(Z((m + 1) / 2), i) * power(Z(m), n - i) * sum; sum *= cnt; } cout \u003c\u003c res \u003c\u003c \"\\n\"; } signed main() { init(); cin.tie(0) -\u003e sync_with_stdio(0); int T; cin \u003e\u003e T; while (T --) { solve(); } } ","date":"2022-08-05","objectID":"/posts/cpeducational-codeforces-round-133-f-bags-with-balls/:1:0","tags":["组合计数","推式子"],"title":"[Educational Codeforces Round 133 F] Bags with Balls","uri":"/posts/cpeducational-codeforces-round-133-f-bags-with-balls/"},{"categories":["算法竞赛"],"content":"线段树 区间异或 https://www.luogu.com.cn/problem/CF242E 区间取模 https://www.luogu.com.cn/problem/CF438D 区间开根 https://www.luogu.com.cn/problem/SP2713 区间约数个数 https://www.luogu.com.cn/problem/CF920F 区间反转 $0$ 变 $1$ $1$ 变 $0$ https://www.luogu.com.cn/problem/P2574 区间 $\\text{lowbit}$ https://codeforces.com/gym/103145/problem/D 区间乘 区间欧拉函数和 $\\text{ICPC}$ 网络赛第二场 $\\text{L}$ 题 区间多重集加 区间三角形 https://ac.nowcoder.com/acm/problem/228151 区间圆盘 动态开点 https://codeforces.com/gym/101630 A题 区间加等差数列 https://www.luogu.com.cn/problem/P1438 区间加、区间乘 https://www.luogu.com.cn/problem/P2023 区间替换 动态开点 https://www.luogu.com.cn/problem/CF911G 区间合法括号序列 https://atcoder.jp/contests/abc223/tasks/abc223_f 区间乘 区间欧拉函数 https://www.luogu.com.cn/problem/CF1114F 区间加斐波那契数列 区间和 https://www.luogu.com.cn/problem/CF446C 区间加 区间 $\\sin$ 和 https://www.luogu.com.cn/problem/P6327 区间赋值 区间加 区间最大值 https://www.luogu.com.cn/problem/P1253 区间颜色修改 区间加 单点查询 https://codeforces.com/problemset/problem/1638/E 区间下取整 区间赋值 区间和 https://atcoder.jp/contests/abc256/tasks/abc256_h 区间最大值 卷积 https://codeforces.com/gym/102822/problem/J 区间加 区间最大值 离散化 差分 A https://codeforces.com/gym/101987/ 区间 $01$ 赋值 区间翻转 区间询问值为 $0$ 的最小左端点 https://codeforces.com/contest/817/problem/F 区间美丽三元组的个数 https://codeforces.com/contest/1701/problem/F 区间翻转 区间找 0 1 https://codeforces.com/contest/1705/problem/E 区间奇数除 2 偶数乘 2 https://ac.nowcoder.com/acm/contest/37344/K ","date":"2022-08-04","objectID":"/posts/cp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E5%8D%95/:1:0","tags":["题单","数据结构"],"title":"数据结构题单","uri":"/posts/cp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E5%8D%95/"},{"categories":["算法竞赛"],"content":"树状数组 区间不同颜色个数 https://www.acwing.com/problem/content/2494/ 区间乘积的欧拉函数 https://www.luogu.com.cn/problem/CF594D $1 \\sim n$ 有多少可以表示为大于等于 $k$ 的质数乘积的数 转为二维偏序 https://ac.nowcoder.com/acm/problem/228989 区间不大于某个数的个数 http://oj.daimayuan.top/course/10/problem/464 二维数点 http://oj.daimayuan.top/course/15/problem/686 ","date":"2022-08-04","objectID":"/posts/cp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E5%8D%95/:2:0","tags":["题单","数据结构"],"title":"数据结构题单","uri":"/posts/cp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E5%8D%95/"},{"categories":["算法竞赛"],"content":"树链剖分 配合权值线段树 https://www.acwing.com/problem/content/description/355/ 配合动态开点的权值线段树 https://www.acwing.com/problem/content/description/1282/ 配合差分 https://www.acwing.com/problem/content/356/ 树上路径边权变为相反数 https://www.luogu.com.cn/problem/P1505 换根树链剖分模板题 https://www.acwing.com/problem/content/2526/ 换根树链剖分 子树最小值 https://www.luogu.com.cn/problem/P3979 推公式 离线差分 https://www.luogu.com.cn/problem/P4211 换根 修改带 $\\text{lca}$ https://www.luogu.com.cn/problem/CF916E 子树迭代加相反数 https://www.luogu.com.cn/problem/CF383C 非常妙的 LCT 转树剖 https://www.luogu.com.cn/problem/P3950 边权修改 所有子路径异或和 https://www.luogu.com.cn/problem/P3401 离线生成树 树链剖分 https://www.luogu.com.cn/problem/P2542 树上所有路径的交点 F https://codeforces.com/gym/102040 树上路径相邻颜色不同 G https://codeforces.com/gym/101617 子树内某个数出现次数 https://atcoder.jp/contests/abc202/tasks/abc202_e ","date":"2022-08-04","objectID":"/posts/cp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E5%8D%95/:3:0","tags":["题单","数据结构"],"title":"数据结构题单","uri":"/posts/cp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E5%8D%95/"},{"categories":["算法竞赛"],"content":"主席树 第 $K$ 小数 https://www.acwing.com/problem/content/257/ 区间某个数出现次数 https://acm.sdut.edu.cn/onlinejudge3/problems/4854 区间最小不能被表示的数 https://ac.nowcoder.com/acm/contest/12548/M 区间最小不能被表示的数 带修 树状数组套主席树 https://nanti.jisuanke.com/t/42547 区间 $\\text{mex}$ https://www.luogu.com.cn/problem/P4137 ","date":"2022-08-04","objectID":"/posts/cp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E5%8D%95/:4:0","tags":["题单","数据结构"],"title":"数据结构题单","uri":"/posts/cp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E5%8D%95/"},{"categories":["算法竞赛"],"content":"树上问题 子树数颜色 树上启发式合并 https://codeforces.com/contest/600/problem/E 子树相邻元素个数 树上启发式合并 https://codeforces.com/gym/102431/problem/K 树的重心性质 https://nanti.jisuanke.com/t/42552 所有异或路径不为 0 启发式合并 https://codeforces.com/contest/1709/problem/E ","date":"2022-08-04","objectID":"/posts/cp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E5%8D%95/:5:0","tags":["题单","数据结构"],"title":"数据结构题单","uri":"/posts/cp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E5%8D%95/"},{"categories":["算法竞赛"],"content":"原题链接 题意 给定一个长度为 $n$ 的排列 $p$ ${1, 2, \\cdots, n}$ 和一个非负整数 $k$，计算排列 $p$ 中的子集 $T$，满足集合大小为 $k$ 且 $T$ 与 $P(T)$ 没有交集，$P(T) = {y \\mid y= p_x,x \\in T}$ 分析： 考虑将排列 $p$ 看成图，$i$ 向 $p_i$ 连边，会形成若干个环，那么原问题等价于从图中选出 $k$ 个点且每个环中不能有相邻被选择的点的方案数。考虑构造每个环 $i$ 的生成函数 $$ 1 + f_{S_i,1}x + f_{S_i,2} x ^ 2 + \\cdots + f_{S_i,\\lfloor \\frac{S_i}{2} \\rfloor} x ^ {\\lfloor \\frac{S_i}{2} \\rfloor} $$ 其中 $S_i$ 表示环 $i$ 的大小，$f_{S_i,j}$ 表示大小为 $S_i$ 的环中选出 $j$ 个互不相邻的点的方案数，根据鸽巢原理，若 $j \u003e \\lfloor \\dfrac{S_i}{2} \\rfloor$，一定有两个点相邻，所以生成函数只需要取到 $\\lfloor \\dfrac{S_i}{2} \\rfloor$ 项即可。那么答案就为 $$ [x ^ k]\\prod_{i = 1} ^ {\\text{cnt}} \\sum_{j = 0} ^ {\\lfloor \\frac{S_i}{2} \\rfloor} f_{S_i,j}x^j $$ $\\text{cnt}$ 为图中环的数量。那么现在考虑求出 $f(n, m)$，即大小为 $n$ 的环选出 $m$ 个互不相邻的点的方案数。 我们先考虑不是环的情况，也就是链式不相邻问题，那么可以先放 $m$ 个被选择的球，考虑把中间 $m - 1$ 个空放上一个不被选择的球，那么剩下 $n - 2\\times m - 1$ 个球就可以随便放，问题就相当于有 $m + 1$ 个盒子，每个盒子可空的方案数，那么就是经典隔板法，方案数为 $g(n, m) =\\dbinom{n - 2\\times m - 1 + m + 1 - 1}{m + 1 - 1}=\\dbinom{n - m + 1}{m}$ 现在考虑是环的情况，假设对于环上一个点，有两种情况，若这个点被选择，则这个点的相邻点不能被选择，那么其他 $n - 3$ 个点就是 $g(n - 3, m - 1)$，若这个点不被选择，那么剩下 $n - 1$ 个点就是 $g(n - 1, m)$，所以 $f(n, m) = g(n - 3, m - 1) + g(n - 1, m) = \\dbinom{n - m - 1}{m - 1} + \\dbinom{n - m}{m}$ ","date":"2022-08-03","objectID":"/posts/cp2022-%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A15-count-set/:0:0","tags":["生成函数","分治 NTT"],"title":"[2022 杭电多校5] Count Set","uri":"/posts/cp2022-%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A15-count-set/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*(Poly a, Poly b) { if (a.size() == 0 || b.size() == 0) { return Poly(); } int sz = 1, tot = min(5000000, a.size() + b.size() - 1); while (sz \u003c tot) { sz *= 2; } a.a.resize(sz); b.a.resize(sz); dft(a.a); dft(b.a); for (int i = 0; i \u003c sz; i ++) { a.a[i] = a[i] * b[i]; } idft(a.a); a.resize(tot); return a; } friend Poly operator*(Z a, Poly b) { for (int i = 0; i \u003c int(b.size()); i ++) { b[i] *= a; } return b; } friend Poly operator*(Poly a, Z b) { for (int i = 0; i \u003c int(a.size()); i ++) { a[i] *= b; } return a; } Poly \u0026operator+=(Poly b) { return (*this) = (*this) + b; } Poly \u0026operator-=(Poly b) { return (*this) = (*this) - b; } Poly \u0026operator*=(Poly b) { return (*this) = (*this) * b; } Poly deriv() const { if (a.empty()) { return Poly(); } vector\u003cZ\u003e res(size() - 1); for (int i","date":"2022-08-03","objectID":"/posts/cp2022-%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A15-count-set/:1:0","tags":["生成函数","分治 NTT"],"title":"[2022 杭电多校5] Count Set","uri":"/posts/cp2022-%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A15-count-set/"},{"categories":["算法竞赛"],"content":"原题链接 题意 给定一个正整数 $w$ 及 $w$ 个数 $c_0, c_1, \\cdots,c_{w - 1}$ $q$ 组询问，每次询问给定一个正整数 $n$，计算有多少个长度为 $n$ 的字符串满足： 每个字符只能取数字 $0 \\sim w - 1$ 数字 $i$ 至少出现 $c_i$ 次 对 $998 , 244 , 353$ 取模。 $2 \\le w \\le 10, 1 \\le c_i \\le 5 \\times 10 ^ 4, \\sum\\limits_{i = 0} ^ {w - 1}c_i \\le 5 \\times 10 ^ 4$ $1 \\le q \\le 300, 1 \\le n \\le 10 ^ 7$ 分析： 首先我们可以写出每个数字 $i$ 的 $\\textbf{EGF}$ $$ \\sum_{j = c_i} ^ {\\infty} \\frac{x ^ j}{j!} $$ 那么每个数字的 $\\textbf{EGF}$ 做乘积表示满足条件的所有长度的字符串的方案数 $$ \\prod_{i = 0} ^ {w - 1}\\sum_{j = c_i} ^ {\\infty} \\frac{x ^ j}{j!} $$ 可以把和式用前缀和相减拆一下 $\\sum\\limits_{j = c_i} ^ {\\infty} \\dfrac{x ^ j}{j!} = \\sum\\limits_{j = 0} ^ {\\infty} \\dfrac{x ^ j}{j!} - \\sum\\limits_{j = 0} ^ {c_i - 1} \\dfrac{x ^ j}{j!}$，发现第一项为 $e ^ x$，故答案为 $$ \\prod_{i = 0} ^ {w - 1}(e ^ x - \\sum_{j = 0} ^ {c_i - 1} \\frac{x ^ j}{j!}) $$ 由于 $w \\le 10$，所以考虑暴力展开式子，做换元 $e ^ x \\rightarrow y$ 在展开式子的过程中，假设当前的多项式为 $f = A_0 + A_1 y + A_2y ^ 2 + A_3y^3 + \\cdots$，那么新遇到一个多项式 $(y + g_i)$ 其中 $g_i = -\\sum\\limits_{j = 0} ^ {c_i - 1} \\dfrac{x ^ j}{j!}$， 则结果变为 $f * y + f * g_i$ ($*$ 表示多项式卷积)，前一项为 $A_0y + A_1 y ^ 2 + A_2y ^ 3 + A_3y^4 + \\cdots$，那么后一项是 $f$ 的每一项系数与 $g_i$ 的多项式卷积，为 $A_0 * g_i + (A_1 * g_i) y + (A_2 * g_i)y ^ 2 + (A_3 * g_i)y^3 + \\cdots$，那么答案就为 $$ A_0 * g_i + (A_0 + A_1 * g_i)y + (A_1 + A_2 * g_i)y ^ 2 + (A_2 + A_3 * g_i)y ^ 3 + \\cdots $$ 这样就预处理好了总答案，现考虑回答每组询问，我们知道最后的答案是形如 $\\sum\\limits_{i = 0} ^ {w - 1} e ^ {ix} F_i(x)$ 的多项式，我们需要知道每一项的第 $n$ 项系数，由于 $\\sum\\limits_{i = 0} ^ {w - 1}c_i \\le 5 \\times 10 ^ 4$，我们可以在询问里对于每个 $i$ 直接枚举 $F_i(x)$ 的项数，设当前枚举到了第 $j$ 项，那么需要在 $e ^ {ix}$ 中取出第 $n - j$ 项，也就是 $e ^ {ix} = 1 + \\dfrac{(ix) ^ 1}{1!} + \\dfrac{(ix) ^ 2}{2!} + \\dfrac{(ix) ^ 3}{3!} + \\cdots$ 的第 $n - j$ 项，为 $\\dfrac{i ^ {n - j}}{(n - j)!}$ 那么答案就为 $$ n! \\times \\sum_{i = 0} ^ {w} \\sum_{j = 0} ^ {\\min(n, |F_i(x)|)} [x ^ j] F_i(x) \\times \\frac{i ^ {n - j}}{(n - j)!} $$ ","date":"2022-08-01","objectID":"/posts/cp2022-%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A14-c-easy-counting-problem/:0:0","tags":["生成函数","NTT"],"title":"[2022 牛客多校4 C] Easy Counting Problem","uri":"/posts/cp2022-%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A14-c-easy-counting-problem/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*(Poly a, Poly b) { if (a.size() == 0 || b.size() == 0) { return Poly(); } int sz = 1, tot = a.size() + b.size() - 1; while (sz \u003c tot) { sz *= 2; } a.a.resize(sz); b.a.resize(sz); dft(a.a); dft(b.a); for (int i = 0; i \u003c sz; i ++) { a.a[i] = a[i] * b[i]; } idft(a.a); a.resize(tot); return a; } friend Poly operator*(Z a, Poly b) { for (int i = 0; i \u003c int(b.size()); i ++) { b[i] *= a; } return b; } friend Poly operator*(Poly a, Z b) { for (int i = 0; i \u003c int(a.size()); i ++) { a[i] *= b; } return a; } Poly \u0026operator+=(Poly b) { return (*this) = (*this) + b; } Poly \u0026operator-=(Poly b) { return (*this) = (*this) - b; } Poly \u0026operator*=(Poly b) { return (*this) = (*this) * b; } Poly deriv() const { if (a.empty()) { return Poly(); } vector\u003cZ\u003e res(size() - 1); for (int i = 0; i \u003c size","date":"2022-08-01","objectID":"/posts/cp2022-%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A14-c-easy-counting-problem/:1:0","tags":["生成函数","NTT"],"title":"[2022 牛客多校4 C] Easy Counting Problem","uri":"/posts/cp2022-%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A14-c-easy-counting-problem/"},{"categories":["算法竞赛"],"content":"原题链接 题意 定义 $F_{n, k}$ 为所有长度为 $n$ 的字符串 $S$ 中恰好出现了 $k$ 次 bit 的个数。 求 $F_{n, 0},F_{n, 1}, \\cdots,F_{n,n}$ 对 $998,244,353$ 取模。 $(1 \\le n \\le 10 ^ 6)$ 分析： 看到求恰好出现 $k$ 次，首先想到求出大于等于 $k$ 次再进行容斥。 考虑钦定出现 $k$ 次 bit 的字符串，将 $k$ 个 bit 进行捆绑，那么有 $n - 3k + k = n - 2k$ 个位置，并且剩下 $n - 3 k$ 个字母任意取值，从 $n - 2k$ 个位置选出 $k$ 个放 bit，方案数为 $\\dbinom{n - 2k}{k} \\times 26 ^ {n - 3k}$，记为 $f(k)$ 那么 $f(k)$ 由所有恰好出现 $k, k + 1, \\cdots, n$ 次的方案数加起来，还要乘上对应次数选出 $k$ 个的方案数，记恰好出现 $k$ 次的方案数为 $g(k)$ $$ f(k) = \\sum_{i = k} ^ {n} \\binom{i}{k} g(i) $$ 根据二项式反演公式 $f(n)= \\sum\\limits_{i = n} ^ {m} \\binom{i}{n} g(i) \\Leftrightarrow g(n) = \\sum\\limits_{i = n} ^ {m}(-1) ^ {i - n}\\binom{i}{n}g(i)$ $$ g(k) = \\sum_{i = k} ^ {n} (-1) ^ {i - k} \\binom{i}{k}f(i) $$ 展开组合数 $\\dbinom{i}{k}= \\dfrac{i!}{k! \\times (i - k)!}$ $$ g(k) = \\sum_{i = k} ^ {n} i!f(i) \\dfrac{(-1) ^ {i - k}}{k! \\times (i - k)!} \\ \\Leftrightarrow k!g(k) = \\sum_{i = k} ^ {n} i!f(i) \\dfrac{(-1) ^ {i - k}}{(i - k)!} $$ 设 $P(k) = k!g(k), F(i) = i!f(i), G(i) = \\dfrac{(-1) ^ {i}}{i!}$，则 $$ P(k) = \\sum_{i = k} ^ {n} F(i) \\times G(i - k) $$ 令 $(i - k) \\rightarrow i$ $$ P(k) = \\sum_{i = 0} ^ {n - k} G(i) \\times F(i + k) $$ 考虑多项式加速。我们知道常规的多项式卷积是 $F(n) = \\sum\\limits_{i = 0} ^ {n} f(i) \\times g(n - i)$，所以上式中 $F$ 对应的下标应为 $n - k - i$，发现 $n - k - i + i + k = n$ 恰好是对称关系，所以可以对 $F$ 函数做翻转进行多项式卷积。 答案为 $\\dfrac{P(i)}{i!}$ $(0 \\le i \\le n)$ ","date":"2022-07-25","objectID":"/posts/cp2022-%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A12-e-falfa-with-substring/:0:0","tags":["二项式反演","NTT"],"title":"[2022 牛客多校2 E] Falfa with Substring","uri":"/posts/cp2022-%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A12-e-falfa-with-substring/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*(Poly a, Poly b) { if (a.size() == 0 || b.size() == 0) { return Poly(); } int sz = 1, tot = a.size() + b.size() - 1; while (sz \u003c tot) { sz *= 2; } a.a.resize(sz); b.a.resize(sz); dft(a.a); dft(b.a); for (int i = 0; i \u003c sz; i ++) { a.a[i] = a[i] * b[i]; } idft(a.a); a.resize(tot); return a; } friend Poly operator*(Z a, Poly b) { for (int i = 0; i \u003c int(b.size()); i ++) { b[i] *= a; } return b; } friend Poly operator*(Poly a, Z b) { for (int i = 0; i \u003c int(a.size()); i ++) { a[i] *= b; } return a; } Poly \u0026operator+=(Poly b) { return (*this) = (*this) + b; } Poly \u0026operator-=(Poly b) { return (*this) = (*this) - b; } Poly \u0026operator*=(Poly b) { return (*this) = (*this) * b; } Poly deriv() const { if (a.empty()) { return Poly(); } vector\u003cZ\u003e res(size() - 1); for (int i = 0; i \u003c size","date":"2022-07-25","objectID":"/posts/cp2022-%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A12-e-falfa-with-substring/:1:0","tags":["二项式反演","NTT"],"title":"[2022 牛客多校2 E] Falfa with Substring","uri":"/posts/cp2022-%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A12-e-falfa-with-substring/"},{"categories":["算法竞赛"],"content":"前置：数学符号介绍 $\\sum\\limits_{i = 1} ^ {n}$：求和符号，例如 $\\sum\\limits_{i = 1} ^ {n}i = \\dfrac{n \\times (n + 1)}{2}$ 代表 $1 + 2 + 3 + 4 + \\cdots + n$ $\\prod\\limits_{i = 1} ^ {n}$：连乘符号，例如 $\\prod\\limits_{i = 1} ^ {n} i = n!$ 代表 $1 \\times 2 \\times 3 \\times 4 \\times \\cdots \\times n$ $\\lfloor \\dfrac{x}{y} \\rfloor$：向下取整符号，例如 $\\lfloor \\dfrac{5}{2} \\rfloor = 2$ $[]$：艾弗森括号，例如 $[n = 1]$ 只有 $n = 1$ 时才取值为 $1$ $x \\mid y$：整除符号，表示 $x$ 整除 $y$，也就是 $x$ 是 $y$ 的约数，例如 $2 \\mid 4$ ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:1:0","tags":["数论"],"title":"数论提高","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["算法竞赛"],"content":"欧拉函数 定义：$\\varphi(x)$ 为小于等于 $x$ 与 $x$ 互质的数，即 $$ \\varphi(x) = \\sum_ {i = 1} ^ {x} [\\gcd(x, i) = 1] $$ ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:2:0","tags":["数论"],"title":"数论提高","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["算法竞赛"],"content":"性质： 积性函数：$\\varphi(x \\times y) = \\varphi(x) \\times \\varphi(y)$ 展开式：设 $x = p_1 ^ {\\alpha_1}p_2 ^ {\\alpha_2}\\cdots p_k ^ {\\alpha_k}$ 则 $\\varphi(x) = x \\times \\prod\\limits_{i = 1} ^ {k} \\dfrac{p_i - 1}{p_i}$ 欧拉反演：$n = \\sum\\limits_{d \\mid n} \\varphi(d)$ ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:2:1","tags":["数论"],"title":"数论提高","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["算法竞赛"],"content":"$O(\\sqrt n)$ 求欧拉函数值： int phi(int x) { int res = x; for (int i = 2; i * i \u003c= x; i ++) { if (x % i == 0) { res = res / i * (i - 1); while (x % i == 0) { x /= i; } } } if (x \u003e 1) { res = res / x * (x - 1); } return res; } ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:2:2","tags":["数论"],"title":"数论提高","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["算法竞赛"],"content":"$O(n)$ 筛欧拉函数 void get_eulers(int n) { euler[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; euler[i] = i - 1; } for (int j = 0; i * primes[j] \u003c= n; j ++) { int t = primes[j] * i; st[t] = true; if (i % primes[j] == 0) { euler[t] = euler[i] * primes[j]; break; } euler[t] = euler[i] * (primes[j] - 1); } } } ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:2:3","tags":["数论"],"title":"数论提高","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["算法竞赛"],"content":"习题 ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:3:0","tags":["数论"],"title":"数论提高","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["算法竞赛"],"content":"[2021 ICPC North American Qualifier Contest] Common Factors 题目链接：https://open.kattis.com/problems/commonfactors 题意 给定一个正整数 $n$，求 $$ \\max\\limits_{i = 2} ^ {n} \\dfrac{i - \\varphi(i)}{i} $$ 并输出其最简分数形式。$(1 \\le n \\le 10 ^ {18})$ 分析： 将式子化简得 $\\max\\limits_{i = 2} ^ {n} \\dfrac{i - \\varphi(i)}{i} = 1 -\\min_{i = 2} ^ {n} \\dfrac{\\varphi(i)}{i}$ 其中 $\\dfrac{\\varphi(x)}{x} = \\prod\\limits_{i = 1} ^ {k}\\dfrac{p_i - 1}{p_i}$，故转换为了求分数最小值。 由于 $\\dfrac{p_i - 1}{p_i} \u003c 1$，所以要尽可能多的含有质因子，那么最好情况就是 $2 \\times3\\times\\cdots$ 注意到 $2 \\times 3 \\times 5 \\times 7 \\times 11 \\times 13 \\times 17 \\times 19 \\times 23 \\times 29 \\times 31 \\times 37 \\times 41 \\times 43 \\times 47 \\times 53 \u003e 10 ^ {18}$ 所以只需要找到 $53$ 以内的素数，不断乘起来即可，注意判断时可能爆 long long，要转 __int128 代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int n; cin \u003e\u003e n; auto prime = [\u0026](int x) { for (int i = 2; i * i \u003c= x; i ++) { if (x % i == 0) { return false; } } return true; }; auto phi = [\u0026](int x) { int res = x; for (int i = 2; i * i \u003c= x; i ++) { if (x % i == 0) { res = res / i * (i - 1); while (x % i == 0) { x /= i; } } } if (x \u003e 1) { res = res / x * (x - 1); } return res; }; int sum = 1; for (int i = 2; i \u003c= 53; i ++) { if (prime(i)) { if ((__int128)i * sum \u003e n) { int up = sum - phi(sum), down = sum; int Gcd = __gcd(up, down); up /= Gcd, down /= Gcd; cout \u003c\u003c up \u003c\u003c \"/\" \u003c\u003c down \u003c\u003c \"\\n\"; return 0; } sum *= i; } } } 思考： 求 $\\dfrac{\\varphi(n)}{n}$ 的最大值。 即只需要找到一个小于等于 $n$ 的最大质数。 ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:3:1","tags":["数论"],"title":"数论提高","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["算法竞赛"],"content":"[洛谷 P1891] 疯狂 LCM 题目链接：https://www.luogu.com.cn/problem/P1891 题意： $T$ 组输入，每次给定一个正整数 $n$，求 $$ \\sum_{i=1} ^{n} \\text{lcm}(i,n) $$ $1 \\le T \\le 3 \\times 10 ^ 5, 1 \\le n \\le 10 ^ 6$ 分析： 由 $\\text{lcm}(i,n) = \\dfrac{i \\times n}{\\gcd{(i,n)}}$ 得 $$ \\sum_{i=1} ^{n} \\frac{i \\times n}{\\gcd{(i,n)}} $$ 枚举 $\\gcd(i,n)$ $$ n \\sum_{d \\mid n} \\sum_{i=1} ^{n} \\frac{i }{d}[\\gcd{(i,n)} = d] $$ 利用 $\\gcd$ 的性质： $$ n \\sum_{d \\mid n} \\sum_{i=1} ^{n} \\frac{i }{d}[\\gcd{(\\frac{i}{d},\\frac{n}{d})} = 1] $$ 把 $d$ 拿到上界，也就是做变换 $\\dfrac{i}{d} \\rightarrow i$ $$ n \\sum_{d \\mid n} \\sum_{i=1} ^{ \\lfloor \\frac{n}{d} \\rfloor } i[\\gcd{(i,\\frac{n}{d})} = 1 ] $$ 由于约数成对出现，所以第二层和式的 $\\lfloor \\dfrac{n}{d} \\rfloor$ 等价于 $d$ $$ n \\sum_{d \\mid n} \\sum_{i=1} ^{ d } i[\\gcd{(i,d)} = 1] $$ 由于 $\\gcd(i, d) = \\gcd(d - i,d)$ ，所以必成对出现，那么总共出现了 $\\dfrac{\\varphi(d)}{2}$ 次，$d - i + i =d$，所以就是 $$ n \\sum_{d \\mid n} \\frac{\\varphi(d)}{2} d $$ 这样时间复杂度是 $O(N+T\\sqrt{n})$，但是可以用狄利克雷卷积优化，可以做到 $O(N \\log{N} + T)$ 设 $F(x) = \\dfrac{x \\times \\varphi(x)}{2}$ 则答案为 $n \\times F * \\textbf{1}$，注意处理 $d \\le 2$ 的情况。 代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; int cnt; vector\u003cint\u003e primes, euler, f; vector\u003cbool\u003e st; void init(int n) { f.resize(n + 1), primes.resize(n + 1), euler.resize(n + 1), st.resize(n + 1); euler[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; euler[i] = i - 1; } for (int j = 0; i * primes[j] \u003c= n; j ++) { int t = i * primes[j]; st[t] = 1; if (i % primes[j] == 0) { euler[t] = euler[i] * primes[j]; break; } euler[t] = euler[i] * (primes[j] - 1); } } for (int i = 1; i \u003c= n; i ++) { for (int j = i; j \u003c= n; j += i) { if (i \u003c= 2) { f[j] ++; } else { f[j] += euler[i] / 2 * i; } } } } void solve() { int n; cin \u003e\u003e n; cout \u003c\u003c n * f[n] \u003c\u003c \"\\n\"; } signed main() { init(1e6); cin.tie(0) -\u003e sync_with_stdio(0); int T; cin \u003e\u003e T; while (T --) { solve(); } } ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:3:2","tags":["数论"],"title":"数论提高","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["算法竞赛"],"content":"数论分块 ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:4:0","tags":["数论"],"title":"数论提高","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["算法竞赛"],"content":"引入：$\\sum\\limits_{i = 1} ^ {n} \\lfloor \\dfrac{n}{i} \\rfloor$ 假设取 $n = 100$，我们可以通过打表发现每一项的分布情况，发现结果的取值都是连续一段的，并且有 $\\sqrt n$ 块 对于每一块 $i$ 的右端点为 $\\left \\lfloor \\dfrac{n}{\\lfloor \\dfrac{n}{i} \\rfloor} \\right \\rfloor$，每一块的值都为 $\\lfloor \\dfrac{n}{i} \\rfloor$ 代码: for (int l = 1, r; l \u003c= n; l = r + 1) { r = n / (n / l); res += (r - l + 1) * (n / l); } 这样就做到了 $O(\\sqrt n)$ 求和 ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:4:1","tags":["数论"],"title":"数论提高","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["算法竞赛"],"content":"习题 •https://www.luogu.com.cn/problem/P2424 ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:5:0","tags":["数论"],"title":"数论提高","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["算法竞赛"],"content":"[洛谷 P2261] 余数求和 题目链接：https://www.luogu.com.cn/problem/P2261 题意 给定正整数 $n, k$，求 $$ \\sum_{i = 1} ^ {n} k \\bmod i $$ $(1 \\le n, k \\le 10 ^ 9)$ 分析： 根据余数的定义：$k \\bmod i = k - i \\times \\lfloor \\dfrac{k}{i} \\rfloor$ 式子等价于 $$ \\sum_{i = 1} ^ {n}(k - i \\times \\lfloor \\dfrac{k}{i} \\rfloor) =n \\times k - \\sum_{i = 1} ^ {n} i \\times \\lfloor \\dfrac{k}{i} \\rfloor $$ 注意到 $\\lfloor \\dfrac{k}{i} \\rfloor$，可以利用整除分块 代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int n, k; cin \u003e\u003e n \u003e\u003e k; int res = 0; for (int l = 1, r; l \u003c= n; l = r + 1) { if (k / l != 0) { r = min(k / (k / l), n); } else { r = n; } res += (r - l + 1) * (l + r) / 2 * (k / l); } cout \u003c\u003c n * k - res \u003c\u003c \"\\n\"; } ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:5:1","tags":["数论"],"title":"数论提高","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["算法竞赛"],"content":"[洛谷 P2424] 约数和 题目链接：https://www.luogu.com.cn/problem/P2424 题意 定义 $f(x)$ 为 $x$ 的所有约数和， 给定两个正整数 $l, r$，求 $\\sum\\limits_{i = l} ^ {r} f(i)$ $(1 \\le l \u003c r \\le 2 \\times 10 ^ 9)$ 分析： 一个数 $x$ 的所有约数和可以表示为 $f(x) = \\sum\\limits_{d \\mid x}d$ 那么 $$ \\sum\\limits_{i = 1} ^ {n} f(i) = \\sum\\limits_{i = 1} ^ {n}\\sum\\limits_{d \\mid i}d $$ 交换一下枚举顺序 $$ \\sum\\limits_{i = 1} ^ {n}\\sum\\limits_{d \\mid i}d = \\sum_{d = 1} ^ {n} d \\times \\lfloor \\frac{n}{d} \\rfloor $$ 可以利用整除分块求解 代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; signed main() { int l, r; cin \u003e\u003e l \u003e\u003e r; auto f = [\u0026](int n) { if (!n) return 0ll; int res = 0; for (int l = 1, r; l \u003c= n; l = r + 1) { r = n / (n / l); res += (l + r) * (r - l + 1) * (n / l) / 2; } return res; }; cout \u003c\u003c f(r) - f(l - 1) \u003c\u003c endl; } ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:5:2","tags":["数论"],"title":"数论提高","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["算法竞赛"],"content":"狄利克雷卷积 ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:6:0","tags":["数论"],"title":"数论提高","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["算法竞赛"],"content":"定义： 对于两个数论函数 $f(x),g(x)$ 那么它们的卷积 $h(x)$ 记作 $f(x) * g(x)$，式子如下： $$ f(x) * g(x) = h(x) = \\sum_{d \\mid n} f(d)g(\\frac{n}{d}) $$ 简记为 $h = f * g$ ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:6:1","tags":["数论"],"title":"数论提高","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["算法竞赛"],"content":"性质： 交换律： $f * g = g * f$ 结合律： $(f * g) * h = f * (g * h)$ 分配律： $(f + g) * h = f * h + g * h$ 两个积性函数的狄利克雷卷积还是积性函数 ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:6:2","tags":["数论"],"title":"数论提高","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["算法竞赛"],"content":"常见积性函数： 1. 莫比乌斯函数：$\\mu(x)$ 设 $n=p_1^{c_1}\\cdots p_k^{c_k}$ $$\\mu(n)=\\begin{cases} 0,\u0026\\exists i \\in[1,k],c_i \u003e1 \\\\ 1,\u0026k \\equiv 0\\pmod2,\\forall i \\in[1,k],c_i=1\\\\ -1,\u0026k\\equiv1\\pmod2,\\forall i\\in [1,k],c_i=1 \\end{cases}$$ 2. 欧拉函数：$\\varphi(x)$ $\\varphi(n) = \\sum \\limits_{i=1} ^{n}[\\gcd(i,n) = 1]$ 3. 单位函数：$\\varepsilon(x)$ $\\varepsilon(n) = [n = 1]$ 4. 恒等函数：$Id(x)$ $Id(n) = n$ 5. 常数函数：$I(x)$ $I(n)=1$ 6. 约数个数函数：$d(x)$ $d(n)=\\sum \\limits_{i \\mid n}1$ 7. 约数和函数：$\\sigma(x)$ $\\sigma(n)=\\sum \\limits_{d \\mid n} d$ ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:6:3","tags":["数论"],"title":"数论提高","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["算法竞赛"],"content":"常见卷积： 1. $\\varepsilon = \\mu * 1$ $\\varepsilon = [n=1]=\\sum \\limits _{d \\mid n} \\mu (d)$ 2. $d = 1 * 1$ $d(n)=\\sum \\limits_{i \\mid n}1$ 3. $Id * 1 = \\sigma$ $\\sigma(n)=\\sum \\limits_{d \\mid n} d$ 4. $\\mu * Id = \\varphi$ $\\varphi(n)=\\sum \\limits _{d \\mid n} d \\times \\mu(\\dfrac{n}{d})$ 5. $\\varphi * 1 = Id$ $Id(n)=\\sum \\limits _{d \\mid n} \\varphi(d)$ 狄利克雷卷积可做到 $O(n \\log n)$，利用枚举倍数法。 $$ \\frac{n}{1} + \\frac{n}{2} + \\cdots + \\frac{n}{n} = n \\times (\\frac{1}{1} + \\frac{1}{2} + \\cdots + \\frac{1}{n}) $$ 其中 $\\dfrac{1}{1} + \\dfrac{1}{2} + \\cdots + \\dfrac{1}{n}$ 为调和级数，约为 $\\ln n$ 枚举倍数法代码： for (int i = 1; i \u003c= n; i ++) { for (int j = i; j \u003c= n; j += i) { } } ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:6:4","tags":["数论"],"title":"数论提高","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["算法竞赛"],"content":"习题 ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:7:0","tags":["数论"],"title":"数论提高","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["算法竞赛"],"content":"[牛客小白月赛 40] 来点gcd 题目链接：https://ac.nowcoder.com/acm/problem/229589 题意 $T$ 组输入，给定一个有 $n$ 个元素的多重集 $S$，有 $m$ 个询问，对于每个询问，给出一个整数 $x$，问是否能选择 $S$ 的一个非空子集，满足这个子集的 $\\gcd$ 等于 $x$，当集合只有一个数时，这个集合的 $\\gcd$ 就等于这个数 $\\sum n, m \\le 10 ^ 6$ 分析： $S$ 中能取 $\\gcd$ 成为 $x$ 的只可能是 $x$ 的倍数，故直接卷积 $O(n \\log n)$ 即可。 代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; void solve() { int n, m; cin \u003e\u003e n \u003e\u003e m; vector\u003cint\u003e Gcd(n + 1), mp(n + 1); for (int i = 1; i \u003c= n; i ++) { int x; cin \u003e\u003e x; mp[x] = 1; } for (int i = 1; i \u003c= n; i ++) { for (int j = i; j \u003c= n; j += i) { if (mp[j]) { Gcd[i] = __gcd(Gcd[i], j); } } } while (m --) { int x; cin \u003e\u003e x; cout \u003c\u003c (Gcd[x] == x ? \"YES\" : \"NO\") \u003c\u003c \"\\n\"; } } signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int T; cin \u003e\u003e T; while (T --) { solve(); } } ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:7:1","tags":["数论"],"title":"数论提高","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["算法竞赛"],"content":"[AtCoder Beginner Contest 206] Divide Both 题目链接：https://atcoder.jp/contests/abc206/tasks/abc206_e 题意 给定两个正整数 $l, r$，找到区间 $[l, r]$ 满足下列条件的二元组 $(x, y)$ $l \\le x,y \\le r$ $\\gcd(x, y) \\ne 1$ 且 $\\dfrac{x}{\\gcd(x, y)} \\ne 1$ 且 $\\dfrac{y}{\\gcd(x, y)} \\ne 1$ 分析： 转换一下题意，即找到区间不互质也不互为倍数的二元组。 考虑枚举两个数的公约数 $x$，设 $x$ 及 $x$ 的倍数在区间 $[l, r]$ 的个数为 $\\text{cnt}_x$，那么两两组合的方案数为 $\\text{cnt}x ^ 2$，这样会有重复，所以减去 $x$ 的倍数所有方案，即 $\\text{cnt}^ 2_x - \\sum\\limits{x \\mid d ,d\\ne x} \\text{cnt}^2_d$。此外，还需要减去与 $x$ 互为倍数的数量，即 $2 \\times \\text{cnt}_x - 1$，$-1$ 是因为 $(x, x)$ 重复减掉了一次。 代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int l, r; cin \u003e\u003e l \u003e\u003e r; vector\u003cint\u003e cnt(r + 1); for (int i = 2; i \u003c= r; i ++) { for (int j = i; j \u003c= r; j += i) { if (j \u003e= l) { cnt[i] ++; } } } int res = 0; vector\u003cint\u003e cnt2(r + 1); for (int i = r; i \u003e= 2; i --) { cnt2[i] = cnt[i] * cnt[i]; for (int j = i \u003c\u003c 1; j \u003c= r; j += i) { cnt2[i] -= cnt2[j]; } res += cnt2[i]; if (i \u003e= l) { res -= 2 * cnt[i] - 1; } } cout \u003c\u003c res \u003c\u003c \"\\n\"; } ","date":"2022-07-24","objectID":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/:7:2","tags":["数论"],"title":"数论提高","uri":"/posts/cp%E6%95%B0%E8%AE%BA%E6%8F%90%E9%AB%98/"},{"categories":["算法竞赛"],"content":"原题链接 题意 $T$ 组输入，每次给定一个正整数 $n$，定义 $f(k)$ 为 $k$ 的质因子个数，$g(k) = 2 ^ {f(i)}$，求 $$ \\sum_{i = 1} ^ {n} g(i) $$ $1 \\le T \\le 50, 1 \\le n \\le 10 ^ {12}$ 分析： 首先 $2 ^ {f(i)}$ 不好直接计算，考虑组合意义，发现 $2 ^ {f(i)}$ 就是从 $i$ 的所有质因子中选出若干个子集的方案数，假设 $i = p_1 ^ {\\alpha_1} p_2 ^ {\\alpha_2}\\cdots p_k ^ {\\alpha_k}$，那么我们可以枚举 $i$ 的所有约数 $d$，将约数带入莫比乌斯函数，那么就去掉了所有存在大于等于 $2$ 次的质因子，所以每个 $\\alpha_i$ 只能取 $0$ 或 $1$，但如果有奇数个质因子莫比乌斯函数值为负数，所以平方一下即可，即 $$\\sum_{i = 1} ^ {n}2 ^ {f(i)} = \\sum_{i = 1} ^ {n} \\sum_{d \\mid i} \\mu ^ 2(d)$$ 交换求和次序 $$ \\sum_{d = 1} ^ {n} \\mu ^ 2(d) \\lfloor\\frac{n}{d}\\rfloor $$ 此时就可以套用完全平方数这个题的公式 $$ \\sum_{i=1}^{n} \\mu^2(i)=\\sum_{i=1} ^{n}\\sum_{d^2 \\mid i} \\mu(d) $$ 代入可得 $$ \\sum_{i = 1} ^ {n} \\lfloor \\frac{n}{i} \\rfloor \\sum_{d ^ 2 \\mid i} \\mu(d) $$ 交换求和次序 $$ \\sum_{d = 1} ^ {\\sqrt n} \\mu(d) \\sum_{i = 1} ^ {\\lfloor \\frac{n}{d ^ 2} \\rfloor} \\lfloor \\frac{n}{i \\times d ^ 2} \\rfloor = \\sum_{d = 1} ^ {\\sqrt n} \\mu(d) \\sum_{i = 1} ^ {\\lfloor \\frac{n}{d ^ 2} \\rfloor} \\lfloor \\frac{\\lfloor \\frac{n}{d ^ 2} \\rfloor}{i} \\rfloor $$ 后面式子直接分块即可，注意优化当莫比乌斯函数非 $0$ 时才计算答案，并且分块要记忆化一下答案，复杂度比较玄学，此题给了 $15$ 秒。 ","date":"2022-07-15","objectID":"/posts/cp2016-ccpc-%E6%9D%AD%E5%B7%9Ej-just-a-math-problem/:0:0","tags":["莫比乌斯反演"],"title":"[2016 CCPC 杭州J] Just a Math Problem","uri":"/posts/cp2016-ccpc-%E6%9D%AD%E5%B7%9Ej-just-a-math-problem/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int mod = 1e9 + 7; int cnt; vector\u003cint\u003e primes(1e6 + 1), mobius(1e6 + 1), block(1e6 + 1); vector\u003cbool\u003e st(1e6 + 1); void init(int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; i * primes[j] \u003c= n; j ++) { int t = i * primes[j]; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } }; void solve() { int n; cin \u003e\u003e n; int res = 0; auto sum = [\u0026](int n) { if (n \u003c 1e6 \u0026\u0026 block[n]) { return block[n]; } int res = 0; for (int l = 1, r; l \u003c= n; l = r + 1) { r = n / (n / l); res = (res + (n / l) * (r - l + 1) % mod) % mod; } if (n \u003e 1e6) { return res; } else { return block[n] = res; } }; for (int i = 1; i * i \u003c= n; i ++) { if (mobius[i]) { res = (res + mobius[i] * sum(n / (i * i)) % mod + mod) % mod; } } cout \u003c\u003c res \u003c\u003c \"\\n\"; } signed main() { init(1e6); cin.tie(0) -\u003e sync_with_stdio(0); int T; cin \u003e\u003e T; for (int t = 1; t \u003c= T; t ++) { cout \u003c\u003c \"Case #\" \u003c\u003c t \u003c\u003c \": \"; solve(); } } ","date":"2022-07-15","objectID":"/posts/cp2016-ccpc-%E6%9D%AD%E5%B7%9Ej-just-a-math-problem/:1:0","tags":["莫比乌斯反演"],"title":"[2016 CCPC 杭州J] Just a Math Problem","uri":"/posts/cp2016-ccpc-%E6%9D%AD%E5%B7%9Ej-just-a-math-problem/"},{"categories":["算法竞赛"],"content":"原题链接 题意 给定两个正整数 $q, d$，定义三元组 $(i, j, k)$ 满足 $i \u003c j \u003c k, k - i \\le d$，为美丽三元组，现在有一个空集和 $q$ 组询问，每次给定一个正整数 $x$，若 $x$ 不在集合，那么将 $x$ 加入集合，若 $x$ 在集合中，那么将 $x$ 从集合中删除，每次询问计算集合中美丽三元组的个数。 分析： 考虑每个数从集合加入或删除的贡献，对于一个数 $x$，从区间 $[x, x + d]$ 中选出任意两个不同的数都可以组成美丽三元组(假设 $x$ 为三元组中的最小值)，记区间中在集合的数量为 $cnt$，那么方案数为 $\\dbinom{cnt}{2}$，那么考虑区间 $[x - d, x - 1]$，对区间中的每个数 $i$，考虑 $x$ 加入后的影响，设区间 $[i, i + d]$ 在集合中的个数为 $a_i$，那么美丽三元组的个数为 $\\dbinom{a_i}{2}$，则 $x$ 加入后的美丽三元组数量为 $\\dbinom{a_i + 1}{2}$，设整个集合为 $S$，那么在区间 $[x - d, x - 1]$ 中新增的美丽三元组数量就为 $\\sum\\limits_{i = x - d} ^ {x - 1} \\left (\\dbinom{a_i + 1}{2} - \\dbinom{a_i}{2} \\right ) [i \\in S] = \\sum\\limits_{i = x - d} ^ {x - 1}a_i [i \\in S]$，对于 $x$ 删除后的影响就为 $\\sum\\limits_{i = x - d} ^ {x - 1} \\left (\\dbinom{a_i}{2} - \\dbinom{a_i - 1}{2} \\right ) [i \\in S] = \\sum\\limits_{i = x - d} ^ {x - 1} (a_i - 1) [i \\in S]$ 考虑使用线段树，我们重点要维护的是每个数 $x$ 在区间 $[x, x + d]$ 中在集合里的个数，那么每次加入或删除操作就相当于对区间 $[x - d, x - 1]$ 进行区间 $+1$ 或 $-1$ 操作，线段树中维护四个值：$\\text{cnt}$ 代表区间里在集合中的数的个数，$\\text{add}$ 代表区间加的懒标记，$\\text{val}$ 代表每个数 $i$ 在区间 $[i, i + d]$ 中在集合里的个数，$\\text{sum}$ 代表存在集合中的每个数 $i$ 在区间 $[i, i + d]$ 中在集合里的个数。因为每个数是否存在于集合中由 $\\text{cnt}$ 是否为 $1$ 来决定，相当于 $\\text{val}$ 是全部的值，也就是说无论区间 $[x - d, x - 1]$ 的某个数存不存在于集合，我们都要维护，那么真正的答案是 $\\text{sum}$，也就是那些存在于集合里的数的值，通过懒标记用 $\\text{cnt} \\times \\text{val}$ 来下传，这样就巧妙地算出了一段区间存在于集合中的数对答案的贡献，至于区间 $[x, x + d]$ 的贡献可以直接查询 $\\text{val}_x$ 的单点值并给答案贡献 $\\dbinom{\\text{val}_x}{2}$ ","date":"2022-07-13","objectID":"/posts/cpeducational-codeforces-round-131-f-points/:0:0","tags":["组合计数","线段树"],"title":"[Educational Codeforces Round 131 F] Points","uri":"/posts/cpeducational-codeforces-round-131-f-points/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; constexpr int N = 2e5; struct SegmentTree { struct Info { int l, r, cnt, add, val, sum; }; vector\u003cInfo\u003e tr; SegmentTree(int n) : tr(n \u003c\u003c 2) { function\u003cvoid(int, int, int)\u003e build = [\u0026](int u, int l, int r) { if (l == r) { tr[u] = {l, r}; } else { tr[u] = {l, r}; int mid = l + r \u003e\u003e 1; build(u \u003c\u003c 1, l, mid), build(u \u003c\u003c 1 | 1, mid + 1, r); pushup(u); } }; build(1, 1, n); } void pushdown(int u) { if (tr[u].add) { tr[u \u003c\u003c 1].add += tr[u].add, tr[u \u003c\u003c 1 | 1].add += tr[u].add; tr[u \u003c\u003c 1].val += (tr[u \u003c\u003c 1].r - tr[u \u003c\u003c 1].l + 1) * tr[u].add; tr[u \u003c\u003c 1 | 1].val += (tr[u \u003c\u003c 1 | 1].r - tr[u \u003c\u003c 1 | 1].l + 1) * tr[u].add; tr[u \u003c\u003c 1].sum += tr[u \u003c\u003c 1].cnt * tr[u].add; tr[u \u003c\u003c 1 | 1].sum += tr[u \u003c\u003c 1 | 1].cnt * tr[u].add; tr[u].add = 0; } } void pushup(int u) { tr[u].cnt = tr[u \u003c\u003c 1].cnt + tr[u \u003c\u003c 1 | 1].cnt; tr[u].val = tr[u \u003c\u003c 1].val + tr[u \u003c\u003c 1 | 1].val; tr[u].sum = tr[u \u003c\u003c 1].sum + tr[u \u003c\u003c 1 | 1].sum; } void modifycnt(int u, int pos, int c) { if (!pos) return ; if (tr[u].l == tr[u].r) { tr[u].cnt += c; if (!tr[u].cnt) { tr[u].sum = 0; } else { tr[u].sum = tr[u].val; } return ; } pushdown(u); int mid = tr[u].l + tr[u].r \u003e\u003e 1; if (pos \u003c= mid) { modifycnt(u \u003c\u003c 1, pos, c); } else { modifycnt(u \u003c\u003c 1 | 1, pos, c); } pushup(u); } void modifysum(int u, int l, int r, int c) { if (l \u003e r) return ; if (tr[u].l \u003e= l \u0026\u0026 tr[u].r \u003c= r) { tr[u].val += (tr[u].r - tr[u].l + 1) * c; tr[u].sum += tr[u].cnt * c; tr[u].add += c; return ; } pushdown(u); int mid = tr[u].l + tr[u].r \u003e\u003e 1; if (l \u003c= mid) modifysum(u \u003c\u003c 1, l, r, c); if (r \u003e mid) modifysum(u \u003c\u003c 1 | 1, l, r, c); pushup(u); } int askval(int u, int pos) { if (!pos) return 0; if (tr[u].l == tr[u].r) return tr[u].val; pushdown(u); int mid = tr[u].l + tr[u].r \u003e\u003e 1, res = 0; if (pos \u003c= mid) { return askval(u \u003c\u003c 1, pos); } else { return askval(u \u003c\u003c 1 | 1, pos); } } int asksum(int u, int l, int r) { if (l \u003e r) return 0; if (tr[u].l \u003e= l \u0026\u0026 tr[u].r \u003c= r) return tr[u].sum; pushdown(u); int mid = tr[u].l + tr[u].r \u003e\u003e 1, res = 0; if (l \u003c= mid) res += asksum(u \u003c\u003c 1, l, r); if (r \u003e mid) res += asksum(u \u003c\u003c 1 | 1, l, r); return res; } }; signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int n, d; cin \u003e\u003e n \u003e\u003e d; vector\u003cint\u003e st(N + 1); SegmentTree tr(N + 1); int ans = 0; for (int i = 1; i \u003c= n; i ++) { int x; cin \u003e\u003e x; int l = max(1ll, x - d), r = x - 1; if (!st[x]) { ans += tr.asksum(1, l, r); tr.modifysum(1, l, r, 1); int cnt = tr.askval(1, x); ans += cnt * (cnt - 1) / 2; tr.modifycnt(1, x, 1); } else if (st[x]) { tr.modifysum(1, l, r, -1); ans -= tr.asksum(1, l, r); int cnt = tr.askval(1, x); ans -= cnt * (cnt - 1) / 2; tr.modifycnt(1, x, -1); } st[x] ^= 1; cout \u003c\u003c ans \u003c\u003c \"\\n\"; } } ","date":"2022-07-13","objectID":"/posts/cpeducational-codeforces-round-131-f-points/:1:0","tags":["组合计数","线段树"],"title":"[Educational Codeforces Round 131 F] Points","uri":"/posts/cpeducational-codeforces-round-131-f-points/"},{"categories":["算法竞赛"],"content":"背包：Acwing 1454 异或和是质数的子集数 题目链接 https://www.acwing.com/problem/content/description/1456/ 分析： 考虑 $01$ 背包，$1 \\sim n$ 中对于每件物品 $1 \\le i \\le n$ 的体积为 $i$ 定义状态 $dp_{i, j}$ 为从前 $i$ 件物品中选，异或和为 $j$ 的方案数，那么有转移 $$ dp_{i,j} = dp_{i - 1,j} + dp_{i - 1,j \\oplus a_i} $$ 由于按位异或会变小，所以状态必须开二维，但第一维可以用滚动数组优化。 注意到 $1 \\le a_i \\le 5 \\times 10 ^ 3$，$2 ^ {12} = 4096 \u003c 5 \\times 10 ^ 3$，所以总体积最大为 $\\sum_{i = 0} ^ {12} 2 ^ i = 2 ^ {13} - 1$ 那么最后的答案为 $$ \\sum_{i \\in \\text{prime}} dp_i $$ 时间复杂度 $O(2 ^{13} \\times n)$ ","date":"2022-07-07","objectID":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:1:0","tags":["DP"],"title":"DP 题目选讲","uri":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["算法竞赛"],"content":"代码： #pragma GCC optimize(2) #pragma GCC optimize(3) #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int mod = 1e9 + 7, N = 1 \u003c\u003c 13; signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int cnt = 0; vector\u003cint\u003e primes(N + 1); vector\u003cbool\u003e st(N + 1); auto sieve = [\u0026](int n) { st[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; } for (int j = 0; i * primes[j] \u003c= n; j ++) { int t = i * primes[j]; st[t] = 1; if (i % primes[j] == 0) { break; } } } }; sieve(N); int n; cin \u003e\u003e n; vector\u003cint\u003e a(n + 1); for (int i = 1; i \u003c= n; i ++) { cin \u003e\u003e a[i]; } vector\u003cvector\u003cint\u003e\u003e dp(2, vector\u003cint\u003e(N + 1)); dp[0][0] = 1; for (int i = 1; i \u003c= n; i ++) { for (int j = 0; j \u003c= N; j ++) { dp[i \u0026 1][j] = dp[(i - 1) \u0026 1][j]; if ((j ^ a[i]) \u003c= N) { dp[i \u0026 1][j] = (dp[i \u0026 1][j] + dp[(i - 1) \u0026 1][j ^ a[i]]) % mod; } } } int res = 0; for (int i = 1; i \u003c= N; i ++) { if (!st[i]) { res = (res + dp[n \u0026 1][i]) % mod; } } cout \u003c\u003c res \u003c\u003c \"\\n\"; } ","date":"2022-07-07","objectID":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:2:0","tags":["DP"],"title":"DP 题目选讲","uri":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["算法竞赛"],"content":"区间DP：CF 1114 D Flood Fill 题目链接 https://codeforces.com/problemset/problem/1114/D 题意： 有 $n$ 个砖块排成一排，从左到右编号为 $1 \\sim n$ 其中，第 $i$ 个砖块的初始颜色为 $c_i$ 我们规定，如果编号范围 $[i,j]$ 内的所有砖块的颜色都相同，则砖块 $i$ 和 $j$ 属于同一个连通块。 现在，要对砖块进行涂色操作。 开始所有操作之前，你需要任选一个砖块作为起始砖块。 每次操作： 任选一种颜色。 将最开始选定的起始砖块所在连通块中包含的所有砖块都涂为选定颜色， 请问，至少需要多少次操作，才能使所有砖块都具有同一种颜色。 分析： 首先把所有砖块进行缩点，也就是相邻相同颜色的砖块进行合并。 考虑区间 DP，定义状态 $dp_{i, j}$ 为将区间 $[i, j]$ 染成同色的最小次数，转移分为两种情况： 对于每个区间 $[l, r]$，每个端点 $i$ 的颜色为 $a_i$ 若 $a_l = a_r$，那么 $dp_{l, r} = dp_{l + 1, r - 1} + 1$ 若 $a_l \\ne a_r$，那么 $dp_{l, r} = \\min(dp_{l + 1, r}, dp_{l, r - 1}) + 1$ 最终答案为 $dp_{1, n}$ 时间复杂度 $O(n ^ 2)$ ","date":"2022-07-07","objectID":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:3:0","tags":["DP"],"title":"DP 题目选讲","uri":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int n; cin \u003e\u003e n; vector\u003cint\u003e a{0}; for (int i = 1; i \u003c= n; i ++) { int x; cin \u003e\u003e x; if (a.back() != x) { a.push_back(x); } } n = a.size() - 1; vector\u003cvector\u003cint\u003e\u003e dp(n + 1, vector\u003cint\u003e(n + 1)); for (int len = 2; len \u003c= n; len ++) { for (int l = 1; l + len - 1 \u003c= n; l ++) { int r = l + len - 1; if (a[l] == a[r]) { dp[l][r] = dp[l + 1][r - 1] + 1; } else { dp[l][r] = min(dp[l + 1][r], dp[l][r - 1]) + 1; } } } cout \u003c\u003c dp[1][n] \u003c\u003c endl; } ","date":"2022-07-07","objectID":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:4:0","tags":["DP"],"title":"DP 题目选讲","uri":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["算法竞赛"],"content":"数位DP：洛谷 P2657 windy 数 题目链接 https://www.luogu.com.cn/problem/P2657 数位 DP 学习笔记：https://www.acwing.com/blog/content/7944/ 题意： 找到区间 $[L,R]$ 相邻数字之差至少为 $2$ 的数的个数 分析： 搜索初始条件第二个参数 $pre$ 必须填一个 $\\le -2$ 的数来保证可以搜索下去，不然会出错。此题需要记录前导零，不然忽视前导零的影响会造成最高位数 $-0\u003c2$ 无法继续搜索的情况。 ","date":"2022-07-07","objectID":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:5:0","tags":["DP"],"title":"DP 题目选讲","uri":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int l, r; cin \u003e\u003e l \u003e\u003e r; auto cal = [\u0026](int x) { vector\u003cint\u003e a{0}; while (x) { a.push_back(x % 10); x /= 10; } vector\u003cvector\u003cint\u003e\u003e dp(a.size(), vector\u003cint\u003e(10, -1)); function\u003cint(int, int, int, int)\u003e dfs = [\u0026](int pos, int pre, int lead, int limit) { if (!pos) return 1ll; if (!limit \u0026\u0026 !lead \u0026\u0026 dp[pos][pre] != -1) return dp[pos][pre]; int res = 0, up = limit ? a[pos] : 9; for (int i = 0; i \u003c= up; i ++) { if (abs(pre - i) \u003c 2) continue; if (lead \u0026\u0026 !i) { res += dfs(pos - 1, -2, lead \u0026\u0026 !i, limit \u0026\u0026 i == up); } else { res += dfs(pos - 1, i, lead \u0026\u0026 !i, limit \u0026\u0026 i == up); } } return limit ? res : (lead ? res : dp[pos][pre] = res); }; return dfs(a.size() - 1, -2, 1, 1); }; cout \u003c\u003c cal(r) - cal(l - 1) \u003c\u003c \"\\n\"; } ","date":"2022-07-07","objectID":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:6:0","tags":["DP"],"title":"DP 题目选讲","uri":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["算法竞赛"],"content":"状压 + 树形DP：武汉科技大学校赛 B 杰哥的树 题目链接 https://ac.nowcoder.com/acm/contest/35746/B 分析： 首先边权只有 $6$ 种颜色可以想到状态压缩，路径的所有颜色必须出现偶数次，可以想到按位异或操作，每次增加颜色时令当前状态异或 $2 ^ i$，$i$ 为该颜色对应的二进制位。 每种颜色都出现偶数次就对应 $0$ 这个状态，那么只有两个状态相同时才可以异或成为 $0$，定义每个点 $u$ 的点权为从 $1$ 到 $u$ 的异或和，问题就转化为树上有多少点对点权相同。直接 $\\text{dfs}$ 遍历一遍树记录状态，$dp_i$ 就为状态 $i$ 的个数，那么最后答案就为 $$ \\sum_{i = 0} ^ {2 ^ 6} \\binom{dp_i}{2} $$ ","date":"2022-07-07","objectID":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:7:0","tags":["DP"],"title":"DP 题目选讲","uri":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int n; cin \u003e\u003e n; vector\u003cvector\u003cpair\u003cint, int\u003e\u003e\u003e g(n + 1); for (int i = 1; i \u003c n; i ++) { int u, v; char ch; cin \u003e\u003e u \u003e\u003e v \u003e\u003e ch; g[u].push_back({v, ch - 'a'}), g[v].push_back({u, ch - 'a'}); } vector\u003cint\u003e dp(1ll \u003c\u003c 6); function\u003cvoid(int, int, int)\u003e dfs = [\u0026](int u, int fa, int st) { dp[st] ++; for (auto [v, w] : g[u]) { if (v == fa) { continue; } dfs(v, u, st ^ (1ll \u003c\u003c w)); } }; dfs(1, -1, 0); int res = 0; for (int i = 0; i \u003c 1ll \u003c\u003c 6; i ++) { res += dp[i] * (dp[i] - 1) / 2; } cout \u003c\u003c res \u003c\u003c \"\\n\"; } ","date":"2022-07-07","objectID":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/:8:0","tags":["DP"],"title":"DP 题目选讲","uri":"/posts/cpdp-%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2/"},{"categories":["算法竞赛"],"content":"题意 求在满足 $\\sum\\limits_{i = 1} ^ {k}\\dfrac{x_i ^ 2}{a_i ^ 2} = 1$ 的条件下，从长度为 $m$ 的数组 $b$ 中选 $k$ 个数组成 $a_1,a_2,\\cdots,a_k$，$\\prod\\limits_{i = 1} ^{k} x_i$ 的最大值的期望，$k$ 为偶数。 $(1 \\le k \\le m \\le 10 ^ 5, 0 \u003c b_i \u003c 10 ^ 9)$ 分析： 首先求解最大值需要用到高等数学中多元函数条件极值的拉格朗日乘数法，设 $$ L(x_1,x_2,\\cdots,x_k, \\lambda) = \\prod_{i = 1} ^{k} x_i + \\lambda(\\sum\\limits_{i = 1} ^ {k}\\dfrac{x_i ^ 2}{a_i ^ 2} - 1) $$ 对每个变量求偏导数，令偏导数为 $0$ 得 $$ \\frac{\\partial L}{\\partial x_1} = \\frac{\\prod\\limits_{i = 1} ^{k} x_i}{x_1} + \\frac{2\\lambda x_1}{a_1 ^ 2} = 0 \\\\ \\frac{\\partial L}{\\partial x_2} = \\frac{\\prod\\limits_{i = 1} ^{k} x_i}{x_2} + \\frac{2\\lambda x_2}{a_2 ^ 2} = 0 \\\\ \\cdots \\\\ \\frac{\\partial L}{\\partial x_k} = \\frac{\\prod\\limits_{i = 1} ^{k} x_i}{x_k} + \\frac{2\\lambda x_k}{a_k ^ 2} = 0 \\\\ \\frac{\\partial L}{\\partial \\lambda} = \\sum_{i = 1} ^ {k}\\dfrac{x_i ^ 2}{a_i ^ 2} - 1 = 0 $$ 那么稍微化简一下，对于 $1 \\le i \\le k$ 都有 $$ \\prod_{i = 1} ^ {k}x_i = \\frac{-2\\lambda x_i ^ 2}{a_i ^ 2} $$ 通过任意两式 $1 \\le i, j \\le k$ 联立消掉 $\\lambda$ $$ \\frac{a_i ^ 2\\prod\\limits_{i = 1} ^ {k}x_i}{-2x_i ^ 2} = \\frac{a_j ^ 2\\prod\\limits_{i = 1} ^ {k}x_i}{-2x_j ^ 2} $$ 化简得 $$ \\frac{x_i}{a_i} = \\frac{x_j}{a_j} $$ 所以当且仅当 $\\dfrac{x_1}{a_1} = \\dfrac{x_2}{a_2}=\\cdots=\\dfrac{x_k}{a_k}$ 时取得最大值，且 $\\sum\\limits_{i = 1} ^ {k}\\dfrac{x_i ^ 2}{a_i ^ 2} = 1$，所以对任意 $1 \\le i \\le k$ 都有 $\\dfrac{x_i}{a_i} = \\pm \\sqrt{\\dfrac{1}{k}}$，那么 $\\prod\\limits_{i = 1} ^{k} x_i = k ^ {- \\frac{k}{2}}\\prod\\limits_{i = 1} ^ {k} a_i$，因为 $k$ 为偶数，所以一定为正，且 $\\dfrac{k}{2}$ 一定是整数。 求从 $b$ 数组中选出 $k$ 个数的所有乘积之和，考虑构造生成函数 $$ F(x) = \\prod_{i = 1} ^ {k} (1 + b_ix) $$ 那么 $[x ^ k]F(x)$ 就是选出 $k$ 个数的所有乘积之和，总共有 $\\dbinom{m}{k}$ 种选法，所以期望就为 $$ k ^ {-\\frac{k}{2}} \\times \\frac{[x ^ k]F(x)}{\\dbinom{m}{k}} $$ $F(x)$ 可用分治 $\\text{NTT}$ 计算，总时间复杂度 $O(n\\log ^ 2n)$ ","date":"2022-07-01","objectID":"/posts/cp2022-%E5%B9%BF%E4%B8%9C%E7%9C%81%E8%B5%9Bm-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/:0:0","tags":["多元函数极值","分治 NTT"],"title":"[2022 广东省赛M] 拉格朗日插值","uri":"/posts/cp2022-%E5%B9%BF%E4%B8%9C%E7%9C%81%E8%B5%9Bm-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*(Poly a, Poly b) { if (a.size() == 0 || b.size() == 0) { return Poly(); } int sz = 1, tot = a.size() + b.size() - 1; while (sz \u003c tot) { sz *= 2; } a.a.resize(sz); b.a.resize(sz); dft(a.a); dft(b.a); for (int i = 0; i \u003c sz; i ++) { a.a[i] = a[i] * b[i]; } idft(a.a); a.resize(tot); return a; } friend Poly operator*(Z a, Poly b) { for (int i = 0; i \u003c int(b.size()); i ++) { b[i] *= a; } return b; } friend Poly operator*(Poly a, Z b) { for (int i = 0; i \u003c int(a.size()); i ++) { a[i] *= b; } return a; } Poly \u0026operator+=(Poly b) { return (*this) = (*this) + b; } Poly \u0026operator-=(Poly b) { return (*this) = (*this) - b; } Poly \u0026operator*=(Poly b) { return (*this) = (*this) * b; } Poly deriv() const { if (a.empty()) { return Poly(); } vector\u003cZ\u003e res(size() - 1); for (int i = 0; i \u003c size","date":"2022-07-01","objectID":"/posts/cp2022-%E5%B9%BF%E4%B8%9C%E7%9C%81%E8%B5%9Bm-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/:1:0","tags":["多元函数极值","分治 NTT"],"title":"[2022 广东省赛M] 拉格朗日插值","uri":"/posts/cp2022-%E5%B9%BF%E4%B8%9C%E7%9C%81%E8%B5%9Bm-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/"},{"categories":["算法竞赛"],"content":"原题链接 题意 初始有 $n$ 个点，给定一个长度为 $n$ 的数组 $a_i$，若 $a_i \\ne -1$，则有无向边 $(i, a_i)$，若 $a_i = -1$，则点 $i$ 可以连向 $1 \\sim n$ 任意点，求所有图的联通块个数之和 $1 \\le n \\le 2 \\times 10 ^ 3, a_i \\in [1, n] \\cup {-1}$ 对 $998244353$ 取模。 分析： 首先考虑忽略 $a_i = -1$ 的所有边，那么图中会有若干个连通块，这些连通块分为三种情况： 树 基环树 环 对于环和基环树来说，因为是 $n$ 个点和 $n$ 条边，所以他们不可能有一条出边，换句话说，里边的点不可能包含 $a_i = -1$，而对于树来说，因为是 $n$ 个点 $n - 1$ 条边，所以有且仅有一条出边，也就是树里面只有一个 $a_i = -1$ 这就代表树可以和其他连通块组成一个新的连通块，但是无论树如何连边，环和基环树的连通性都不会发生变化，也就是他始终有一个环，所以可以先计算出这部分的贡献，设图中环和基环树的数量为 $u$，树的数量为 $v$，则这部分贡献就为 $u \\times n ^ {v}$ 接下来考虑树的所有连边情况，我们枚举 $k$ 条边组成一个环，设第 $i$ 棵树的大小为 $f_i$，每棵树则有生成函数 $1 + f_ix$，记 $F(x)$ 为选若干个树构成一个环的方案数，可以用分治 $\\text{NTT}$ 快速求出。 $$ F(x) = \\prod_{i = 1} ^ {v} (1 + f_ix) $$ 每个点构成一个 $k$ 元环是有顺序的，第一个点可以有 $k - 1$ 种选择，第二个点有 $k - 2$ 种选择，所以总共构成一个 $k$ 元环的方案数为 $(k - 1)!$，还要考虑剩下没有被选出来的点，那么可以随便连，都不影响这个环，方案数就为 $n ^ {v - k}$，那么答案就是 $$ u \\times n ^ {v} + \\sum_{k = 1} ^ {v} (k - 1)! \\times [x ^ k]F(x) \\times n ^ {v - k} $$ 时间复杂度 $O(n\\log ^ 2n)$ ","date":"2022-05-18","objectID":"/posts/cpatcoder-arc140-d-one-to-one/:0:0","tags":["图论","组合计数","分治 NTT"],"title":"[AtCoder arc140 D] One to One","uri":"/posts/cpatcoder-arc140-d-one-to-one/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; struct DSU { vector\u003cint\u003e p, Size; DSU(int n) : p(n), Size(n, 1) { iota(p.begin(), p.end(), 0); } int find(int x) { return p[x] == x ? p[x] : p[x] = find(p[x]); } bool same(int u, int v) { return find(u) == find(v); } void merge(int u, int v) { u = find(u), v = find(v); if (u != v) { Size[v] += Size[u]; p[u] = v; } } }; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*(Poly a, Poly b) { if (a.size() == 0 || b.size() == 0) { return Poly(); } int sz = 1, tot = a.size() + b.size() - 1; while (sz \u003c tot) { sz *= 2; } a.a.resize(sz); b.a.resize(sz); dft(a.a); dft(b.a); for (int i = 0; i \u003c sz; i ++) { a.a[i] = a[i] * b[i]; } idft(a.a); a.resize(tot); return a; } friend Poly operator*(Z a, Poly b) { for (int i = 0; i \u003c int(b.size()); i ++) { b[i] *= a; } return b; } friend Poly operator*(Poly a, Z b) { for (int i = 0; i \u003c int(a.size","date":"2022-05-18","objectID":"/posts/cpatcoder-arc140-d-one-to-one/:1:0","tags":["图论","组合计数","分治 NTT"],"title":"[AtCoder arc140 D] One to One","uri":"/posts/cpatcoder-arc140-d-one-to-one/"},{"categories":["算法竞赛"],"content":"原题链接 题意 有 $n$ 种体积为 $1$ 的物品和 $m$ 种体积为 $2$ 的物品，求选择物品的体积为 $k$ 的方案数 对 $998244353$ 取模 $(1 \\le n, m \\le 10 ^ 6,1 \\le k \\le 9 \\times 10 ^ 8)$ 分析： 所有体积为 $1$ 的生成函数为 $$ F(x) = \\left ( \\sum_{i = 0} ^ {\\infty} x ^ i \\right ) ^ n $$ 所有体积为 $2$ 的生成函数为 $$ G(x) = \\left ( \\sum_{i = 0} ^ {\\infty} x ^ {2i} \\right ) ^ m $$ 那么组成的所有体积方案数为 $F(x) \\times G(x)$ 把 $F(x)$ 和 $G(x)$ 写成形式幂级数的逆的形式就为 $$ \\frac{1}{(1-x) ^ n(1 - x ^ 2) ^ m} $$ 为了使分母的形式一致，对分数上下乘 $(1 + x) ^ n$ $$ \\frac{(1 + x) ^ n}{(1 - x ^ 2) ^ {n + m}} $$ 再把 $\\dfrac{1}{(1 - x ^ 2) ^ {n + m}}$ 转为一般形式 $\\sum\\limits_{j = 0} ^ {\\infty} \\binom{j + n + m - 1}{n + m - 1} x ^ {2j}$ 那么 $(1 + x) ^ n$ 也对应二项式展开 $\\sum\\limits_{i = 0} ^ {n} \\binom{n}{i} x ^ i$ 因为我们要求第 $k$ 项的系数，所以考虑 $x ^ i$ 与 $x ^ {2j}$ 凑出 $x ^ k$ 的所有项， 也就是 $i + 2 j = k$，整理出 $j = \\dfrac{k - i}{2}$ 由于 $i \\in [0, n]$ 所以可以 $O(n)$ 枚举 $i$ 的范围，即 $$ \\sum_{i = 0} ^ {n} [(k - i) \\bmod 2 = 0] \\binom{n}{i} \\binom{\\dfrac{k - i}{2} + n + m - 1}{n + m - 1} $$ 每次 $\\dfrac{k - i}{2}$ 只会减少 $1$，所以对第二个的组合数可以递推求解，分母一定是 $(n + m - 1)!$，那么分子每次必定会减少 $1$，所以只需要维护 $a$ 为第一次的 $\\dfrac{k - i}{2} + 1$，之后每次乘 $a + n + m$ 的逆元再乘 $a - 1$ 就是答案 ($a$ 每次自减 $1$) ","date":"2022-04-27","objectID":"/posts/cpwannafly-28-msc%E7%9A%84%E8%83%8C%E5%8C%85/:0:0","tags":["组合数","生成函数"],"title":"[Wannafly 28] msc的背包","uri":"/posts/cpwannafly-28-msc%E7%9A%84%E8%83%8C%E5%8C%85/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int mod = 998244353; int qmi(int a, int b) { int res = 1; while (b) { if (b \u0026 1) res = res * a % mod; a = a * a % mod; b \u003e\u003e= 1; } return res; } vector\u003cint\u003e fact, infact; void init(int n) { fact.resize(n + 1), infact.resize(n + 1); fact[0] = infact[0] = 1; for (int i = 1; i \u003c= n; i ++) { fact[i] = fact[i - 1] * i % mod; } infact[n] = qmi(fact[n], mod - 2); for (int i = n; i; i --) { infact[i - 1] = infact[i] * i % mod; } } int C(int n, int m) { if (n \u003c 0 || m \u003c 0 || n \u003c m) return 0; return fact[n] * infact[n - m] % mod * infact[m] % mod; } signed main() { cin.tie(0) -\u003e sync_with_stdio(0); init(1e6); int n, m, k; cin \u003e\u003e n \u003e\u003e m \u003e\u003e k; int res = 0; int inv = 1; for (int i = 1; i \u003c= n + m - 1; i ++) { inv = inv * i % mod; } inv = qmi(inv, mod - 2); int flag = 0, sum = 1, last = 0; for (int i = 0; i \u003c= n; i ++) { if ((k - i) % 2 == 0) { if (!flag) { flag = 1; for (int j = 1; j \u003c= n + m - 1; j ++) { sum = sum * ((k - i) / 2 + j) % mod; } last = (k - i) / 2 + 1; } else { last --; sum = sum * qmi((k - i) / 2 + n + m, mod - 2) % mod; sum = sum * last % mod; } res = (res + C(n, i) * sum % mod * inv % mod) % mod; } } cout \u003c\u003c res \u003c\u003c endl; } ","date":"2022-04-27","objectID":"/posts/cpwannafly-28-msc%E7%9A%84%E8%83%8C%E5%8C%85/:1:0","tags":["组合数","生成函数"],"title":"[Wannafly 28] msc的背包","uri":"/posts/cpwannafly-28-msc%E7%9A%84%E8%83%8C%E5%8C%85/"},{"categories":["算法竞赛"],"content":"原题链接 题意 给定三个正整数 $n, d, k$ ，现有排列 $p = (1,2,3,\\cdots,n)$ ，有 $n - d + 1$ 个询问，对于每个询问有正整数 $m (d \\le m \\le n)$ ，现从 $p$ 中随机可重复地选取 $m$ 个数构成序列 $q$ ，求 $q$ 中第 $d$ 小数大于 $k$ 的概率， 对 $998244353$ 取模。 分析： 对于满足第 $d$ 小数大于 $k$ 的序列 $q = (a_1, a_2, \\cdots,a_i,\\cdots,a_m)$ ，假设最后一个小于等于 $k$ 的数为 $a_i$，那么一定有 $i \\le d - 1$，所以前 $i$ 个数一定要在 $1 \\sim k$ 中任取，方案记为 $F(x)$，那么后 $m - i$ 个数一定要在 $k +1 \\sim n$ 中取，方案记为 $G(x)$，可以考虑写出 $F(x)$ 与 $G(x)$ 的生成函数，因为数是可排列的，所以要用 $\\textbf{EGF}$ 在 $1 \\sim k$ 中取 $i$ 个数的方案数为 $k ^ i$，作为 $F(x)$ 取 $i$ 个数生成函数的系数，$1 \\sim k$ 中至多取 $d - 1$ 个数，所以 $F(x)$ 的项数为 $d$ $$ F(x) = 1+\\frac{k^1}{1!}x^1 + \\frac{k^2}{2!}x^2+\\cdots+\\frac{k^{d - 1}}{(d-1)!}x^{d - 1} $$ 在 $k + 1 \\sim n$ 中取 $i$ 个数的方案数为 $(n - k) ^ {i}$，作为 $G(x)$ 取 $i$ 个数生成函数的系数，$k + 1 \\sim n$ 中可以取至多 $n$ 个数，所以 $G(x)$ 项数为 $n + 1$ $$ G(x) = 1 + \\frac{(n - k) ^1}{1!}x^1 + \\frac{(n - k)^2}{2!}x^2 + \\cdots + \\frac{(n - k) ^ n}{n!}x^n $$ 那么选 $m$ 个数满足第 $d$ 小数大于 $k$ 的总方案数就为 $m!\\times[x^m] F(x)G(x)$，所有取数的情况为 $n ^ m$，所以概率就为 $$ \\frac{m!\\times[x^m] F(x)G(x)}{n ^m} $$ 可以用 $\\text{NTT}$ 算出 $F(x) * G(x)$ 时间复杂度 $O(n\\log n)$ ","date":"2022-04-13","objectID":"/posts/cp2020-bsuirpc-function-analysis/:0:0","tags":["EGF","NTT"],"title":"[2020 BSUIRPC] Function analysis","uri":"/posts/cp2020-bsuirpc-function-analysis/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*(Poly a, Poly b) { if (a.size() == 0 || b.size() == 0) { return Poly(); } int sz = 1, tot = a.size() + b.size() - 1; while (sz \u003c tot) { sz *= 2; } a.a.resize(sz); b.a.resize(sz); dft(a.a); dft(b.a); for (int i = 0; i \u003c sz; i ++) { a.a[i] = a[i] * b[i]; } idft(a.a); a.resize(tot); return a; } friend Poly operator*(Z a, Poly b) { for (int i = 0; i \u003c int(b.size()); i ++) { b[i] *= a; } return b; } friend Poly operator*(Poly a, Z b) { for (int i = 0; i \u003c int(a.size()); i ++) { a[i] *= b; } return a; } Poly \u0026operator+=(Poly b) { return (*this) = (*this) + b; } Poly \u0026operator-=(Poly b) { return (*this) = (*this) - b; } Poly \u0026operator*=(Poly b) { return (*this) = (*this) * b; } Poly deriv() const { if (a.empty()) { return Poly(); } vector\u003cZ\u003e res(size() - 1); for (int i = 0; i \u003c size","date":"2022-04-13","objectID":"/posts/cp2020-bsuirpc-function-analysis/:1:0","tags":["EGF","NTT"],"title":"[2020 BSUIRPC] Function analysis","uri":"/posts/cp2020-bsuirpc-function-analysis/"},{"categories":["杂项"],"content":"今晚闲来无事看了看 $2022$ 年的济南一模最后一题第三问，发现真的是两年没碰高考数学手生疏了，不过还好做出来了。 题意 证明 $$ \\sum_{x = 2}^{n} \\frac{1}{\\ln x} \u003e 1 - \\frac{1}{n} $$ 分析： $1 - \\dfrac{1}{n} = \\dfrac{n - 1}{n}$，左边是 $n$ 个数求和，所以考虑裂项右边 $$ \\frac{n - 1}{n} = \\frac{1}{1 \\times 2} + \\frac{1}{2 \\times 3} + \\cdots + \\frac{1}{(n - 1) \\times n} $$ 接下来只需证 $x ^ 2 - x - \\ln x \u003e 0 (x \\ge 2)$ 设 $f(x) = x ^ 2 - x - \\ln x$ 则 $f’(x) = \\dfrac{(2x+ 1)(x-1)}{x} \u003e 0$ 由于 $f(2) = 2 - \\ln2 \u003e 0$ 所以 $f(x)\u003e 0$ ","date":"2022-04-06","objectID":"/posts/misc%E8%AE%B0%E4%B8%80%E4%B8%AA%E7%BB%8F%E5%85%B8%E4%B8%8D%E7%AD%89%E5%BC%8F%E6%94%BE%E7%BC%A9/:0:0","tags":["高考数学"],"title":"记一个经典不等式放缩","uri":"/posts/misc%E8%AE%B0%E4%B8%80%E4%B8%AA%E7%BB%8F%E5%85%B8%E4%B8%8D%E7%AD%89%E5%BC%8F%E6%94%BE%E7%BC%A9/"},{"categories":["算法竞赛"],"content":"原题链接 题意 给定一个长度为 $n$ 的 $1 \\sim n$ 排列 $P$，找到有多少个 $1 \\sim n$ 的排列 $Q$ 使得 $\\forall i \\in[1, n - 1], Q_{i + 1} \\ne P_{Q_i}$ 对 $998244353$ 取模 $(1 \\le n \\le 10 ^ 5, 1 \\le P_i \\le n)$ 分析： 如果只观察式子可能看不出什么规律，我们可以把条件转化为 $n$ 个点的图，考虑把排列 $Q$ 表示为边集 ${(Q_1, Q_2),(Q_2, Q_3),\\cdots,(Q_{n-1},Q_n)}$ ，那么排列 $P$ 的意思就是图中不能存在边集 ${(1,P_1),(2,P_2),\\cdots,(n,P_n)}$ ，那么就等价于在一张图中选一条哈密顿路径的方案数，所以考虑对每条不存在的边集进行容斥。考虑计算选了 $i$ 个不存在的边的方案数，发现排列 $P$ 一定会成环，所以对于每个 $k$ 元环可以选择 $0 \\sim k - 1$ 个不存在的边(哈密顿路径无环所以不能包含 $k$ 个不存在的边)，那么可以用生成函数 $f(k)$ 来表示 $$ f(k) = 1 + \\binom{k}{1}x + \\binom{k}{2}x ^ 2 + \\binom{k}{3}x ^ 3 + \\cdots + \\binom{k}{k - 1}x ^ {k - 1} $$ $x$ 项的系数 $m$ 表示 $k$ 元环中选了 $m$ 条不存在的边，那么系数显然是 $\\dbinom{k}{m}$ 所以只需找出排列 $P$ 的所有环及其环的大小，假设有 $t$ 个 $a_1,a_2,\\cdots,a_t$ ，$a_i$ 表示第 $i$ 个环的大小。 那么方案就是 $$ \\prod_{i = 1} ^ {t} f(a_i) $$ 做一次分治 $\\text{NTT}$ 或启发式合并得到多项式 $F(x)$ 最后容斥计算答案，钦定选了 $i$ 条不存在的边其他边的数量就是 $(n - i)!$ 那么最后的答案就为 $$ \\sum_{i = 0} ^ {n}(-1) ^ i(n - i)![x^i]F(x) $$ 时间复杂度 $O(n\\log ^2n)$ ","date":"2022-03-26","objectID":"/posts/cp2021icpc%E4%B8%8A%E6%B5%B7-b-strange-permutations/:0:0","tags":["容斥原理","分治 NTT"],"title":"[2021ICPC上海 B] Strange Permutations","uri":"/posts/cp2021icpc%E4%B8%8A%E6%B5%B7-b-strange-permutations/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*(Poly a, Poly b) { if (a.size() == 0 || b.size() == 0) { return Poly(); } int sz = 1, tot = a.size() + b.size() - 1; while (sz \u003c tot) { sz *= 2; } a.a.resize(sz); b.a.resize(sz); dft(a.a); dft(b.a); for (int i = 0; i \u003c sz; i ++) { a.a[i] = a[i] * b[i]; } idft(a.a); a.resize(tot); return a; } friend Poly operator*(Z a, Poly b) { for (int i = 0; i \u003c int(b.size()); i ++) { b[i] *= a; } return b; } friend Poly operator*(Poly a, Z b) { for (int i = 0; i \u003c int(a.size()); i ++) { a[i] *= b; } return a; } Poly \u0026operator+=(Poly b) { return (*this) = (*this) + b; } Poly \u0026operator-=(Poly b) { return (*this) = (*this) - b; } Poly \u0026operator*=(Poly b) { return (*this) = (*this) * b; } Poly deriv() const { if (a.empty()) { return Poly(); } vector\u003cZ\u003e res(size() - 1); for (int i = 0; i \u003c size","date":"2022-03-26","objectID":"/posts/cp2021icpc%E4%B8%8A%E6%B5%B7-b-strange-permutations/:1:0","tags":["容斥原理","分治 NTT"],"title":"[2021ICPC上海 B] Strange Permutations","uri":"/posts/cp2021icpc%E4%B8%8A%E6%B5%B7-b-strange-permutations/"},{"categories":["算法竞赛"],"content":"原题链接 ","date":"2022-02-04","objectID":"/posts/cp2021ccpc-%E5%A8%81%E6%B5%B7m-810975/:0:0","tags":["组合计数","容斥原理","多项式快速幂"],"title":"[2021CCPC 威海M] 810975","uri":"/posts/cp2021ccpc-%E5%A8%81%E6%B5%B7m-810975/"},{"categories":["算法竞赛"],"content":"前言 今天看了衣锦夜行 $2021$ 年度 $\\text{top10}$，看完 $810975$ 突然想起来这题还没补完代码，最近又刚学习了一点多项式，学完多项式快速幂之后终于可以补这道题了，所以决定重新写一遍对这个题发一个重制版的题解 先科普一下 $810975$ 是什么意思：知名炉石传说主播衣锦夜行在 $8$ 月 $10$ 号打了 $9$ 盘酒馆战旗，吃了 $7$ 鸡，其中一个还是 $5$ 连鸡，后来多次在直播间疯狂吹嘘自己，节目效果拉满 https://www.bilibili.com/video/BV1Uy4y1V75X 后来上了 $317$ 期的逗鱼时刻，片尾给夜吹做了一个鬼畜 https://www.bilibili.com/video/BV11f4y1H7TJ 深刻的被洗脑了，$810975$ 还荣登 $2021$ 逗鱼时刻 $\\text{TOP50}$ 的 $\\text{TOP0}$ (压轴级别) 顺带一提，衣锦夜行是我最喜欢的主播，技术不错虽然有时候嘴很硬，因夺得 $2020$ 年世俱杯冠军被称为“世界冠军”，可惜现在只有 $8000$ 分左右，但是我最赞同他的一句话：分数没有意义，快乐才是真谛。 题意 夜吹下了 $n$ 盘酒馆战旗，吃了 $m$ 次鸡，并且 $k$ 连鸡，求方案数对 $998244353$ 取模。 $0 \\le n,m,k \\le 10^5$ 分析： 已知下了 $n$ 盘棋，吃了 $m$ 次鸡，所以有 $n - m$ 局是未吃鸡的，所以考虑把 $m$ 次鸡插空，$n - m$ 局未吃鸡局有 $n - m + 1$ 个空位，那么每个空的生成函数为 $$ 1+x+x^2+x^3+\\cdots+x^k $$ 所以所有的方案数就为 $$[x ^ m](1+x+x^2+x^3+\\cdots+x^k)^{n - m + 1}$$ $[x^m]$ 表示 $m$ 次项的系数 记 $f(k)$ 为 $n$ 把 $m$ 鸡 小于等于 $k$ 连鸡的方案数 那么答案就为 $f(k) - f(k - 1)$，可以用多项式快速幂来求解 ","date":"2022-02-04","objectID":"/posts/cp2021ccpc-%E5%A8%81%E6%B5%B7m-810975/:1:0","tags":["组合计数","容斥原理","多项式快速幂"],"title":"[2021CCPC 威海M] 810975","uri":"/posts/cp2021ccpc-%E5%A8%81%E6%B5%B7m-810975/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; using i64 = long long; constexpr int mod = 998244353; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*(Poly a, Poly b) { if (a.size() == 0 || b.size() == 0) { return Poly(); } int sz = 1, tot = a.size() + b.size() - 1; while (sz \u003c tot) { sz *= 2; } a.a.resize(sz); b.a.resize(sz); dft(a.a); dft(b.a); for (int i = 0; i \u003c sz; i ++) { a.a[i] = a[i] * b[i]; } idft(a.a); a.resize(tot); return a; } friend Poly operator*(Z a, Poly b) { for (int i = 0; i \u003c int(b.size()); i ++) { b[i] *= a; } return b; } friend Poly operator*(Poly a, Z b) { for (int i = 0; i \u003c int(a.size()); i ++) { a[i] *= b; } return a; } Poly \u0026operator+=(Poly b) { return (*this) = (*this) + b; } Poly \u0026operator-=(Poly b) { return (*this) = (*this) - b; } Poly \u0026operator*=(Poly b) { return (*this) = (*this) * b; } Poly deriv() const { if (a.empty()) { return Poly(); } vector\u003cZ\u003e res(size() - 1); for (int i = 0; i \u003c size","date":"2022-02-04","objectID":"/posts/cp2021ccpc-%E5%A8%81%E6%B5%B7m-810975/:2:0","tags":["组合计数","容斥原理","多项式快速幂"],"title":"[2021CCPC 威海M] 810975","uri":"/posts/cp2021ccpc-%E5%A8%81%E6%B5%B7m-810975/"},{"categories":["算法竞赛"],"content":"动态规划的引入：斐波那契数列 题目链接 已知斐波那契数列 $f_1 = 1, f_2 = 1, f_i = f_{i - 1} + f_{i - 2}, i \\ge 3$ ，给定正整数 $n$ ，求 $f_n \\bmod 10 ^ 9 + 7$ $3 \\le n \\le 2 \\times 10^6$ 直观上可以采用最暴力的方法，递归。 递归代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int mod = 1e9 + 7; int n; int f(int n) { if (n == 1 || n == 2) return 1; return (f(n - 1) + f(n - 2)) % mod; } signed main() { cin \u003e\u003e n; cout \u003c\u003c f(n) \u003c\u003c endl; } 可以试一下，这种方法在 $n = 45$ 时就会超时，原因是递归耗费了大量的时间，计算了许多重复的子问题。 假设 $n = 5$ 那么计算 $f_5$ 会先计算 $f_3, f_4$ ，计算 $f_3$ 会计算 $f_1,f_2$ ，计算 $f_4$ 会计算 $f_2,f_3$ ，这样 $f_3$ 就被计算了 $2$ 次，如果规模更大，会被重复计算很多次，我们称为**重复子问题 **。 那么要避免重复计算情况我们可以用一个数组来保存计算的结果，使得每个值只会被计算 $1$ 次，我们称为记忆化搜索。 记忆化搜索代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 2e6 + 5, mod = 1e9 + 7; int n, dp[N]; int f(int n) { if (dp[n]) return dp[n]; return dp[n] = (f(n - 1) + f(n - 2)) % mod; } signed main() { dp[1] = dp[2] = 1; cin \u003e\u003e n; cout \u003c\u003c f(n) \u003c\u003c endl; } 也可以直接用数组转移，这是一般 $\\text{DP}$ 的常规写法 DP代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 2e6 + 5, mod = 1e9 + 7; int n, dp[N]; signed main() { dp[1] = dp[2] = 1; for (int i = 3; i \u003c N; i ++) dp[i] = (dp[i - 1] + dp[i - 2]) % mod; cin \u003e\u003e n; cout \u003c\u003c dp[n] \u003c\u003c endl; } 如此可以对动态规划做一个总结： 1.最优子结构：$f(n)$ 的最优解可以由 $f(n−2)$ 和 $f(n−1)$ 的最优解推出。 2.无后效性：要求 $f(n)$，只需要求 $f(n−1)$ 和 $f(n−2)$，无需关心 $f(n - 1)$ 和 $f(n - 2)$ 是怎么得到的。 3.状态：求解过程进行到了哪一步，可以理解为一个子问题。 4.转移：$f_i = f_{i - 1} + f_{i - 2}$ ","date":"2022-01-15","objectID":"/posts/cpdp/:1:0","tags":["DP"],"title":"DP","uri":"/posts/cpdp/"},{"categories":["算法竞赛"],"content":"数字三角形： 题目链接 给定一个由 $n$ 行数字组成的数字三角形 $a_{i, j} (j \\le i)$，计算出从三角形的顶至底的一条路径，使该路径经过的数字总和最大。$(1 \\le n \\le 5 \\times 10 ^2, - 10^4 \\le a_{i, j} \\le 10 ^ 4)$ 状态表示：$dp_{i,j}$ 表示从起点走到 $(i, j)$ 的路径总和最小值。 状态转移：在点 $(i, j)$ 处只可能由两个点转移过来，分别是 $(i - 1, j - 1)$ 和 $(i - 1, j)$，所以该点的状态转移方程就是 $$ dp_{i,j} = \\max(dp_{i - 1, j - 1}, dp_{i - 1, j}) + a_{i, j} $$ 初始状态：因为我们要取最大值，所以一开始把所有状态更新为 $-\\infty$ 并且 $(0, 0)$ 点的 $dp_{0, 0} = 0$ 答案：根据状态和题意，我们需要找到底部的一个最优值，所以就遍历一遍最底部的一层 (枚举列)，来得到答案，即 $$ \\max_{i = 1} ^ {n} dp_{n, i} $$ 代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 5e2 + 5; int n, a[N][N], dp[N][N], res = -2e9; signed main() { memset(dp, -0x3f, sizeof dp); dp[0][0] = 0; cin \u003e\u003e n; for (int i = 1; i \u003c= n; i ++) { for (int j = 1; j \u003c= i; j ++) { cin \u003e\u003e a[i][j]; } } for (int i = 1; i \u003c= n; i ++) { for (int j = 1; j \u003c= i; j ++) { dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j]) + a[i][j]; } } for (int i = 1; i \u003c= n; i ++) res = max(res, dp[n][i]); cout \u003c\u003c res \u003c\u003c endl; } ","date":"2022-01-15","objectID":"/posts/cpdp/:2:0","tags":["DP"],"title":"DP","uri":"/posts/cpdp/"},{"categories":["算法竞赛"],"content":"最长上升子序列 题目链接 给定一个长度为 $n$ 的数列 $a$，求数值严格单调递增的非空子序列的最长长度。 $(1 \\le n \\le 10^3,-10^9 \\le a_i \\le 10 ^ 9)$ 状态表示：$dp_i$ 表示以 $a_i$ 结尾的最长上升子序列的长度。 状态转移：对于每个 $a_i$，枚举 $j \\in [1, i - 1]$ 让 $a_i$ 接到 $a_j$ 后面的最优解，也就是 $$ dp_i = \\max_{j = 1} ^{i - 1} (dp_j + 1, dp_i)[a_j \u003c a_i] $$ 初始状态：$dp_{1 \\sim n} = 1$ 每个数都是一个长度为 $1$ 的子序列。 答案：枚举可能作为最长上升子序列结尾的 $a_i$，取一遍最大值，即 $$ \\max_{i = 1} ^ {n} dp_i $$ 代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 1e3 + 5; int n, dp[N], a[N], res; signed main() { cin \u003e\u003e n; for (int i = 1; i \u003c= n; i ++) cin \u003e\u003e a[i]; for (int i = 1; i \u003c= n; i ++) { dp[i] = 1; for (int j = 1; j \u003c i; j ++) { if (a[j] \u003c a[i]) { dp[i] = max(dp[j] + 1, dp[i]); } } res = max(res, dp[i]); } cout \u003c\u003c res \u003c\u003c endl; } ","date":"2022-01-15","objectID":"/posts/cpdp/:3:0","tags":["DP"],"title":"DP","uri":"/posts/cpdp/"},{"categories":["算法竞赛"],"content":"最长公共子序列 题目链接 给定两个长度分别为 $n$ 和 $m$ 的字符串 $a$ 和 $b$，求既是 $a$ 的子序列又是 $b$ 的子序列的字符串的最长长度。 $(1 \\le n,m \\le 10^3)$ 状态表示：$dp_{i, j}$ 表示 $a$ 的前 $i$ 个字母和 $b$ 的前 $j$ 个字母的最长公共子序列。 状态转移：从小到大枚举 $a, b$ 所有不同位置 $i, j$ 的情况，如果 $a_i = b_j$ 说明遇到了公共部分，那么 $dp_{i, j}$ 应该从 $dp_{i - 1, j - 1}$ 转移过来，否则，就一定要舍弃 $a_i, b_j$ 中的一个字母，就取两种情况的最大值，即 $$ \\begin{cases} dp_{i, j} = \\max(dp_{i,j}, dp_{i - 1, j - 1} + 1) \u0026a_i = a_j \\ dp_{i, j} = \\max(dp_{i - 1, j}, dp_{i, j - 1}) \u0026a_i \\ne a_j \\end{cases} $$ 初始状态：所有状态初始为 $0$ 答案：$a$ 中全部的字母和 $b$ 中全部的字母组成的最长上升子序列，即 $dp_{n, m}$ 代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 1e3 + 5; int n, m, dp[N][N]; char a[N], b[N]; signed main() { cin \u003e\u003e n \u003e\u003e m \u003e\u003e a + 1 \u003e\u003e b + 1; for (int i = 1; i \u003c= n; i ++) { for (int j = 1; j \u003c= m; j ++) { if (a[i] == b[j]) { dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1); } else { dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } } cout \u003c\u003c dp[n][m] \u003c\u003c endl; } ","date":"2022-01-15","objectID":"/posts/cpdp/:4:0","tags":["DP"],"title":"DP","uri":"/posts/cpdp/"},{"categories":["算法竞赛"],"content":"原题链接 题意 给定一个长度为 $n$ 的字符串 $S$，计算有多少种非空子序列的排列，对 $998244353$ 取模。 $1 \\le n \\le 5\\times 10^3$ 分析： 设 $26$ 个英文字母每个字母 $u$ 的生成函数为（因为要计算排列，所以是 $\\textbf{EGF}$） $$ 1 + \\frac{1}{1!}x + \\frac{1}{2!}x^2 + \\cdots + \\frac{1}{cnt_{u}!}x^{cnt_{u}} $$ 其中 $cnt_{u}$ 为字母在 $S$ 中出现次数。 那么最终所有方案为 $$ \\prod_{u = 1} ^{26}(1 + \\frac{1}{1!}x + \\frac{1}{2!}x^2 + \\cdots + \\frac{1}{cnt_{u}!}x^{cnt_{u}}) $$ 记所有方案为 $F(x)$，那么计算子序列的方案数就是把字符串长度为 $1 \\sim n$ 的所有方案乘长度的阶乘加起来，即 $$ \\sum_{i = 1}^{n}i! \\times [x^i]F(x) $$ 因为最多只有 $26$ 个字母，所以直接每次暴力 $\\text{NTT}$ 即可，当然也可以分治 $\\text{NTT}$ 官方标程是 $\\text{DP}$，可以发现多项式比标程快一些。 ","date":"2022-01-09","objectID":"/posts/cpatcoder-abc234-f-reordering/:0:0","tags":["NTT","EGF"],"title":"[AtCoder abc234 F] Reordering","uri":"/posts/cpatcoder-abc234-f-reordering/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; constexpr int mod = 998244353; using i64 = long long; int norm(int x) { if (x \u003c 0) { x += mod; } if (x \u003e= mod) { x -= mod; } return x; } template\u003cclass T\u003e T power(T a, int b) { T res = 1; for (; b; b /= 2, a *= a) { if (b % 2) { res *= a; } } return res; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return power(*this, mod - 2); } Z \u0026operator*=(const Z \u0026rhs) { x = i64(x) * rhs.x % mod; return *this; } Z \u0026operator+=(const Z \u0026rhs) { x = norm(x + rhs.x); return *this; } Z \u0026operator-=(const Z \u0026rhs) { x = norm(x - rhs.x); return *this; } Z \u0026operator/=(const Z \u0026rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026lhs, const Z \u0026rhs) { Z res = lhs; res /= rhs; return res; } friend istream \u0026operator\u003e\u003e(istream \u0026is, Z \u0026a) { i64 v; is \u003e\u003e v; a = Z(v); return is; } friend ostream \u0026operator\u003c\u003c(ostream \u0026os, const Z \u0026a) { return os \u003c\u003c a.val(); } }; vector\u003cint\u003e rev; vector\u003cZ\u003e roots{0, 1}; void dft(vector\u003cZ\u003e \u0026a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u003c n; i ++) { rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c k; } } for (int i = 0; i \u003c n; i ++) { if (rev[i] \u003c i) { swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u003c n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u003c\u003c k) \u003c n) { Z e = power(Z(3), (mod - 1) \u003e\u003e (k + 1)); for (int i = 1 \u003c\u003c (k - 1); i \u003c (1 \u003c\u003c k); i ++) { roots[i \u003c\u003c 1] = roots[i]; roots[i \u003c\u003c 1 | 1] = roots[i] * e; } k ++; } } for (int k = 1; k \u003c n; k *= 2) { for (int i = 0; i \u003c n; i += 2 * k) { for (int j = 0; j \u003c k; j ++) { Z u = a[i + j], v = a[i + j + k] * roots[k + j]; a[i + j] = u + v, a[i + j + k] = u - v; } } } } void idft(vector\u003cZ\u003e \u0026a) { int n = a.size(); reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - mod) / n; for (int i = 0; i \u003c n; i ++) { a[i] *= inv; } } struct Poly { vector\u003cZ\u003e a; Poly() {} Poly(const vector\u003cZ\u003e \u0026a) : a(a) {} Poly(const initializer_list\u003cZ\u003e \u0026a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u003c size()) { return a[idx]; } else { return 0; } } Z \u0026operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = min(k, size()); return Poly(vector\u003cZ\u003e(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u003c= k) { return Poly(); } return Poly(vector\u003cZ\u003e(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026a, const Poly \u0026b) { vector\u003cZ\u003e res(max(a.size(), b.size())); for (int i = 0; i \u003c int(res.size()); i ++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*(Poly a, Poly b) { if (a.size() == 0 || b.size() == 0) { return Poly(); } int sz = 1, tot = a.size() + b.size() - 1; while (sz \u003c tot) { sz *= 2; } a.a.resize(sz); b.a.resize(sz); dft(a.a); dft(b.a); for (int i = 0; i \u003c sz; i ++) { a.a[i] = a[i] * b[i]; } idft(a.a); a.resize(tot); return a; } friend Poly operator*(Z a, Poly b) { for (int i = 0; i \u003c int(b.size()); i ++) { b[i] *= a; } return b; } friend Poly operator*(Poly a, Z b) { for (int i = 0; i \u003c int(a.size()); i ++) { a[i] *= b; } return a; } Poly \u0026operator+=(Poly b) { return (*this) = (*this) + b; } Poly \u0026operator-=(Poly b) { return (*this) = (*this) - b; } Poly \u0026operator*=(Poly b) { return (*this) = (*this) * b; } Poly deriv() const { if (a.empty()) { return Poly(); } vector\u003cZ\u003e res(size() - 1); for (int i = 0; i \u003c size","date":"2022-01-09","objectID":"/posts/cpatcoder-abc234-f-reordering/:1:0","tags":["NTT","EGF"],"title":"[AtCoder abc234 F] Reordering","uri":"/posts/cpatcoder-abc234-f-reordering/"},{"categories":["算法竞赛"],"content":"原题链接 题意 给定一个 $n$ 个点 $m$ 条边的图，有不超过 $40000$ 次的操作，每次操作有三个参数 $op, u, v$ 若 $op =0$ ，表示删除点 $u,v$ 之间的边 若 $op = 1$，表示询问 $u, v$ 之间有多少关键边 关键边： $u, v$ 联通，若删除该边 $u, v$ 不连通，则为关键边 分析： 最朴素的想法是每次删完边之后 $\\text{tarjan}$ 缩点，再维护树上两点距离，但这样显然会超时。 所以考虑逆序离线处理。 我们发现如果是一棵树，那么所有的边都是关键边，$u, v$ 两点的关键边数量就等于 $u, v$ 树上两点距离。并且在树上任意两点加一条边都会形成一个环，环内所有的边都不可能成为关键边，所以此时只需要将这两点路径上的每一条边的权值都变为 $0$ ，这个操作可以用树链剖分线段树维护。 先在图中随意找一颗生成树，可以用并查集维护，把这些树边标记一下，那么其他未标记的边就是要成环的边，也就是要进行路径上赋值为 $0$ 的点对。 之后读入操作，把要删除的边以点对的形式用 $\\text{STL map}$ 维护，这些点对相当于覆盖一开始要进行路径上赋值为 $0$ 的点对，最后逆序地处理询问，逆序输出结果即可。 ","date":"2021-12-10","objectID":"/posts/cpahoi2015-%E8%88%AA%E7%BA%BF%E8%A7%84%E5%88%92/:0:0","tags":["离线","树链剖分"],"title":"[AHOI2015] 航线规划","uri":"/posts/cpahoi2015-%E8%88%AA%E7%BA%BF%E8%A7%84%E5%88%92/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long #define x first #define y second #define PII pair\u003cint, int\u003e using namespace std; const int N = 1e5 + 5, M = N \u003c\u003c 1; int n, m, u[N], v[N], op, cnt, h[N], e[M], ne[M], idx, Size[N], top[N], dep[N], fa[N], son[N], id[N], Cnt, p[N]; bool st[N]; map\u003cPII, int\u003e mp; vector\u003cint\u003e ans; struct Query { int op, u, v; } q[N]; struct SegmentTree { int l, r, add, sum; } tr[N \u003c\u003c 2]; int find(int x) { return p[x] == x ? p[x] : p[x] = find(p[x]); } void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++; } void dfs1(int u, int father, int depth) { dep[u] = depth, fa[u] = father, Size[u] = 1; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == father) continue; dfs1(j, u, depth + 1); Size[u] += Size[j]; if (Size[son[u]] \u003c Size[j]) son[u] = j; } } void dfs2(int u, int t) { id[u] = ++ Cnt, top[u] = t; if (!son[u]) return ; dfs2(son[u], t); for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == fa[u] || j == son[u]) continue; dfs2(j, j); } } void pushup(int u) { tr[u].sum = tr[u \u003c\u003c 1].sum + tr[u \u003c\u003c 1 | 1].sum; } void pushdown(int u) { if (tr[u].add != -1) { tr[u \u003c\u003c 1].add = tr[u \u003c\u003c 1 | 1].add = tr[u].add; tr[u \u003c\u003c 1].sum = (tr[u \u003c\u003c 1].r - tr[u \u003c\u003c 1].l + 1) * tr[u].add; tr[u \u003c\u003c 1 | 1].sum = (tr[u \u003c\u003c 1 | 1].r - tr[u \u003c\u003c 1 | 1].l + 1) * tr[u].add; tr[u].add = -1; } } void build(int u, int l, int r) { if (l == r) { tr[u] = {l, r, -1, 1}; } else { tr[u] = {l, r, -1}; int mid = l + r \u003e\u003e 1; build(u \u003c\u003c 1, l, mid), build(u \u003c\u003c 1 | 1, mid + 1, r); pushup(u); } } void modify(int u, int l, int r, int c) { if (tr[u].l \u003e= l \u0026\u0026 tr[u].r \u003c= r) { tr[u].add = c; tr[u].sum = (tr[u].r - tr[u].l + 1) * c; return ; } pushdown(u); int mid = tr[u].l + tr[u].r \u003e\u003e 1; if (l \u003c= mid) modify(u \u003c\u003c 1, l, r, c); if (r \u003e mid) modify(u \u003c\u003c 1 | 1, l, r, c); pushup(u); } int ask(int u, int l, int r) { if (tr[u].l \u003e= l \u0026\u0026 tr[u].r \u003c= r) return tr[u].sum; pushdown(u); int mid = tr[u].l + tr[u].r \u003e\u003e 1, res = 0; if (l \u003c= mid) res += ask(u \u003c\u003c 1, l, r); if (r \u003e mid) res += ask(u \u003c\u003c 1 | 1, l, r); return res; } void modify_path(int u, int v, int k) { while (top[u] != top[v]) { if (dep[top[u]] \u003c dep[top[v]]) swap(u, v); modify(1, id[top[u]], id[u], k); u = fa[top[u]]; } if (dep[u] \u003c dep[v]) swap(u, v); modify(1, id[v] + 1, id[u], k); } int ask_path(int u, int v) { int res = 0; while (top[u] != top[v]) { if (dep[top[u]] \u003c dep[top[v]]) swap(u, v); res += ask(1, id[top[u]], id[u]); u = fa[top[u]]; } if (dep[u] \u003c dep[v]) swap(u, v); res += ask(1, id[v] + 1, id[u]); return res; } signed main() { memset(h, -1, sizeof h); cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i ++) p[i] = i; for (int i = 1; i \u003c= m; i ++) cin \u003e\u003e u[i] \u003e\u003e v[i]; for (int i = 1; i \u003c= m; i ++) { int pu = find(u[i]), pv = find(v[i]); if (pu != pv) { p[pu] = pv; add(u[i], v[i]), add(v[i], u[i]); st[i] = 1; } } dfs1(1, -1, 1), dfs2(1, 1); build(1, 1, n); while (1) { cin \u003e\u003e op; if (op == -1) break; cnt ++; q[cnt].op = op; cin \u003e\u003e q[cnt].u \u003e\u003e q[cnt].v; } for (int i = 1; i \u003c= cnt; i ++) { if (!q[i].op) { mp[{q[i].u, q[i].v}] = mp[{q[i].v, q[i].u}] = 1; } } for (int i = 1; i \u003c= m; i ++) { if (!st[i] \u0026\u0026 !mp[{u[i], v[i]}]) { modify_path(u[i], v[i], 0); } } for (int i = cnt; i; i --) { if (!q[i].op) { modify_path(q[i].u, q[i].v, 0); } else if (q[i].op == 1) { ans.push_back(ask_path(q[i].u, q[i].v)); } } for (int i = ans.size() - 1; ~i; i --) cout \u003c\u003c ans[i] \u003c\u003c endl; } ","date":"2021-12-10","objectID":"/posts/cpahoi2015-%E8%88%AA%E7%BA%BF%E8%A7%84%E5%88%92/:1:0","tags":["离线","树链剖分"],"title":"[AHOI2015] 航线规划","uri":"/posts/cpahoi2015-%E8%88%AA%E7%BA%BF%E8%A7%84%E5%88%92/"},{"categories":["算法竞赛"],"content":"形式幂级数 设数列 $a_0,a_1, a_2,\\cdots,a_n,\\cdots$ 那么他的形式幂级数就为 $$\\sum_{i = 0}^{\\infty}a_ix^i$$ 运算： 设 $f(x) = \\sum_{i = 0}^{\\infty}a_ix^i,g(x) = \\sum_{i = 0}^{\\infty}b_ix^i$ 加法： $$f(x) + g(x) = \\sum_{i = 0}^{\\infty}(a_i + b_i)x^i$$ 减法： $$f(x) - g(x) = \\sum_{i = 0}^{\\infty}(a_i - b_i)x^i$$ 乘法： $$f(x) * g(x) = \\sum_{i = 0}^{\\infty}\\sum_{k = 0}^{i}a_k * b_{i - k}x^i$$ 记号： 记形式幂级数 $f(x)$ 的 $x^n$ 项系数为 $[x^n] f(x)$ ","date":"2021-12-06","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/:1:0","tags":["生成函数"],"title":"生成函数","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"categories":["算法竞赛"],"content":"常生成函数 ","date":"2021-12-06","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/:2:0","tags":["生成函数"],"title":"生成函数","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"categories":["算法竞赛"],"content":"定理： 设 $S = {a_1,a_2,\\cdots,a_k}$ ，且 $a_i$ 可以取的次数的集合为 $M_i$ ，记 $F_i(x) = \\sum_{u \\in M_i}x^u$ ，则从 $S$ 中取 $n$ 个元素组成集合的方案数 $g(n)$ 的常生成函数 $G(x) = \\sum_{i =0}^{\\infty}g(i)x^i$ 满足： $$G(x) = F_1(x)F_2(x) \\cdots F_k(x)$$ ","date":"2021-12-06","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/:2:1","tags":["生成函数"],"title":"生成函数","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"categories":["算法竞赛"],"content":"形式幂级数的逆元： $A(x)B(x) = 1$ 逆元存在的条件：$[x^0]A(x) \\ne 0$ 暴力计算的方法：递推 常见的逆： $$\\sum_{i = 0}^{\\infty}x^i = \\frac{1}{1 - x}$$ $$\\sum_{i = 0}^{\\infty} a^ix^i = \\frac{1}{1 - ax}$$ $$\\sum_{ i = 0}^{\\infty}\\binom{i + k - 1}{i}x^i=\\frac{1}{(1 - x)^k}$$ ","date":"2021-12-06","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/:2:2","tags":["生成函数"],"title":"生成函数","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"categories":["算法竞赛"],"content":"例题： 食物 在一个自助水果店，有苹果、香蕉、草莓三种水果，你可以取 $n$ 个水果，但是水果店要求，取的苹果数必须是偶数，取的香蕉数必须是 $3$ 的倍数，取的草莓数不能超过 $5$ 个。求有多少种取 $n$ 个水果的方案。 苹果：$A(x) = 1+x^2+x^4+\\cdots$ 香蕉：$B(x) = 1 + x^3 + x^6+\\cdots$ 草莓：$C(x) = 1 + x + x ^2 + x ^3 + x ^ 4 + x ^ 5$ 那么答案就是 $[x^n]A(x)B(x)C(x)$ Devu and Flowers $n$ 种花，分别有 $f_1,f_2,\\cdots,f_n$ 个，求取 $s$ 朵花的方案数 $(1 \\le n \\le 20, 0 \\le f_i \\le 10^{12}, 0 \\le s \\le 10^{14})$ 每一朵花的生成函数： $$F_i(x) = 1 + x + x ^2 + \\cdots + x^{f_i} = \\frac{1 - x^{f_i + 1}}{1 - x}$$ 方案数： $$F(x) = F_1(x)F_2(x)\\cdots F_n(x) = \\frac{\\prod_{i = 1}^{n}(1-x^{f_i + 1})}{(1-x)^n}$$ 设 $A(x) = \\prod_{i = 1}^{n}(1-x^{f_i + 1})$ 那么答案就为 $$[x^s]F(x) = \\sum_{i = 0}^{s}[x^i]A(x) [x^{ s- i}] \\frac{1}{(1 - x)^n}$$ 等价于 $$[x^s]F(x) = \\sum_{i = 0}^{s}[x^i]A(x) C_{s - i + n - 1}^{n - 1} $$ [CEOI2004] Sweets $n$ 种糖果，别分有 $m_1,m_2,\\cdots,m_n$ 个，求取不少于 $a$ 不多于 $b$ 颗糖果的方案数。 $(1 \\le n \\le 10, 0 \\le a \\le b \\le 10^7,0 \\le m_i \\le 10^6)$ 每一个糖果的生成函数： $$F_i(x) = 1 + x + x ^2 + \\cdots + x^{m_i} = \\frac{1 - x^{m_i + 1}}{1 - x}$$ 方案数： $$F(x) = F_1(x)F_2(x)\\cdots F_n(x) = \\frac{\\prod_{i = 1}^{n}(1-x^{m_i + 1})}{(1-x)^n}$$ 那么答案就为 $$\\sum_{s = a}^{b}[x^s]F(x) = \\sum_{s = a}^{b}\\sum_{i = 0}^{s}[x^i]A(x) C_{s - i + n - 1}^{n - 1}$$ 根据组合数公式 $$C_{a}^{j}+C_{a + 1}^{j} + \\cdots+C_{b}^{j} = C_{b + 1}^{j + 1} - C_{a}^{j + 1}$$ 得到 $$\\sum_{i = 0}^{s}[x^i]A(x) (C_{a - i + n}^{n} - C_{b - i+ n - 1}^{n})$$ ","date":"2021-12-06","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/:2:3","tags":["生成函数"],"title":"生成函数","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"categories":["算法竞赛"],"content":"指数生成函数 一个数列 ${a_n}$ 对应的指数生成函数为 $f(x) = \\sum_{i = 0}^{\\infty}a_i\\dfrac{x_i}{i!}$ ","date":"2021-12-06","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/:3:0","tags":["生成函数"],"title":"生成函数","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"categories":["算法竞赛"],"content":"定理： 设 $S = {a_1,a_2,\\cdots,a_k}$ ，且 $a_i$ 可以取的次数的集合为 $M_i$ ，记 $F_i(x) = \\sum_{u \\in M_i}\\dfrac{x^u}{u!}$ ，则从 $S$ 中取 $n$ 个元素排成一列的方案数 $g(n)$ 的指数生成函数 $G(x) = \\sum_{i =0}^{\\infty}g(i)\\dfrac{x^i}{i!}$ 满足： $$G(x) = F_1(x)F_2(x) \\cdots F_k(x)$$ 常见公式： $$\\sum_{i = 0}^{\\infty}\\frac{x^i}{i!} = e^x$$ $$\\sum_{i = 0}^{\\infty}a^i\\frac{x^i}{i!} = e^{ax}$$ ","date":"2021-12-06","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/:3:1","tags":["生成函数"],"title":"生成函数","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"categories":["算法竞赛"],"content":"例题： blocks 一段长度为 $n$ 的序列，你有红黄蓝绿 $4$ 种颜色的砖块，一块砖长度为 $1$，问你铺砖的方案数，其中红色砖和绿色砖的数量必须为偶数 答案可能很大，请输出 $\\bmod 10007$ 后的结果 设 $$F(x) = 1 + \\dfrac{x^2}{2!} + \\dfrac{x^4}{4!} +\\cdots = \\dfrac{e^{x}+e^{-x}}{2}$$ $$G(x) = 1 + x+\\dfrac{x^2}{2!} + \\dfrac{x^3}{3!} +\\cdots = e^x$$ 则答案为 $$n!\\times[x^n]F^2(x)G^2(x) = n!\\times[x^n]\\frac{e^{4x}+2e^{2x} + 1}{4}=\\frac{4^n+2\\times2^n}{4} = 4^{n - 1} + 2^{n - 1}$$ ","date":"2021-12-06","objectID":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/:3:2","tags":["生成函数"],"title":"生成函数","uri":"/posts/cp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"categories":["算法竞赛"],"content":"题意 求 $$\\sum_{k = 1}^{n}\\sum_{i \\mid k} \\sum_{j \\mid i} \\lambda(i) \\lambda(j)$$ 对 $998244353$ 取模 其中 $\\lambda(x) = (-1)^{\\sum\\limits_{i}e_i},x=\\prod\\limits_{i}p_i^{e_i}$ 分析： $\\lambda(x)$ 为刘维尔函数，可以打表发现 $$\\sum_{d \\mid n}\\lambda(d) =[n = a^2,a \\in N^+]$$ 也就是 $n$ 是否为完全平方数 把式子中的 $\\lambda(i)$ 提到前面 $$\\sum_{k = 1}^{n}\\sum_{i \\mid k} \\lambda(i)\\sum_{j \\mid i} \\lambda(j)$$ 那么就变为 $$\\sum_{k = 1}^{n}\\sum_{i \\mid k} \\lambda(i)[i= a^2,a \\in N^+]$$ 那么完全平方数的刘维尔函数为 $1$，再设 $f(x)=[i= a^2,a \\in N^+]$ 得 $$\\sum_{i = 1}^{n}\\sum_{d \\mid i}f(d)$$ 交换求和次序 $$\\sum_{d = 1}^{n}f(d) \\lfloor\\frac{n}{d}\\rfloor$$ 这样直接枚举平方数即可，时间复杂度 $O(\\sqrt{n})$ ","date":"2021-11-20","objectID":"/posts/cp2021-ccpc%E5%A8%81%E6%B5%B7%E7%83%AD%E8%BA%AB%E8%B5%9B-number-theory/:0:0","tags":["打表","推式子"],"title":"[2021 CCPC威海热身赛] Number Theory","uri":"/posts/cp2021-ccpc%E5%A8%81%E6%B5%B7%E7%83%AD%E8%BA%AB%E8%B5%9B-number-theory/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int mod = 998244353; int n, res; signed main() { cin \u003e\u003e n; for (int i = 1; i * i \u003c= n; i ++) { res = (res + n / (i * i)) % mod; } cout \u003c\u003c res \u003c\u003c endl; } ","date":"2021-11-20","objectID":"/posts/cp2021-ccpc%E5%A8%81%E6%B5%B7%E7%83%AD%E8%BA%AB%E8%B5%9B-number-theory/:1:0","tags":["打表","推式子"],"title":"[2021 CCPC威海热身赛] Number Theory","uri":"/posts/cp2021-ccpc%E5%A8%81%E6%B5%B7%E7%83%AD%E8%BA%AB%E8%B5%9B-number-theory/"},{"categories":["算法竞赛"],"content":"原题链接 题意 给定一颗 $n$ 个节点并且根为 $1$ 的树和 $q$ 次询问，每次询问给定 $l,r,z$ 求 $$\\sum_{i=l}^{r} \\text{dep}(\\text{lca}(i,z))$$ 对 $201314$ 取模 $\\text{dep}(x)$ 表示点 $x$ 的深度，$\\text{lca}(u,v)$ 表示 $u,v$ 的最近公共祖先 $1 \\le n,q \\le 5×10^4$ 分析： 对式子进行一步转化，那就相当于在 $[l,r]$ 区间内的每个点，每次将该点和树根的路径上点权 $+1$，最后查询 $z$ 到树根路径的点权之和。这样做显然是超时的，所以就考虑怎么优化式子，我们发现每次询问是在 $[1,n]$ 区间的，所以就可以想到前缀和，也就是 $$\\sum_{i=l}^{r} \\text{dep}(\\text{lca}(i,z))=\\sum_{i=1}^{r} \\text{dep}(\\text{lca}(i,z)) - \\sum_{i=1}^{l - 1} \\text{dep}(\\text{lca}(i,z))$$ 这样就可以将一个询问分为两个询问，那只需要处理每个询问的 $r$ 和 $l-1$ 最后相减就可以了，所以我们可以考虑离线来做： 对于每个修改：维护一个差分，就相当于在区间 $[l-1, r]$ 都 $+1$，表示要在区间里的每个点加一次对树根的贡献(也就是 $1$)。 对于每个查询：在 $r$ 和 $l - 1$ 挂上 $z$ 的询问，左端点打上 $0$ 的标记， 右端点打上 $1$ 的标记。 最后从 $1$ 到 $n$ 扫一遍，先判断差分，如果是大于$0$的，那么表示这个点要修改一次。在判断询问，如果遇到有标记的点就查询 $z$ 到 树根的路径和，设当前的询问编号为 $id$， $0$ 的话就记到 $L_{id}$ ，$1$ 的话就记到 $R_{id}$，每个询问的答案就是 $R_{id} - L_{id}$ ","date":"2021-11-01","objectID":"/posts/cplnoi2014-lca/:0:0","tags":["离线","差分","树链剖分"],"title":"[LNOI2014] LCA","uri":"/posts/cplnoi2014-lca/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 5e4 + 5, M = N \u003c\u003c 1, mod = 201314; int L[N], R[N], sum[N], n, m, h[N], e[M], ne[M], idx, l, v, r, z, top[N], Size[N], fa[N], son[N], dep[N], cnt, id[N]; struct SegmentTree { int l, r, add, sum; } tr[N \u003c\u003c 2]; struct node { int id, z, type; }; vector\u003cnode\u003e num[N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++; } void dfs1(int u, int father, int depth) { dep[u] = depth, fa[u] = father, Size[u] = 1; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == father) continue; dfs1(j, u, depth + 1); Size[u] += Size[j]; if (Size[son[u]] \u003c Size[j]) son[u] = j; } } void dfs2(int u,int t) { id[u] = ++ cnt, top[u] = t; if (!son[u]) return ; dfs2(son[u], t); for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == fa[u] || j == son[u]) continue; dfs2(j, j); } } void pushup(int u) { tr[u].sum = (tr[u \u003c\u003c 1].sum + tr[u \u003c\u003c 1 | 1].sum) % mod; } void pushdown(int u) { if (tr[u].add) { tr[u \u003c\u003c 1].add += tr[u].add; tr[u \u003c\u003c 1 | 1].add += tr[u].add; tr[u \u003c\u003c 1].sum += (tr[u \u003c\u003c 1].r - tr[u \u003c\u003c 1].l + 1) * tr[u].add % mod; tr[u \u003c\u003c 1 | 1].sum += (tr[u \u003c\u003c 1 | 1].r - tr[u \u003c\u003c 1 | 1].l + 1) * tr[u].add % mod; tr[u].add = 0; } } void build(int u, int l, int r) { if (l == r) { tr[u] = {l, r}; } else { tr[u] = {l, r}; int mid = l + r \u003e\u003e 1; build(u \u003c\u003c 1, l, mid), build(u \u003c\u003c 1 | 1, mid + 1, r); pushup(u); } } void modify(int u, int l, int r, int c) { if (tr[u].l \u003e= l \u0026\u0026 tr[u].r \u003c= r) { tr[u].add += c; tr[u].sum += (tr[u].r - tr[u].l + 1) * c % mod; return ; } pushdown(u); int mid = tr[u].l + tr[u].r \u003e\u003e 1; if (l \u003c= mid) modify(u \u003c\u003c 1, l, r, c); if (r \u003e mid) modify(u \u003c\u003c 1 | 1, l, r, c); pushup(u); } int ask(int u, int l, int r) { if (tr[u].l \u003e= l \u0026\u0026 tr[u].r \u003c= r) return tr[u].sum; pushdown(u); int mid = tr[u].l + tr[u].r \u003e\u003e 1, res = 0; if (l \u003c= mid) res = (res + ask(u \u003c\u003c 1, l, r)) % mod; if (r \u003e mid) res = (res + ask(u \u003c\u003c 1 | 1, l, r)) % mod; return res; } void modify_path(int u, int v, int k) { while (top[u] != top[v]) { if (dep[top[u]] \u003c dep[top[v]]) swap(u, v); modify(1, id[top[u]], id[u], k); u = fa[top[u]]; } if (dep[u] \u003c dep[v]) swap(u, v); modify(1, id[v], id[u], k); } int ask_path(int u, int v) { int res = 0; while (top[u] != top[v]) { if (dep[top[u]] \u003c dep[top[v]]) swap(u, v); res = (res + ask(1, id[top[u]], id[u])) % mod; u = fa[top[u]]; } if (dep[u] \u003c dep[v]) swap(u, v); res = (res + ask(1, id[v], id[u])) % mod; return res; } signed main() { memset(h, -1, sizeof h); cin \u003e\u003e n \u003e\u003e m; for (int u = 2; u \u003c= n; u ++) { cin \u003e\u003e v, v ++; add(u, v), add(v, u); } dfs1(1, -1, 1), dfs2(1, 1); build(1, 1, n); for (int i = 1; i \u003c= m; i ++) { cin \u003e\u003e l \u003e\u003e r \u003e\u003e z, l ++, r ++, z ++; sum[l] ++, sum[r + 1] --; num[l - 1].push_back({i, z, 0}); num[r].push_back({i, z, 1}); } for (int i = 1; i \u003c= n; i ++) { sum[i] += sum[i - 1]; if (sum[i]) modify_path(i, 1, 1); for (int j = 0; j \u003c num[i].size(); j ++) { if (num[i][j].type == 0) { L[num[i][j].id] = ask_path(num[i][j].z, 1); } else { R[num[i][j].id] = ask_path(num[i][j].z, 1); } } } for (int i = 1; i \u003c= m; i ++) { cout \u003c\u003c (R[i] - L[i] + mod) % mod \u003c\u003c endl; } } ","date":"2021-11-01","objectID":"/posts/cplnoi2014-lca/:1:0","tags":["离线","差分","树链剖分"],"title":"[LNOI2014] LCA","uri":"/posts/cplnoi2014-lca/"},{"categories":["算法竞赛"],"content":"原题链接 题意 求从区间 $[L,R]$ 选出 $n$ 个数使得最大公约数为 $k$ 的方案数，对 $10^9 + 7$ 取模 $1 \\le n,k \\le 10^9$ $1 \\le L \\le R \\le10^9$ 分析： 根据题意 $$\\sum_{a_1=L}^{R}\\sum_{a_2=L}^{R}\\cdots\\sum_{a_n=L}^{R}[\\gcd(a_1,a_2,\\cdots,a_n)=k]$$ 把 $k$ 拿到上下界 $$\\sum_{a_1=\\lfloor \\frac{L-1}{k} \\rfloor +1}^{\\lfloor \\frac{R}{k} \\rfloor}\\sum_{a_2=\\lfloor \\frac{L - 1}{k} \\rfloor + 1}^{\\lfloor \\frac{R}{k} \\rfloor}\\cdots\\sum_{a_n=\\lfloor \\frac{L - 1}{k} \\rfloor + 1}^{\\lfloor \\frac{R}{k} \\rfloor}[\\gcd(a_1,a_2,\\cdots,a_n)=1]$$ 莫比乌斯反演 $$\\sum_{a_1=\\lfloor \\frac{L-1}{k} \\rfloor +1}^{\\lfloor \\frac{R}{k} \\rfloor}\\sum_{a_2=\\lfloor \\frac{L-1}{k} \\rfloor +1}^{\\lfloor \\frac{R}{k} \\rfloor}\\cdots\\sum_{a_n=\\lfloor \\frac{L-1}{k} \\rfloor +1}^{\\lfloor \\frac{R}{k} \\rfloor}\\sum_{d \\mid \\gcd(a_1,a_2,\\cdots,a_n)} \\mu(d)$$ 交换求和次序 $$\\sum_{d=1}^{\\lfloor \\frac{R}{k} \\rfloor}\\mu(d) (\\lfloor \\frac{R}{kd}\\rfloor - \\lfloor \\frac{L - 1}{kd}\\rfloor)^n$$ 然后用杜教筛做 ","date":"2021-10-19","objectID":"/posts/cpcqoi2015-%E9%80%89%E6%95%B0/:0:0","tags":["莫比乌斯反演","杜教筛"],"title":"[CQOI2015] 选数","uri":"/posts/cpcqoi2015-%E9%80%89%E6%95%B0/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 2e6 + 5, mod = 1e9 + 7; int n, k, L, R, primes[N], mobius[N], cnt, res, sum[N]; bool st[N]; unordered_map\u003cint, int\u003e mp; int qmi(int a, int b) { int res = 1; while (b) { if (b \u0026 1) res = res * a % mod; a = a * a % mod; b \u003e\u003e= 1; } return res; } void get_mobius(int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; primes[j] * i \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = (sum[i - 1] + mobius[i] + mod) % mod; } int Sum(int n) { if (n \u003c N) return sum[n]; if (mp[n]) return mp[n]; int res = 1; for (int l = 2, r; l \u003c= n; l = r + 1) { r = n / (n / l); res = (res - Sum(n / l) * (r - l + 1) % mod + mod) % mod; } return mp[n] = res; } signed main() { get_mobius(N - 1); cin \u003e\u003e n \u003e\u003e k \u003e\u003e L \u003e\u003e R; L = (L - 1) / k, R /= k; for (int l = 1, r; l \u003c= R; l = r + 1) { r = min(R / (R / l), L / l ? L / (L / l) : mod); res = (res + (Sum(r) - Sum(l - 1)) * qmi(R / l - L / l, n) % mod + mod) % mod; } cout \u003c\u003c res \u003c\u003c endl; } ","date":"2021-10-19","objectID":"/posts/cpcqoi2015-%E9%80%89%E6%95%B0/:1:0","tags":["莫比乌斯反演","杜教筛"],"title":"[CQOI2015] 选数","uri":"/posts/cpcqoi2015-%E9%80%89%E6%95%B0/"},{"categories":["算法竞赛"],"content":"原题链接 题意 求 $$\\prod_{i=1}^{n}\\prod^{n}_{j=1}\\frac{\\text{lcm}(i,j)}{\\gcd(i,j)}$$ 对 $104857601$ 取模 $1 \\le n \\le 10^6$ 分析： 将 $\\text{lcm}(i,j)=\\dfrac{i \\cdot j}{\\gcd(i,j)}$ 替换原式得 $$\\prod_{i=1}^{n}\\prod^{n}_{j=1}\\frac{i \\cdot j}{\\gcd(i,j)^2}$$ 对 $\\gcd(i,j)^2$ 求逆元 $$\\prod_{i=1}^{n}\\prod^{n}_{j=1}i \\cdot j \\cdot \\gcd(i,j)^{-2}$$ 前后分开来看 $$\\prod_{i=1}^{n}\\prod_{j=1} ^ {n} i \\cdot j\\prod_{i=1}^{n}\\prod^{n}_{j=1}\\gcd(i,j)^{-2}$$ 前面 $\\prod\\limits_{i=1}^{n}\\prod\\limits_{j=1} ^{n}i \\cdot j=\\prod\\limits_{i=1}^{n}i^n\\prod\\limits_{j=1} ^{n}j=\\prod\\limits_{i=1}^{n}i^n\\cdot n!=(n!)^{n}\\prod\\limits_{i=1}^{n}i^n=(n!)^{2n}$ 后半部分 先看原来的值再求逆元 $$\\prod_{i=1}^{n}\\prod^{n}_{j=1}\\gcd(i,j)^{2}$$ 先把平方拿出去看里面 $$\\prod_{i=1}^{n}\\prod^{n}_{j=1}\\gcd(i,j)$$ 枚举 $\\gcd(i,j)$ $$\\prod_{d=1}^{n}d^{\\sum\\limits_{i=1}^{n}\\sum\\limits^{n}_{j=1}[\\gcd(i,j)=d]}$$ 指数部分 因为 $\\sum\\limits_{i=1}^{n}\\sum\\limits_{i=1}^{n}[\\gcd(i,j)=1]=2\\sum\\limits_{i=1}^{n}\\varphi(i)-1$ 所以 $$\\prod_{d=1}^{n}d^{2\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d} \\rfloor}\\varphi(i)-1}$$ 最后答案为 $$(n!)^{2n}\\cdot (\\prod_{d=1}^{n}d^{2\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d} \\rfloor}\\varphi(i)-1})^{-2}$$ ","date":"2021-10-19","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p5221-product/:0:0","tags":["莫比乌斯反演"],"title":"[洛谷 P5221] Product","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p5221-product/"},{"categories":["算法竞赛"],"content":"代码(毒瘤出题人卡空间)： #include \u003ccstdio\u003e using namespace std; const int N = 1e6 + 5, mod = 104857601; int n, fact = 1, euler[N], primes[N], cnt, res = 1, inv = 1; bool st[N]; int qmi(int a, int b) { int res = 1; while (b) { if (b \u0026 1) res = 1ll * res * a % mod; a = 1ll * a * a % mod; b \u003e\u003e= 1; } return res; } void get_eulers(int n) { euler[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; euler[i] = i - 1; } for (int j = 0; primes[j] * i \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { euler[t] = euler[i] * primes[j]; break; } euler[t] = euler[i] * (primes[j] - 1); } } for (int i = 1; i \u003c= n; i ++) euler[i] = (euler[i - 1] + 2 * euler[i]) % (mod - 1); } signed main() { scanf(\"%d\", \u0026n); get_eulers(n); for (int i = 1; i \u003c= n; i ++) fact = 1ll * fact * i % mod; res = qmi(fact, 2 * n); for (int i = 1; i \u003c= n; i ++) { inv = (1ll * inv * qmi(i, euler[n / i] - 1)) % mod; } printf(\"%d\\n\", 1ll * res * qmi(1ll * inv * inv % mod, mod - 2) % mod); } ","date":"2021-10-19","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p5221-product/:1:0","tags":["莫比乌斯反演"],"title":"[洛谷 P5221] Product","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p5221-product/"},{"categories":["算法竞赛"],"content":"原题链接 题意 给定一棵 $n$ 个节点的树，每个点都有一个宗教 $c_i$ 和权值 $w_i$ 有 $m$ 次操作： $1.$ 将节点 $x$ 的宗教 $c_x$ 修改为 $c$ $2.$ 将节点 $x$ 的权值 $w_x$ 修改为 $w$ $3.$ 询问树上路径 $u$ 到 $v$ 宗教为 $c_u$ 的权值和 (保证 $c_u=c_v$ ) $4.$ 询问树上路径 $u$ 到 $v$ 宗教为 $c_u$ 的最大权值 (保证 $c_u=c_v$ ) $1 \\le n,m,c \\le 10^5$ 分析： 这种树上问题可以想到树链剖分，那么重点是线段树如何维护，每个点可能会记录 $10^5$ 种宗教，空间显然是开不下的，但是询问只有 $10^5$，所以可以给每个宗教开一颗权值线段树，然后用动态开点的方式维护操作。我们就在权值线段树上记录每个点对应宗教的权值，也就是做映射 $c_u \\rightarrow w_u$ 每次如果修改某个点的宗教 $c_u$ 为新宗教 $c$，那么就先清空原宗教的权值 $c_u=0$，然后把原来的权值给新宗教 $c=w_u$，最后改变宗教 $c_u=c$ 每次如果修改某个点的权值 $w_u$ 为新权值 $w$，那么就直接修改原值 $w_u=w$ 查询时直接询问 $u$ 到 $v$ 路径上树链剖分对应节点编号的区间为宗教 $x$ 的区间最值和区间和。 ","date":"2021-09-29","objectID":"/posts/cpsdoi-2014-%E6%97%85%E8%A1%8C/:0:0","tags":["树链剖分","权值线段树","动态开点"],"title":"[SDOI 2014] 旅行","uri":"/posts/cpsdoi-2014-%E6%97%85%E8%A1%8C/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 1e5 + 5, M = N \u003c\u003c 1; int root[N], Idx, W[N], C[N], w, c, u, v, n, m, h[N], e[M], ne[M], idx, id[N], cnt, dep[N], Size[N], top[N], fa[N], son[N]; string op; struct SegmentTree { int l, r, sum, mx; } tr[N \u003c\u003c 5]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++; } void dfs1(int u, int father, int depth) { dep[u] = depth, fa[u] = father, Size[u] = 1; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == father) continue; dfs1(j, u, depth + 1); Size[u] += Size[j]; if (Size[son[u]] \u003c Size[j]) son[u] = j; } } void dfs2(int u,int t) { id[u] = ++ cnt, top[u] = t; if (!son[u]) return ; dfs2(son[u], t); for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == fa[u] || j == son[u]) continue; dfs2(j, j); } } void pushup(int u) { tr[u].sum = tr[tr[u].l].sum + tr[tr[u].r].sum; tr[u].mx = max(tr[tr[u].l].mx, tr[tr[u].r].mx); } void modify(int \u0026u, int l, int r, int pos, int c) { if (!u) u = ++ Idx; if (l == pos \u0026\u0026 r == pos) { tr[u].mx = tr[u].sum = c; return ; } int mid = l + r \u003e\u003e 1; if (pos \u003c= mid) { modify(tr[u].l, l, mid, pos, c); } else { modify(tr[u].r, mid + 1, r, pos, c); } pushup(u); } int ask_sum(int u, int l, int r, int ql, int qr) { if(l \u003e qr || r \u003c ql) return 0; if (!u) return 0; if (l \u003e= ql \u0026\u0026 r \u003c= qr) return tr[u].sum; int mid = l + r \u003e\u003e 1, res = 0; if (l \u003c= mid) res += ask_sum(tr[u].l, l, mid, ql, qr); if (r \u003e mid) res += ask_sum(tr[u].r, mid + 1, r, ql, qr); return res; } int ask_max(int u, int l, int r, int ql, int qr) { if(l \u003e qr || r \u003c ql) return 0; if (!u) return 0; if (l \u003e= ql \u0026\u0026 r \u003c= qr) return tr[u].mx; int mid = l + r \u003e\u003e 1, res = 0; if (l \u003c= mid) res = max(res, ask_max(tr[u].l, l, mid, ql, qr)); if (r \u003e mid) res = max(res, ask_max(tr[u].r, mid + 1, r, ql, qr)); return res; } int ask_path_sum(int u, int v, int c) { int res = 0; while (top[u] != top[v]) { if (dep[top[u]] \u003c dep[top[v]]) swap(u, v); res += ask_sum(root[c], 1, N - 1, id[top[u]], id[u]); u = fa[top[u]]; } if (dep[u] \u003c dep[v]) swap(u, v); res += ask_sum(root[c], 1, N - 1, id[v], id[u]); return res; } int ask_path_max(int u, int v, int c) { int res = 0; while (top[u] != top[v]) { if (dep[top[u]] \u003c dep[top[v]]) swap(u, v); res = max(res, ask_max(root[c], 1, N - 1, id[top[u]], id[u])); u = fa[top[u]]; } if (dep[u] \u003c dep[v]) swap(u, v); res = max(res, ask_max(root[c], 1, N - 1, id[v], id[u])); return res; } signed main() { memset(h, -1, sizeof h); cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i ++) { cin \u003e\u003e W[i] \u003e\u003e C[i]; } for (int i = 0; i \u003c n - 1; i ++) { cin \u003e\u003e u \u003e\u003e v; add(u, v), add(v, u); } dfs1(1, -1, 1), dfs2(1, 1); for (int i = 1; i \u003c= n; i ++) { modify(root[C[i]], 1, N - 1, id[i], W[i]); } while (m --) { cin \u003e\u003e op \u003e\u003e u; if (op == \"CC\") { cin \u003e\u003e c; modify(root[C[u]], 1, N - 1, id[u], 0); modify(root[c], 1, N - 1, id[u], W[u]); C[u] = c; } else if (op == \"CW\") { cin \u003e\u003e w; modify(root[C[u]], 1, N - 1, id[u], w); W[u] = w; } else if (op == \"QS\") { cin \u003e\u003e v; cout \u003c\u003c ask_path_sum(u, v, C[u]) \u003c\u003c endl; } else if (op == \"QM\") { cin \u003e\u003e v; cout \u003c\u003c ask_path_max(u, v, C[u]) \u003c\u003c endl; } } } ","date":"2021-09-29","objectID":"/posts/cpsdoi-2014-%E6%97%85%E8%A1%8C/:1:0","tags":["树链剖分","权值线段树","动态开点"],"title":"[SDOI 2014] 旅行","uri":"/posts/cpsdoi-2014-%E6%97%85%E8%A1%8C/"},{"categories":["算法竞赛"],"content":"原题链接 题意 给定一棵 $n$ 个节点的树和 $m$ 次操作，每次操作把 $u$ 到 $v$ 路径上的节点加上一个颜色 $z$，最后询问每个点最多颜色的编号(如果相同取编号最小) $1 \\le n,m,z \\le 10^5$ 分析： 此题是线段树合并模板题，这里给出树链剖分的做法。 每次操作修改树上的路径，可以用树链剖分维护一下，注意到 $z$ 的范围是 $10^5$ ，所以我们不能在树上的每个节点上开一个桶记录颜色，所以可以用权值线段树的动态开点。不过这里有更优做法，因为树链剖分出来的序列对应树上的唯一路径，所以题目的操作就相当于：给定一个序列，每次在 $[l,r]$ 区间添加一个颜色，询问每个点最多颜色的编号。这样就可以用差分的思想，每次在 $l$ 点 $+1$，$r + 1$ 点 $-1$，我们把 $l$ 排序，扫描 $1 \\sim N$ 的每个点，每次遍历这个点的询问，把对这个点的修改在权值线段树上操作，然后查询一下最大的下标。 此题在 $\\text{acwing}$ 上 $z$ 的数据范围为 $10^9$ 所以最好离散化一下。 ","date":"2021-09-28","objectID":"/posts/cp%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-%E9%9B%A8%E5%A4%A9%E7%9A%84%E5%B0%BE%E5%B7%B4/:0:0","tags":["线段树合并","树链剖分","线段树"],"title":"[算法竞赛进阶指南] 雨天的尾巴","uri":"/posts/cp%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-%E9%9B%A8%E5%A4%A9%E7%9A%84%E5%B0%BE%E5%B7%B4/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long #define find(x) lower_bound(num.begin(), num.end(), x) - num.begin() using namespace std; const int N = 1e5 + 5, M = N \u003c\u003c 1; int z[N], a[N], u[N], v[N], n, m, h[N], e[M], ne[M], idx, id[N], ans[N], mp[N], cnt, dep[N], Size[N], top[N], fa[N], son[N]; vector\u003cint\u003e x[N], num; struct SegmentTree { int l, r, mx, val; } tr[N \u003c\u003c 2]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++; } void dfs1(int u, int father, int depth) { dep[u] = depth, fa[u] = father, Size[u] = 1; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == father) continue; dfs1(j, u, depth + 1); Size[u] += Size[j]; if (Size[son[u]] \u003c Size[j]) son[u] = j; } } void dfs2(int u,int t) { id[u] = ++ cnt, top[u] = t, mp[cnt] = u; if (!son[u]) return ; dfs2(son[u], t); for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == fa[u] || j == son[u]) continue; dfs2(j, j); } } void pushup(int u) { if (tr[u \u003c\u003c 1].mx \u003e= tr[u \u003c\u003c 1 | 1].mx) { tr[u].mx = tr[u \u003c\u003c 1].mx; tr[u].val = tr[u \u003c\u003c 1].val; } else { tr[u].mx = tr[u \u003c\u003c 1 | 1].mx; tr[u].val = tr[u \u003c\u003c 1 | 1].val; } } void build(int u, int l, int r) { if (l == r) { tr[u] = {l, r, 0, l}; } else { tr[u] = {l, r}; int mid = l + r \u003e\u003e 1; build(u \u003c\u003c 1, l, mid), build(u \u003c\u003c 1 | 1, mid + 1, r); pushup(u); } } void modify(int u, int pos, int c) { if (tr[u].l == pos \u0026\u0026 tr[u].r == pos) { tr[u].mx += c; } else { int mid = tr[u].l + tr[u].r \u003e\u003e 1; if (pos \u003c= mid) { modify(u \u003c\u003c 1, pos, c); } else { modify(u \u003c\u003c 1 | 1, pos, c); } pushup(u); } } void modify_path(int u, int v, int k) { while (top[u] != top[v]) { if (dep[top[u]] \u003c dep[top[v]]) swap(u, v); x[id[top[u]]].push_back(k), x[id[u] + 1].push_back(-k); u = fa[top[u]]; } if (dep[u] \u003c dep[v]) swap(u, v); x[id[v]].push_back(k), x[id[u] + 1].push_back(-k); } signed main() { memset(h, -1, sizeof h); cin \u003e\u003e n \u003e\u003e m; for (int i = 0; i \u003c n - 1; i ++) { cin \u003e\u003e u[i] \u003e\u003e v[i]; add(u[i], v[i]), add(v[i], u[i]); } dfs1(1, -1, 1), dfs2(1, 1); build(1, 1, N - 1); for (int i = 1; i \u003c= m; i ++) { cin \u003e\u003e u[i] \u003e\u003e v[i] \u003e\u003e z[i]; num.push_back(z[i]); } sort(num.begin(), num.end()); num.erase(unique(num.begin(), num.end()), num.end()); for (int i = 1; i \u003c= m; i ++) { modify_path(u[i], v[i], find(z[i]) + 1); } for (int i = 1; i \u003c N; i ++) { for (int j = 0; j \u003c x[i].size(); j ++) { if (x[i][j] \u003e 0) { modify(1, x[i][j], 1); } else { modify(1, -x[i][j], -1); } } ans[mp[i]] = tr[1].mx ? num[tr[1].val - 1] : 0; } for (int i = 1; i \u003c= n; i ++) cout \u003c\u003c ans[i] \u003c\u003c endl; } ","date":"2021-09-28","objectID":"/posts/cp%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-%E9%9B%A8%E5%A4%A9%E7%9A%84%E5%B0%BE%E5%B7%B4/:1:0","tags":["线段树合并","树链剖分","线段树"],"title":"[算法竞赛进阶指南] 雨天的尾巴","uri":"/posts/cp%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-%E9%9B%A8%E5%A4%A9%E7%9A%84%E5%B0%BE%E5%B7%B4/"},{"categories":["算法竞赛"],"content":"题意 每次从 $[1,n]$ 中选择一个数加到一个序列末尾，当 $\\gcd(a_1,\\cdots,a_n)=1$ 时停止，求期望长度，对 $p$ 取模 $1\\le n \\le 10^{11},n\u003c p \\le 10 ^{12}$ 分析： 设 $E(x)$ 为长度为 $x$ 的期望，那么根据期望定义 $$E(x)=\\sum_{i=1}^{\\infty}P(x=i) \\times i$$ 把 $i$ 改为 $\\sum\\limits_{j=1} ^{i}$ $$E(x)=\\sum_{i=1}^{\\infty}P(x=i) \\sum_{j=1}^{i}$$ 交换求和次序 $$\\sum_{i=1}^{\\infty}\\sum_{j = i}^{\\infty}P(x=j)$$ 等价于 $$\\sum_{i=1}^{\\infty}P(x\\ge i)$$ 化简一下 $$\\sum_{i=1}^{\\infty}P(x\\ge i)=1+\\sum_{i=1}^{\\infty}P(x\u003e i)$$ 考虑 $P(x\u003e i)$，进行容斥 $1-P(x \\le i)$ 就等价于 $$1-P(\\gcd(a_1,\\cdots,a_i)=1)$$ 枚举 $a_i$ 在 $[1,n]$ 中的取值 $$1-\\sum_{a_1=1}^{n}\\cdots\\sum_{a_i=1}^{n}\\frac{[\\gcd(a_1,\\cdots,a_i)=1]}{n^{i}}$$ 莫比乌斯反演 $$1-\\sum_{a_1=1}^{n}\\cdots\\sum_{a_i=1}^{n}\\frac{\\sum\\limits_{d \\mid\\gcd(a_1,\\cdots,a_i) }\\mu(d)}{n^{i}}$$ 交换求和次序 $$1-\\frac{\\sum\\limits_{d=1}^{n}\\mu(d)\\lfloor \\dfrac{n}{d} \\rfloor^i}{n^i}$$ 把 $1$ 拿到分子，和第一项抵消了 $$-\\frac{\\sum\\limits_{d=2}^{n}\\mu(d)\\lfloor \\dfrac{n}{d} \\rfloor^i}{n^{i}}$$ 代入到 $1+\\sum\\limits_{i=1}^{\\infty}P(len \u003e i)$ 得 $$1-\\sum_{i=1}^{\\infty}\\frac{\\sum\\limits_{d=2}^{n}\\mu(d)\\lfloor \\dfrac{n}{d} \\rfloor^i}{n^{i}}$$ 交换求和次序 $$1-\\sum_{d=2}^{n}\\mu(d)\\sum_{i=1}^{\\infty}(\\frac{\\lfloor \\dfrac{n}{d} \\rfloor}{n})^i$$ $\\sum\\limits_{i=1}^{\\infty}(\\dfrac{\\lfloor \\dfrac{n}{d} \\rfloor}{n})^i$ 这是个等比级数，极限为 $\\dfrac{首项}{1-公比}$ $$1-\\sum_{d=2}^{n}\\mu(d)\\frac{\\lfloor \\dfrac{n}{d} \\rfloor}{n-\\lfloor \\dfrac{n}{d} \\rfloor}$$ 就可以用杜教筛了 ","date":"2021-09-23","objectID":"/posts/cp2021-cccc%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E5%8F%AF%E6%80%9C%E7%9A%84%E7%AE%80%E5%8D%95%E9%A2%98/:0:0","tags":["莫比乌斯反演","杜教筛","概率期望"],"title":"[2021 CCCC天梯赛] 可怜的简单题","uri":"/posts/cp2021-cccc%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E5%8F%AF%E6%80%9C%E7%9A%84%E7%AE%80%E5%8D%95%E9%A2%98/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; signed main() { cin.tie(0) -\u003e sync_with_stdio(0); int n, mod; cin \u003e\u003e n \u003e\u003e mod; int cnt = 0, N = 2.2e7 + 5; vector\u003cint\u003e primes(N), mobius(N), sum(N); vector\u003cbool\u003e st(N); auto sieve = [\u0026](int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; i * primes[j] \u003c= n; j ++) { int t = i * primes[j]; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } for (int i = 1; i \u003c= n; i ++) { sum[i] = (sum[i - 1] + mobius[i] + mod) % mod; } }; sieve(N - 1); auto qmul = [\u0026](int a, int b) { return (__int128)a * b % mod; }; auto qmi = [\u0026](int a, int b) { int res = 1; while (b) { if (b \u0026 1) res = qmul(res, a); a = qmul(a, a); b \u003e\u003e= 1; } return res; }; unordered_map\u003cint, int\u003e mp; function\u003cint(int)\u003e Sum = [\u0026](int n) { if (n \u003c N) return sum[n]; if (mp[n]) return mp[n]; int res = 1; for (int l = 2, r; l \u003c= n; l = r + 1) { r = n / (n / l); res = (res - qmul(r - l + 1, Sum(n / l)) % mod + mod) % mod; } return mp[n] = res; }; int res = 1; for (int l = 2, r; l \u003c= n; l = r + 1) { r = n / (n / l); int t = qmul(n / l, qmi(n - n / l, mod - 2)); res = (res - qmul(Sum(r) - Sum(l - 1), t) + mod) % mod; } cout \u003c\u003c res \u003c\u003c endl; } ","date":"2021-09-23","objectID":"/posts/cp2021-cccc%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E5%8F%AF%E6%80%9C%E7%9A%84%E7%AE%80%E5%8D%95%E9%A2%98/:1:0","tags":["莫比乌斯反演","杜教筛","概率期望"],"title":"[2021 CCCC天梯赛] 可怜的简单题","uri":"/posts/cp2021-cccc%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E5%8F%AF%E6%80%9C%E7%9A%84%E7%AE%80%E5%8D%95%E9%A2%98/"},{"categories":["算法竞赛"],"content":"原题链接 题意 求 $$\\sum_{i=1}^{n}\\sum_{j=1}^{n} \\varphi(\\gcd(i,j))$$ $1 \\le n \\le 10^9$，对 $10^9+7$ 取模 分析： 枚举 $\\gcd(i,j)$ $$\\sum_{d=1}^{n}\\varphi(d)\\sum_{i=1}^{n}\\sum_{j=1}^{n}[\\gcd(i,j)=d]$$ 将 $d$ 拿到上界 $$\\sum_{d=1}^{n}\\varphi(d)\\sum_{i=1}^{\\lfloor \\frac{n}{d} \\rfloor}\\sum_{j=1}^{\\lfloor \\frac{n}{d} \\rfloor}[\\gcd(i,j)=1]$$ 因为 $\\sum\\limits_{i=1}^{n}\\sum\\limits_{i=1}^{n}[\\gcd(i,j)=1]=\\sum\\limits_{i=1}^{n}2\\varphi(i)-1$，所以 $$\\sum_{d=1}^{n}\\varphi(d)(\\sum_{i=1}^{\\lfloor \\frac{n}{d} \\rfloor}2\\varphi(i)-1)$$ 再用一下杜教筛就好了 ","date":"2021-09-23","objectID":"/posts/cpnc-200008-lady-layton-with-math/:0:0","tags":["杜教筛"],"title":"[NC 200008] Lady Layton with Math","uri":"/posts/cpnc-200008-lady-layton-with-math/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 2e6 + 5, mod = 1e9 + 7; int T, n, euler[N], primes[N], cnt, sum[N]; bool st[N]; unordered_map\u003cint, int\u003e mp; void get_eulers(int n) { euler[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; euler[i] = i - 1; } for (int j = 0; primes[j] \u003c= n / i; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { euler[t] = primes[j] * euler[i]; break; } euler[t] = (primes[j] - 1) * euler[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = (sum[i - 1] + euler[i]) % mod; } int Sum(int n) { if (n \u003c N) return sum[n]; if (mp[n]) return mp[n]; int res = n * (n + 1) / 2 % mod; for (int l = 2, r; l \u003c= n; l = r + 1) { r = n / (n / l); res = (res - Sum(n / l) * (r - l + 1) % mod + mod) % mod; } return mp[n] = res; } signed main() { get_eulers(N - 1); cin \u003e\u003e T; while (T --) { int res = 0; cin \u003e\u003e n; for (int l = 1, r; l \u003c= n; l = r + 1) { r = n / (n / l); res = (res + (Sum(r) - Sum(l - 1)) * (2 * Sum(n / l) - 1) % mod + mod) % mod; } cout \u003c\u003c res \u003c\u003c endl; } } ","date":"2021-09-23","objectID":"/posts/cpnc-200008-lady-layton-with-math/:1:0","tags":["杜教筛"],"title":"[NC 200008] Lady Layton with Math","uri":"/posts/cpnc-200008-lady-layton-with-math/"},{"categories":["算法竞赛"],"content":"原题链接 题意 求 $$\\sum_{i=1}^{m} \\mu(in)$$ $m \\le 2×10^9,n\\le 10^{12}$ 分析： 首先分析 $n$ 的因子中有没有平方，如果有那么答案就是 $0$ 如果 $n$ 的因子没有平方，设某个因子为 $p$，原式就可以拆成 $$\\sum_{i=1} ^{m}\\mu(i\\cdot\\frac{n}{p}\\cdot p)$$ 莫比乌斯函数是积性函数，考虑把 $p$ 分出去，那么 $p$ 与 $\\dfrac{n}{p}$ 一定是互质的，但 $i\\cdot \\dfrac{n}{p}$ 并不一定互质，那么就考虑 $i$ 与 $p$ 的关系，在 $[1,m]$ 中只有 $p$ 的倍数才与 $p$ 不互质，所以要加上这一部分。 $$\\sum_{i=1}^{m}\\mu(i\\cdot\\frac{n}{p})\\mu(p)+\\sum_{i=1}^{\\lfloor \\frac{m}{p} \\rfloor}\\mu(i\\cdot p \\cdot \\frac{n}{p})$$ 由于 $p$ 是单因子，所以 $\\mu(p)=-1$ $$\\sum_{i=1}^{\\lfloor \\frac{m}{p} \\rfloor}\\mu(i n) - \\sum_{i=1}^{m}\\mu(i\\cdot\\frac{n}{p})$$ 设 $S(n,m)=\\sum\\limits_{i=1}^{m}\\mu(in)$，那么得到递推式 $$S(n,m)=S(n,\\frac{m}{p})-S(\\frac{n}{p},m)$$ 那么就可以每次枚举 $n$ 的质因子 $p$，递归求解，那么递归边界就是 $S(0,n)$ 和 $S(1,m)$，也就是莫比乌斯函数前缀和，用杜教筛处理一下就好了 ","date":"2021-09-18","objectID":"/posts/cp2018-icpc%E5%BE%90%E5%B7%9E%E7%BD%91%E7%BB%9C%E8%B5%9B-easy-math/:0:0","tags":["杜教筛"],"title":"[2018 ICPC徐州网络赛] Easy Math","uri":"/posts/cp2018-icpc%E5%BE%90%E5%B7%9E%E7%BD%91%E7%BB%9C%E8%B5%9B-easy-math/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 2e6 + 5; int t, n, m, mobius[N], primes[N], cnt, sum[N]; bool st[N]; unordered_map\u003cint, int\u003e mp; void get_mobius(int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; primes[j] * i \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = sum[i - 1] + mobius[i]; } int Sum(int n) { if (n \u003c N) return sum[n]; if (mp[n]) return mp[n]; int res = 1; for (int l = 2, r; l \u003c= n; l = r + 1) { r = n / (n / l); res -= Sum(n / l) * (r - l + 1); } return mp[n] = res; } int S(int n, int m) { if (m == 0) return 0; if (n == 1) return Sum(m); int flag = 0; for (int i = 2; i * i \u003c= n; i ++) { if (n % i == 0) { flag = 1; return S(n, m / i) - S(n / i, m); } } if (!flag) return S(n, m / n) - S(1, m); } signed main() { get_mobius(N - 1); cin \u003e\u003e m \u003e\u003e n; t = n; for (int i = 2; i * i \u003c= t; i ++) { if (t % i == 0) { int cnt = 0; while (t % i == 0) { t /= i; cnt ++; if (cnt == 2) { cout \u003c\u003c 0 \u003c\u003c endl; return 0; } } } } cout \u003c\u003c S(n, m) \u003c\u003c endl; } ","date":"2021-09-18","objectID":"/posts/cp2018-icpc%E5%BE%90%E5%B7%9E%E7%BD%91%E7%BB%9C%E8%B5%9B-easy-math/:1:0","tags":["杜教筛"],"title":"[2018 ICPC徐州网络赛] Easy Math","uri":"/posts/cp2018-icpc%E5%BE%90%E5%B7%9E%E7%BD%91%E7%BB%9C%E8%B5%9B-easy-math/"},{"categories":["算法竞赛"],"content":"原题链接 题意 求 $$\\sum_{i=1}^{n}\\sum_{j=1}^{n}\\sum_{p=1}^{\\lfloor \\frac{n}{j} \\rfloor} \\sum_{q=1}^{\\lfloor \\frac{n}{j} \\rfloor}[\\gcd(i,j)=1][\\gcd(p,q)=1]$$ 对 $998244353$ 取模 分析： 常规套用莫比乌斯反演式子会很麻烦，所以这里反向把上界拿下来 $$\\sum_{i=1}^{n}\\sum_{j=1}^{n}\\sum_{p=1}^{n} \\sum_{q=1}^{n}[\\gcd(i,j)=1][\\gcd(p,q)=j]$$ 那么就是 $$\\sum_{i=1}^{n}\\sum_{j=1}^{n}\\sum_{k=1}^{n} [\\gcd(i,j,k)=1]$$ 再来莫比乌斯反演 $$\\sum_{i=1}^{n}\\sum_{j=1}^{n}\\sum_{k=1}^{n} \\sum_{d \\mid \\gcd(i,j,k)}\\mu(d)$$ 化简一下 $$\\sum_{d=1}^{n}\\mu(d) \\lfloor\\frac{n}{d}\\rfloor^3$$ 就可以用杜教筛了 ","date":"2021-09-17","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p6055-rc-02-gcd/:0:0","tags":["莫比乌斯反演","杜教筛"],"title":"[洛谷 P6055] [RC-02] GCD","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p6055-rc-02-gcd/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 2e6 + 5, mod = 998244353; int n, mobius[N], primes[N], cnt, sum[N], res; bool st[N]; unordered_map\u003cint, int\u003e mp; void get_mobius(int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; primes[j] * i \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = (sum[i - 1] + mobius[i] + mod) % mod; } int Sum(int n) { if (n \u003c N) return sum[n]; if (mp[n]) return mp[n]; int res = 1; for (int l = 2, r; l \u003c= n; l = r + 1) { r = n / (n / l); res = (res - Sum(n / l) * (r - l + 1) % mod + mod) % mod; } return mp[n] = res; } signed main() { get_mobius(N - 1); cin \u003e\u003e n; for (int l = 1, r; l \u003c= n; l = r + 1) { r = n / (n / l); res = (res + (Sum(r) - Sum(l - 1)) * (n / l) % mod * (n / l) % mod * (n / l) % mod + mod) % mod; } cout \u003c\u003c res \u003c\u003c endl; } ","date":"2021-09-17","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p6055-rc-02-gcd/:1:0","tags":["莫比乌斯反演","杜教筛"],"title":"[洛谷 P6055] [RC-02] GCD","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p6055-rc-02-gcd/"},{"categories":["算法竞赛"],"content":"原题链接 题意 求 $$\\prod_{i=1} ^{n} \\prod_{j=1}^{n}\\prod_{k=1}^{n}m^{\\gcd(i,j)[k \\mid \\gcd(i,j)]} \\bmod p$$ $n \\le10^9,m \\le 2 ×10^9,p\\le 2×10^9$ ，$p$是质数 分析： 相乘变为指数相加 $$m ^ {\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{n}\\sum\\limits_{k=1}^{n}\\gcd(i,j)[k \\mid \\gcd(i,j)]}$$ 看一下指数部分 $$\\sum_{i=1}^{n}\\sum_{j=1}^{n}\\sum_{k=1}^{n}\\gcd(i,j)[k \\mid \\gcd(i,j)]$$ 发现 $\\sum\\limits_{k=1}^{n}[k \\mid \\gcd(i,j)]$ 就是 $d(\\gcd(i,j))$ $$\\sum_{i=1}^{n}\\sum_{j=1}^{n}\\gcd(i,j)d(\\gcd(i,j))$$ 枚举 $\\gcd(i,j)$ $$\\sum_{k=1}^{n}k \\cdot d(k)\\sum_{i=1}^{n}\\sum_{j=1}^{n}[\\gcd(i,j)=k]$$ $k$ 拿到上界 $$\\sum_{k=1}^{n}k \\cdot d(k)\\sum_{i=1}^{\\lfloor \\frac{n}{k} \\rfloor }\\sum_{j=1}^{\\lfloor \\frac{n}{k} \\rfloor}[\\gcd(i,j)=1]$$ 因为 $\\sum\\limits_{i=1}^{n}\\sum\\limits_{i=1}^{n}[\\gcd(i,j)=1]=\\sum\\limits_{i=1}^{n}2\\varphi(i)-1$，所以 $$\\sum_{k=1}^{n}k \\cdot d(k)(\\sum_{i=1}^{\\lfloor \\frac{n}{k} \\rfloor }2\\varphi(i)-1)$$ 对于 $\\sum\\limits_{k=1}^{n}k \\cdot d(k)$ $$\\sum_{k=1}^{n}k \\cdot d(k)=\\sum_{k=1} ^ {n} \\sum_{d \\mid k}k=\\sum_{d=1}^{n}d\\sum_{k=1} ^{\\lfloor \\frac{n}{d} \\rfloor}k=\\sum_{d=1}^{n}d\\frac{\\lfloor \\frac{n}{d}\\rfloor^2+\\lfloor \\frac{n}{d}\\rfloor}{2}$$ 替换得 $$\\sum_{d =1}^{n}d \\frac{\\lfloor \\frac{n}{d}\\rfloor^2+\\lfloor \\frac{n}{d}\\rfloor}{2}(\\sum_{i=1}^{\\lfloor \\frac{n}{d} \\rfloor }2\\varphi(i)-1)$$ 整除分块+杜教筛 那么在求原式的时候用一下欧拉降幂就好了 ","date":"2021-09-17","objectID":"/posts/cp2019-icpc%E8%A5%BF%E5%AE%89%E9%82%80%E8%AF%B7%E8%B5%9B-product/:0:0","tags":["莫比乌斯反演","杜教筛"],"title":"[2019 ICPC西安邀请赛] Product","uri":"/posts/cp2019-icpc%E8%A5%BF%E5%AE%89%E9%82%80%E8%AF%B7%E8%B5%9B-product/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 2e6 + 5; int n, m, mod, primes[N], euler[N], cnt, res, sum[N], d[N], num[N]; bool st[N]; unordered_map\u003cint, int\u003e mp, Mp; void get_eulers(int n) { euler[1] = d[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; euler[i] = i - 1; d[i] = 2; num[i] = 1; } for (int j = 0; primes[j] \u003c= n / i; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { num[t] = num[i] + 1; euler[t] = primes[j] * euler[i]; d[t] = (d[i] / num[t] * (num[t] + 1)) % mod; break; } euler[t] = (primes[j] - 1) * euler[i]; num[t] = 1; d[t] = (d[i] * 2) % mod; } } for (int i = 1; i \u003c= n; i ++) { sum[i] = (sum[i - 1] + euler[i]) % mod; d[i] = (d[i - 1] + i * d[i]) % mod; } } int qmi(int a, int b) { int res = 1; while (b) { if (b \u0026 1) res = res * a % mod; a = a * a % mod; b \u003e\u003e= 1; } return res; } int Sum_euler(int n) { if (n \u003c N) return sum[n]; if (mp[n]) return mp[n]; int res = n * (n + 1) / 2 % mod; for (int l = 2, r; l \u003c= n; l = r + 1) { r = n / (n / l); res = (res - Sum_euler(n / l) * (r - l + 1) + mod) % mod; } return mp[n] = res; } int Sum(int n) { if (n \u003c N) return d[n]; if (Mp[n]) return Mp[n]; int res = 0; for (int l = 1, r; l \u003c= n; l = r + 1) { r = n / (n / l); res = (res + (l + r) * (r - l + 1) / 2 % mod * (n / l) * (n / l + 1) / 2 % mod) % mod; } return Mp[n] = res; } signed main() { cin \u003e\u003e n \u003e\u003e m \u003e\u003e mod; mod --; get_eulers(N - 1); for (int l = 1, r; l \u003c= n; l = r + 1) { r = n / (n / l); res = (res + (2 * Sum_euler(n / l) - 1) * (Sum(r) - Sum(l - 1) + mod) % mod) % mod; } mod ++; cout \u003c\u003c qmi(m, res) \u003c\u003c endl; } ","date":"2021-09-17","objectID":"/posts/cp2019-icpc%E8%A5%BF%E5%AE%89%E9%82%80%E8%AF%B7%E8%B5%9B-product/:1:0","tags":["莫比乌斯反演","杜教筛"],"title":"[2019 ICPC西安邀请赛] Product","uri":"/posts/cp2019-icpc%E8%A5%BF%E5%AE%89%E9%82%80%E8%AF%B7%E8%B5%9B-product/"},{"categories":["算法竞赛"],"content":"原题链接 题意 $T$ 组询问，回答第 $K_i$ 个不是完全平方数的正整数倍的数。 $1\\le K_i \\le 10^9,T \\le 50$ 分析： ","date":"2021-09-15","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p4318-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/:0:0","tags":["杜教筛"],"title":"[洛谷 P4318] 完全平方数","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p4318-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"},{"categories":["算法竞赛"],"content":"法一： 如果一个数 $n$ 不是完全平方数，那么 $n=p_1^{\\alpha_1}p_2^{\\alpha_2} \\cdots p_k^{\\alpha_k}$ 中 $0 \\le \\alpha_i \\le 1$，所以就想到了莫比乌斯函数，那么题目要询问第 $K$ 个数是什么，可以用二分来解决，但是必须要有单调性，莫比乌斯函数前缀和可能存在负数，所以就想到把莫比乌斯函数做一个平方，这样前缀和就没有负数了，就有了单调性。 现在考虑如何计算 $\\sum\\limits_{i=1} ^{n} \\mu^2(i)$，根据数据范围来看必须要用杜教筛来快速求前缀和，设 $f(n)=\\mu^2(n)$，那么设 $g(n)=[n=k ^ 2,k \\in N^+]$，发现 $f*g=1$，所以 $$S(n)=n-\\sum_{i=2}^{n}g(i)S(\\lfloor \\frac{n}{i} \\rfloor)$$ 改为枚举平方 $$S(n)=n-\\sum_{i=2}^{\\sqrt{n}}S(\\lfloor \\frac{n}{i^2} \\rfloor)$$ ","date":"2021-09-15","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p4318-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/:1:0","tags":["杜教筛"],"title":"[洛谷 P4318] 完全平方数","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p4318-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"},{"categories":["算法竞赛"],"content":"代码($O_2$优化)： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 2e6 + 5; unordered_map\u003cint,int\u003e mp; int T, n, mobius[N], primes[N], cnt, sum[N]; bool st[N]; void get_mobius(int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; primes[j] * i \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = sum[i - 1] + mobius[i] * mobius[i]; } int Sum(int n) { if (n \u003c N) return sum[n]; if (mp[n]) return mp[n]; int res = n; for (int l = 2, r; l * l \u003c= n; l = r + 1) { r = n / (n / l); res -= Sum(n / (l * l)); } return mp[n] = res; } signed main() { get_mobius(N - 1); cin \u003e\u003e T; while (T --) { cin \u003e\u003e n; int l = 1, r = n \u003c\u003c 1; while (l \u003c r) { int mid = l + r \u003e\u003e 1; if (Sum(mid) \u003c n) { l = mid + 1; } else { r = mid; } } cout \u003c\u003c l \u003c\u003c endl; } } ","date":"2021-09-15","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p4318-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/:2:0","tags":["杜教筛"],"title":"[洛谷 P4318] 完全平方数","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p4318-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"},{"categories":["算法竞赛"],"content":"法二： $$\\sum_{i=1}^{n} \\mu^2(i)=\\sum_{i=1} ^{n}\\sum_{d^2 \\mid i} \\mu(d)=\\sum_{d=1} ^{\\sqrt{n}} \\mu(d)\\lfloor \\frac{n}{d^2}\\rfloor$$ ","date":"2021-09-15","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p4318-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/:3:0","tags":["杜教筛"],"title":"[洛谷 P4318] 完全平方数","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p4318-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 2e6 + 5; int T, n, mobius[N], primes[N], cnt, sum[N]; bool st[N]; void get_mobius(int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; primes[j] * i \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = sum[i - 1] + mobius[i]; } int Sum(int n) { int res = 0; for (int l = 1, r; l * l \u003c= n; l = r + 1) { r = n / (n / l); res += (sum[r] - sum[l - 1]) * (n / (l * l)); } return res; } signed main() { get_mobius(N - 1); cin \u003e\u003e T; while (T --) { cin \u003e\u003e n; int l = 1, r = n \u003c\u003c 1; while (l \u003c r) { int mid = l + r \u003e\u003e 1; if (Sum(mid) \u003c n) { l = mid + 1; } else { r = mid; } } cout \u003c\u003c l \u003c\u003c endl; } } ","date":"2021-09-15","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p4318-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/:4:0","tags":["杜教筛"],"title":"[洛谷 P4318] 完全平方数","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p4318-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"},{"categories":["算法竞赛"],"content":"原题链接 题意 $T$ 组输入，给定 $n,a,b$ 求 $$f(n,a,b)=\\sum_{i=1} ^{n}\\sum_{j=1}^{i} \\gcd(i^a-j^a, i ^ b - j ^ b)[\\gcd(i,j)=1]$$ 对 $10^9+7$ 取模，$1 \\le n,a,b \\le10^9$ $a,b$ 互质 分析： $\\gcd$ 的性质： $$\\gcd(a ^ m - b ^ m, a ^ n - b ^ n)=a^{\\gcd(n,m)}-b^{\\gcd(n,m)}$$ 条件：$\\gcd(a,b)=1$ 套用结论带入原式 $$\\sum_{i=1} ^{n}\\sum_{j=1}^{i}( i -j)[\\gcd(i,j)=1]$$ 也就是 $$\\sum_{i=1} ^{n}\\sum_{j=1}^{i}i[\\gcd(i,j)=1]-\\sum_{i=1} ^{n}\\sum_{j=1}^{i}j[\\gcd(i,j)=1]$$ 前半部分$\\sum\\limits_{i=1} ^{n}i\\sum\\limits_{j=1}^{i}[\\gcd(i,j)=1]$是欧拉函数的定义 $\\varphi(i)$ $$\\sum_{i=1} ^{n}i \\varphi(i)-\\sum_{i=1} ^{n}\\sum_{j=1}^{i}j[\\gcd(i,j)=1]$$ 看后半部分，这不就是疯狂LCM那个题吗，所以是 $\\dfrac{i\\varphi(i)+1}{2}$ $$\\sum_{i=1} ^{n}i \\varphi(i)-\\sum_{i=1} ^{n}\\frac{i\\varphi(i)+1}{2}$$ 整理得 $$\\sum_{i=1} ^{n}\\frac{i\\varphi(i)-1}{2}$$ 用杜教筛，令 $f(x)=x\\varphi(x)$，令 $S(n)=\\sum\\limits_{i=1} ^{n}f(i)$ $$g(1)S(n) = \\sum_{i=1} ^{n}f*g-\\sum_{i=2}^{n} g(i)S(\\lfloor\\frac{n}{i} \\rfloor)$$ $$f*g=\\sum_{d \\mid n} d\\varphi(d)g(\\frac{n}{d})$$ 要消掉一个 $d$，所以令 $g(x)=x$ $$f*g=n\\sum_{d \\mid n} \\varphi(d)=n \\cdot \\varphi * I$$ 因为 $\\varphi*I=Id$，所以 $f * g=n^2$，杜教筛原式为 $$S(n) = \\sum_{i=1} ^{n}i^2-\\sum_{i=2}^{n} iS(\\lfloor\\frac{n}{i} \\rfloor)$$ $\\sum\\limits_{i=1}^{n}i^2=\\dfrac{n(n+1)(2n+1)}{6}$ ","date":"2021-09-14","objectID":"/posts/cp2019-ccpc%E7%BD%91%E7%BB%9C%E8%B5%9B-huntian-oy/:0:0","tags":["莫比乌斯反演","杜教筛"],"title":"[2019 CCPC网络赛] huntian oy","uri":"/posts/cp2019-ccpc%E7%BD%91%E7%BB%9C%E8%B5%9B-huntian-oy/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 2e6 + 5, mod = 1e9 + 7; int T, a, b, n, primes[N], euler[N], cnt, sum[N], inv2, inv6; bool st[N]; unordered_map\u003cint, int\u003e mp; int qmi(int a, int b) { int res = 1; while (b) { if (b \u0026 1) res = res * a % mod; a = a * a % mod; b \u003e\u003e= 1; } return res; } void get_eulers(int n) { euler[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; euler[i] = i - 1; } for (int j = 0; primes[j] \u003c= n / i; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { euler[t] = primes[j] * euler[i]; break; } euler[t] = (primes[j] - 1) * euler[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = (sum[i - 1] + i * euler[i] % mod) % mod; } int s2(int n) { return n * (n + 1) % mod * (2 * n + 1) % mod * inv6 % mod; } int Sum(int n) { if (n \u003c N) return sum[n]; if (mp[n]) return mp[n]; int res = s2(n); for (int l = 2, r; l \u003c= n; l = r + 1) { r = n / (n / l); res = (res - (r - l + 1) * (l + r) % mod * inv2 % mod * Sum(n / l) % mod + mod) % mod; } return mp[n] = res; } signed main() { inv2 = qmi(2, mod - 2); inv6 = qmi(6, mod - 2); get_eulers(N - 1); cin \u003e\u003e T; while (T --) { cin \u003e\u003e n \u003e\u003e a \u003e\u003e b; cout \u003c\u003c (Sum(n) - 1 + mod) % mod * inv2 % mod \u003c\u003c endl; } } ","date":"2021-09-14","objectID":"/posts/cp2019-ccpc%E7%BD%91%E7%BB%9C%E8%B5%9B-huntian-oy/:1:0","tags":["莫比乌斯反演","杜教筛"],"title":"[2019 CCPC网络赛] huntian oy","uri":"/posts/cp2019-ccpc%E7%BD%91%E7%BB%9C%E8%B5%9B-huntian-oy/"},{"categories":["算法竞赛"],"content":"题目链接 题意： 求 $$\\sum_{i=1}^{n}\\sum_{j=1}^{n}ij\\gcd(i,j)$$ 对 $p$ 取模，$n \\le10^{10}, 5 ×10^8\\le p \\le1.1 ×10^{9}$ 分析： $$\\sum_{i=1}^{n}\\sum_{j=1}^{n}ij\\gcd(i,j)$$ 枚举 $\\gcd(i,j)$ $$\\sum_{d=1} ^{n} d \\sum_{i=1}^{n}\\sum_{j=1}^{n}ij[\\gcd(i,j)=d]$$ 利用 $\\gcd$ 的性质 $$\\sum_{d=1} ^{n} d \\sum_{i=1}^{n}\\sum_{j=1}^{n}ij[\\gcd(\\frac{i}{d},\\frac{j}{d})=1]$$ 让式子除 $d^2$ 再乘 $d^2$ $$\\sum_{d=1} ^{n} d^3 \\sum_{i=1}^{n}\\sum_{j=1}^{n} \\frac{i}{d} \\cdot \\frac{j}{d}[\\gcd(\\frac{i}{d},\\frac{j}{d})=1]$$ 换一下上界 $$\\sum_{d=1} ^{n} d^3 \\sum_{i=1}^{\\lfloor \\frac{n}{d} \\rfloor}\\sum_{j=1}^{\\lfloor \\frac{n}{d} \\rfloor} i j[\\gcd(i,j)=1]$$ 莫比乌斯反演 $$\\sum_{d=1} ^{n} d^3 \\sum_{i=1}^{\\lfloor \\frac{n}{d} \\rfloor}\\sum_{j=1}^{\\lfloor \\frac{n}{d} \\rfloor} i j \\sum_{k \\mid \\gcd(i,j)} \\mu(k)$$ 交换求和次序 $$\\sum_{d=1} ^{n} d^3 \\sum_{k=1} ^{\\lfloor \\frac{n}{d} \\rfloor} \\mu(k) \\sum_{i=1}^{\\lfloor \\frac{n}{dk} \\rfloor} ik\\sum_{j=1}^{\\lfloor \\frac{n}{dk} \\rfloor} jk$$ 化简后半部分 $$\\sum_{d=1} ^{n} d^3 \\sum_{k=1} ^{\\lfloor \\frac{n}{d} \\rfloor} k^2 \\mu(k) (\\sum_{i=1} ^{\\lfloor \\frac{n}{dk} \\rfloor}i)^2$$ 设 $T=dk$ $$\\sum_{T=1} ^{n} T^2 \\sum_{d \\mid T} d\\mu(\\frac{T}{d}) (\\sum_{i=1} ^{\\lfloor \\frac{n}{T} \\rfloor}i)^2$$ 因为 $\\mu * Id=\\varphi$，替换 $\\sum \\limits_{d \\mid T} d\\mu(\\frac{T}{d})$ 得 $$\\sum_{T=1} ^{n} T^2 \\varphi(T) (\\sum_{i=1} ^{\\lfloor \\frac{n}{T} \\rfloor}i)^2$$ 根据 $(\\dfrac{n^2 +n}{2})^2=1^3+2^3+\\cdots+n^3$ $$\\sum_{T=1} ^{n} T^2 \\varphi(T) \\sum_{i=1} ^{\\lfloor \\frac{n}{T} \\rfloor}i^3$$ 设 $f(x)= x^2\\varphi(x)$ 套用杜教筛，$S(n)$ 为 $\\sum \\limits_{i=1}^{n} f(i)$ $$g(1)S(n)=\\sum_{i=1} ^{n}h(i)-\\sum_{i=1}^{n}g(i)S(\\lfloor \\frac{n}{i} \\rfloor)$$ 那么 $h=f *g$，也就是 $h(n)=\\sum \\limits _{d \\mid n}f(n)g(\\dfrac{n}{d})$，带入 $f(n)$ 得 $$h(n)=\\sum_{d \\mid n} d^2\\varphi(d)g(\\frac{n}{d})$$ 考虑把 $d^2$ 消去，所以设 $g(x)=x^2$，故 $$h(n)=n^2\\sum_{d \\mid n}\\varphi(d)$$ 根据 $\\varphi *I=Id$ $$h(n)=n^3$$ 那么 $f(x)$ 的前缀和就是 $$S(n)=(\\frac{n^2+n}{2})^2-\\sum_{i=2} ^{n}i^2S(\\lfloor \\frac{n}{i} \\rfloor)$$ ","date":"2021-09-13","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p3768-%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98/:0:0","tags":["莫比乌斯反演"],"title":"[洛谷 P3768] 简单的数学题","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p3768-%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 5e6 + 5; int mod, n, euler[N], primes[N], cnt, sum[N], inv, res; bool st[N]; unordered_map\u003cint, int\u003e mp; int qmi(int a, int b) { int res = 1; while (b) { if (b \u0026 1) res = res * a % mod; a = a * a % mod; b \u003e\u003e= 1; } return res; } void get_eulers(int n) { euler[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; euler[i] = i - 1; } for (int j = 0; primes[j] \u003c= n / i; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { euler[t] = primes[j] * euler[i]; break; } euler[t] = (primes[j] - 1) * euler[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = (sum[i - 1] + i * i % mod * euler[i] % mod) % mod; } int s2(int n) { n %= mod; return n * (n + 1) % mod * (2 * n + 1) % mod * inv % mod; } int s3(int n) { n %= mod; return (n * (n + 1) / 2) % mod * ((n * (n + 1) / 2) % mod) % mod; } int Sum(int n) { if (n \u003c N) return sum[n]; if (mp[n]) return mp[n]; int res = s3(n); for (int l = 2, r; l \u003c= n; l = r + 1) { r = n / (n / l); res -= (s2(r) - s2(l - 1) + mod) % mod * Sum(n / l) % mod; res = (res + mod) % mod; } return mp[n] = res; } signed main() { cin \u003e\u003e mod \u003e\u003e n; get_eulers(N - 1); inv = qmi(6, mod - 2); for (int l = 1, r; l \u003c= n; l = r + 1) { r = n / (n / l); res += (Sum(r) - Sum(l - 1) + mod) % mod * s3(n / l) % mod; res = (res % mod + mod) % mod; } cout \u003c\u003c res \u003c\u003c endl; } ","date":"2021-09-13","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p3768-%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98/:1:0","tags":["莫比乌斯反演"],"title":"[洛谷 P3768] 简单的数学题","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p3768-%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98/"},{"categories":["算法竞赛"],"content":"杜教筛 杜教筛可以在 $O(n ^{\\frac{2}{3}})$ 的复杂度内求解积性函数的前缀和 设数论函数 $f(x)$，求 $$\\sum_{i=1}^{n}f(i)$$ 令 $S(n) = \\sum \\limits_{i=1} ^{n} f(i)$，找一个数论函数 $g(x)$ 与 $f(x)$ 做卷积 $$\\sum_{i=1} ^ {n} f * g = \\sum_{i=1} ^{n}g *f$$ 展开卷积 $$\\sum_{i=1}^{n} \\sum_{d \\mid i}g(d)f(\\frac{i}{d})$$ 交换求和次序 $$\\sum_{d=1} ^{n}g(d) \\sum_{i=1}^{\\lfloor\\frac{n}{d} \\rfloor} f(i)$$ 后半部分其实就是 $S(\\lfloor\\dfrac{n}{d} \\rfloor)$，换一下变量名得 $$\\sum_{i=1} ^{n}g(i)S(\\lfloor\\frac{n}{i} \\rfloor)$$ 那么就有递推公式 $$g(1)S(n) = \\sum_{i=1} ^{n}f*g-\\sum_{i=2}^{n} g(i)S(\\lfloor\\frac{n}{i} \\rfloor)$$ 假设 $\\sum\\limits _{i=1} ^{n}f*g$ 可以快速求出，后半部分则可以用数论分块求解 ","date":"2021-09-13","objectID":"/posts/cp%E6%9D%9C%E6%95%99%E7%AD%9B/:1:0","tags":["数论","杜教筛"],"title":"杜教筛","uri":"/posts/cp%E6%9D%9C%E6%95%99%E7%AD%9B/"},{"categories":["算法竞赛"],"content":"莫比乌斯函数前缀和 由狄利克雷卷积 $$\\varepsilon = \\mu * I$$ 设 $h=\\varepsilon,f=\\mu,g=I$ 套用杜教筛 $$S(n) = \\sum_{i=1} ^{n}\\varepsilon(i)-\\sum_{i=2}^{n} I(i)S(\\lfloor\\frac{n}{i} \\rfloor)$$ 化简可得 $$S(n) = 1 - \\sum_{i=2}^{n} S(\\lfloor\\frac{n}{i} \\rfloor)$$ ","date":"2021-09-13","objectID":"/posts/cp%E6%9D%9C%E6%95%99%E7%AD%9B/:2:0","tags":["数论","杜教筛"],"title":"杜教筛","uri":"/posts/cp%E6%9D%9C%E6%95%99%E7%AD%9B/"},{"categories":["算法竞赛"],"content":"欧拉函数前缀和 法一: 先对欧拉函数用莫比乌斯反演 $$\\sum_{i=1} ^{n}\\varphi(i)$$ 展开欧拉函数 $$\\sum_{i=1} ^{n} \\sum_{j = 1} ^{n} [\\gcd(i,j)=1]$$ 莫比乌斯反演 $$\\sum_{i=1}^{n} \\sum_{j = 1} ^{n} \\sum_{d \\mid \\gcd(i,j)}\\mu(d)$$ 交换求和次序 $$\\sum_{d=1} ^{n}\\mu(d) \\lfloor \\frac{n}{d} \\rfloor ^2$$ 那么就可以用前面的莫比乌斯函数前缀和来求解了 注意要减去 $i=1,j=1$ 的情况，并且 $/2$ 法二： 由狄利克雷卷积 $$Id = \\varphi * I$$ 设 $h = Id,f=\\varphi,g=I$ 套用杜教筛 $$S(n) = \\sum_{i=1} ^{n}Id(i)-\\sum_{i=2}^{n} I(i)S(\\lfloor\\frac{n}{i} \\rfloor)$$ $$S(n) = \\sum_{i=1} ^{n}i-\\sum_{i=2}^{n} S(\\lfloor\\frac{n}{i} \\rfloor)$$ 等差数列求和 $$S(n) = \\frac{n (n + 1)}{2} - \\sum_{i=2}^{n} S(\\lfloor\\frac{n}{i} \\rfloor)$$ ","date":"2021-09-13","objectID":"/posts/cp%E6%9D%9C%E6%95%99%E7%AD%9B/:3:0","tags":["数论","杜教筛"],"title":"杜教筛","uri":"/posts/cp%E6%9D%9C%E6%95%99%E7%AD%9B/"},{"categories":["算法竞赛"],"content":"代码(两个函数一起求)： 题目：洛谷P4213 #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 2e6 + 5; int T, n, mobius[N], primes[N], cnt, sum[N]; bool st[N]; unordered_map\u003cint, int\u003e mp; void get_mobius(int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; primes[j] * i \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = sum[i - 1] + mobius[i]; } int sum_mobius(int n) { if (n \u003c N) return sum[n]; if (mp[n]) return mp[n]; int res = 1; for (int l = 2, r; l \u003c= n; l = r + 1) { r = n / (n / l); res -= sum_mobius(n / l) * (r - l + 1); } return mp[n] = res; } int sum_phi(int n) { int res = 0; for (int l = 1, r; l \u003c= n; l = r + 1) { r = n / (n / l); res += (sum_mobius(r) - sum_mobius(l - 1)) * (n / l) * (n / l); } return (res - 1) / 2 + 1; } signed main() { get_mobius(N - 1); cin \u003e\u003e T; while (T --) { cin \u003e\u003e n; cout \u003c\u003c sum_phi(n) \u003c\u003c \" \" \u003c\u003c sum_mobius(n) \u003c\u003c endl; } } ","date":"2021-09-13","objectID":"/posts/cp%E6%9D%9C%E6%95%99%E7%AD%9B/:4:0","tags":["数论","杜教筛"],"title":"杜教筛","uri":"/posts/cp%E6%9D%9C%E6%95%99%E7%AD%9B/"},{"categories":["算法竞赛"],"content":"题目链接 题意： 求 $$\\sum_{i = 1} ^{n} \\sum_{j = 1} ^{m} \\text{lcm}(i, j)$$ 对 $20101009$ 取模 分析： 首先 $\\text{lcm}(i, j) = \\dfrac{i \\cdot j}{\\gcd(i,j)}$ 代入： $$\\sum_{i = 1} ^{n} \\sum_{j = 1} ^{m} \\frac{i \\cdot j}{\\gcd(i,j)}$$ 枚举 $\\gcd(i,j)$ $$\\sum_{d = 1} ^{\\min(n,m)}\\sum_{i = 1} ^{n} \\sum_{j = 1} ^{m} \\frac{i \\cdot j}{d}[\\gcd(i,j)=d] $$ 根据 $\\gcd$ 的性质： $$\\sum_{d = 1} ^{\\min(n,m)}\\sum_{i = 1} ^{n} \\sum_{j = 1} ^{m} \\frac{i \\cdot j}{d}[\\gcd(\\frac{i}{d}, \\frac{j}{d}) = 1] $$ 在 $\\dfrac{i \\cdot j}{d}$ 中 除一个 $d$ 乘一个 $d$，来凑形式一致。 $$\\sum_{d = 1} ^{\\min(n,m)}d \\sum_{i = 1} ^{n} \\sum_{j = 1} ^{m} \\frac{i}{d}\\cdot \\frac{j}{d} [\\gcd(\\frac{i}{d}, \\frac{j}{d}) = 1] $$ 替换 $\\dfrac{i}{d},\\dfrac{j}{d}$ $$\\sum_{d = 1} ^{\\min(n,m)}d \\sum_{i = 1} ^{ \\lfloor \\frac{n}{d} \\rfloor } \\sum_{j = 1} ^{\\lfloor \\frac{m}{d} \\rfloor }i\\cdot j [\\gcd(i, j) = 1]$$ 用单位函数替换 $$\\sum_{d = 1} ^{\\min(n,m)}d \\sum_{i = 1} ^{ \\lfloor \\frac{n}{d} \\rfloor } \\sum_{j = 1} ^{\\lfloor \\frac{m}{d} \\rfloor }i\\cdot j \\cdot \\varepsilon (\\gcd(i, j) = 1)$$ 莫比乌斯反演 $$\\sum_{d = 1} ^{\\min(n,m)}d \\sum_{i = 1} ^{ \\lfloor \\frac{n}{d} \\rfloor } \\sum_{j = 1} ^{\\lfloor \\frac{m}{d} \\rfloor }i\\cdot j \\sum_{k \\mid \\gcd(i,j)} \\mu(k)$$ 交换求和次序 $$\\sum_{d = 1} ^{\\min(n,m)}d \\sum_{k =1} ^{\\min(\\lfloor \\frac{n}{d} \\rfloor,\\lfloor \\frac{m}{d} \\rfloor)} \\mu(k) \\sum_{i = 1} ^{ \\lfloor \\frac{n}{dk} \\rfloor } i \\cdot k \\sum_{j = 1} ^{\\lfloor \\frac{m}{dk} \\rfloor } j \\cdot k$$ 整理式子 $$\\frac{1}{4} \\sum_{d = 1} ^{\\min(n,m)}d \\sum_{k =1} ^{\\min(\\lfloor \\frac{n}{d} \\rfloor,\\lfloor \\frac{m}{d} \\rfloor)} k^2 \\mu(k) (\\lfloor \\frac{n}{dk} \\rfloor ^2 + \\lfloor \\frac{n}{dk} \\rfloor) \\cdot (\\lfloor \\frac{m}{dk} \\rfloor ^2 + \\lfloor \\frac{m}{dk} \\rfloor) $$ 时间复杂度 $O(N\\sqrt{N})$ ","date":"2021-09-09","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p1829-crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC/:0:0","tags":["莫比乌斯反演"],"title":"[洛谷 P1829] Crash的数字表格","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p1829-crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 1e7 + 5, mod = 20101009; int n, m, mobius[N], primes[N], cnt, res, sum[N]; bool st[N]; void get_mobius(int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; primes[j] * i \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = (sum[i - 1] + i * i * mobius[i] % mod + mod) % mod; } signed main() { get_mobius(N - 1); cin \u003e\u003e n \u003e\u003e m; for (int d = 1; d \u003c= min(n, m); d ++) { int x = n / d, y = m / d, Sum = 0; for (int l = 1, r; l \u003c= min(x, y); l = r + 1) { r = min(x / (x / l), y / (y / l)); int p = ((x / l) * (x / l) + x / l) / 2 % mod, q = ((y / l) * (y / l) + y / l) / 2 % mod; Sum += (sum[r] - sum[l - 1]) % mod * p % mod * q % mod; Sum = (Sum % mod + mod) % mod; } res = (res + d * Sum) % mod; } cout \u003c\u003c res \u003c\u003c endl; } ","date":"2021-09-09","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p1829-crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC/:1:0","tags":["莫比乌斯反演"],"title":"[洛谷 P1829] Crash的数字表格","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p1829-crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC/"},{"categories":["算法竞赛"],"content":"题目链接 题意： 求 $$\\sum_{i=1} ^{n} \\text{lcm}(i,n)$$ 分析： ","date":"2021-09-08","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p1891-%E7%96%AF%E7%8B%82-lcm/:0:0","tags":["莫比乌斯反演","欧拉函数"],"title":"[洛谷 P1891] 疯狂 LCM","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p1891-%E7%96%AF%E7%8B%82-lcm/"},{"categories":["算法竞赛"],"content":"法一：欧拉函数 拆一下 $\\text{lcm}(i,n) = \\dfrac{i \\cdot n}{\\gcd{(i,n)}}$ 变为： $$\\sum_{i=1} ^{n} \\frac{i \\cdot n}{\\gcd{(i,n)}}$$ 枚举 $\\gcd(i,n)$： $$n \\sum_{d \\mid n} \\sum_{i=1} ^{n} \\frac{i }{d}[\\gcd{(i,n)} = d ]$$ 利用 $\\gcd$ 的性质： $$n \\sum_{d \\mid n} \\sum_{i=1} ^{n} \\frac{i }{d}[\\gcd{(\\frac{i}{d},\\frac{n}{d})} = 1 ]$$ 把 $d$ 拿到上界 $$n \\sum_{d \\mid n} \\sum_{i=1} ^{ \\lfloor \\frac{n}{d} \\rfloor } i[\\gcd{(i,\\frac{n}{d})} = 1 ]$$ $\\lfloor \\dfrac{n}{d} \\rfloor$ 等价于 $d$ $$n \\sum_{d \\mid n} \\sum_{i=1} ^{ d } i[\\gcd{(i,d)} = 1 ]$$ 由于 $\\gcd(i, d) = \\gcd(d - i,d)$ ，所以因子必成对出现（除了1），那么总共出现了 $\\dfrac{\\varphi(d)}{2}$ 次，$d - i + i =d$，所以就是 $$n \\sum_{d \\mid n} \\frac{\\varphi(d)}{2} d$$ 这样时间复杂度是 $O(N+T\\sqrt{n})$，但是可以用狄利克雷卷积优化，可以做到 $O(N \\log{N} + T)$ 设 $F(x) = \\dfrac{x \\cdot \\varphi(x)}{2}$ 则答案为 $n \\cdot F * \\textbf{1}$，注意处理 $d=1$ 的情况。 ","date":"2021-09-08","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p1891-%E7%96%AF%E7%8B%82-lcm/:1:0","tags":["莫比乌斯反演","欧拉函数"],"title":"[洛谷 P1891] 疯狂 LCM","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p1891-%E7%96%AF%E7%8B%82-lcm/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; int cnt; vector\u003cint\u003e primes, euler, f; vector\u003cbool\u003e st; void init(int n) { f.resize(n + 1), primes.resize(n + 1), euler.resize(n + 1), st.resize(n + 1); euler[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; euler[i] = i - 1; } for (int j = 0; i * primes[j] \u003c= n; j ++) { int t = i * primes[j]; st[t] = 1; if (i % primes[j] == 0) { euler[t] = euler[i] * primes[j]; break; } euler[t] = euler[i] * (primes[j] - 1); } } for (int i = 1; i \u003c= n; i ++) { for (int j = i; j \u003c= n; j += i) { f[j] += (euler[i] * i + 1) / 2; } } } void solve() { int n; cin \u003e\u003e n; cout \u003c\u003c n * f[n] \u003c\u003c \"\\n\"; } signed main() { init(1e6); cin.tie(0) -\u003e sync_with_stdio(0); int T; cin \u003e\u003e T; while (T --) { solve(); } } ","date":"2021-09-08","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p1891-%E7%96%AF%E7%8B%82-lcm/:2:0","tags":["莫比乌斯反演","欧拉函数"],"title":"[洛谷 P1891] 疯狂 LCM","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p1891-%E7%96%AF%E7%8B%82-lcm/"},{"categories":["算法竞赛"],"content":"法二：莫比乌斯反演 还是法一的式子，推到这一步 $$n \\sum_{d \\mid n} \\sum_{i=1} ^{ d } i[\\gcd{(i,d)} = 1 ]$$ 用单位函数替换 $$n \\sum_{d \\mid n} \\sum_{i=1} ^{ d } i \\cdot \\varepsilon (\\gcd{(i,d)})$$ 莫比乌斯反演 $$n \\sum_{d \\mid n} \\sum_{i=1} ^{ d } i \\sum_{k \\mid \\gcd(i,d) } \\mu(k)$$ 交换枚举次序 $$n \\sum_{d \\mid n} \\sum_{k \\mid d} k\\mu(k) \\sum_{i=1} ^ { \\lfloor \\frac{d}{k} \\rfloor } i$$ 对后半部分求和 $$\\frac{n}{2} \\sum_{d \\mid n} \\sum_{k \\mid d} k\\mu(k) (\\lfloor \\frac{d}{k} \\rfloor ^ 2 + \\lfloor \\frac{d}{k} \\rfloor) $$ 可以用狄利克雷卷积优化到 $O(N\\log N +T)$ 设 $f(x)=x \\cdot \\mu(x)$ ，$g(x)=x^2+x$，$F(x) = f * g$ 那么答案就为： $$\\frac{n}{2} \\cdot F * \\textbf {1}$$ ","date":"2021-09-08","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p1891-%E7%96%AF%E7%8B%82-lcm/:3:0","tags":["莫比乌斯反演","欧拉函数"],"title":"[洛谷 P1891] 疯狂 LCM","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p1891-%E7%96%AF%E7%8B%82-lcm/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 1e6 + 5; int T, n, mobius[N], primes[N], cnt, F[N], ans[N]; bool st[N]; void get_mobius(int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; primes[j] * i \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } for (int i = 1; i \u003c= n; i ++) { for (int j = i; j \u003c= n; j += i) { F[j] += i * mobius[i] * ((j / i) * (j / i) + (j / i)); } } for (int i = 1; i \u003c= n; i ++) { for (int j = i; j \u003c= n; j += i) { ans[j] += F[i]; } } } signed main() { get_mobius(N - 1); cin \u003e\u003e T; while (T --) { cin \u003e\u003e n; cout \u003c\u003c n * ans[n] / 2 \u003c\u003c endl; } } ","date":"2021-09-08","objectID":"/posts/cp%E6%B4%9B%E8%B0%B7-p1891-%E7%96%AF%E7%8B%82-lcm/:4:0","tags":["莫比乌斯反演","欧拉函数"],"title":"[洛谷 P1891] 疯狂 LCM","uri":"/posts/cp%E6%B4%9B%E8%B0%B7-p1891-%E7%96%AF%E7%8B%82-lcm/"},{"categories":["算法竞赛"],"content":"定义： 对于两个数论函数 $f(x),g(x)$ 那么它们的卷积 $h(x)$ 记作 $f(x) * g(x)$，式子如下： $$f(x) * g(x) = h(x) = \\sum_{d \\mid n} f(d)g(\\frac{n}{d})$$ 简记为 $h = f * g$ ","date":"2021-09-06","objectID":"/posts/cp%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/:1:0","tags":["数论"],"title":"狄利克雷卷积","uri":"/posts/cp%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/"},{"categories":["算法竞赛"],"content":"性质： 交换律： $f * g = g * f$ 结合律： $(f * g) * h = f * (g * h)$ 分配律： $(f + g) * h = f * h + g * h$ 单位元： 对 $\\forall f(x), f * \\varepsilon = f$ 逆元： 对一个非零的数论函数 $f(x)$，和另一个数论函数 $g(x)$ 满足 $f*g=\\varepsilon$，则称 $g(x)$ 为 $f(x)$ 的逆元。 $g(x) = \\dfrac{\\varepsilon - \\sum \\limits_{d \\mid x,d \\ne 1} f(d)g(\\dfrac{x}{d})}{f(1)}$ 积性函数的逆元还是积性函数 两个积性函数的狄利克雷卷积还是积性函数 ","date":"2021-09-06","objectID":"/posts/cp%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/:2:0","tags":["数论"],"title":"狄利克雷卷积","uri":"/posts/cp%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/"},{"categories":["算法竞赛"],"content":"常见积性函数： 1. 莫比乌斯函数：$\\mu(x)$ 设 $n=p_1^{c_1}\\cdots p_k^{c_k}$ $$\\mu(n)=\\begin{cases} 0,\u0026\\exists i \\in[1,k],c_i \u003e1 \\\\ 1,\u0026k \\equiv 0\\pmod2,\\forall i \\in[1,k],c_i=1\\\\ -1,\u0026k\\equiv1\\pmod2,\\forall i\\in [1,k],c_i=1 \\end{cases}$$ 2. 欧拉函数：$\\varphi(x)$ $\\varphi(n) = \\sum \\limits_{i=1} ^{n}[\\gcd(i,n) = 1]$ 3. 单位函数：$\\varepsilon(x)$ $\\varepsilon(n) = [n = 1]$ 4. 恒等函数：$Id(x)$ $Id(n) = n$ 5. 常数函数：$I(x)$ $I(n)=1$ 6. 约数个数函数：$d(x)$ $d(n)=\\sum \\limits_{i \\mid n}1$ 7. 约数和函数：$\\sigma(x)$ $\\sigma(n)=\\sum \\limits_{d \\mid n} d$ ","date":"2021-09-06","objectID":"/posts/cp%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/:3:0","tags":["数论"],"title":"狄利克雷卷积","uri":"/posts/cp%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/"},{"categories":["算法竞赛"],"content":"常见卷积： 1. $\\varepsilon = \\mu * 1$ $\\varepsilon = [n=1]=\\sum \\limits _{d \\mid n} \\mu (d)$ 2. $d = 1 * 1$ $d(n)=\\sum \\limits_{i \\mid n}1$ 3. $Id * 1 = \\sigma$ $\\sigma(n)=\\sum \\limits_{d \\mid n} d$ 4. $\\mu * Id = \\varphi$ $\\varphi(n)=\\sum \\limits _{d \\mid n} d \\cdot \\mu(\\dfrac{n}{d})$ 5. $\\varphi * 1 = Id$ $Id(n)=\\sum \\limits _{d \\mid n} \\varphi(d)$ ","date":"2021-09-06","objectID":"/posts/cp%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/:4:0","tags":["数论"],"title":"狄利克雷卷积","uri":"/posts/cp%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/"},{"categories":["算法竞赛"],"content":"狄利克雷卷积证莫比乌斯反演： 已知 $f = g * 1$ 其中 $1$ 的逆元为 $\\mu$，所以有 $f * \\mu = g$ ","date":"2021-09-06","objectID":"/posts/cp%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/:5:0","tags":["数论"],"title":"狄利克雷卷积","uri":"/posts/cp%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/"},{"categories":["算法竞赛"],"content":"题目链接 题意： 求 $$2\\sum_{i=1}^{n}\\sum_{j=1}^{m}\\gcd(i,j)-nm$$ 分析： ","date":"2021-08-24","objectID":"/posts/cpnoi2010-%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86/:0:0","tags":["莫比乌斯反演","欧拉反演"],"title":"[NOI2010] 能量采集","uri":"/posts/cpnoi2010-%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86/"},{"categories":["算法竞赛"],"content":"莫比乌斯反演： 那么只需要求 $$\\sum_{i=1}^{n}\\sum_{j=1}^{m}\\gcd(i,j)$$ 枚举每个 $\\gcd(i,j)$ 的值 $$\\sum_{d=1}^{n}d\\sum_{i=1}^{n}\\sum_{j=1}^{m}[\\gcd(i,j)=d]$$ 再用莫比乌斯反演，和 problem b 这题是一样的 $$\\sum_{d=1}^{n}d\\sum_{i=1}^{\\left \\lfloor \\frac{\\min(n,m)}{d} \\right \\rfloor }\\mu(i)\\left \\lfloor \\frac{n}{di} \\right \\rfloor \\left \\lfloor \\frac{m}{di} \\right \\rfloor $$ 后面可用整除分块。 ","date":"2021-08-24","objectID":"/posts/cpnoi2010-%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86/:1:0","tags":["莫比乌斯反演","欧拉反演"],"title":"[NOI2010] 能量采集","uri":"/posts/cpnoi2010-%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 1e5 + 5; int n, m, mobius[N], primes[N], cnt, res, sum[N]; bool st[N]; void get_mobius(int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; primes[j] * i \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = sum[i - 1] + mobius[i]; } signed main() { get_mobius(N - 1); cin \u003e\u003e n \u003e\u003e m; for (int d = 1; d \u003c= n; d ++) { int k = min(n, m) / d, ans = 0; for (int l = 1, r; l \u003c= k; l = r + 1) { r = min(n / (n / l), m / (m / l)); ans += (sum[r] - sum[l - 1]) * (n / (d * l)) * (m / (d * l)); } res += d * ans; } cout \u003c\u003c 2 * res - n * m \u003c\u003c endl; } ","date":"2021-08-24","objectID":"/posts/cpnoi2010-%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86/:2:0","tags":["莫比乌斯反演","欧拉反演"],"title":"[NOI2010] 能量采集","uri":"/posts/cpnoi2010-%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86/"},{"categories":["算法竞赛"],"content":"欧拉反演： 定理： $$n=\\sum_{d \\mid n} \\varphi(d)$$ 原式为 $$\\sum_{i=1}^{n}\\sum_{j=1}^{m}\\gcd(i,j)$$ 将 $\\gcd(i,j)$ 套用欧拉反演定理 $$\\sum_{i=1}^{n}\\sum_{j=1}^{m} \\sum_{d \\mid \\gcd(i,j)}\\varphi(d)$$ 将 $\\varphi(d)$ 提到前面，枚举 $d$ $$\\sum_{d=1}^{n}\\varphi(d)\\sum_{i=1}^{n}\\sum_{j=1}^{m}[d \\mid \\gcd(i,j)]$$ 化简后面 $$\\sum_{d=1}^{n}\\varphi(d)\\left \\lfloor \\frac{n}{d} \\right \\rfloor \\left \\lfloor \\frac{m}{d} \\right \\rfloor $$ 预处理欧拉函数前缀和，用整除分块即可。 ","date":"2021-08-24","objectID":"/posts/cpnoi2010-%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86/:3:0","tags":["莫比乌斯反演","欧拉反演"],"title":"[NOI2010] 能量采集","uri":"/posts/cpnoi2010-%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; const int N = 1e5 + 5; int n, m, primes[N], euler[N], cnt, res, sum[N]; bool st[N]; void get_eulers(int n) { euler[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; euler[i] = i - 1; } for (int j = 0; primes[j] \u003c= n / i; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { euler[t] = primes[j] * euler[i]; break; } euler[t] = (primes[j] - 1) * euler[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = sum[i - 1] + euler[i]; } signed main() { get_eulers(N - 1); cin \u003e\u003e n \u003e\u003e m; for (int l = 1, r; l \u003c= min(n, m); l = r + 1) { r = min(n / (n / l), m / (m / l)); res += (sum[r] - sum[l - 1]) * (n / l) * (m / l); } cout \u003c\u003c 2 * res - n * m \u003c\u003c endl; } ","date":"2021-08-24","objectID":"/posts/cpnoi2010-%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86/:4:0","tags":["莫比乌斯反演","欧拉反演"],"title":"[NOI2010] 能量采集","uri":"/posts/cpnoi2010-%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86/"},{"categories":["算法竞赛"],"content":"$\\text{BSGS (Baby Step Giant Step)}:$ 给定正整数 $a,b,p,a \\perp p$ ，求满足 $$a^{x} \\equiv b(\\text{ mod } p)$$ 的最小非负整数 $x$ 首先由欧拉定理的推论有： $$a^x\\equiv a^{x\\text{ mod }\\varphi (p)}(\\text{ mod }p)$$ 所以 $a^x$ 在模 $p$ 意义下的最小循环节为 $\\varphi(p)$ ，那么只需要考虑 $x \\in [0,\\varphi(p)-1]$ 即可，为了简便避免算欧拉函数，我们对欧拉函数进行放缩 $\\varphi(p) \\le p + 1$，那就是枚举 $x \\in [0,p]$。那么我们对暴力枚举的算法做一个优化：令 $x =kt-y$ $,k=\\lfloor \\sqrt{p} \\rfloor +1$，则原式为 $$a^{kt}\\equiv ba^{y} (\\text{ mod }p)$$ $y$ 的范围是 $[0,k-1]$ ，所以可以枚举每个 $y$ ，预处理右边的值，插入到一个哈希表中，再枚举左边的 $t\\in[1,k]$ 如果从哈希表找到值，那么就是答案，特判 $t=0$ 的情况，时间复杂度 $O(\\sqrt{p})$ ","date":"2021-07-25","objectID":"/posts/cpbsgsexbsgs/:1:0","tags":["数论"],"title":"BSGS、exBSGS","uri":"/posts/cpbsgsexbsgs/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; int a, b, p; int bsgs(int a, int b, int p) { if (1 % p == b % p) return 0; int k = sqrt(p) + 1; unordered_map\u003cint, int\u003e mp; for (int i = 0, j = b % p; i \u003c k; i ++) { mp[j] = i; j = j * a % p; } int ak = 1; for (int i = 0; i \u003c k; i ++) ak = ak * a % p; for (int i = 1, j = ak; i \u003c= k; i ++) { if (mp.count(j)) return i * k - mp[j]; j = j * ak % p; } return -1; } signed main() { while (cin \u003e\u003e a \u003e\u003e p \u003e\u003e b, a || b || p) { int res = bsgs(a, b, p); if (res == -1) { cout \u003c\u003c \"No Solution\" \u003c\u003c endl; } else { cout \u003c\u003c res \u003c\u003c endl; } } } ","date":"2021-07-25","objectID":"/posts/cpbsgsexbsgs/:2:0","tags":["数论"],"title":"BSGS、exBSGS","uri":"/posts/cpbsgsexbsgs/"},{"categories":["算法竞赛"],"content":"$\\text{exBSGS}:$ 给定正整数 $a,b,p$ ，$a,p$ 不一定互质，求满足 $$a^{x} \\equiv b(\\text{ mod } p)$$ 的最小非负整数 $x$ 分情况来看，如果 $x=0$ 时，满足 $1 \\equiv b(\\text{ mod } p)$，答案就是 $0$ 如果 $\\gcd(a,p)=1$，那么就直接用朴素 $\\text{BSGS}$ 算法 如果 $\\gcd(a,p) \u003e 1$，由裴蜀定理得 $$a^x+kp = b$$ 设 $\\gcd(a,p)=d$，如果$d\\nmid p$ 那么无解，否则，等式两边同除 $d$ 得 $$\\frac{a}{d}a^{x-1}+k\\frac{p}{d} = \\frac{b}{d}$$ 等价于同余方程： $$\\frac{a}{d}a^{x-1} \\equiv\\frac{b}{d} (\\text{ mod }\\frac{p}{d})$$ 由于 $\\gcd(\\frac{a}{d},\\frac{p}{d})=1$ ，所以把 $\\frac{a}{d}$ 移到等式右边，就是乘 $\\frac{a}{d}$ 的逆元 $$a^{x-1} \\equiv\\frac{b}{d} (\\frac{a}{d})^{-1}(\\text{ mod }\\frac{p}{d})$$ 用新变量替换： $$ (a')^{x} \\equiv b' \\pmod {p'} $$ 由于 $x \\ge 1$，这样就可以递归地用 $\\text{BSGS}$ 求解了，新的解就为 $x+1$，逆元可以用扩展欧几里得算法求解。 ","date":"2021-07-25","objectID":"/posts/cpbsgsexbsgs/:3:0","tags":["数论"],"title":"BSGS、exBSGS","uri":"/posts/cpbsgsexbsgs/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long using namespace std; int a, b, p; int exgcd(int a, int b, int\u0026 x, int\u0026 y) { if (!b) { x = 1, y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; } int bsgs(int a, int b, int p) { if (1 % p == b % p) return 0; int k = sqrt(p) + 1; unordered_map\u003cint, int\u003e mp; for (int i = 0, j = b % p; i \u003c k; i ++) { mp[j] = i; j = j * a % p; } int ak = 1; for (int i = 0; i \u003c k; i ++) ak = ak * a % p; for (int i = 1, j = ak; i \u003c= k; i ++) { if (mp.count(j)) return i * k - mp[j]; j = j * ak % p; } return -1; } int exbsgs(int a, int b, int p) { b = (b % p + p) % p; if (1 % p == b % p) return 0; int x, y; int d = exgcd(a, p, x, y); if (d \u003e 1) { if (b % d) return -2e9; exgcd(a / d, p / d, x, y); return exbsgs(a, b / d * x % (p / d), p / d) + 1; } return bsgs(a, b, p); } signed main() { while (cin \u003e\u003e a \u003e\u003e p \u003e\u003e b, a || b || p) { int res = exbsgs(a, b, p); if (res \u003c 0) { cout \u003c\u003c \"No Solution\" \u003c\u003c endl; } else { cout \u003c\u003c res \u003c\u003c endl; } } } ","date":"2021-07-25","objectID":"/posts/cpbsgsexbsgs/:4:0","tags":["数论"],"title":"BSGS、exBSGS","uri":"/posts/cpbsgsexbsgs/"},{"categories":["算法竞赛"],"content":"题目链接 题意： 设 $d(x)$ 为 $x$ 的约数个数，求 $$\\sum_{i=1}^{N}\\sum_{j=1}^{M} d(ij)$$ 分析： 首先 $i=p_1 ^{\\alpha_1}\\cdots p_k^{\\alpha_k},j=p_1 ^{\\beta_1}\\cdots p_k^{\\beta_k},i×j=p_1 ^{\\alpha_1+\\beta_1}\\cdots p_k^{\\alpha_k+\\beta_k}$ 约数个数和为 $$d(ij)=(\\alpha_1+\\beta_1+1)\\cdots(\\alpha_k+\\beta_k+1)=\\alpha_1\\beta_2+\\cdots + 1$$ 所以$$d(ij)=\\sum_{x|i}\\sum_{y|j}[\\gcd(x,y)=1]$$ 所以原式为 $$\\sum_{i=1}^{N}\\sum_{j=1}^{M}\\sum_{x|i}\\sum_{y|j}[\\gcd(x,y)=1]$$ 设 $g(n)$ 为： $$g(n)=\\sum_{i=1}^{N}\\sum_{j=1}^{M}\\sum_{x|i}\\sum_{y|j}[n\\mid\\gcd(x,y)]$$ 设 $f(n)$ 为： $$\\sum_{i=1}^{N}\\sum_{j=1}^{M}\\sum_{x|i}\\sum_{y|j}[\\gcd(x,y)=n]$$ 则有 $$g(n)=\\sum_{n\\mid d} f(d)$$ 那么就可以莫比乌斯反演了 $$f(n)=\\sum_{n\\mid d}\\mu(\\frac{d}{n})g(d)$$ 交换 $g(n)$ 的求和次序 由于 $x,y$ 分别是 $i,j$ 的约数，所以可以先枚举 $x,y$ 那么后面的 $[n \\mid \\gcd(x,y)]$ 与 $i,j$ 无关不需要考虑，所以只需要计算 $i$ 中有多少 $x$ 的倍数， $j$ 中有多少 $y$ 的倍数，所以是 $\\lfloor \\frac{N}{x} \\rfloor \\lfloor \\frac{M}{y} \\rfloor$ 所以式子就变为了 $$\\sum_{x=1}^{N}\\sum_{y=1}^{M}\\lfloor \\frac{N}{x} \\rfloor \\lfloor \\frac{M}{y} \\rfloor[n \\mid \\gcd(x,y)]$$ $[n \\mid \\gcd(x,y)]$ 只需要关心 $n$ 的倍数即可，那么就是 $$x’=\\frac{x}{n},y’=\\frac{y}{n}$$ 替换得 $$\\sum_{x’=1}^{\\frac{N}{n}}\\sum_{y’=1}^{\\frac{M}{n}} \\lfloor\\frac{N}{nx’} \\rfloor \\lfloor\\frac{M}{ny’} \\rfloor$$ 设 $$N’=\\frac{N}{n},M’=\\frac{M}{n}$$ 则 $$\\sum_{x’=1}^{N’}\\sum_{y’=1}^{M’} \\lfloor\\frac{N’}{x’} \\rfloor \\lfloor\\frac{M’}{y’} \\rfloor$$ 假设有二重积分 $$\\iint_{D}f(x,y)\\text{d}x\\text{d}y$$ 当区域 $D$ 为矩形区域时，可以转为二次积分 $$\\int_{D_1}f(x,y)\\text{d}x\\int_{D_2}f(x,y)\\text{d}y$$ 那么原式可以变为 $$\\sum_{x’=1}^{N’}\\lfloor\\frac{N’}{x’} \\rfloor \\sum_{y’=1}^{M’}\\lfloor\\frac{M’}{y’} \\rfloor$$ 设 $$h(x)=\\sum_{i=1}^{x}\\lfloor\\frac{x}{i} \\rfloor$$ 那么 $$f(n)=\\sum_{n\\mid d}\\mu(\\frac{d}{n})g(d)$$ 答案为 $$f(1)=\\sum_{d=1}^{N}\\mu(d)g(d)$$ 带入 $g(d)$ $$\\sum_{i=1}^{\\min(N,M)}\\mu(i)h(\\lfloor \\frac{N}{i} \\rfloor)h(\\lfloor \\frac{M}{i} \\rfloor)$$ 可以用整除分块计算，$h(x)$ 也同样可以用整除分块预处理。 ","date":"2021-07-23","objectID":"/posts/cpsdoi2015-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C/:0:0","tags":["莫比乌斯反演"],"title":"[SDOI2015] 约数个数和","uri":"/posts/cpsdoi2015-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cstdio.h\u003e #include \u003calgorithm\u003e #define int long long using namespace std; const int N = 5e4 + 5; int T, n, m, primes[N], mobius[N], cnt, sum[N], h[N]; bool st[N]; void get_mobius(int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; primes[j] * i \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = sum[i - 1] + mobius[i]; } void get_h(int n) { for (int i = 1; i \u003c= n; i ++) { for (int l = 1, r; l \u003c= i; l = r + 1) { r = min(i, i / (i / l)); h[i] += (r - l + 1) * (i / l); } } } signed main() { get_mobius(N - 1), get_h(N - 1); scanf(\"%lld\", \u0026T); while (T --) { scanf(\"%lld%lld\", \u0026n, \u0026m); int res = 0, k = min(n, m); for (int l = 1, r; l \u003c= k; l = r + 1) { r = min(k, min(n / (n / l), m / (m / l))); res += (sum[r] - sum[l - 1]) * h[n / l] * h[m / l]; } printf(\"%lld\\n\", res); } } ","date":"2021-07-23","objectID":"/posts/cpsdoi2015-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C/:1:0","tags":["莫比乌斯反演"],"title":"[SDOI2015] 约数个数和","uri":"/posts/cpsdoi2015-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C/"},{"categories":["算法竞赛"],"content":"题意： 求 $$\\sum_{i=a}^{b}\\sum_{j=c}^{d}[\\gcd(i,j)=k]$$ 分析： 用二维前缀和的思想，把答案分为$4$个部分 $$令S(x,y)=\\sum_{i=1}^{x}\\sum_{j=1}^{y}[\\gcd(i,j)=k]$$ 则 $$\\sum_{i=a}^{b}\\sum_{j=b}^{d}[\\gcd(i,j)=k]=S(b,d)-S(a-1,d)-S(b,c-1)+S(a-1,c-1)$$ 问题转化为求 $S(x,y)$ 构造 $$f(n)=\\sum_{i=1}^{x}\\sum_{j=1}^{y}[n|\\gcd(i,j)]$$ $$g(n)=\\sum_{i=1}^{x}\\sum_{j=1}^{y}[\\gcd(i,j)=n]$$ 可以发现 $$f(n)=\\sum_{n \\mid d}g(d)$$ 所以就可以莫比乌斯反演 $$g(n)=\\sum_{n \\mid d}\\mu(\\frac{d}{n})f(d)$$ $$\\because d\\mid\\gcd(i,j),\\therefore d\\mid i,d \\mid j$$ $$\\therefore f(d)=\\lfloor\\frac{x}{d}\\rfloor\\lfloor\\frac{y}{d}\\rfloor$$ $$g(n)=\\sum_{n \\mid d}\\mu(\\frac{d}{n})\\lfloor\\frac{x}{d}\\rfloor\\lfloor\\frac{y}{d}\\rfloor$$ 设 $$t=\\frac{d}{n},d=nt$$ 则 $$g(n)=\\sum_{t=1}^{\\min(x,y)}\\mu(t)\\lfloor\\frac{x}{nt}\\rfloor\\lfloor\\frac{y}{nt}\\rfloor$$ 所以只需要求 $g(k)$，可以枚举 $t$，用整除分块，加上筛莫比乌斯函数前缀和，时间复杂度 $O(N+T\\sqrt n)$ ","date":"2021-07-22","objectID":"/posts/cphaoi2011-problem-b/:0:0","tags":["莫比乌斯反演"],"title":"[HAOI2011] problem b","uri":"/posts/cphaoi2011-problem-b/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; const int N = 5e5 + 5; int T, a, b, c, d, k, mobius[N], primes[N], cnt, sum[N]; bool st[N]; void get_mobius(int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; primes[j] * i \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } for (int i = 1; i \u003c= n; i ++) sum[i] = sum[i - 1] + mobius[i]; } int f(int x, int y) { int res = 0; for (int l = 1, r; l \u003c= min(x, y); l = r + 1) { r = min(x / (x / l), y / (y / l)); res += (sum[r] - sum[l - 1]) * ((x / k) / l) * ((y / k) / l); } return res; } signed main() { get_mobius(N - 1); cin \u003e\u003e T; while (T --) { cin \u003e\u003e a \u003e\u003e b \u003e\u003e c \u003e\u003e d \u003e\u003e k; cout \u003c\u003c f(b, d) - f(a - 1, d) - f(b, c - 1) + f(a - 1, c - 1) \u003c\u003c endl; } } ","date":"2021-07-22","objectID":"/posts/cphaoi2011-problem-b/:1:0","tags":["莫比乌斯反演"],"title":"[HAOI2011] problem b","uri":"/posts/cphaoi2011-problem-b/"},{"categories":["算法竞赛"],"content":"前置知识1:整除分块 ","date":"2021-07-22","objectID":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/:1:0","tags":["莫比乌斯反演"],"title":"莫比乌斯反演","uri":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"categories":["算法竞赛"],"content":"$①:\\lfloor \\dfrac{a}{bc} \\rfloor = \\lfloor \\dfrac{\\lfloor \\dfrac{a}{b} \\rfloor}{c} \\rfloor$ 证明： $$\\dfrac{a}{b}=\\lfloor \\dfrac{a}{b}\\rfloor + r,r\\in[0,1)$$ $$\\lfloor \\dfrac{a}{bc} \\rfloor = \\lfloor \\dfrac{a}{b} ·\\dfrac{1}{c} \\rfloor$$ $$=\\lfloor \\dfrac{1}{c}·(\\lfloor \\dfrac{a}{b}\\rfloor + r)\\rfloor$$ $$=\\lfloor \\dfrac{\\lfloor \\dfrac{a}{b} \\rfloor}{c}+\\dfrac{r}{c} \\rfloor$$ $$\\because r\u003cc$$ $$\\therefore \\lfloor \\dfrac{\\lfloor \\dfrac{a}{b} \\rfloor}{c}+\\dfrac{r}{c} \\rfloor=\\lfloor \\dfrac{\\lfloor \\dfrac{a}{b} \\rfloor}{c} \\rfloor$$ ","date":"2021-07-22","objectID":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/:2:0","tags":["莫比乌斯反演"],"title":"莫比乌斯反演","uri":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"categories":["算法竞赛"],"content":"$②:i \\in [1,n],|\\lfloor \\dfrac{n}{i}\\rfloor| \\le 2 \\sqrt{n}$ 证明： 当 $i \\in[1,\\lfloor \\sqrt n\\rfloor]$ 时，$\\lfloor \\dfrac{n}{i} \\rfloor$有$\\lfloor \\sqrt n\\rfloor$种取值 当 $i\\in(\\lfloor \\sqrt n\\rfloor, n]$ 时，$\\lfloor \\dfrac{n}{i} \\rfloor\\le \\lfloor \\sqrt n\\rfloor$，有$\\lfloor \\sqrt n\\rfloor$种取值 ","date":"2021-07-22","objectID":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/:3:0","tags":["莫比乌斯反演"],"title":"莫比乌斯反演","uri":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"categories":["算法竞赛"],"content":"$③:$ 对 $\\lfloor\\dfrac{n}{i}\\rfloor$ 求和， $\\forall i\\in[1,n]$ 只需要找到最大的一个 $j(i \\le j \\le n)$，使得 $\\lfloor\\dfrac{n}{i}\\rfloor=\\lfloor\\dfrac{n}{j}\\rfloor$，此时 $j=\\lfloor\\dfrac{n}{\\lfloor\\dfrac{n}{j}\\rfloor}\\rfloor$ 证明： 先证明 $j \\ge i$： $$\\lfloor \\dfrac{n}{i}\\rfloor \\le \\dfrac{n}{i} $$ $$\\Leftrightarrow \\lfloor\\dfrac{n}{\\lfloor\\dfrac{n}{i}\\rfloor}\\rfloor \\ge \\lfloor\\dfrac{n}{\\dfrac{n}{i}}\\rfloor = \\lfloor i \\rfloor=i$$ $$\\Leftrightarrow i \\le \\lfloor\\dfrac{n}{\\lfloor\\dfrac{n}{i}\\rfloor}\\rfloor =j$$ 再证明最大值 设 $k=\\lfloor\\dfrac{n}{i}\\rfloor$，则 $$k \\le \\dfrac{n}{j} \u003ck + 1$$ $$\\dfrac{1}{k + 1} \u003c \\dfrac{j}{n} \\le \\dfrac{1}{k}$$ $$\\dfrac{n}{k + 1} \u003c j \\le \\dfrac{n}{k}$$ 因为 $j$ 是整数，所以最大值为 $\\lfloor \\dfrac{n}{k}\\rfloor$ 所以每次将 $[i,j]$ 分为一块求解累加到答案上 ","date":"2021-07-22","objectID":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/:4:0","tags":["莫比乌斯反演"],"title":"莫比乌斯反演","uri":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"categories":["算法竞赛"],"content":"代码： for (int l = 1, r; l \u003c= n; l = r + 1) { r = n / (n / l); res += (r - l + 1) * (n / l); } ","date":"2021-07-22","objectID":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/:5:0","tags":["莫比乌斯反演"],"title":"莫比乌斯反演","uri":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"categories":["算法竞赛"],"content":"前置知识2：莫比乌斯函数 定义： 设 $n=p_1^{c_1}\\cdots p_k^{c_k}$ $$\\mu(n)=\\begin{cases} 0,\u0026\\exists i \\in[1,k],c_i \u003e1 \\\\ 1,\u0026k \\equiv 0\\pmod2,\\forall i \\in[1,k],c_i=1\\\\ -1,\u0026k\\equiv1\\pmod2,\\forall i\\in [1,k],c_i=1 \\end{cases}$$ 性质： $$\\sum_{d|n}\\mu(d) = \\begin{cases} 1,\u0026n=1\\\\ 0,\u0026n\u003e1 \\end{cases}$$ 证明： $$取n=\\prod_{i=1}^{k}p_i$$ $$\\sum_{d|n}\\mu(d)=\\sum_{i=0}^{k}C_{k}^{i}·(-1)^i$$ $$=(1+(-1))^k=0(二项式定理)$$ ","date":"2021-07-22","objectID":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/:6:0","tags":["莫比乌斯反演"],"title":"莫比乌斯反演","uri":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"categories":["算法竞赛"],"content":"线性筛莫比乌斯函数： void get_mobius(int n) { mobius[1] = 1; for (int i = 2; i \u003c= n; i ++) { if (!st[i]) { primes[cnt ++] = i; mobius[i] = -1; } for (int j = 0; primes[j] * i \u003c= n; j ++) { int t = primes[j] * i; st[t] = 1; if (i % primes[j] == 0) { mobius[t] = 0; break; } mobius[t] = -mobius[i]; } } } ","date":"2021-07-22","objectID":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/:7:0","tags":["莫比乌斯反演"],"title":"莫比乌斯反演","uri":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"categories":["算法竞赛"],"content":"莫比乌斯反演： 设 $f(n),g(n)$ 为两个数论函数 形式一： 如果 $$f(n)=\\sum_{d|n}g(d)$$ 则有 $$g(n)=\\sum_{d|n}\\mu(d)f(\\dfrac{n}{d})$$ 证明： 将 $$f(n)=\\sum_{d|n}g(d)$$ 带入 $$\\sum_{d|n}\\mu(d)f(\\dfrac{n}{d})$$ 得 $$\\sum_{d|n}\\mu(d)\\sum_{k \\mid \\frac{n}{d}}g(k)$$ 交换求和次序： 因为 $k \\mid \\dfrac{n}{d}$ ，那么 $k$ 也是 $n$ 的因子，所以枚举 $n$ 的所有因子 $d$ 等价于枚举 $k$，$k \\mid \\dfrac{n}{d}=d \\mid \\dfrac{n}{k}$ 所以 $$\\sum_{k|n}g(k)\\sum_{d|\\frac{n}{k}}\\mu(d)$$ 根据 $\\sum_{d \\mid n}\\mu(d)=[n=1]$ 所以 $n=k$，所以 $$\\sum_{k|n}g(k)\\sum_{d \\mid \\frac{n}{k}}\\mu(d)=g(n)$$ 证毕。 形式二(常用)： 如果 $$f(n)=\\sum_{n|d}g(d)$$ 则有 $$g(n)=\\sum_{n|d}\\mu(\\dfrac{d}{n})f(d)$$ 证明： 将 $$f(n)=\\sum_{n|d}g(d)$$ 带入 $$\\sum_{n|d}\\mu(\\dfrac{d}{n})f(d)$$ 得 $$\\sum_{n|d}\\mu(\\dfrac{d}{n})\\sum_{d|k}g(k)$$ 交换求和次序： $$\\sum_{n|k}g(k)\\sum_{\\frac{d}{n}|\\frac{k}{n}}\\mu(\\dfrac{d}{n})$$ 根据 $\\sum_{d|n}\\mu(d)=[n=1]$ 所以 $n=k$，所以 $$\\sum_{n|k}g(k)\\sum_{\\frac{d}{n} \\mid \\frac{k}{n}}\\mu(\\dfrac{d}{n})=g(n)$$ 证毕。 ","date":"2021-07-22","objectID":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/:8:0","tags":["莫比乌斯反演"],"title":"莫比乌斯反演","uri":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"categories":["算法竞赛"],"content":"反演技巧 $$\\sum_{i=1}^{n} f(i) \\sum_{j=1}^{m}g(j)=\\sum_{j=1}^{m}g(j)\\sum_{i=1}^{n}f(i)$$ $$\\sum_{i=1}^{n} f(i) \\sum_{d \\mid i}g(d)=\\sum_{d=1}^{n}g(d)\\sum_{i=1}^{\\lfloor \\frac{n}{d} \\rfloor}f(id)$$ ","date":"2021-07-22","objectID":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/:9:0","tags":["莫比乌斯反演"],"title":"莫比乌斯反演","uri":"/posts/cp%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"categories":["杂项"],"content":"被某数据结构老师说简单。。。。。 #include \u003cbits/stdc++.h\u003e //万能头 #include \u003cwindows.h\u003e //调用Sleep()需要 using namespace std; //命名空间 const int N = 1e5 + 5; //最大数组空间 int version, idx, log_id, history_id; //version表示现在版本 idx表示id号 log_id表示日志id history_id表示历史id string Your_pos, Content, op; //op表示当前操作 Your_pos表示你的职位 Content表示内容 char line[N]; //文件每一行的数组 FILE *in, *out; //文件指针 struct Segment_Tree { //线段树结构体 int l, r; //l左儿子节点，r右儿子节点 string content; //每个节点存的内容 } tr[N \u003c\u003c 5]; //空间乘32防止溢出 struct Chairman_Tree_Root { //主席树根结构体 int id, end; //id表示根的id， end表示每个版本有多少个文档 } root[N]; void build(int \u0026p, int l, int r) { //建树 p = ++ idx; //建立新节点 if (l == r) return ; //递归结束边界 int mid = l + r \u003e\u003e 1; //取中点 build(tr[p].l, l, mid), build(tr[p].r, mid + 1, r); //递归建树 } void insert(int \u0026p, int pre, int pos, string x, int l, int r) { //主席树插入 p = ++ idx; //建立新版本 tr[p].l = tr[pre].l, tr[p].r = tr[pre].r; //复制旧版本的信息 tr[p].content = tr[pre].content; //复制旧版本的内容 if (l == r) { //新插内容 tr[p].content = x; return ; } int mid = l + r \u003e\u003e 1; //取中点 if (pos \u003c= mid){ //递归插入 insert(tr[p].l, tr[pre].l, pos, x, l, mid); } else { insert(tr[p].r, tr[pre].r, pos, x, mid + 1, r); } } string ask(int now, int pos, int l, int r) { //主席树查询，返回一个string类型字符串 if (l == r) return tr[now].content; //递归边界，返回位置为pos的查询结果 int mid = l + r \u003e\u003e 1; if (pos \u003c= mid) { //递归查询 return ask(tr[now].l, pos, l, mid); } else { return ask(tr[now].r, pos, mid + 1, r); } } void Gui(); //预先定义主界面函数 void Show_List(int Show_Version); //预先定义显示所有文档 void Welcome() { printf(\"\\t\\t*---------------------------------------*\\n\"); printf(\"\\t\\t|\\t \\t|\\n\"); printf(\"\\t\\t|\\t \\t|\\n\"); printf(\"\\t\\t|\\t欢迎访问企业文档管理系统\\t|\\n\"); printf(\"\\t\\t|\\t 作者:某某某1111某某某 \\t|\\n\"); printf(\"\\t\\t|\\t \\t|\\n\"); printf(\"\\t\\t|\\t \\t|\\n\"); printf(\"\\t\\t*---------------------------------------*\\n\"); } void back() { //返回 Sleep(1000); //延迟1秒 system(\"cls\"); //清屏 Gui(); //显示主界面 } bool Empty_Check() { //文档判空 if (!root[version].end || !version) { //当前没有任何版本 或 此版本没有文档就说明为空 printf(\"\\t\\t*---------------------------------------*\\n\"); printf(\"\\t\\t|\\t\\t文档为空!\\t\\t|\\n\"); printf(\"\\t\\t*---------------------------------------*\\n\"); back(); } return 0; } void Show_History() { //显示历史版本 printf(\"\\t\\t*---------------------------------------*\\n\"); printf(\"\\t\\t|\\t\\t当前的历史版本号有:\\t|\\n\"); printf(\"\\t\\t*---------------------------------------*\\n\\n\"); for (int i = 1; i \u003c= version; i ++) { printf(\"\\t\\t*---------------------------------------*\\n\"); printf(\"\\t\\t|\\t\\t版本%d:\\t\\t\\t|\\n\", i); printf(\"\\t\\t*---------------------------------------*\\n\"); Show_List(i); //调用展示第i个版本的所有文档就可以，节省代码量 cout \u003c\u003c endl; } cout \u003c\u003c endl; } bool Power_Check() { //权限判断 printf(\"输入你的职务(老板、员工):\"); getchar(), getline(cin, Your_pos); if (Your_pos == \"老板\") { printf(\"\\t\\t*---------------------------------------*\\n\"); printf(\"\\t\\t|\\t\\t尊敬的老板，欢迎您!\\t|\\n\"); printf(\"\\t\\t*---------------------------------------*\\n\"); return 1; } else if (Your_pos == \"员工\") { printf(\"\\t\\t*---------------------------------------*\\n\"); printf(\"\\t\\t|\\t\\t没有权限这么做!\\t\\t|\\n\"); printf(\"\\t\\t*---------------------------------------*\\n\"); return 0; } else { printf(\"\\t\\t*---------------------------------------*\\n\"); printf(\"\\t\\t|\\t\\t职务不合法!\\t\\t|\\n\"); printf(\"\\t\\t*---------------------------------------*\\n\"); return 0; } } void Show_List(int Show_Version) { //显示所有文档列表 Empty_Check(); //判空 for (int i = 1; i \u003c= root[Show_Version].end; i ++) { //显示所有版本的所有文档 printf(\"\\t\\t*---------------------------------------*\\n\\t\\t\"); cout \u003c\u003c i \u003c\u003c \".\" \u003c\u003c ask(root[Show_Version].id, i, 1, N - 1) \u003c\u003c endl; //查询第i个版本的文档 Sleep(100); } printf(\"\\t\\t*---------------------------------------*\\n\"); cout \u003c\u003c endl; } void History_Roll_Back() { //历史记录查看和回滚 Empty_Check(); //判空 Show_History(); //显示历史记录 printf(\"\\n请输入你要回滚的历史版本号:\"); cin \u003e\u003e history_id; if (history_id \u003e version || history_id \u003c= 0) { //判断版本号合法 printf(\"\\t\\t*---------------------------------------*\\n\"); printf(\"\\t\\t|\\t\\t版本号不合法!\\t\\t|\\n\"); printf(\"\\t\\t*---------------------------------------*\\n\"); } else { version = history_id; printf(\"\\t\\t*----------------------------------","date":"2021-07-06","objectID":"/posts/miscc%E8%AF%AD%E8%A8%80%E5%AE%9E%E8%AE%AD%E9%A1%B9%E7%9B%AE%E4%BC%81%E4%B8%9A%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E4%B8%BB%E5%B8%AD%E6%A0%91%E5%AE%9E%E7%8E%B0/:0:0","tags":["实训项目"],"title":"c语言实训项目——企业文档管理(主席树实现)","uri":"/posts/miscc%E8%AF%AD%E8%A8%80%E5%AE%9E%E8%AE%AD%E9%A1%B9%E7%9B%AE%E4%BC%81%E4%B8%9A%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E4%B8%BB%E5%B8%AD%E6%A0%91%E5%AE%9E%E7%8E%B0/"},{"categories":["算法竞赛"],"content":"树状数组的基本应用： $O(\\log n)$单点修改、区间查询 ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:1:0","tags":["树状数组"],"title":"树状数组","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法竞赛"],"content":"原理： 设区间 $[1,R]$，对区间右端点 $R$ 做二进制拆分，有： $$R=2^{x_1}+2^{x_2}+\\cdots+2^{x_k}$$ 假设 $x_1\\sim x_k$ 严格单调递减，那么可以把区间 $[1,R]$ 拆分成 $\\log R$ 个区间 $$[1,2^{x_1}],\\ [2^{x_1}+1,2^{x_1}+2^{x_2}],\\ \\cdots, \\ [2^{x_1}+2^{x_2}+ \\cdots + 2^{x_{k-1}}+1,2^{x_1}+2^{x_2}+\\cdots+2^{x_k}]$$ 可以发现每个区间的长度就等于每个区间结尾的 $\\text{lowbit}$，所以可以建立一个数组 $tr$，保存区间 $[R-\\text{lowbit}(R)+1,R]$ 的和，也就是树状数组。 ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:2:0","tags":["树状数组"],"title":"树状数组","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法竞赛"],"content":"查询区间和： 对区间 $[L,R]$ 只需要求出 $\\sum_{i=1}^{R}-\\sum_{i=1}^{L-1}$。 所以目标只要计算区间 $[1,i]$ 的和：设 $i$ 的二进制下的最后一位 $1$ 是第 $k$ 位，那么只需要求出 $k-1$ 个子节点的和加上 $tr_i$，访问每个子节点只需要减去 $\\text{lowbit}(i)$，一共 $\\log i$ 次，所以时间复杂度为 $O(\\log n)$ ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:3:0","tags":["树状数组"],"title":"树状数组","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法竞赛"],"content":"代码： int ask(int x) { int res = 0; for (int i = x; i; i -= lowbit(i)) res += tr[i]; return res; } ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:4:0","tags":["树状数组"],"title":"树状数组","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法竞赛"],"content":"单点修改 假设令 $a_i$ 增加 $c$，考虑只有 $tr_i$ 及其祖先节点保存 $a_i$ 的值，所以只需要每次加上 $\\text{lowbit}(i)$，就可以一直修改祖先节点，最多 $\\log n$ 次，所以时间复杂度为 $O(\\log n)$ ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:5:0","tags":["树状数组"],"title":"树状数组","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法竞赛"],"content":"代码： void update(int x, int c) { for (int i = x; i \u003c= n; i += lowbit(i)) tr[i] += c; } ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:6:0","tags":["树状数组"],"title":"树状数组","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法竞赛"],"content":"树状数组的扩展应用： ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:7:0","tags":["树状数组"],"title":"树状数组","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法竞赛"],"content":"$1.$求某个数前面或后面有几个数比它大或小 AcWing 788 逆序对的数量 分析： 令$tr_x$ 定义为 $x$ 出现的次数，那么 $\\sum_{i=L}^{R} tr[i]$ 就表示在区间 $[L,R]$ 中出现的数有多少个，那么相当于在 $x$ 的数值范围上建立一个树状数组。所以求逆序对时可以倒序统计 $i$ 之后比 $a_i$ 小的数，每次将 $tr_{a_i} + 1$ ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:8:0","tags":["树状数组"],"title":"树状数组","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long #define lowbit(x) x \u0026 -x #define find(x) lower_bound(num.begin(), num.end(), x) - num.begin() using namespace std; const int N = 1e5 + 5; int n, a[N], tr[N], res; vector\u003cint\u003e num; void modify(int x, int c) { for (int i = x; i \u003c N; i += lowbit(i)) tr[i] += c; } int ask(int x) { int res = 0; for (int i = x; i; i -= lowbit(i)) res += tr[i]; return res; } signed main() { cin \u003e\u003e n; for (int i = 1; i \u003c= n; i ++) cin \u003e\u003e a[i], num.push_back(a[i]); sort(num.begin(), num.end()); num.erase(unique(num.begin(), num.end()), num.end()); for (int i = 1; i \u003c= n; i ++) { res += ask(N - 1) - ask(find(a[i]) + 1); modify(find(a[i]) + 1, 1); } cout \u003c\u003c res \u003c\u003c endl; } AcWing 241 楼兰图腾 分析： 与逆序对一样，在取值范围建立树状数组。求比 $a_i$ 小直接用 $ask(a_i-1)$，求比 $a_i$ 大的数可以用 $ask(n)-ask(a_i)$ 这一前缀和技巧处理。 ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:9:0","tags":["树状数组"],"title":"树状数组","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long #define lowbit(x) x \u0026 -x using namespace std; const int N = 2e5 + 5; int n, a[N], tr[N], res1, res2, high[N], low[N]; void update(int x, int c) { for (int i = x; i \u003c= n; i += lowbit(i)) tr[i] += c; } int ask(int x) { int res = 0; for (int i = x; i; i -= lowbit(i)) res += tr[i]; return res; } signed main() { cin \u003e\u003e n; for (int i = 1; i \u003c= n; i ++) cin \u003e\u003e a[i]; for (int i = 1; i \u003c= n; i ++) { high[i] = ask(n) - ask(a[i]); low[i] = ask(a[i] - 1); update(a[i], 1); } memset(tr, 0, sizeof tr); for (int i = n; i; i --) { res1 += high[i] * (ask(n) - ask(a[i])); res2 += low[i] * ask(a[i] - 1); update(a[i], 1); } cout \u003c\u003c res1 \u003c\u003c \" \" \u003c\u003c res2 \u003c\u003c endl; } ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:10:0","tags":["树状数组"],"title":"树状数组","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法竞赛"],"content":"$2.$区间修改，单点查询 AcWing 242 一个简单的整数问题 分析： 可以利用差分的思想，在区间 $[L,R]$ 加上某一个数 $c$，那么就是在差分数组 $b$ 上将 $b_L+c,b_{R+1}-c$，所以可以用树状数组维护 $a_i$ 的差分。 ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:11:0","tags":["树状数组"],"title":"树状数组","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long #define lowbit(x) x \u0026 -x using namespace std; const int N = 1e5 + 5; int n, m, a[N], tr[N], l, r, x, d; char op; int ask(int x) { int res = 0; for (int i = x; i; i -= lowbit(i)) res += tr[i]; return res; } void update(int x, int c) { for (int i = x; i \u003c= n; i += lowbit(i)) tr[i] += c; } signed main() { cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i ++) cin \u003e\u003e a[i]; for (int i = 1; i \u003c= n; i ++) update(i, a[i] - a[i - 1]); while (m --) { cin \u003e\u003e op; if (op == 'Q') { cin \u003e\u003e x; cout \u003c\u003c ask(x) \u003c\u003c endl; } else if (op == 'C') { cin \u003e\u003e l \u003e\u003e r \u003e\u003e d; update(l, d), update(r + 1, -d); } } } ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:12:0","tags":["树状数组"],"title":"树状数组","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法竞赛"],"content":"$3.$ 区间修改，区间查询 AcWing 243 一个简单的整数问题2 分析： 区间修改可以用差分维护，那么如果查询区间 $[1,R]$，就等价于求 $$\\sum_{i=1}^{R}\\sum_{j=1}^{i}b_{j}=\\sum_{i=1}^{R}(R-i+1) * b_{i}=(R+1)\\sum_{i=1}^{R}b_{i}-\\sum_{i=1}^{R}i * b_{i}$$ 所以只需要再增加一个树状数组维护 $i*b_i$ 的前缀和即可。 ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:13:0","tags":["树状数组"],"title":"树状数组","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e #define int long long #define lowbit(x) x \u0026 -x using namespace std; const int N = 1e5 + 5; int n, m, a[N], l, r, d, tr1[N], tr2[N]; char op; void update(int tr[], int x, int c) { for (int i = x; i \u003c= n; i += lowbit(i)) tr[i] += c; } int ask(int tr[], int x) { int res = 0; for (int i = x; i; i -= lowbit(i)) res += tr[i]; return res; } int sum(int x) { return ask(tr1, x) * (x + 1) - ask(tr2, x); } signed main() { cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i ++) cin \u003e\u003e a[i]; for (int i = 1; i \u003c= n; i ++) update(tr2, i, i * (a[i] - a[i - 1])), update(tr1, i, a[i] - a[i - 1]); while (m --) { cin \u003e\u003e op; if (op == 'Q') { cin \u003e\u003e l \u003e\u003e r; cout \u003c\u003c sum(r) - sum(l - 1) \u003c\u003c endl; } else if (op == 'C') { cin \u003e\u003e l \u003e\u003e r \u003e\u003e d; update(tr1, l, d), update(tr2, l, d * l); update(tr1, r + 1, -d), update(tr2, r + 1, (r + 1) * -d); } } } ","date":"2021-07-02","objectID":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:14:0","tags":["树状数组"],"title":"树状数组","uri":"/posts/cp%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法竞赛"],"content":"由于算法提高课的数位 DP 的非搜索做法比较难想，所以总结一下数位 DP 的 DFS 写法。 数位 DP 问题一般给定一个区间 $[L,R]$，问区间满足的条件的数有多少个。 可以利用前缀和来求解答案：$\\sum \\limits _ {i=1}^{R} ans_i - \\sum \\limits_{i=1}^{L - 1} ans_i$ ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:0:0","tags":["数位 DP"],"title":"数位DP(DFS做法)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["算法竞赛"],"content":"模板： int dfs(int pos, int pre, int lead, int limit) { if (!pos) { 边界条件 } if (!limit \u0026\u0026 !lead \u0026\u0026 dp[pos][pre] != -1) return dp[pos][pre]; int res = 0, up = limit ? a[pos] : 无限制位; for (int i = 0; i \u003c= up; i ++) { if (不合法条件) continue; res += dfs(pos - 1, 未定参数, lead \u0026\u0026 !i, limit \u0026\u0026 i == up); } return limit ? res : (lead ? res : dp[pos][sum] = res); } int cal(int x) { memset(dp, -1, sizeof dp); len = 0; while (x) a[++ len] = x % 进制, x /= 进制; return dfs(len, 未定参数, 1, 1); } signed main() { cin \u003e\u003e l \u003e\u003e r; cout \u003c\u003c cal(r) - cal(l - 1) \u003c\u003c endl; } ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:1:0","tags":["数位 DP"],"title":"数位DP(DFS做法)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["算法竞赛"],"content":"$\\text{cal}$函数（一般情况）： 注意每次初始化 DP 数组为 $-1$，长度 $len=0$ ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:2:0","tags":["数位 DP"],"title":"数位DP(DFS做法)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["算法竞赛"],"content":"基本参数： $len:$ 数位长度，一般根据这个来确定数组范围 $a_i:$ 每个数位具体数字 返回值 $\\text{return}$ 根据题目的初始条件来确定前导 $0$ 以及 $pre$ ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:3:0","tags":["数位 DP"],"title":"数位DP(DFS做法)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["算法竞赛"],"content":"DFS 函数（一般情况）： 变量 $res$ 来记录答案，初始化一般为 $0$ 变量 $up$ 表示能枚举的最高位数 采用记忆化搜索的方式： if (!limit \u0026\u0026 !lead \u0026\u0026 dp[pos][pre] != -1) return dp[pos][pre]; 只有无限制、无前导零才算，不然都是未搜索完的情况。 return limit ? res : dp[pos][pre] = res; 如果最后还有限制，那么返回 res，否则返回 dp[pos][pre] ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:4:0","tags":["数位 DP"],"title":"数位DP(DFS做法)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["算法竞赛"],"content":"基本参数： 假设数字 $x$ 位数为 $a_1\\cdots a_n$ 必填参数： $pos:$ 表示数字的位数 从末位或第一位开始，要根据题目的数字构造性质来选择顺序，一般选择从 $a_1$ 到 $a_n$ 的顺序。初始从 $len$ 开始的话，边界条件应该是 $pos = 0$，限制位数应该是 $a_{pos}$，DFS 时 $pos-1$；初始从$1$开始的话，边界条件应该是 $pos \u003e len$，限制位数应该是 $a_{len - pos + 1}$，DFS 时 $pos+1$。两种都可以，看个人习惯。 $limit:$ 可以填数的限制（无限制的话 $(limit=0)$ $0\\sim 9$ 随便填，否则只能填到 $a_i$） 如果搜索到 $a_1\\cdots a_{pos} \\cdots a_n$，原数位为 $a_1\\cdots a_k \\cdots a_n$，那么我们必须对接下来搜索的数加以限制，也就是不能超过区间右端点 $R$，所以要引入 $limit$ 这个参数，如果 $limit=1$，那么最高位数 $up \\le a_{pos+1}$，如果没有限制，那么 $up=9$（十进制下）这也就是确定搜索位数上界的语句 limit ? a[pos] : 9; 如果 $limit=1$ 且已经取到了能取到的最高位时 $(a_{pos}=a_k)$，那么下一个 $limit=1$ 如果 $limit=1$ 且没有取到能取到的最高位时 $(a_{pos} \u003c a_k)$，那么下一个 $limit=0$ 如果 $limit=0$，那么下一个 $limit=0$，因为前一位没有限制后一位必定没有限制。 所以我们可以把这 $3$ 种情况合成一个语句进行下一次搜索：limit \u0026\u0026 i == up $(i$为当前枚举的数字$)$ 可选参数： $pre:$ 表示上一个数是多少 有些题目会用到前面的数 $lead:$ 前导零是否存在，$lead=1$ 存在前导零，否则不存在。 一般来说有些题目不加限制前导零会影响数字结构，所以 $lead$ 是一个很重要的参数。 如果 $lead=1$ 且当前位为 $0$，那么说明当前位是前导 $0$，继续搜索 $pos+1$，其他条件不变。 如果 $lead=1$ 且当前位不为 $0$，那么说明当前位是最高位，继续搜索 $pos+1$，条件变动。 如果 $lead=0$，则不需要操作。 $sum:$ 搜索到当前所有数字之和 有些题目会出现数字之和的条件 $cnt:$ 某个数字出现的次数 有些题目会出现某个数字出现次数的条件 ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:5:0","tags":["数位 DP"],"title":"数位DP(DFS做法)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["算法竞赛"],"content":"参数基本的差不多这些，有些较难题目会用到更多方法或改变$\\text{DP}$状态 ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:6:0","tags":["数位 DP"],"title":"数位DP(DFS做法)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["算法竞赛"],"content":"题目1：不要62 题意： 找到区间 $[L,R]$ 不能出现 $4$ 和 $62$ 的数的个数 分析： 首先此题不需要 $lead$，其次有 $62$ 所以要记前驱 $pre$ ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:7:0","tags":["数位 DP"],"title":"数位DP(DFS做法)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; const int N = 15; int l, r, dp[N][N], len, a[N]; int dfs(int pos, int pre, int limit) { if (!pos) return 1; if (!limit \u0026\u0026 dp[pos][pre] != -1) return dp[pos][pre]; int res = 0, up = limit ? a[pos] : 9; for (int i = 0; i \u003c= up; i ++) { if (i == 4 || (i == 2 \u0026\u0026 pre == 6)) continue; res += dfs(pos - 1, i, limit \u0026\u0026 i == up); } return limit ? res : dp[pos][pre] = res; } int cal(int x) { memset(dp, -1, sizeof dp); len = 0; while (x) a[++ len] = x % 10, x /= 10; return dfs(len, 0, 1); } signed main() { while (cin \u003e\u003e l \u003e\u003e r, l || r) { cout \u003c\u003c cal(r) - cal(l - 1) \u003c\u003c endl; } } ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:8:0","tags":["数位 DP"],"title":"数位DP(DFS做法)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["算法竞赛"],"content":" 题目2：windy数 题意： 找到区间 $[L,R]$ 相邻数字之差至少为 $2$ 的数的个数 分析： 搜索初始条件第二个参数 $pre$ 必须填一个 $\\le -2$ 的数来保证可以搜索下去，不然会出错。此题需要记录前导零，不然忽视前导零的影响会造成最高位数 $-0\u003c2$ 无法继续搜索的情况。 ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:9:0","tags":["数位 DP"],"title":"数位DP(DFS做法)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; const int N = 15; int l, r, a[N], len, dp[N][N]; int dfs(int pos, int pre, int lead, int limit) { if (!pos) return 1; if (!limit \u0026\u0026 !lead \u0026\u0026 dp[pos][pre] != -1) return dp[pos][pre]; int res = 0, up = limit ? a[pos] : 9; for (int i = 0; i \u003c= up; i ++) { if (abs(pre - i) \u003c 2) continue; if (lead \u0026\u0026 !i) { res += dfs(pos - 1, -2, lead \u0026\u0026 !i, limit \u0026\u0026 i == up); } else { res += dfs(pos - 1, i, lead \u0026\u0026 !i, limit \u0026\u0026 i == up); } } return limit ? res : (lead ? res : dp[pos][pre] = res); } int cal(int x) { memset(dp, -1, sizeof dp); len = 0; while (x) a[++ len] = x % 10, x /= 10; return dfs(len, -2, 1, 1); } signed main() { cin \u003e\u003e l \u003e\u003e r; cout \u003c\u003c cal(r) - cal(l - 1) \u003c\u003c endl; } ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:10:0","tags":["数位 DP"],"title":"数位DP(DFS做法)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["算法竞赛"],"content":"题目3：数字游戏 题意： 找到区间 $[L,R]$ 各位数字非严格单调递增的数的个数 分析： 前导零不影响，所以不需要 $lead$。所以只需要判断枚举的位数是不是非严格递增来判断是否继续搜索。 ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:11:0","tags":["数位 DP"],"title":"数位DP(DFS做法)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; const int N = 15; int l, r, a[N], len, dp[N][N]; int dfs(int pos, int pre, int limit) { if (!pos) return 1; if (!limit \u0026\u0026 dp[pos][pre] != -1) return dp[pos][pre]; int res = 0, up = limit ? a[pos] : 9; for (int i = 0; i \u003c= up; i ++) { if (i \u003c pre) continue; res += dfs(pos - 1, i, limit \u0026\u0026 i == up); } return limit ? res : dp[pos][pre] = res; } int cal(int x) { memset(dp, -1, sizeof dp); len = 0; while (x) a[++ len] = x % 10, x /= 10; return dfs(len, 0, 1); } signed main() { while (cin \u003e\u003e l \u003e\u003e r) { cout \u003c\u003c cal(r) - cal(l - 1) \u003c\u003c endl; } } ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:12:0","tags":["数位 DP"],"title":"数位DP(DFS做法)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["算法竞赛"],"content":"题目4：数字游戏Ⅱ 题意： 找到区间 $[L,R]$ 各位数字之和 $\\mod n=0$ 的数的个数 分析： 前导零不影响，所以不需要 $lead$。此题涉及到数字和 ，所以要用到 $sum$，不需要记录前驱 $pre$，所以 $\\text{dp}$ 状态变为了 $\\text{dp}[pos][sum]$。边界条件为 $sum \\bmod n=0$，返回 $1$，否则返回 $0$ ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:13:0","tags":["数位 DP"],"title":"数位DP(DFS做法)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; const int N = 1e3 + 5; int l, r, p, len, a[N], dp[N][N]; int dfs(int pos, int sum, int limit) { if (!pos) return sum % p == 0; if (!limit \u0026\u0026 dp[pos][sum] != -1) return dp[pos][sum]; int res = 0, up = limit ? a[pos] : 9; for (int i = 0; i \u003c= up; i ++) { res += dfs(pos - 1, sum + i, limit \u0026\u0026 i == up); } return limit ? res : dp[pos][sum] = res; } int cal(int x) { memset(dp, -1, sizeof dp); len = 0; while (x) a[++ len] = x % 10, x /= 10; return dfs(len, 0, 1); } signed main() { while (cin \u003e\u003e l \u003e\u003e r \u003e\u003e p) { cout \u003c\u003c cal(r) - cal(l - 1) \u003c\u003c endl; } } ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:14:0","tags":["数位 DP"],"title":"数位DP(DFS做法)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["算法竞赛"],"content":"题目5：度的数量 题意： 找到区间$[L,R]$恰好为$K$个$B$的幂次方之和的数的个数 分析： 前导零不影响，所以不需要$lead$。因为要记录数量，所以要增加变量$cnt$。前驱$pre$不需要记录。判断边界时只要最后数量$cnt=k$，返回$1$，否则返回$0$。同时枚举数字时如果前面系数不为$1$或者没搜索完就已经$K$个了，那么就continue ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:15:0","tags":["数位 DP"],"title":"数位DP(DFS做法)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; const int N = 35; int l, r, k, b, a[N], len, dp[N][N]; int dfs(int pos, int cnt, int limit) { if (!pos) return cnt == k; if (!limit \u0026\u0026 dp[pos][cnt] != -1) return dp[pos][cnt]; int res = 0, up = limit ? a[pos] : b - 1; for (int i = 0; i \u003c= up; i ++) { if ((i == 1 \u0026\u0026 cnt == k) || i \u003e 1) continue; res += dfs(pos - 1, cnt + (i == 1), limit \u0026\u0026 i == up); } return limit ? res : dp[pos][cnt] = res; } int cal(int x) { memset(dp, -1, sizeof dp); len = 0; while (x) a[++ len] = x % b, x /= b; return dfs(len, 0, 1); } signed main() { cin \u003e\u003e l \u003e\u003e r \u003e\u003e k \u003e\u003e b; cout \u003c\u003c cal(r) - cal(l - 1) \u003c\u003c endl; } ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:16:0","tags":["数位 DP"],"title":"数位DP(DFS做法)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["算法竞赛"],"content":"题目6：计数问题 题意： 统计区间$[L,R]$出现$0123456789$的各个数字总次数 分析： 需要用到$lead$，需要用到次数总和$sum$，还有哪个数字$num$。基本上可以套模板，注意边界条件。 ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:17:0","tags":["数位 DP"],"title":"数位DP(DFS做法)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["算法竞赛"],"content":"代码： #include \u003cbits/stdc++.h\u003e using namespace std; const int N = 15; int l, r, len, a[N], dp[N][N]; int dfs(int pos, int sum, int num, int lead, int limit) { if (!pos) { if (lead \u0026\u0026 !num) return 1; return sum; } if (!limit \u0026\u0026 !lead \u0026\u0026 dp[pos][sum] != -1) return dp[pos][sum]; int res = 0, up = limit ? a[pos] : 9; for (int i = 0; i \u003c= up; i ++) { int t; if (i == num) { if (!num) { t = sum + (lead == 0); } else { t = sum + 1; } } else { t = sum; } res += dfs(pos - 1, t, num, lead \u0026\u0026 i == 0, limit \u0026\u0026 i == up); } return limit ? res : (lead ? res : dp[pos][sum] = res); } int cal(int x, int num) { memset(dp, -1, sizeof dp); len = 0; while (x) a[++ len] = x % 10, x /= 10; return dfs(len, 0, num, 1, 1); } signed main() { while (cin \u003e\u003e l \u003e\u003e r, l || r) { if (l \u003e r) swap(l, r); for (int i = 0; i \u003c= 9; i ++) cout \u003c\u003c cal(r, i) - cal(l - 1, i) \u003c\u003c \" \"; cout \u003c\u003c endl; } } ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:18:0","tags":["数位 DP"],"title":"数位DP(DFS做法)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["算法竞赛"],"content":"以上只是模板题用来熟悉数位$\\text{DP}$，当然做这些题还远远不够，需要更多练习。 ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:19:0","tags":["数位 DP"],"title":"数位DP(DFS做法)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["算法竞赛"],"content":"题单： CodeForce1036C Classy Numbers 找到区间$[L,R]$有不超过$3$个非$0$的数的个数 洛谷P4127 同类分布 找到区间$[L,R]$各位数字之和能整除原数的数的个数 洛谷P4317 花神的数论题 设 $\\text{sum}(i)$ 表示 $i$ 的二进制表示中 $1$ 的个数。给出一个正整数 $N$ ，求 $\\prod _{i=1}^{N}\\text{sum}(i)$ ​ 较难： HDU 3693 Math teacher’s homework HDU 4352 XHXJ’s LIS CodeForce 55D Beautiful numbers AcWing 1086 恨7不成妻 POJ 3252 Round Numbers ","date":"2021-06-25","objectID":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/:20:0","tags":["数位 DP"],"title":"数位DP(DFS做法)","uri":"/posts/cp%E6%95%B0%E4%BD%8Ddpdfs%E5%81%9A%E6%B3%95/"},{"categories":["杂项"],"content":"$1.已知函数f(x)连续且f(x+2)-f(x)=\\cos x,\\int_{0}^{2}f(x)dx=1,求\\int^{1}_{-1}f(x)dx$ 分析： 构造。题目中给出了两点差的函数式，想到构造变动上下限积分，题眼$\\int^{2}_{0}f(x)dx=1$，提示构造$F(x)$并解出任意常数$C$ $$令F(x)=\\int^{x+2}_{x}f(t)dt,则F’(x)=f(x+2)-f(x)=\\cos x$$ $$\\therefore F(x)=\\sin x+C$$ $$\\because \\int^{2}_{0}f(x)dx=1,\\therefore F(0)=1$$ $$带入 F(x)=\\sin x+C,得C=1$$ $$\\therefore F(x)=\\sin x+1$$ $$则\\int^{1}_{-1}f(x)dx=F(-1)=1-\\sin 1$$ ","date":"2021-06-16","objectID":"/posts/misc%E9%AB%98%E6%95%B0%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/:1:0","tags":["高等数学"],"title":"高数竞赛笔记","uri":"/posts/misc%E9%AB%98%E6%95%B0%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/"},{"categories":["杂项"],"content":"$2.计算I=\\int_{L}\\frac{(x-1)\\text{d}y-y\\text{d}x}{(x-1)^2+y^2},L是从(-2,0)到(2,0)的上半椭圆\\frac{x^2}{4}+y^2=1$ 分析： 格林公式+第二类曲线积分的路径无关性。 看到这种形式应该想到路径无关，同时分母是个圆的方程，要注意考虑分母为$0$的情况，经典套路用一个很小的圆计算无意义的点，再次用格林公式。 $$I=\\int_{L}\\frac{-y\\text{d}x+(x-1)\\text{d}y}{(x-1)^2+y^2}$$ $$P=\\frac{-y}{(x-1)^2+y^2},Q=\\frac{x-1}{(x-1)^2+y^2}$$ $$则\\frac{\\partial P}{\\partial y}=\\frac{\\partial Q}{\\partial x}=\\frac{y^2-(x-1)^2}{((x-1)^2+y^2)^2}$$ $$\\because L为单连通区域\\therefore I与路径无关$$ $$\\because (x-1)^2+y^2\\ne 0,\\therefore 不包含(1,0)$$ $$\\therefore 取L_{\\varepsilon}=(x-1)^2+y^2=\\varepsilon ^2(\\varepsilon \u003e0且足够小),y\\ge 0$$ $$\\int_{L_\\varepsilon}\\frac{(x-1)\\text{d}y-y\\text{d}x}{(x-1)^2+y^2}=-\\frac{1}{\\varepsilon^2}\\iint_{L_\\varepsilon}\\text{d}x\\text{d}y=-\\pi$$ $$\\therefore I=0+\\int_{L_\\varepsilon}=-\\pi$$ ","date":"2021-06-16","objectID":"/posts/misc%E9%AB%98%E6%95%B0%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/:2:0","tags":["高等数学"],"title":"高数竞赛笔记","uri":"/posts/misc%E9%AB%98%E6%95%B0%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/"},{"categories":["杂项"],"content":"$3.设f(x)在[0,1]上二阶可导,f(0)=0,f(1)=1,\\int^{1}_{0}f(x)\\text{d}x=1$ ","date":"2021-06-16","objectID":"/posts/misc%E9%AB%98%E6%95%B0%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/:3:0","tags":["高等数学"],"title":"高数竞赛笔记","uri":"/posts/misc%E9%AB%98%E6%95%B0%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/"},{"categories":["杂项"],"content":"$(1)证明 \\exists \\xi \\in(0,1),使得f’(\\xi)=0$ ","date":"2021-06-16","objectID":"/posts/misc%E9%AB%98%E6%95%B0%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/:4:0","tags":["高等数学"],"title":"高数竞赛笔记","uri":"/posts/misc%E9%AB%98%E6%95%B0%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/"},{"categories":["杂项"],"content":"$(2)证明：\\exists \\eta \\in (0,1),使得f’'(\\eta)\u003c-2$ $(1)$ 分析： 看见导数先想到罗尔定理，两个点一个用1，一个就要去题干找点，发现积分式$\\int_{0}^{1}f(x)\\text{d}x=1$，发现恰好符合积分中值定理$\\frac{\\int^{1}_{0}f(x)\\text{d}x}{1-0}=f(\\xi)$，于是找到第二个点$\\xi_1$。 再用这两个点找到$\\xi$ $$\\because \\int^{1}_{0}f(x)\\text{d}x=1$$ $$\\therefore 由积分中值定理得:\\exists \\xi_1\\in(0,1),使得f(\\xi_1)=1$$ $$\\because f(\\xi_1)=1,f(1)=1$$ $$\\therefore 由罗尔中值定理得:\\exists \\xi\\in(\\xi_1,1),使得f’(\\xi)=0$$ $(2)$ 分析： 构造+反证。看到$f’'(\\eta)\u003c-2$应该想到构造函数，二阶导$\u003e0$可以判断函数的凹凸性，再根据题目的已知条件有积分，所以利用凹函数的积分性质来证明不等式。 $$令g(x)=f(x)+x^2$$ $$假设f’'(x)\\ge-2,即f’'(x)+2\\ge0$$ $$\\because g’'(x)=f’'(x)+2$$ $$\\therefore g’'(x)\\ge0$$ $$\\therefore g’'(x)为凹函数$$ $$则有:\\int_{0}^{1}g(x) \\text{d}x \\le \\int_{0}^{1}2x\\text{d}x=1$$ $$\\int_{0}^{1}g(x) \\text{d}x=\\int_{0}^{1}(f(x)+x^2) \\text{d}x=\\frac{4}{3} \u003e 1,矛盾$$ $$\\therefore \\exists \\eta \\in (0,1),使得g’'(x)\u003c0$$ $$即:\\exists \\eta \\in (0,1),使得f’'(\\eta)\u003c-2$$ ","date":"2021-06-16","objectID":"/posts/misc%E9%AB%98%E6%95%B0%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/:5:0","tags":["高等数学"],"title":"高数竞赛笔记","uri":"/posts/misc%E9%AB%98%E6%95%B0%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/"},{"categories":["杂项"],"content":"$4.设正值函数f(x)在[a,b]上连续,\\int_{a}^{b}f(x)\\text{d}x=A,证明:\\int_{a}^{b}f(x)e^{f(x)}\\text{d}x\\int_{a}^{b}\\frac{1}{f(x)}\\text{d}x \\ge (b-a)(b-a+A)$ 法一：化为二重积分 分析： 题目给了两个积分，想到把另一个积分变元为$y$，转为二重积分，而区间$[a,b]$变为矩形区域，可以利用其性质变为二重积分。根据对称性，二重积分可以互换变量，构造$\\frac{1}{2}$，再用重要不等式$e^x\\ge x+1$进行放缩，最后证出答案。 $$I=\\int_{a}^{b}f(x)e^{f(x)}\\text{d}x\\int_{a}^{b}\\frac{1}{f(x)}\\text{d}x=\\int_{a}^{b}f(x)e^{f(x)}\\text{d}x\\int_{a}^{b}\\frac{1}{f(y)}\\text{d}y$$ $$\\because D: [a,b] ×[a,b]为矩形区域$$ $$\\therefore I=\\iint\\limits_{D}^{}\\frac{f(x)}{f(y)}e^{f(x)}\\text{d}x\\text{d}y =\\iint\\limits_{D}^{}\\frac{f(y)}{f(x)}e^{f(y)}\\text{d}x\\text{d}y$$ $$\\therefore I=\\frac{1}{2}\\iint\\limits_{D}^{}\\frac{f(x)}{f(y)}e^{f(x)}\\text{d}x\\text{d}y +\\iint\\limits_{D}^{}\\frac{f(y)}{f(x)}e^{f(y)}\\text{d}x\\text{d}y$$ $$I=\\frac{1}{2}\\iint\\limits_{D}\\frac{f^2(x)e^{f(x)}+f^2(y)e^{f(y)}}{f(x)f(y)}\\text{d}x\\text{d}y \\ge \\iint\\limits_{D}\\sqrt{e^{f(x)+f(y)}}\\text{d}x\\text{d}y$$ $$I=\\iint\\limits_{D}e^{\\frac{f(x)+f(y)}{2}}\\text{d}x\\text{d}y \\ge \\iint\\limits_{D}(1+\\frac{f(x)+f(y)}{2})\\text{d}x\\text{d}y$$ $$I\\ge \\iint\\limits_{D}\\text{d}x\\text{d}y+\\iint\\limits_{D} f(x) \\text{d}x\\text{d}y=(b-a)^2+\\int_{a}^{b}f(x)\\text{d}x\\int_{a}^{b}\\text{d}y$$ $$I\\ge(b-a)^2+(b-a)A=(b-a)(b-aA)$$ 法二：柯西不等式 分析： 看到两个积分可以凑柯西不等式，再放缩证出答案。 $$\\because I= \\int_{a}^{b}f^2(x)\\text{d}x\\int_{a}^{b}g^2(x)\\text{d}x \\ge (\\int_{a}^{b}f(x)g(x)\\text{d}x)^2$$ $$\\therefore \\int_{a}^{b}f(x)e^{f(x)}\\text{d}x\\int_{a}^{b}\\frac{1}{f(x)}\\text{d}x \\ge (\\int_{a}^{b}\\sqrt{e^{f(x)}}\\text{d}x)^2$$ $$(\\int_{a}^{b}\\sqrt{e^{f(x)}}\\text{d}x)^2 = (\\int_{a}^{b} e^{\\frac{f(x)}{2}} \\text{d}x)^2 \\ge [\\int_{a}^{b}(1+\\frac{f(x)}{2})\\text{d}x]^2$$ $$\\int_{a}^{b}(1+\\frac{f(x)}{2})\\text{d}x=b-a+\\frac{A}{2}$$ $$\\therefore I\\ge (b-a+\\frac{A}{2})^2$$ $$先证: \\forall x,(\\frac{x}{2}+k)^2 \\ge k(k+x),k为常数$$ $$\\Leftrightarrow \\frac{x^2}{4}+k^2+kx\\ge k^2+ kx$$ $$\\Leftrightarrow x^2\\ge0恒成立$$ $$\\therefore I \\ge (b-a)(b-a+A)$$ ","date":"2021-06-16","objectID":"/posts/misc%E9%AB%98%E6%95%B0%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/:6:0","tags":["高等数学"],"title":"高数竞赛笔记","uri":"/posts/misc%E9%AB%98%E6%95%B0%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/"},{"categories":["杂项"],"content":"题面: $已知函数f(x)=x(1-\\ln{x})$ $(1)讨论f(x)的单调性$ $(2)设a,b\u003e0,a\\ne b,且b\\ln{a}-a\\ln{b}=a-b,证明:2\u003c\\frac{1}{a}+\\frac{1}{b}\u003ce$ ","date":"2021-06-08","objectID":"/posts/misc2021%E6%96%B0%E9%AB%98%E8%80%83%E5%85%A8%E5%9B%BD%E5%8D%B7-22%E9%A2%98/:1:0","tags":["高考数学"],"title":"2021新高考全国Ⅰ卷 22题","uri":"/posts/misc2021%E6%96%B0%E9%AB%98%E8%80%83%E5%85%A8%E5%9B%BD%E5%8D%B7-22%E9%A2%98/"},{"categories":["杂项"],"content":"题解: $(1)f’(x)=-\\ln{x},则x\\in(0,1]时,f(x)单调递增,x\\in[1,+\\infty)时,f(x)单调递减$ $(2)$ $$\\because b\\ln{a}-a\\ln{b}=a-b$$ $$两边同时除ab$$ $$\\therefore \\frac{\\ln{a}}{a}-\\frac{\\ln{b}}{b}=\\frac{1}{b}-\\frac{1}{a}$$ $$\\therefore \\frac{\\ln{a}}{a}+\\frac{1}{a}=\\frac{\\ln{b}}{b}+\\frac{1}{b}$$ $$\\therefore \\frac{1}{a} ( 1+\\ln{a})=\\frac{1}{b} (1+ \\ln{b})$$ $$\\therefore \\frac{1}{a} ( 1-\\ln{\\frac{1}{a}})=\\frac{1}{b} ( 1-\\ln{\\frac{1}{b}})$$ $$由(1)知:0\u003c\\frac{1}{a}\u003c1\u003c\\frac{1}{b}\u003ce$$ $$令x_1=\\frac{1}{a},x_2=\\frac{1}{b}$$ $$左边:x_1+x_2\u003e2$$ $$\\Leftrightarrow x_2\u003e2-x_1$$ $$\\Leftrightarrow f(x_2)=f(x_1)\u003cf(2-x_1)$$ $$\\Leftrightarrow f(2-x_1)-f(x_1)\u003e0$$ $$令g(x)=f(2-x)-f(x),x \u003e1$$ $$g’(x)=\\ln{(2-x)}+\\ln{x}=\\ln{(2x-x^2)}\u003e0,g(x)单调递增$$ $$\\because g(1)=0\\therefore g(x)\u003e0,原式成立$$ $$右边:x_1+x_2\u003ce$$ $$f(x)在(e,0)点的切线为y=e-x$$ $$切线放缩:x(1-\\ln{x})\\le e-x$$ $$\\because x_1(1-\\ln{x_1})=x_2(1-\\ln{x_2})$$ $$\\therefore x_1(1-\\ln{x_1})\u003ce-x_2$$ $$\\Leftrightarrow x_1+x_2\u003ce+x_1\\ln{x_1}$$ $$\\because x_1 \\in (0,1)$$ $$\\therefore x_1\\ln{x_1}\u003c0$$ $$\\therefore x_1+x_2\u003ce+x_1\\ln{x_1}\\ \u003ce$$ $$\\therefore 2\u003cx_1+x_2\u003ce \\Leftrightarrow 2\u003c\\frac{1}{a}+\\frac{1}{b}\u003ce$$ ","date":"2021-06-08","objectID":"/posts/misc2021%E6%96%B0%E9%AB%98%E8%80%83%E5%85%A8%E5%9B%BD%E5%8D%B7-22%E9%A2%98/:2:0","tags":["高考数学"],"title":"2021新高考全国Ⅰ卷 22题","uri":"/posts/misc2021%E6%96%B0%E9%AB%98%E8%80%83%E5%85%A8%E5%9B%BD%E5%8D%B7-22%E9%A2%98/"},{"categories":["算法竞赛"],"content":"最大独立集 选出最多的点,使得所有点都是不相邻的 状态表示： $dp_{i,j}$ 表示以 $i$ 为根的树，如果 $j$ 为 $0$ ，表示不选这个点，如果 $j$ 为 $1$，表示选这个点 属性： $\\text{Max}$ 状态计算： 如果当前点 $i$ 不选，那么子节点 $j$ 可以被选或不被选： $$dp_{i,0}=\\sum_{k=1}^{n}\\max (dp_{j_k,0},dp_{j_k,1})$$ 如果当前点 $i$ 被选，那么子节点 $j$ 一定不能被选： $$dp_{i,1}=\\sum_{k=1}^{n}dp_{j_k,0}$$ $\\text{AcWing}$ $285$ 没有上司的舞会(带点权) ","date":"2021-06-02","objectID":"/posts/cp%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86%E6%9C%80%E5%B0%8F%E7%82%B9%E8%A6%86%E7%9B%96%E6%9C%80%E5%B0%8F%E6%94%AF%E9%85%8D%E9%9B%86/:1:0","tags":["树形 DP"],"title":"最大独立集、最小点覆盖、最小支配集","uri":"/posts/cp%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86%E6%9C%80%E5%B0%8F%E7%82%B9%E8%A6%86%E7%9B%96%E6%9C%80%E5%B0%8F%E6%94%AF%E9%85%8D%E9%9B%86/"},{"categories":["算法竞赛"],"content":"最小点覆盖 选出最少的点,覆盖所有的边 状态表示： $dp_{i,j}$ 表示以$i$为根的树，如果 $j$ 为 $0$ ，表示不选这个点，如果 $j$ 为 $1$ ，表示选这个点 属性：$\\text{Min}$ 状态计算： 如果当前点 $i$ 不选，那么子节点 $j$ 一定被选： $$dp_{i,0}=\\sum_{k=1}^{n} dp_{j_k,1}$$ 如果当前点 $i$ 被选，那么子节点 $j$ 可以被选或者不选： $$dp_{i,1}=\\sum_{k=1}^{n} \\min (dp_{j_k,0},dp_{j_k,1})$$ $\\text{AcWing}$ $323$ 战略游戏(带点权) ","date":"2021-06-02","objectID":"/posts/cp%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86%E6%9C%80%E5%B0%8F%E7%82%B9%E8%A6%86%E7%9B%96%E6%9C%80%E5%B0%8F%E6%94%AF%E9%85%8D%E9%9B%86/:2:0","tags":["树形 DP"],"title":"最大独立集、最小点覆盖、最小支配集","uri":"/posts/cp%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86%E6%9C%80%E5%B0%8F%E7%82%B9%E8%A6%86%E7%9B%96%E6%9C%80%E5%B0%8F%E6%94%AF%E9%85%8D%E9%9B%86/"},{"categories":["算法竞赛"],"content":"最小支配集 选出最少的点,使得每个点要么被选、要么被它的相邻点支配 状态表示： $dp_{i,j}$ 表示以$i$为根的树，如果 $j$ 为 $0$，表示在点 $i$不被支配，且将要被父节点支配，如果 $j$ 为 $1$，表示在点 $i$ 不被支配，且将要被子节点支配，如果 $j$ 为 $2$，表示在点 $i$ 支配 属性：$\\text{Min}$ 状态计算： 如果当前点 $i$ 要被父节点支配，那么可以选择子节点或者选择该节点： $$dp_{i,0}=\\sum_{k=1}^{n}\\min(dp_{j_k,1},dp_{j_k,2})$$ 如果当前的点 $i$ 要被子节点支配，那么就要枚举是哪个子节点 $j$ 被选的方案最小($u_k$ 代表子节点的第 $k$ 个子节点)： $$dp_{i,1}= \\min( dp_{i,1},dp_{j_k,2}+dp_{i,0}-\\sum_{k=1}^{n}\\min (dp_{u_k,1},dp_{u_k,2}))$$ 如果选当前的点 $i$，那么子节点 $j$ 被 $i$ 支配，或者选择子节点 $j$，或者子节点 $j$ 被子节点的子节点 $u$ 支配： $$dp_{i,2}=\\sum_{k=1}^{n}\\min(dp_{j_k,0},dp_{j_k,1},dp_{j_k,2})$$ $\\text{SDUT}$ $4831$ 树的染色 $\\text{AcWing}$ $1077$ 皇宫看守(带点权) 参考： AcWing算法提高课 树上dp的一些总结 没有上司的舞会题解(小呆呆) 战略游戏题解(小呆呆) 皇宫看守题解(小呆呆) $\\text{SDUT}$ $4831$ 树的染色题解(lxw) ","date":"2021-06-02","objectID":"/posts/cp%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86%E6%9C%80%E5%B0%8F%E7%82%B9%E8%A6%86%E7%9B%96%E6%9C%80%E5%B0%8F%E6%94%AF%E9%85%8D%E9%9B%86/:3:0","tags":["树形 DP"],"title":"最大独立集、最小点覆盖、最小支配集","uri":"/posts/cp%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86%E6%9C%80%E5%B0%8F%E7%82%B9%E8%A6%86%E7%9B%96%E6%9C%80%E5%B0%8F%E6%94%AF%E9%85%8D%E9%9B%86/"},{"categories":["杂项"],"content":" A 选项： $n=1$ 时， $p_1=1$，$∴ H(X)=−p_1\\log_2p_1=0$，正确。 B 选项： $n=2$ 时， $p_1+p_2=1$，$H(X)=-(p_{1}\\log_{2}p_{1}+p_{2}\\log_{2}p_{2})=-[p_{1}\\log_{2}p_{1}+(1-p_{1})\\log_{2}(1-p_{1})]$ 我们令 $f(x)=-x\\log_{2}x-(1-x)\\log_{2}(1-x)$ 则 $f'(x)=\\log_{2}\\frac{1-x}{x}$，易证 $f'(x)$ 在 $x\\in(0,\\frac{1}{2})$ 单调递增，在 $x\\in(\\frac{1}{2},1)$ 单调递减，错误。 C 选项：$H(X)=(-\\dfrac{1}{n}\\log_{2}\\dfrac{1}{n})\\cdot n=\\log_{2}n$，单调递增，正确。 D 选项：$H(Y)=-\\sum_{j=1}^{m}({p_{j}+p_{2m+1-j}})\\log_{2}(p_{j}+p_{2m+1-j})$，$H(X)=-\\sum_{i=1}^{2m}{p_{i}\\log_{2}p_{i}}$ 即证：$({p_{i}+p_{2m+1-i}})\\log_{2}(p_{i}+p_{2m+1-i}) \\le p_{i}\\log_{2}p_{i} + p_{2m + 1 - i}\\log_{2}p_{2m + 1 - i}$ 逐项比较：$p_{i}\\log_{2}(p_{i}+p_{2m+1-i}) \\le p_{i}\\log_{2}p_{i}$ $p_{2m + 1 - i}\\log_{2}(p_{i} + p_{2m+1-i}) \\le p_{2m + 1 - i}\\log_{2}p_{2m + 1 - i}$ 因为 $p_i, p_{2m+ 1 - i} \u003e 0$，所以等式不成立，错误。 答案为：AC ","date":"2020-07-15","objectID":"/posts/misc2020%E5%B9%B4%E9%AB%98%E8%80%83%E6%95%B0%E5%AD%A612%E9%A2%98/:0:0","tags":["高考数学"],"title":"2020年普通高等学校招生全国统一考试（新高考全国Ⅰ卷）数学12题","uri":"/posts/misc2020%E5%B9%B4%E9%AB%98%E8%80%83%E6%95%B0%E5%AD%A612%E9%A2%98/"},{"categories":["杂项"],"content":"21.（12分） 已知函数 $f(x)=ae^{x-1}-\\ln x+\\ln a$ (1) 当 $a = e$ 时，求曲线 $y=f(x)$ 在点 $(1,f(1))$ 处的切线与两个坐标轴围成的三角形的面积。 (2) 若 $f(x)\\geq1$ ，求 $a$ 的取值范围。 这里重点解一下第二问。 同构法：$ae^{x-1}-\\ln x+\\ln a \\geq 1 \\Leftrightarrow ae^{x-1} \\geq \\ln\\dfrac{ex}{a}$ 观察到左边有 $x-1$ 次方，右边为 $ex$，所以两边同乘 $ex$ $axe^{x}\\geq ex \\ln\\dfrac{ex}{a}$ 此时形势已经很明了，是 $xe^x$ 形式的同构： $f(x)e^{f(x)} \\ge g(x)e^{g(x)} $ 当 $a\u003e0$ 时， $xe^{x}\\geq \\dfrac{ex}{a}\\ln\\dfrac{ex}{a} \\Leftrightarrow xe^{x}\\geq \\ln\\dfrac{ex}{a}e^{\\ln\\frac{ex}{a}}$ ∴只需证 $x\\geq \\ln\\dfrac{ex}{a}$ ，整理得 $ae^{x}\\geq ex$，显然是 $e^{x}\\geq ex$ 的放缩。故而 $a≥1 $ 当 $a\u003c0$ 时，$xe^{x}\\leq \\dfrac{ex}{a}\\ln\\dfrac{ex}{a} \\Leftrightarrow xe^{x}\\leq \\ln\\dfrac{ex}{a}e^{\\ln\\frac{ex}{a}}$ 所以只需证 $x\\leq \\ln\\dfrac{ex}{a}$，整理得 $ae^{x}\\geq ex$，与 $a\u003e0$ 情况相同。 综上 $a\\in[1,\\infty)$ ","date":"2020-07-15","objectID":"/posts/misc2020%E5%B9%B4%E9%AB%98%E8%80%83%E6%95%B0%E5%AD%A621%E9%A2%98/:0:0","tags":["高考数学"],"title":"2020年普通高等学校招生全国统一考试（新高考全国Ⅰ卷）数学21题","uri":"/posts/misc2020%E5%B9%B4%E9%AB%98%E8%80%83%E6%95%B0%E5%AD%A621%E9%A2%98/"},{"categories":["杂项"],"content":" 分析： $(1)$ $g'(x)=\\dfrac{π^{x}}{x^{π}}(\\lnπ-\\frac{π}{x})$ $∴g'(1)=π(\\lnπ-π)$ $(2)$ $f(x)=\\int x \\text{d} \\frac{π^{x}}{\\lnπ} = \\dfrac{xπ^{x}}{\\lnπ}-\\int \\dfrac{π^{x}}{\\lnπ}\\text{d}x = \\dfrac{xπ^{x}}{\\lnπ}-\\dfrac{π^{x}}{\\ln ^ 2π}$ $∴h(x)=\\dfrac{x}{\\lnπ}-\\dfrac{1}{\\ln^2π}-\\dfrac{1}{x^{π}}$ $∴h(1)=\\dfrac{1}{\\lnπ}-\\dfrac{1}{\\ln^2π}-1$ 令 $t=\\dfrac{1}{\\lnπ}\\in(0,1)$，$h(1)=t-t^{2}-1\\leq-\\frac{3}{4}\u003c0$ $h(π)+\\dfrac{1}{π^π}=\\dfrac{π}{\\lnπ}-\\dfrac{1}{\\ln^2π}=\\dfrac{π\\lnπ-1}{\\ln^2π}$ 令 $u=\\lnπ \\in (1,2)$，$h(π)+\\dfrac{1}{π^π}=\\dfrac{ue^u-1}{u^2} = \\varphi(u)$ $\\varphi’(u)=\\dfrac{(u^2-u)e^{u}+2}{u^{3}}$，令 $\\phi(u)=(u^2-u)e^{u}+2, \\phi’(u)=(u^2+u-1)e^u$ 易证 $\\phi’(u)\u003e0\\ (u\\in(1,2))$，$∴\\varphi’(u)\u003e0$，$\\varphi(u)$ 在 $u\\in(1,2)$ 单调递增。 $\\varphi(1)=e-1\u003e0,\\varphi(2)=\\dfrac{2e^2-1}{4}\u003e0,∴h(π)+\\dfrac{1}{π^π}\u003e0$ $∴h(1)·[h(π)+\\dfrac{1}{π^π}]\u003c0$ 得证。 ","date":"2020-03-14","objectID":"/posts/miscpi%E8%8A%82/:0:0","tags":["高考数学"],"title":"今天π节，出了一道题，高中生 大佬勿喷","uri":"/posts/miscpi%E8%8A%82/"}]